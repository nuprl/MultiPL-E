language: go_test.go
name: HumanEval_126_is_sorted
results:
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    last\
    \ := lst[0]\n    counts := make(map[int]int)\n\n    for _, n := range lst {\n\
    \        counts[n]++\n        if n == last {\n            continue\n        }\n\
    \n        if counts[n] == 1 {\n            return false\n        }\n\n       \
    \ last = n\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp93bbn28p_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp93bbn28p_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp93bbn28p_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp93bbn28p_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp93bbn28p_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0] == lst[1]\n    }\n    if len(lst) == 2 {\n   \
    \     return lst[0] < lst[1]\n    }\n    if lst[0] != lst[1] {\n        return\
    \ false\n    }\n    for idx := 2; idx < len(lst); idx++ {\n        if lst[idx-1]\
    \ != lst[idx] {\n            return false\n        }\n    }\n    return true\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nA slight variation on the above\
    \ solutions: this version allows negative numbers, as well as duplicates, and\
    \ allows an arbitrary number of duplicates. To remove duplicates use removeDuplicates.\
    \ \n<code>\npackage main\n\nimport \"fmt\"\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr86iq3kj_test.go:48:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075291
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if lst == nil {\n        return false\n    }\n    if len(lst)\
    \ == 0 {\n        return true\n    }\n    if len(lst) == 1 {\n        return true\n\
    \    }\n    idx := 0\n    prev := lst[0]\n    for idx < len(lst) {\n        if\
    \ lst[idx] != prev {\n            return false\n        }\n        prev = lst[idx]\n\
    \        idx++\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpvf9cworx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpvf9cworx_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpvf9cworx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpvf9cworx_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpvf9cworx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    lastValue\
    \ := lst[0]\n    for _, value := range lst {\n        if value != lastValue {\n\
    \            return false\n        }\n        lastValue = value\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp3dxt02pa_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp3dxt02pa_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp3dxt02pa_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp3dxt02pa_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp3dxt02pa_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst) - 1\n\n    for i < j {\n        if lst[i] < lst[j] {\n\
    \            return false\n        }\n        i++\n        j--\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp7gjuw5gj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp7gjuw5gj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp7gjuw5gj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmp7gjuw5gj_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp7gjuw5gj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp7gjuw5gj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    if len(lst)\
    \ == 2 {\n        if lst[0] < lst[1] {\n            return true\n        }\n \
    \       return false\n    }\n\n    // Find midpoint\n    middle := len(lst) /\
    \ 2\n    middle := int(middle)\n\n    // If middle is even, return true if sorted\
    \ with lower number\n    // greater than or equal to. Otherwise return true if\
    \ sorted with\n    // greater number greater or equal to.\n    if middle % 2 ==\
    \ 0 {\n        if lst.is_sorted(middle+1) {\n            return true\n       \
    \ }\n        return false\n    }\n\n    // If middle is odd, return true if sorted\
    \ with higher number\n    // greater than or equal to. Otherwise return true if\
    \ sorted with\n    // lower number greater or equal to.\n    if middle % 2 ==\
    \ 1 {\n        if lst.is_sorted(middle-1) {\n            return true\n       \
    \ }\n        return false\n    }\n\n    return lst.is_sorted(middle)\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd3zq08vx_test.go:41:12: no new variables on left side of :=

    /tmp/tmpd3zq08vx_test.go:47:16: lst.is_sorted undefined (type []int has no field
    or method is_sorted)

    /tmp/tmpd3zq08vx_test.go:57:16: lst.is_sorted undefined (type []int has no field
    or method is_sorted)

    /tmp/tmpd3zq08vx_test.go:63:16: lst.is_sorted undefined (type []int has no field
    or method is_sorted)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    m :=\
    \ map[int]int{}\n    for _, n := range lst {\n        m[n] = m[int(n)]+1\n   \
    \ }\n    for k, v := range m {\n        if v == 1 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5zhawbgn_test.go:36:9: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    last := lst[0]\n    for _, val := range lst {\n        if\
    \ val > last {\n            return false\n        }\n        last = val\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmp5u7jizv__test.go:29\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmp5u7jizv__test.go:52\
    \ +0x2de\ntesting.tRunner(0xc0001a0000, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    lastIdx\
    \ := len(lst) - 1\n    for i := 0; i < lastIdx; i++ {\n        for j := i + 1;\
    \ j < lastIdx; j++ {\n            if lst[i] > lst[j] {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmp4i0x2bbv_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmp4i0x2bbv_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return false\n    }\n    for i := 1; i < len(lst); i++ {\n \
    \       if lst[i-1] != lst[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp_2580vfq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp_2580vfq_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp_2580vfq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp_2580vfq_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp_2580vfq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    i := 0\n\
    \    j := 0\n    k := 0\n    for i < len(lst) {\n        if lst[i] > lst[j] {\n\
    \            return false\n        }\n        j++\n        if j == len(lst) {\n\
    \            break\n        }\n        if lst[i] > lst[k] {\n            return\
    \ false\n        }\n        k++\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpjyty8_o7_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpjyty8_o7_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpjyty8_o7_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpjyty8_o7_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    i :=\
    \ 1\n    for i < len(lst) {\n        if lst[i] > lst[i-1] {\n            return\
    \ false\n        }\n        i++\n    }\n    return true\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=go,sorting,algorithm,python |>\n<code>\ndef is_sorted(lst):\n\
    \    return lst.count(lst[0]) == len(lst)\n\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis answer doesn't meet OP's requirement _\"...in ascending order.\"_\n\
    <|/ c |>\n<| c |>\nThis does not answer the question, which is why I voted to\
    \ close as \"unclear what you're asking\".\n<|/ c |>\n<| a dscore=2 |>\nHere is\
    \ my solution written in python\n<code>\ndef isSorted(nums):\n    return len(set(nums))\
    \ == len(nums) and len(nums)==0 or all([nums[i-1] <= nums[i] for i in range(1,len(nums))])\n\
    \n</code>\n<|/ a tags=go,sorting,algorithm,python |>\n<| a dscore=1 |>\n<code>\n\
    import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\
    class isSorted{\n    public static boolean isSorted(List<Integer> nums) {\n  \
    \      List<Integer> tempList = new ArrayList<Integer>();\n        int totalCount\
    \ = nums.size();\n        Collections.sort(nums);\n        for(int i=1; i<totalCount;\
    \ i++) {\n            if (nums.get(i) > nums.get(i-1)) {\n                return\
    \ false;\n            }\n            tempList.add(nums.get(i));\n        }\n \
    \       if(tempList.size()>1) {\n            return false;\n        }\n      \
    \  return true;\n    }\n    public static void main(String[] args){\n        System.out.println(isSorted(new\
    \ ArrayList<Integer>(Arrays.asList(10, 20, 30, 50, 70, 10, 30, 50, 70, 100)));\n\
    \        System.out.println(isSorted(new ArrayList<Integer>(Arrays.asList(10,\
    \ 20, 30, 50, 70, 10, 30, 50, 70, 100)));\n        System.out.println(isSorted(new\
    \ ArrayList<Integer>(Arrays.asList(10, 20, 30, 50, 70, 10, 30, 50, 70, 100)));\n\
    \        System.out.println(isSorted(new ArrayList<Integer>(Arrays.asList(10,\
    \ 20, 30, 50, 70, 10, 30, 50, 70, 100)));\n    }\n}\n</code>\n<|/ a tags=go,sorting,algorithm,python\
    \ |>\n<| a tags=go,sorting,algorithm,python dscore=1 |>\nGo solution\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n)\n\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnijd0rw_test.go:41:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075291
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := len(lst) - 1; i > 0; i-- {\n        if lst[i] !=\
    \ lst[i-1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp6ilxpsz7_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp6ilxpsz7_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp6ilxpsz7_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp6ilxpsz7_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp6ilxpsz7_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    if lst[0]\
    \ != lst[len(lst)-1] {\n        return false\n    }\n    for _, x := range lst[1:]\
    \ {\n        if x != lst[0] {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpn8_n_aoz_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpn8_n_aoz_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpn8_n_aoz_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpn8_n_aoz_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpn8_n_aoz_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpn8_n_aoz_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // check for unique number\n    count := make(map[int]int)\n\
    \    for _, num := range lst {\n        count [num]++\n    }\n    for num, _ :=\
    \ range count {\n        if count[num] > 1 {\n            return false\n     \
    \   }\n    }\n    // check for order\n    for i := len(lst) - 1; i > 0; i-- {\n\
    \        if lst[i] > lst[i-1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp2j337ivt_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp2j337ivt_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp2j337ivt_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmp2j337ivt_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp2j337ivt_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp2j337ivt_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    i := 0\n    j := len(lst) - 1\n    for i < j {\n        if\
    \ lst[i] > lst[j] {\n            return false\n        }\n        i++\n      \
    \  j--\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp77s755cm_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp77s755cm_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmp77s755cm_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmp77s755cm_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    if\
    \ len(lst) == 1 {\n        return lst[0] >= 0\n    }\n\n    for i := 1; i < len(lst);\
    \ i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpbe37t14v_test.go:71: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpbe37t14v_test.go:71:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var lastElem\
    \ int\n    var prevElem int\n    for i := 0; i < len(lst)-1; i++ {\n        if\
    \ lst[i] != prevElem {\n            lastElem = lst[i]\n            prevElem =\
    \ lst[i]\n        } else {\n            if i < len(lst)-1 {\n                prevElem\
    \ = lst[i+1]\n            }\n        }\n    }\n    return lst[len(lst)-1] == lastElem\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpk459d1ih_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpk459d1ih_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpk459d1ih_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpk459d1ih_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpk459d1ih_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := range lst {\n        j := i\n        for ; j < len(lst)\
    \ && lst[j] == lst[i]; j++ {\n        }\n        if j > i {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpr1p3xjz6_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpr1p3xjz6_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpr1p3xjz6_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpr1p3xjz6_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmpr1p3xjz6_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpr1p3xjz6_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpr1p3xjz6_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    first\
    \ := lst[0]\n    for i, val := range lst {\n        if i == 0 {\n            return\
    \ false\n        }\n        if val == first {\n            continue\n        }\n\
    \        return false\n    }\n    return true\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis would be a better answer if you explained what the code is doing\
    \ and how it works.\n<|/ c |>\n<| a |>\n<code>\npackage main\n\nimport \"fmt\"\
    \n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj2unosuw_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075291
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    prev\
    \ := lst[0]\n    for _, v := range lst[1:] {\n        if prev > v {\n        \
    \    return false\n        }\n        prev = v\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpiro1rlro_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpiro1rlro_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    return\
    \ is_sorted_impl(lst, 0, len(lst)-1)\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgv5e26v_test.go:32:12: undefined: is_sorted_impl

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    if len(lst)\
    \ == 1 {\n        return true\n    }\n    if lst[0] == lst[1] {\n        return\
    \ false\n    }\n    prev := lst[0]\n    for _, item := range lst[1:] {\n     \
    \   if item < prev {\n            return false\n        }\n        prev = item\n\
    \    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpmnnbv7lq_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpmnnbv7lq_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpmnnbv7lq_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    j :=\
    \ 1\n    for i:= 0; i < len(lst); i++ {\n        if lst[i] > lst[j] {\n      \
    \      return false\n        }\n\n        if i == j {\n            j++\n     \
    \   }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpfhjn0psn_test.go:71: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpfhjn0psn_test.go:71:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpfhjn0psn_test.go:71: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpfhjn0psn_test.go:71:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var first int\n    var duplicate bool\n\n    if len(lst)\
    \ == 0 {\n        return true\n    }\n\n    if len(lst) == 1 {\n        return\
    \ true\n    }\n\n    if len(lst) > 1 {\n        for i := 1; i < len(lst); i++\
    \ {\n            if lst[i] == lst[i-1] {\n                duplicate = true\n \
    \               break\n            }\n        }\n        if !duplicate {\n   \
    \         return true\n        }\n    }\n\n    for i := range lst {\n        if\
    \ lst[i] < first {\n            return false\n        }\n        first = lst[i]\n\
    \    }\n\n    return true\n}\n`\n        )\n        test.Run(t, p, []TestOpts{\n\
    \            {\"package\", package},\n        })\n    }\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw8ktt56d_test.go:61:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for _, i := range lst {\n        if i > lst[len(lst)-1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmps_xszvv4_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmps_xszvv4_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmps_xszvv4_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmps_xszvv4_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // sort is stable.\n    // https://golang.org/ref/spec#Stable\n\
    \    sort.Stable(sort.IntSlice(lst))\n    return !sort.IsSorted(lst)\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6gtwzhz7_test.go:31:5: undefined: sort

    /tmp/tmp6gtwzhz7_test.go:32:13: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    var\
    \ i int = 0\n    var j int = len(lst)\n    var k int = 1\n    var result bool\
    \ = true\n    for ; j < i; j++ {\n        if lst[j] != lst[i] {\n            break\n\
    \        }\n        i++\n    }\n    if j == i {\n        return true\n    }\n\
    \    for ; j < k; j++ {\n        if lst[j] > lst[k] {\n            result = false\n\
    \            break\n        }\n        k++\n    }\n    return result\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpz92_fn_f_test.go:80: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpz92_fn_f_test.go:80:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpz92_fn_f_test.go:80: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpz92_fn_f_test.go:80:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpz92_fn_f_test.go:80: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpz92_fn_f_test.go:80:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 1 {\n        return false\n    }\n    counts\
    \ := make(map[int]int)\n    for _, num := range lst {\n        counts[num] +=\
    \ 1\n    }\n    for k := range counts {\n        if counts[k] >= 2 {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpqh395bmg_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpqh395bmg_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpqh395bmg_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpqh395bmg_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpqh395bmg_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    //\
    \ If we have more than 1 identical element, return false\n    if len(lst) > 1\
    \ {\n        return false\n    }\n\n    // If last number is greater than all\
    \ numbers, return false\n    if lst[len(lst)-1] >= lst[0] {\n        return false\n\
    \    }\n\n    // If first number is less than all numbers, return false\n    if\
    \ lst[0] < lst[len(lst)-1] {\n        return false\n    }\n\n    // Otherwise,\
    \ return true\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpwyxjh354_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpwyxjh354_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpwyxjh354_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpwyxjh354_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpwyxjh354_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmpwyxjh354_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpwyxjh354_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpwyxjh354_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 || len(lst) == 1 {\n        return true\n\
    \    }\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] < lst[i+1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp96j49vep_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp96j49vep_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp96j49vep_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmp96j49vep_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp96j49vep_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp96j49vep_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n\n    if\
    \ len(lst) == 2 {\n        if lst[0] < lst[1] {\n            return true\n   \
    \     }\n        return false\n    }\n\n    for i := 1; i < len(lst); i++ {\n\
    \        if lst[i] < lst[i-1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmphq83vx45_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmphq83vx45_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := range lst {\n        if i != lst[0] {\n            return false\n     \
    \   }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpksunka52_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpksunka52_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpksunka52_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpksunka52_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpksunka52_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 || len(lst) == 1 {\n        return true\n\
    \    }\n    lastVal := lst[len(lst)-1]\n    firstVal := lst[0]\n    if lastVal\
    \ != firstVal {\n        return false\n    }\n    for i := 1; i < len(lst); i++\
    \ {\n        if lst[i] != lst[i-1] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate :=\
    \ is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpyos8ivg__test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpyos8ivg__test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpyos8ivg__test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpyos8ivg__test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpyos8ivg__test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Store the previous value.\n    prev := lst[0]\n    for\
    \ _, n := range lst {\n        // If we encounter an inconsistent state, return\
    \ false.\n        if prev < n {\n            return false\n        }\n       \
    \ prev = n\n    }\n    // All numbers are in ascending order.\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmpg4047rv8_test.go:30\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmpg4047rv8_test.go:55\
    \ +0x2de\ntesting.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    last,\
    \ first := lst[0], lst[0]\n    for _, val := range lst[1:] {\n        if val !=\
    \ last {\n            return false\n        }\n        last = val\n    }\n   \
    \ return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptyi2mj7b_test.go:32:11: first declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    last\
    \ := 0\n    i := 0\n    for j := 0; j < len(lst); j++ {\n        if lst[j] > lst[last]\
    \ {\n            return false\n        }\n        if lst[j] == lst[last] {\n \
    \           i++\n            if i == len(lst) {\n                return true\n\
    \            }\n            last = i\n        }\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpeejxvryh_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpeejxvryh_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpeejxvryh_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpeejxvryh_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpeejxvryh_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmp3i9aime1_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmp3i9aime1_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    // Find\
    \ the smallest value in the list\n    min := lst[0]\n    for _, value := range\
    \ lst {\n        if value < min {\n            min = value\n        }\n    }\n\
    \    return false\n}\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmpj9gzwrxn_test.go:33\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmpj9gzwrxn_test.go:54\
    \ +0x5e\ntesting.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0] != lst[1]\n    }\n    sorted, _ := is_sorted(sorted(lst))\n\
    \    return sorted\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7lkzwmb_test.go:35:18: assignment mismatch: 2 variables but is_sorted
    returns 1 value

    /tmp/tmpo7lkzwmb_test.go:35:28: undefined: sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var i\
    \ int\n    var prev int\n    for i := 0; i < len(lst); i++ {\n        prev = lst[i]\n\
    \        if prev >= i && prev == lst[i-1] {\n            return false\n      \
    \  }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbdcgodnc_test.go:32:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 || len(lst) == 1 {\n        return true\n\
    \    }\n    first := lst[0]\n    seen := make([]int, 0)\n    for _, num := range\
    \ lst {\n        if seen[num] == true {\n            return false\n        }\n\
    \        seen[num] = true\n    }\n    return true\n}\n</code>\n<|/ a dscore=3\
    \ tags=sorting,arrays,go |>\n<| a tags=sorting,arrays,go |>\nA simple and fast\
    \ method would be\n<code>\nimport \"sort\"\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu0f11009_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        if lst[0] < lst[1] {\n            return true\n        }\n \
    \   }\n\n    if lst[0] < lst[1] {\n        return false\n    }\n\n    return is_sorted(lst[0:len(lst)-1])\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted({0xc0000f5bc8?, 0x1?, 0x1?})\n\
    \t/tmp/tmphisexkqn_test.go:33 +0x78\ncommand-line-arguments_test.TestIs_Sorted(0x0?)\n\
    \t/tmp/tmphisexkqn_test.go:52 +0x62\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    //\
    \ Use maps to save time at the expense of readability\n    mapa := make(map[int]\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ge006a9_test.go:34:26: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var a []int\n    var b []int\n    sort.Sort(&a)\n    sort.Sort(&b)\n\
    \    for _, v := range a {\n        if !reflect.DeepEqual(v, lst) {\n        \
    \    return false\n        }\n    }\n    for _, v := range b {\n        if !reflect.DeepEqual(v,\
    \ lst) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhss5cjc_test.go:31:5: undefined: sort

    /tmp/tmpmhss5cjc_test.go:32:5: undefined: sort

    /tmp/tmpmhss5cjc_test.go:34:13: undefined: reflect

    /tmp/tmpmhss5cjc_test.go:39:13: undefined: reflect

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    length := len(lst)\n    last := length - 1\n    var checked\
    \ int\n    for i := 0; i < length; i++ {\n        if i == 0 {\n            last\
    \ = length - 1\n        }\n        if checked < lst[i] {\n            checked\
    \ = lst[i]\n            last = i\n        }\n        if checked == lst[i] {\n\
    \            last = i\n            i++\n        }\n    }\n    return last < length\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpwqyiceau_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpwqyiceau_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpwqyiceau_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpwqyiceau_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpwqyiceau_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    seen\
    \ := make(map[int]bool)\n    for _, val := range lst {\n        if seen[val] {\n\
    \            return false\n        }\n        seen[val] = true\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpdymlnbqp_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpdymlnbqp_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpdymlnbqp_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpdymlnbqp_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpdymlnbqp_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Initialize count of occurrences of each number\n    count\
    \ := make(map[int]int, len(lst))\n    for _, i := range lst {\n        count[i]++\n\
    \    }\n\n    // Sort list into descending order\n    for i := len(count) - 1;\
    \ i > 0; i-- {\n        if count[i] != 1 {\n            return false\n       \
    \ }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp8wqjx89e_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp8wqjx89e_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp8wqjx89e_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp8wqjx89e_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    cnt := make(map[int]bool)\n    for _, v := range lst {\n\
    \        if _, ok := cnt[v]; !ok {\n            cnt[v] = true\n        } else\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpyyp6bl3h_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpyyp6bl3h_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpyyp6bl3h_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpyyp6bl3h_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075297
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    last\
    \ := lst[0]\n    i, ok := 1\n    for _, val := range lst[i:][:len(lst)-i] {\n\
    \        if val > last {\n            return false\n        }\n        last =\
    \ val\n        i++\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wzomce__test.go:33:14: assignment mismatch: 2 variables but 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n\n    last\
    \ := lst[0]\n    last := lst[0]\n\n    for i := 1; i < len(lst); i++ {\n     \
    \   if lst[i] > last {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f0312vm_test.go:34:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // If list is empty, return true\n    if len(lst) <= 0 {\n\
    \        return true\n    }\n\n    // If the first number in the list is equal\
    \ to the last number in the list, return true\n    if len(lst) == 1 {\n      \
    \  return true\n    }\n\n    // If the first number in the list is not equal to\
    \ the last number in the list, return false\n    if lst[0] != lst[len(lst)-1]\
    \ {\n        return false\n    }\n\n    // If there are 2 or more duplicates,\
    \ return false\n    if len(lst) > 1 {\n        return false\n    }\n\n    // Else,\
    \ return true\n    return true\n}\n</code>\n<|/ a tags=sorting,go,arrays |>\n\
    <| c |>\nThis doesn't work in case of repeated values - i.e. if a duplicate is\
    \ present in the array, it will be treated as if it was the only value in the\
    \ list.\n<|/ c |>\n<| c |>\nI think that's why I called it a \"sorted list\" rather\
    \ than a \"sorted array\". I didn't consider that case in my answer. I'll edit\
    \ my answer to reflect that.\n<|/ c |>\n<| c |>\nThe list you provided is sorted\
    \ in the first two examples. In the third example \"1, 2, 2, 3, 3, 4\", the code\
    \ will return true. This is an incorrect result for many real world purposes,\
    \ most notably in a cryptographic hash function which can only output unique keys.\n\
    <|/ c |>\n<| a tags=sorting,go,arrays dscore=2 |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n)\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppq662hzj_test.go:52:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Go through each element\n    for _, v := range lst {\n\
    \        // If v is not the first element\n        if v != lst[0] {\n        \
    \    // If v is equal to previous elements\n            if v == lst[len(lst)-1]\
    \ {\n                // Remove duplicate\n                lst = lst[:len(lst)-1]\n\
    \                // If no duplicates, return true\n                if len(lst)\
    \ == 0 {\n                    return true\n                }\n            } else\
    \ {\n                // If v is not equal to the previous elements\n         \
    \       return false\n            }\n        } else {\n            // If v is\
    \ equal to previous elements\n            return false\n        }\n    }\n   \
    \ return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpyeqpbxil_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpyeqpbxil_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpyeqpbxil_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpyeqpbxil_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpyeqpbxil_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmpyeqpbxil_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpyeqpbxil_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpyeqpbxil_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    // assume\
    \ no negative numbers\n    // assume no duplicates\n    // assume only integers\n\
    \n    // traverse the list to count the number of occurrences of number\n    //\
    \ until count is one\n    count := 0\n    for _, num := range lst {\n        if\
    \ num == lst[0] {\n            count++\n        } else {\n            break\n\
    \        }\n    }\n\n    // return false if there are more than one occurrences\
    \ of the number\n    // or if the number occurs more than once\n    return count\
    \ < 2 || count == len(lst)\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp3gafyok3_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp3gafyok3_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp3gafyok3_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp3gafyok3_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp3gafyok3_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    var\
    \ prev int\n    var found bool\n    for idx, item := range lst {\n        if found\
    \ {\n            if item == prev {\n                return false\n           \
    \ }\n        } else {\n            prev = item\n            found = true\n   \
    \     }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd39jm9q3_test.go:34:9: idx declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    count := 0\n    last := 0\n    for _, num := range lst {\n\
    \        if num == last {\n            count++\n        } else {\n           \
    \ if count > 1 {\n                return false\n            }\n            last\
    \ = num\n            count = 0\n        }\n    }\n    return count == 1\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmps5736zgj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmps5736zgj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmps5736zgj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmps5736zgj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmps5736zgj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmps5736zgj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmps5736zgj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmps5736zgj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    if lst[0]\
    \ == lst[1] {\n        return is_sorted(lst[2:])\n    }\n    for i := 0; i < len(lst)/2;\
    \ i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted({0xc0000f5bc8?, 0x1?, 0x1?})\n\
    \t/tmp/tmpj5xym9qo_test.go:32 +0xe5\ncommand-line-arguments_test.TestIs_Sorted(0x0?)\n\
    \t/tmp/tmpj5xym9qo_test.go:50 +0x62\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    len := len(lst)\n    if (len < 2) || (len > 100) {\n    \
    \    return false\n    }\n    last := 0\n    for i := 1; i < len; i++ {\n    \
    \    if lst[i-1] > lst[i] {\n            return false\n        }\n        if i\
    \ > 1 {\n            if lst[i-1] != lst[i-2]+1 {\n                return false\n\
    \            }\n        }\n        last = i\n    }\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo71v_7c1_test.go:33:5: last declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] != lst[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpqty0vwpr_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpqty0vwpr_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpqty0vwpr_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpqty0vwpr_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpqty0vwpr_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    last\
    \ := lst[0]\n    found := false\n    for _, elem := range lst {\n        if elem\
    \ < last {\n            return false\n        }\n        last = elem\n       \
    \ found = true\n    }\n    return found\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp_1jw5p5d_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp_1jw5p5d_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp_1jw5p5d_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var found bool\n    var prev, current int\n\n    for _, num\
    \ := range lst {\n        current = num\n        prev = nil\n        for _, num\
    \ := range lst {\n            if current == num {\n                if prev ==\
    \ nil {\n                    return false\n                } else {\n        \
    \            prev = current\n                }\n                continue\n   \
    \         } else {\n                break\n            }\n        }\n\n      \
    \  if prev != nil {\n            found = true\n            break\n        }\n\
    \    }\n\n    return found\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6q8m58z2_test.go:34:16: cannot use nil as int value in assignment

    /tmp/tmp6q8m58z2_test.go:37:28: invalid operation: prev == nil (mismatched types
    int and untyped nil)

    /tmp/tmp6q8m58z2_test.go:48:20: invalid operation: prev != nil (mismatched types
    int and untyped nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Sort and check against original list.\n    sort.Ints(lst)\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] != i {\n            return\
    \ false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=sorting,algorithm,language-agnostic |>\nJust for fun I thought about\
    \ this problem (with different numbers and different order) without having to\
    \ import a library. My solution was to convert the array of integers to an array\
    \ of strings, then sort them in descending order, then return the last value.\
    \ For example:\n<code>\nvar ints = [3, 1, 2, 4, 2, 3, 3]\nvar strings = ints.map((x)\
    \ => String(x.toFixed(0)))\n\nstrings.sort( (a, b) => b.length - a.length );\n\
    var result = strings.pop();\n</code>\n<|/ a dscore=1 |>\n<| a tags=sorting,algorithm,language-agnostic\
    \ |>\n<code>\ndef is_sorted(nums):\n  l = len(nums)\n  for i in range(1,l-1):\n\
    \    if nums[l-1] > nums[i]:\n      return False\n  return True\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=sorting,algorithm,language-agnostic dscore=1 |>\nI\
    \ came up with this in Java:\n<code>\npublic static boolean isSorted(List<Integer>\
    \ list) {\n    if (list == null || list.size() == 0) {\n        return false;\n\
    \    }\n    Collections.sort(list);\n    int lastElem = list.get(list.size() -\
    \ 1);\n    boolean isSorted = true;\n    for (int i = 0; i < list.size(); i++)\
    \ {\n        if (list.get(i) < lastElem) {\n            isSorted = false;\n  \
    \          break;\n        }\n    }\n    return isSorted;\n}\n</code>\n<|/ a |>\n\
    <| a tags=sorting,algorithm,language-agnostic |>\nIn C#:\n<code>\nstatic bool\
    \ isSorted(int[] arr, int low, int high)\n{\n    if (arr.Length == 0)\n    {\n\
    \        return false;\n    }\n    if (low >= high)\n    {\n        return true;\n\
    \    }\n    int mid = low + Math.Max(high - low, 1);\n    int pivot = arr[mid];\n\
    \    int leftPivot = arr[low];\n    int rightPivot = arr[high];\n    while (true)\n\
    \    {\n        while (leftPivot <= pivot && mid > 0)\n        {\n           \
    \ mid--;\n        }\n        while (rightPivot >= pivot && mid < arr.Length -\
    \ 1)\n        {\n            mid++;\n        }\n        if (mid < 0 || leftPi\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7924hq0u_test.go:38:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Use a map to record how many of each number we see.\n\
    \    m := make(map[int]int)\n\n    // The first element in the map will be unused.\n\
    \    for _, n := range lst {\n        if _, ok := m[n]; !ok {\n            m[n]\
    \ = 1\n        } else {\n            m[n] += 1\n        }\n    }\n\n    for _,\
    \ n := range lst {\n        // We see all numbers - return true.\n        if m[n]\
    \ == len(lst) {\n            return true\n        }\n\n        // Not all numbers\
    \ - see if we can find another one earlier in the\n        // sequence.\n    \
    \    if _, ok := m[(n-len(lst))%len(lst)]; ok {\n            return false\n  \
    \      }\n    }\n\n    // No numbers were seen - return false\n    return false\n\
    }\n`\n)\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp75atqjcg_test.go:57:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    for _,\
    \ i := range lst {\n        if i == lst[len(lst)-1] {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprxg4ggjh_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprxg4ggjh_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprxg4ggjh_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmprxg4ggjh_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmprxg4ggjh_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    seen\
    \ := make(map[int]bool)\n    for _, x := range lst {\n        if seen[x] {\n \
    \           return false\n        }\n        seen[x] = true\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpjvv7gp4k_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpjvv7gp4k_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpjvv7gp4k_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpjvv7gp4k_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Sort the list\n    sort.Ints(lst)\n\n    // Find the first\
    \ non-duplicate number\n    idx := sort.Search(len(lst), 1, func(i int) bool {\n\
    \        return lst[i] != lst[i+1]\n    })\n    if idx < len(lst)-1 {\n      \
    \  // If there isn't a duplicate of the last number, return true\n        return\
    \ true\n    }\n    // If there are no duplicated numbers, return false\n    return\
    \ false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnofjvjdr_test.go:30:5: undefined: sort

    /tmp/tmpnofjvjdr_test.go:33:12: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    if\
    \ lst[0] == lst[len(lst)-1] {\n        return is_sorted(lst[1:])\n    }\n\n  \
    \  for i := range lst {\n        for j := 0; j < i; j++ {\n            if lst[i]\
    \ > lst[j] {\n                return false\n            }\n        }\n    }\n\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpi0et0alz_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpi0et0alz_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpi0et0alz_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpi0et0alz_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpi0et0alz_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmpi0et0alz_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpi0et0alz_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpi0et0alz_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpi0et0alz_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    var\
    \ last int\n    for i := 1; i < len(lst); i++ {\n        if lst[i] > last {\n\
    \            return false\n        }\n        last = lst[i]\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp_ikoh6oq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp_ikoh6oq_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp_ikoh6oq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp_ikoh6oq_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp_ikoh6oq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    prev\
    \ := 0\n    for _, n2 := range lst {\n        if n2 > prev {\n            return\
    \ false\n        }\n        prev++\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpn9qq_hzv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpn9qq_hzv_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpn9qq_hzv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpn9qq_hzv_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpn9qq_hzv_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    //\
    \ Sort is stable, so first check if list is sorted\n    for i := 1; i < len(lst);\
    \ i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n\
    \    }\n\n    // Now the list is sorted, check if there is duplicate\n    for\
    \ i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp1t4bz01w_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp1t4bz01w_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    var\
    \ j int\n    for i := len(lst) - 1; i > 0; i-- {\n        if lst[i] >= lst[j]\
    \ {\n            return false\n        }\n        j--\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmp8tj3tdzn_test.go:35\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmp8tj3tdzn_test.go:58\
    \ +0x9df\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Write your code here.\n    return len(lst)>2 && is_sorted_helper(lst)\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryv_uvz4_test.go:30:26: undefined: is_sorted_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075299
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    i := 0\n\
    \    j := 0\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9w038yuu_test.go:32:5: i declared but not used

    /tmp/tmp9w038yuu_test.go:33:5: j declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 || len(lst) == 1 {\n        return true\n\
    \    }\n    return is_sorted(lst[1:len(lst)])\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpqf78iwbm_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpqf78iwbm_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpqf78iwbm_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpqf78iwbm_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpqf78iwbm_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // sort the list and return false\n    // if list is unsorted\n\
    \    if lst == nil || len(lst) <= 1 {\n        return true\n    }\n    return\
    \ is_sorted_impl(nil, lst)\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgerrqb4p_test.go:34:12: undefined: is_sorted_impl

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if lst == nil {\n        return true\n    }\n    if len(lst)\
    \ < 2 {\n        return true\n    }\n    return is_sorted_helper(lst)\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpme2u0ooi_test.go:35:12: undefined: is_sorted_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // If len(lst) == 1, return true since no duplicates\n  \
    \  if len(lst) == 1 {\n        return true\n    }\n    // If len(lst) == 2, then\
    \ check if lst[0] == lst[1]\n    if len(lst) == 2 {\n        if lst[0] != lst[1]\
    \ {\n            return false\n        }\n    }\n    // Iterate through all indices\
    \ and check if lst[i] < lst[i-1]\n    // If so, then we know that lst[i] is not\
    \ a duplicate of lst[i-1]\n    // and lst[i] is not sorted\n    for i := 0; i\
    \ < len(lst)-1; i++ {\n        if lst[i] < lst[i+1] {\n            return false\n\
    \        }\n    }\n    // If all went well, lst[-1] is the duplicate of lst[0],\
    \ so\n    // lst[-1] is not sorted\n    return lst[0] != lst[-1]\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6fuuvro0_test.go:49:26: invalid argument: index -1 (constant of type int)
    must not be negative

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    s :=\
    \ 0\n    for i := 1; i < len(lst); i++ {\n        if lst[i] > lst[s] {\n     \
    \       return false\n        }\n        s = i\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmps26z3xfw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmps26z3xfw_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmps26z3xfw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmps26z3xfw_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmps26z3xfw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmps26z3xfw_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    // O(n)\
    \ linear time\n    for i := 0; i < len(lst); i++ {\n        if i == 0 || lst[i]\
    \ != lst[i-1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp9prgazqr_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp9prgazqr_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp9prgazqr_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp9prgazqr_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp9prgazqr_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmp9prgazqr_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp9prgazqr_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp9prgazqr_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    var\
    \ i int\n    var lastVar int\n    var last int\n\n    for i = 0; i < len(lst)-1;\
    \ i++ {\n        lastVar = lst[i]\n        last = lst[i + 1]\n\n        if last\
    \ > lastVar {\n            return false\n        }\n    }\n\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpg6z1ttst_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpg6z1ttst_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpg6z1ttst_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpg6z1ttst_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpg6z1ttst_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpg6z1ttst_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    if\
    \ len(lst) == 1 {\n        return true\n    }\n\n    if lst[0] == lst[1] {\n \
    \       return true\n    }\n\n    for i := 1; i < len(lst); i++ {\n        if\
    \ lst[i] < lst[i-1] {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpmbknk_l0_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpmbknk_l0_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpmbknk_l0_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var count int\n    for _, v := range lst {\n        if v\
    \ != count+1 {\n            return false\n        }\n        count++\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpmx7u725e_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpmx7u725e_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    for\
    \ i := 0; i < len(lst)-1; i++ {\n        if lst[i] < lst[i+1] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpmuazk0ck_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpmuazk0ck_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpmuazk0ck_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpmuazk0ck_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpmuazk0ck_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpmuazk0ck_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpmuazk0ck_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 || len(lst) == 1 {\n        return true\n\
    \    }\n\n    // We only care about two elements in the list\n    if len(lst)\
    \ > 1 {\n        // If the second element is equal to the first,\n        // the\
    \ list is not sorted\n        if lst[1] == lst[0] {\n            return false\n\
    \        }\n    }\n\n    // The first element in the list must be less than the\
    \ last\n    if lst[0] < lst[len(lst)-1] {\n        return false\n    }\n\n   \
    \ // Scan the list from beginning to end\n    for i := 0; i < len(lst)-1; i++\
    \ {\n        // If the two elements are equal, skip to next element\n        if\
    \ lst[i] != lst[i+1] {\n            break\n        }\n    }\n\n    // The list\
    \ is sorted\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpclvpcaus_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpclvpcaus_test.go:84:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpclvpcaus_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpclvpcaus_test.go:84:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpclvpcaus_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpclvpcaus_test.go:84:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    length := len(lst)\n    if length == 0 {\n        return\
    \ true\n    }\n\n    first := lst[0]\n    for i := 0; i < length-1; i++ {\n  \
    \      next := lst[i]\n        if next < first {\n            return false\n \
    \       }\n        if lst[i] == next {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpiwd5wpa6_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpiwd5wpa6_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpiwd5wpa6_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpiwd5wpa6_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpiwd5wpa6_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    if\
    \ len(lst) == 1 {\n        if lst[0] != 1 {\n            return false\n      \
    \  }\n        return true\n    }\n\n    for i := len(lst) - 1; i >= 1; i-- {\n\
    \        if lst[i] != i {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpyt5mpb6e_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpyt5mpb6e_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpyt5mpb6e_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpyt5mpb6e_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpyt5mpb6e_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpyt5mpb6e_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    m :=\
    \ map[int]int{}\n    for _, v := range lst {\n        m[v]++\n    }\n\n    for\
    \ k := range m {\n        if m[k] == 1 {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpbanze6p6_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpbanze6p6_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpbanze6p6_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpbanze6p6_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpbanze6p6_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // sort with slice\n    slice := make([]int, len(lst))\n\
    \    copy(slice, lst)\n    sort.Sort(slice)\n\n    // check sorted\n    for i,\
    \ j := 0, 1; j < len(slice); i, j = i+1, j+1 {\n        if slice[i] != slice[j]\
    \ {\n            return false\n        }\n    }\n    return true\n}\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ti6eziq_test.go:32:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // first we check the length of the list\n    if len(lst)\
    \ == 0 || len(lst) > 1 {\n        return false\n    }\n\n    // then we check\
    \ each of the elements of the list to see if they are in order\n    for i := range\
    \ lst {\n        if i > 0 && lst[i-1] != lst[i] {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ tags=go |>\nI like this solution. The idea is to sort the slice. Then you can\
    \ use unique to remove duplicates. You can easily add this to a type that will\
    \ return an array or slice, whatever you choose. Just remember to add the sort\
    \ to your methods.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\
    \n)\n\ntype SortedArray []int\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeogx7y1__test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075301
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 1 {\n        return false\n    }\n\n    var\
    \ lasti int = 0\n    lasti := len(lst) - 1\n    for i := range lst {\n       \
    \ if lst[i] == lst[lasti] {\n            lasti--\n            continue\n     \
    \   }\n\n        if i == lasti {\n            return false\n        }\n\n    \
    \    return true\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ys0a41a_test.go:34:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n</code>\n<|/ a tags=sorting,algorithm,arrays\
    \ dscore=4 |>\n<| c |>\nThis is not working for the input []int{1, 2, 3, 4, 5}\n\
    <|/ c |>\n<| a |>\nIn Ruby this would be (using Enumerable#each_cons):\n<code>\n\
    input = [1, 3, 2, 4, 5]\n\ninput.each_cons(2).none?{ |a, b| a > b }\n#=> true\n\
    \ninput = [1, 2, 2, 2, 3, 4]\n\ninput.each_cons(2).none?{ |a, b| a > b }\n#=>\
    \ false\n</code>\nIf you use Ruby 2.2+ (or any version that supports Enumerable#each_cons),\
    \ you can simplify this to:\n<code>\ninput.each_cons(2).none?(&:first)\n</code>\n\
    <|/ a dscore=4 tags=sorting,algorithm,arrays |>\n<| c |>\nThe Ruby 2.2+ version\
    \ seems elegant. Thanks!\n<|/ c |>\n<| a dscore=4 |>\nSince you're only looking\
    \ at the consecutive numbers, you can iterate through the array starting with\
    \ the second element and keep a running count of consecutive numbers. When you\
    \ get to the end, you know that all elements need to be consecutive numbers. In\
    \ the example above, all numbers are consecutive, so you know that there are 2\
    \ elements in the array.\n<|/ a tags=sorting,algorithm,arrays |>\n<| c |>\nYeah\
    \ I just figured that out but it's too good to be true. I had thought of it at\
    \ one point but I knew I'd get it wrong. Thanks!\n<|/ c |>\n<| c |>\nThe first\
    \ element has to be 1 and not 2\n<|/ c |>\n<| c |>\n: Yeah, I saw that too, thanks\
    \ for pointing it out. Good catch!\n<|/ c |>\n<| a dscore=3 |>\nYou can achieve\
    \ this with a single loop:\n<code>\nbool sortArray(std::vector<int>& arr) {\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (i > 0 && arr[i-1] !=\
    \ arr[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=sorting,algorithm,arrays |>\n<| c |>\nDoesn't work if the\
    \ array starts with `{ 2,1,4,5,6 }`. You need to check whether the first element\
    \ in `arr` is not `arr[0]`\n<|/\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphpcy1nv6_test.go:39:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var lastInt\
    \ int\n    lastInt = lst[0]\n    hasDup := false\n    for _, val := range lst\
    \ {\n        if val == lastInt {\n            hasDup = true\n            continue\n\
    \        }\n        if val < lastInt {\n            return false\n        }\n\
    \    }\n    return hasDup\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp9t_cugah_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp9t_cugah_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmp9t_cugah_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmp9t_cugah_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    current\
    \ := lst[0]\n    lastIndex := 0\n    for index := 1; index < len(lst); index++\
    \ {\n        if current+lst[index] != current {\n            return false\n  \
    \      }\n        if current == lst[index] {\n            lastIndex = index\n\
    \        }\n    }\n    if lastIndex == len(lst)-1 {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate :=\
    \ is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmprwhp53ek_test.go:32\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmprwhp53ek_test.go:61\
    \ +0x2a9\ntesting.tRunner(0xc000103380, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    prev\
    \ := lst[0]\n    for _, x := range lst {\n        if prev == x {\n           \
    \ return false\n        }\n        prev = x\n    }\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpqsg70lfa_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpqsg70lfa_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpqsg70lfa_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpqsg70lfa_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpqsg70lfa_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    lastElem\
    \ := lst[len(lst)-1]\n    if len(lst) == 1 {\n        return true\n    }\n   \
    \ for i := 0; i < len(lst)-1; i++ {\n        if lst[i] >= lastElem {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpmacgt8jk_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpmacgt8jk_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpmacgt8jk_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpmacgt8jk_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    first\
    \ := lst[0]\n    last := lst[len(lst)-1]\n\n    if first < last {\n        return\
    \ false\n    }\n\n    for i := 1; i < len(lst); i++ {\n        if lst[i] < first\
    \ {\n            return false\n        }\n        if lst[i] > last {\n       \
    \     return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp17qdp0o5_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp17qdp0o5_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp17qdp0o5_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp17qdp0o5_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp17qdp0o5_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    seen\
    \ := make(map[int]bool)\n    for i, e := range lst {\n        if seen[e] {\n \
    \           return false\n        }\n        seen[e] = true\n    }\n\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx1ttn99b_test.go:34:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var lastInt\
    \ int = 0\n    var lastInt int = 0\n    for _, num := range lst {\n        if\
    \ num > lastInt {\n            return false\n        }\n        lastInt = num\n\
    \    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vhyrc13_test.go:33:9:\
    \ lastInt redeclared in this block\n\t/tmp/tmp0vhyrc13_test.go:32:9: other declaration\
    \ of lastInt\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    last\
    \ := lst[0]\n    for _, v := range lst {\n        if v != last {\n           \
    \ return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpmn4ec10z_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpmn4ec10z_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpmn4ec10z_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpmn4ec10z_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpmn4ec10z_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpmn4ec10z_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075061
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ _, num1 := range lst[:len(lst)-1] {\n        for _, num2 := range lst[len(lst)-1:]\
    \ {\n            if num1 > num2 {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=2 tags=sorting,algorithm,go,unique\
    \ |>\n<| c |>\nThis is probably O(n^2)\n<|/ c |>\n<| c |>\nNot really, see `if\
    \ !IsSorted{nums...}` branch. Also this is not a O(n) algorithm but O(n log n)\n\
    <|/ c |>\n<| c |>\n: It's O(n*log(n)) to sort (O(n) for sorting is O(n log n)),\
    \ then O(n) to check for uniqueness (O(n) for uniqueness is O(n)). Which is O(n\
    \ log n).\n<|/ c |>\n<| c |>\n: You are right. My mistake.\n<|/ c |>\n<| c |>\n\
    Isn't this `O(n^2)` rather than `O(n log n)`? Also it seems that it only works\
    \ for ascending or descending sorting, which is probably not what the OP wants.\
    \ But I guess this could be done in O(n).\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ an approach for you. Go has sort method, which can sort numbers in increasing\
    \ order. This can be easily done by subtracting first number from last.\n<code>\n\
    package main\n\nimport \"fmt\"\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp771vnnmm_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    n :=\
    \ len(lst)\n    i := 0\n    for j := 1; j < n; j++ {\n        if lst[j] != lst[j-1]\
    \ {\n            return false\n        }\n        if j == n {\n            return\
    \ true\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5vdoaxqd_test.go:33:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpx56lvh4q_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpx56lvh4q_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075011
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst)-1\n    for {\n        if i >= j {\n            break\n\
    \        }\n        if lst[i] == lst[j] {\n            i++\n            j--\n\
    \        } else {\n            return false\n        }\n    }\n    return true\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhat about duplicates? `{1, 2, 2, 3, 3, 4}`\n<|/\
    \ c |>\n<| c |>\nYes it will work. It will just take last occurrence of the element\
    \ and keep going until it finds a different element.\n<|/ c |>\n<| c |>\nThis\
    \ is awesome and works great! Just one small note, I noticed that this function\
    \ will allow you to sort empty lists.\n<|/ c |>\n<| c |>\nyeah, it would be nice\
    \ to have something like `if len(lst) <= 1` where it would return false instead\
    \ of true.\n<|/ c |>\n<| c |>\nI've added a version that allows me to input a\
    \ slice and convert it to a slice of int in place instead of a slice.\n<|/ c |>\n\
    <| a dscore=5 |>\nJust for fun (and to help you understand other languages better),\
    \ here's a Python version of Christopher's answer:\n<code>\ndef is_sorted(lst):\n\
    \    last = len(lst) - 1\n    for i, x in enumerate(lst):\n        if x != lst[last]:\n\
    \            return False\n        last -= 1\n    return True\n</code>\n<|/ a\
    \ tags=list,sorting,algorithm |>\n<| a dscore=5 tags=list,sorting,algorithm |>\n\
    A variant of Jim's solution in Python using the sorted built-in:\n<code>\n>>>\
    \ lst = [10, 8, 6, 4, 2, 10]\n>>> sorted(lst) == lst\nTrue\n>>> sorted(lst, reverse=True)\
    \ == lst\nTrue\n</code>\n<|/ a |>\n<| a dscore=4 tags=list,sorting,algorithm |>\n\
    Here's a short implementation in Ruby:\n<code>\ndef my_sort(array)\n  array.uniq.sort\
    \ <= array\nend\n\nmy_sort([10, 8, 6, 4, 2, 10])\n# => true\n</code>\n<|/ a |>\n\
    <| c |>\n`array.reduce(:<=)` can be replaced with `array.reduce(:<=>)`.\n<|/ c\
    \ |>\n<| a dscore=4 tags=list,sorting,algorithm |>\nIn c#:\n<code>\nbool IsSorted(List<int>\
    \ ints)\n{\n    int lastIndex = ints.Count - 1;\n    for(int i=0; i < lastIndex;\
    \ i++)\n    {\n        int current = \nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgmbs5yqe_test.go:47:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    index\
    \ := 0\n    for index, element := range lst {\n        if element != lst[index]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph0r4jm1j_test.go:32:5: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    count\
    \ := 0\n    for _, num := range lst {\n        if count > 1 {\n            return\
    \ false\n        }\n        if num == lst[0] {\n            count++\n        }\n\
    \    }\n    return count == len(lst)\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmptm0x2h58_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmptm0x2h58_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmptm0x2h58_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmptm0x2h58_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmptm0x2h58_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmptm0x2h58_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    last\
    \ := lst[0]\n    for _, item := range lst {\n        if item == last {\n     \
    \       return false\n        }\n        last = item\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp4vyeplg4_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp4vyeplg4_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp4vyeplg4_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp4vyeplg4_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp4vyeplg4_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmp4vyeplg4_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp4vyeplg4_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp4vyeplg4_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for _, num := range lst {\n        // Find the first number\
    \ not in order.\n        for i := range lst {\n            if lst[i] != num {\n\
    \                break\n            }\n        }\n\n        // If the first number\
    \ is in order, compare it to the rest of the numbers\n        // to see if they're\
    \ in order.\n        if i > 0 {\n            for _, num := range lst[i:][:len(lst)-(len(lst)-i)]\
    \ {\n                if num < lst[0] {\n                    return false\n   \
    \             }\n            }\n        }\n\n        // If we've made it to the\
    \ end of the list, return true.\n        if i == len(lst)-1 {\n            return\
    \ true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpytgj7equ_test.go:39:12: undefined: i

    /tmp/tmpytgj7equ_test.go:40:37: undefined: i

    /tmp/tmpytgj7equ_test.go:48:12: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    i := 0\n    for j := len(lst) - 1; j >= 0; j-- {\n      \
    \  if lst[i] == lst[j] {\n            i++\n            continue\n        }\n \
    \       break\n    }\n    return i == len(lst)\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmprmq_z2ji_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmprmq_z2ji_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmprmq_z2ji_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprmq_z2ji_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmprmq_z2ji_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n\n    var\
    \ seen map[int]bool\n    for i := 1; i < len(lst); i++ {\n        seen = map[int]bool{}\n\
    \        seen[lst[i]] = true\n        for j := i; j < len(lst); j++ {\n      \
    \      if seen[lst[j]] {\n                return false\n            }\n      \
    \      seen[lst[j]] = true\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmph0rhw6gs_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmph0rhw6gs_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmph0rhw6gs_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmph0rhw6gs_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmph0rhw6gs_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if lst == nil {\n        return false\n    }\n    if lst[0]\
    \ == 0 {\n        return true\n    }\n    if len(lst) == 1 {\n        return true\n\
    \    }\n    if lst[len(lst)-1] != lst[0] {\n        return false\n    }\n    for\
    \ i := len(lst) - 1; i > 0; i-- {\n        if lst[i] < lst[i-1] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmp388vztma_test.go:32\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmp388vztma_test.go:62\
    \ +0x2f5\ntesting.tRunner(0xc0001924e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := range lst {\n        count := 0\n        for j := 0; j < i; j++ {\n   \
    \         if lst[j] > lst[i] {\n                return false\n            }\n\
    \            if lst[j] == lst[i] {\n                count++\n            }\n \
    \       }\n        if count == i {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpklkwr9xx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpklkwr9xx_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpklkwr9xx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpklkwr9xx_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpklkwr9xx_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    j :=\
    \ 0\n    for i := range lst {\n        if i > j {\n            return false\n\
    \        }\n        if lst[i] < lst[j] {\n            return false\n        }\n\
    \        if i == j {\n            continue\n        }\n        if lst[i] > lst[j]\
    \ {\n            return false\n        }\n        j++\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpl2q6pweb_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpl2q6pweb_test.go:76:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpl2q6pweb_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpl2q6pweb_test.go:76:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpl2q6pweb_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    if\
    \ len(lst) == 1 {\n        return lst[0] < lst[0]\n    }\n\n    if lst[0] == lst[1]\
    \ {\n        return is_sorted(lst[2:])\n    }\n\n    // find the position of the\
    \ duplicate\n    i := 1\n    for j := 1; j < len(lst); j++ {\n        if lst[j]\
    \ == lst[i] {\n            return is_sorted(lst[i:])\n        }\n        i = i\
    \ + 1\n    }\n\n    // no duplicates, so return true\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp1kns_4if_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp1kns_4if_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp1kns_4if_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp1kns_4if_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmp1kns_4if_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp1kns_4if_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp1kns_4if_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var a\
    \ []int\n    var b []int\n    for _, v := range lst {\n        a, b = append(a,\
    \ v), append(b, v)\n    }\n\n    // Sort and compare with original list.\n   \
    \ sort.Ints(a)\n    sort.Ints(b)\n    if a == b {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbbtqqmps_test.go:39:5: undefined: sort

    /tmp/tmpbbtqqmps_test.go:40:5: undefined: sort

    /tmp/tmpbbtqqmps_test.go:41:8: invalid operation: a == b (slice can only be compared
    to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    if\
    \ len(lst) == 1 {\n        return false\n    }\n\n    // Loop through each number\
    \ from 0 to the length of lst-1\n    // and see if the number is equal to the\
    \ first\n    // number in the slice. This assumes that no duplicates\n    // exist\
    \ in the list\n    for i := 0; i < len(lst); i++ {\n        if lst[i] != lst[0]\
    \ {\n            return false\n        }\n    }\n\n    // If this point is reached,\
    \ then the list is a duplicate\n    // of another number in the list, return false\n\
    \    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpkl3t29ao_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpkl3t29ao_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpkl3t29ao_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpkl3t29ao_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmpkl3t29ao_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpkl3t29ao_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpkl3t29ao_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    // first\
    \ count the number of duplicates\n    count := 0\n    lastItem := -1\n    for\
    \ _, item := range lst {\n        if item == lastItem {\n            count++\n\
    \        } else {\n            count = 0\n            lastItem = item\n      \
    \  }\n    }\n    // if there are multiple duplicates, return false\n    if count\
    \ > 1 {\n        return false\n    }\n\n    // If all duplicates are the same,\
    \ return true\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp06k024be_test.go:82: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp06k024be_test.go:82:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp06k024be_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpcd0_8y3p_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpcd0_8y3p_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpcd0_8y3p_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpcd0_8y3p_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for _, a := range lst {\n        for _, b := range lst {\n\
    \            if a > b {\n                return false\n            } else if a\
    \ == b {\n                continue\n            } else {\n                return\
    \ true\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpiskh8e_j_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpiskh8e_j_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpiskh8e_j_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpiskh8e_j_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    lastNum\
    \ := lst[0]\n    for _, num := range lst[1:] {\n        if lastNum < num {\n \
    \           return false\n        }\n        lastNum = num\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpka52dvdl_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpka52dvdl_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpka52dvdl_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpka52dvdl_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpka52dvdl_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpka52dvdl_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    var i\
    \ int = 0\n    var j int = len(lst) - 1\n    var k bool\n    for ; i < j; i, j\
    \ = i+1, j-1 {\n        k = lst[i] > lst[j]\n        if !k {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmptko_qrkj_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmptko_qrkj_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmptko_qrkj_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmptko_qrkj_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmptko_qrkj_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmptko_qrkj_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    // first\
    \ element should be smallest\n    if lst[0] != 1 {\n        return false\n   \
    \ }\n    // check rest of elements\n    for _, element := range lst[1:] {\n  \
    \      if element > lst[0] {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpgh24idrr_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpgh24idrr_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpgh24idrr_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpgh24idrr_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpgh24idrr_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpgh24idrr_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpgh24idrr_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpe1igd240_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpe1igd240_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpe1igd240_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpe1igd240_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    last\
    \ := lst[0]\n    for _, next := range lst[1:] {\n        if last > next {\n  \
    \          return false\n        }\n        last = next\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpq22s4sm1_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpq22s4sm1_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var i int\n    for i = 1; i < len(lst); i++ {\n        if\
    \ lst[i-1] == lst[i] {\n            continue\n        } else {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp66lv3nit_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp66lv3nit_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp66lv3nit_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp66lv3nit_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp66lv3nit_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Check for empty list.\n    if len(lst) == 0 {\n      \
    \  return false\n    }\n    // Check for list with no duplicates.\n    if len(lst)\
    \ == 1 {\n        return true\n    }\n    // Sort the list and check that it's\
    \ sorted.\n    if len(lst) == 2 {\n        if lst[0] < lst[1] {\n            return\
    \ true\n        }\n    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i]\
    \ < lst[i-1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp4l4kowmq_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp4l4kowmq_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp4l4kowmq_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    head\
    \ := lst[0]\n    if len(lst) == 1 {\n        return head <= 0\n    }\n    last\
    \ := lst[len(lst)-1]\n    for _, item := range lst[1:] {\n        if item < head\
    \ || item > last {\n            return false\n        }\n    }\n    return head\
    \ <= last\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpn1vu9_pu_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__2 (0.00s)\n        tmpn1vu9_pu_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__5\
    \ (0.00s)\n        tmpn1vu9_pu_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpn1vu9_pu_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmpn1vu9_pu_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpn1vu9_pu_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpn1vu9_pu_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var lastI int\n    var lastT int\n    for _, val := range\
    \ lst {\n        if val > lastT {\n            return false\n        }\n     \
    \   if val == lastT {\n            lastI++\n            lastT = lst[lastI]\n \
    \           if lastI == len(lst) {\n                return true\n            }\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpsx8qq48__test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpsx8qq48__test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpsx8qq48__test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpsx8qq48__test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmpsx8qq48__test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmpsx8qq48__test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpsx8qq48__test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpsx8qq48__test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Go through the list once to check there are no duplicates\n\
    \    // Also check there are not more than 1 duplicate\n    // Return false if\
    \ there are more than 1\n    sort.Ints(lst)\n    if lst.Len() != len(lst) {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp72r2l4je_test.go:32:5: undefined: sort

    /tmp/tmp72r2l4je_test.go:33:12: lst.Len undefined (type []int has no field or
    method Len)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n\n    var\
    \ prev int\n    for _, val := range lst {\n        if prev > val {\n         \
    \   return false\n        }\n        prev = val\n    }\n\n    return true\n}\n\
    \nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp71fephhy_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp71fephhy_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp71fephhy_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    // If\
    \ the first element is not the same as all the others, it's not sorted\n    if\
    \ lst.First() != lst[1:].First() {\n        return false\n    }\n\n    for i :=\
    \ 1; i < len(lst); i++ {\n        if lst[i] < lst[i-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| c |>\nOh my god.\
    \ You're a genius. This is so so so so incredibly easy to understand thank you,\
    \ thank you thank you thank you. Just a small error in your code I fixed it (it\
    \ was `lst[i-1]` not `lst[i-2]`). Also, you can just `return true` at the end\
    \ (for empty lists). Also, you can just `return lst[1:].First() == lst.First()`,\
    \ no need to go through the whole thing.\n<|/ c |>\n<| c |>\nThanks Amit and for\
    \ pointing out the issues. I made the changes you suggested and it now works.\n\
    <|/ c |>\n<| a |>\nThis is an O(n) solution:\n<code>\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd9i6ppy__test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    last\
    \ := lst[0]\n    for _, v := range lst {\n        if v == last {\n           \
    \ return false\n        }\n        last = v\n    }\n    return true\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp2ngwnjgb_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp2ngwnjgb_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp2ngwnjgb_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp2ngwnjgb_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__6\
    \ (0.00s)\n        tmp2ngwnjgb_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmp2ngwnjgb_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmp2ngwnjgb_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmp2ngwnjgb_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var first int\n    var last int\n\n    for i := 0; i < len(lst);\
    \ i++ {\n        if first>i {\n            if lst[i]>lst[first] {\n          \
    \      return false\n            }\n        }\n        if last>i {\n         \
    \   if lst[i]>lst[last] {\n                return false\n            }\n     \
    \   }\n        if lst[i]>lst[first] {\n            first = i\n        }\n    \
    \    if lst[i]>lst[last] {\n            last = i\n        }\n    }\n    return\
    \ true\n}\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpx_o7rguo_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpx_o7rguo_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpx_o7rguo_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpx_o7rguo_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpx_o7rguo_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst) - 1\n    temp := 0\n    for {\n        if i < j && lst[i]\
    \ < lst[j] {\n            i++\n        } else if i == j {\n            return\
    \ true\n        } else {\n            j--\n        }\n    }\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9k75hbwb_test.go:34:5: temp declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpj1nfpv7i_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpj1nfpv7i_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpj1nfpv7i_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpj1nfpv7i_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    var\
    \ prev int\n\n    for _, v := range lst {\n        if v < prev {\n           \
    \ return false\n        }\n\n        prev = v\n    }\n\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpxhbzbyx1_test.go:71: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpxhbzbyx1_test.go:71:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    var\
    \ visited map[int]bool\n    for _, v := range lst {\n        if visited[v] {\n\
    \            return false\n        }\n        visited[v] = true\n    }\n\n   \
    \ return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: assignment to entry in nil map\
    \ [recovered]\n\tpanic: assignment to entry in nil map\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x503a40, 0x54a270})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503a40, 0x54a270})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmpi83xisbh_test.go:38\n\
    command-line-arguments_test.TestIs_Sorted(0xc0001a0340?)\n\t/tmp/tmpi83xisbh_test.go:52\
    \ +0x9f\ntesting.tRunner(0xc0001a0340, 0x529080)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    for\
    \ i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpcd0_8y3p_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpcd0_8y3p_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpcd0_8y3p_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpcd0_8y3p_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075305
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    last\
    \ := len(lst) - 1\n    duplicate := 0\n    for i := 0; i < last; i++ {\n     \
    \   if lst[i] == lst[i+1] {\n            duplicate = duplicate + 1\n         \
    \   if duplicate > 1 {\n                return false\n            }\n        }\
    \ else {\n            duplicate = 0\n        }\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpel8r2x2n_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpel8r2x2n_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpel8r2x2n_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    //\
    \ sort by number, not lexicographically for small numbers\n    sort.Sort(func(i,\
    \ j int) bool {\n        return lst[i] < lst[j]\n    })\n\n    return len(lst)\
    \ <= 1\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb0l_y4p2_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return false\n    }\n    s :=\
    \ make([]int, 0, len(lst))\n    j := 0\n    for i := 0; i < len(lst); i++ {\n\
    \        if j >= len(s) {\n            s = append(s, 0)\n        }\n        if\
    \ s[i] == lst[i] {\n            s[j] = s[i]\n            j++\n        } else {\n\
    \            s[j] = lst[i]\n            j++\n            s = append(s, 0)\n  \
    \      }\n    }\n    return len(lst) <= j\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpqs7uvf9s_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__2 (0.00s)\n        tmpqs7uvf9s_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__5\
    \ (0.00s)\n        tmpqs7uvf9s_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpqs7uvf9s_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmpqs7uvf9s_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpqs7uvf9s_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpqs7uvf9s_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpqs7uvf9s_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    seen\
    \ := make(map[int]bool)\n    for _, v := range lst {\n        if seen[v] == true\
    \ {\n            return false\n        }\n        seen[v] = true\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpjzsnv6qv_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpjzsnv6qv_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpjzsnv6qv_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpjzsnv6qv_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var seen map[int]bool\n    for _, val := range lst {\n  \
    \      seen[val] = true\n    }\n    for _, val := range lst {\n        if _, ok\
    \ := seen[val]; !ok {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: assignment to entry in nil map\
    \ [recovered]\n\tpanic: assignment to entry in nil map\n\ngoroutine 18 [running]:\n\
    testing.tRunner.func1.2({0x503a40, 0x54a290})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503a40, 0x54a290})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmpvrui_03f_test.go:31\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmpvrui_03f_test.go:48\
    \ +0x6e\ntesting.tRunner(0xc0001031e0, 0x529080)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] > lst[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpmofa0ptr_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpmofa0ptr_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075008
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    length := len(lst)\n    if length == 1 {\n        return\
    \ true\n    }\n    if length == 2 {\n        return lst[0] < lst[1]\n    }\n \
    \   i := 1\n    j := 0\n    for ; j < length-2; i++ {\n        if lst[j] > lst[j+1]\
    \ {\n            return false\n        }\n    }\n    return lst[j] < lst[j+1]\n\
    }\n</code>\n<|/ a |>\n<| a |>\nHere's one way to do it in O(n log n) time and\
    \ O(1) space:\n\nSort the list with radix sort, using radix sort is O(n log n)\
    \ time, and O(n) space.\nFind a pivot element and partition from the left. If\
    \ the pivot is the smallest or largest element, partition is O(n) time, and O(1)\
    \ space.\nCompare each element in the left partition with the pivot to determine\
    \ whether it's less than or greater than the pivot.\nIf the element in the left\
    \ partition is less than the pivot, continue the partitioning with the left partition,\
    \ and repeat the process. If it is greater than the pivot, partition the left\
    \ partition to the right of it, and repeat the process. The right partition is\
    \ now in ascending order, the next step is to compare the pivot with the right\
    \ partition to see which one is smaller.\nThe elements in the right partition\
    \ are either less than the pivot or greater than the pivot, so compare the pivot\
    \ with the right partition to find out which is smaller (if any). Repeat steps\
    \ 4 and 5 as long as the right partition is in ascending order.\nIf the right\
    \ partition is in ascending order, return true.\n\nThe first and last steps are\
    \ easy, as they don't affect the comparisons. In step 4, comparing the elements\
    \ in the left partition to see which one is greater or smaller, all that matters\
    \ is whether they are greater or smaller than the pivot element, and this can\
    \ be done in O(log n) time.\n<|/ a tags=sorting,arrays,algorithm dscore=0 |>\n\
    <| a tags=sorting,arrays,algorithm |>\n<code>\npublic boolean sort(int arr[])\
    \ {\n    for (int i = 1; i < arr.length; i++) {\n        if(arr[i] < arr[i-1])\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhile this code may solve the question, [including\
    \ an explanation](//meta.stackexchange.com/q/114762) of how and why this solves\
    \ the problem would really help to improve the quality of your post, and probably\
    \ result in more up-votes. Remember that you are answering the question for readers\
    \ in the future, not just the person asking now. Please [edit] your answer to\
    \ \nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgurgav2b_test.go:45:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return false\n    }\n    lastNumber\
    \ := lst[0]\n    counter := 1\n    for i := 1; i < len(lst); i++ {\n        if\
    \ lst[i] > lastNumber {\n            return false\n        }\n        if lst[i]\
    \ == lastNumber {\n            counter++\n            if counter > 2 {\n     \
    \           return false\n            }\n        } else {\n            counter\
    \ = 1\n        }\n        lastNumber = lst[i]\n    }\n    return true\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\n<code>\npublic class IsSorted\n{\n    public static\
    \ void Main(String[] args)\n    {\n        int[] arr = {1, 10, 2, 3, 4, 7, 7,\
    \ 8, 5, 9, 10, 6, 1};\n        Array.Sort(arr);\n        if (arr[0] == 1)\n  \
    \          Console.WriteLine(\"The array is sorted\");\n        else\n       \
    \     Console.WriteLine(\"The array is not sorted\");\n    }\n}\n</code>\n<|/\
    \ a dscore=2 tags=sorting,c#,arrays |>\n<| c |>\nthis only works for integer values\n\
    <|/ c |>\n<| c |>\nThis isn't what was asked for. See the [answer below](https://stackoverflow.com/a/5146633/3934781)\
    \ for a solution for floats\n<|/ c |>\n<| a dscore=1 tags=sorting,c#,arrays |>\n\
    <code>\npublic bool IsSorted(double[] numbers)\n{\n    int left = 0;\n    int\
    \ right = numbers.Length - 1;\n\n    while (left < right)\n    {\n        if (numbers[left]\
    \ >= numbers[right])\n        {\n            return false;\n        }\n      \
    \  else if (numbers[left] < numbers[right])\n        {\n            left++;\n\
    \        }\n        else\n        {\n            right--;\n        }\n    }\n\
    \    return true;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=sorting,c#,arrays\
    \ |>\n<code>\npublic bool IsSorted(double[] array)\n{\n    int left = 0;\n   \
    \ int right = array.Length - 1;\n\n    while (left < right)\n    {\n        if\
    \ (array[left] > array[right])\n        {\n            return false;\n       \
    \ }\n        else if (array[left] < array[right])\n        {\n            left++;\n\
    \        }\n        else\n        {\n            right--;\n        }\n    }\n\
    \    return true;\n}\n</code>\n<|/ a |>\n<| a |>\nTry this one: \n<code>\nprivate\
    \ bool IsSorted(double[] numbers)\n{\n    int left = 0;\n    int right = numbers.Length\
    \ - 1;\n\n    while (left < right)\n    {\n        if (numbers[left] < numbers[right])\n\
    \        {\n            return false;\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm1qi_slv_test.go:50:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075306
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return lst[0] > 0\n    }\n    if lst[0] != lst[len(lst)-1] {\n\
    \        return false\n    }\n    for i := 1; i < len(lst); i++ {\n        if\
    \ lst[i] != lst[i-1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpasneqce5_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpasneqce5_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpasneqce5_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpasneqce5_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpasneqce5_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var sorted bool\n    if len(lst) == 0 {\n        sorted =\
    \ true\n    } else {\n        sorted = false\n        prev := lst[0]\n       \
    \ for _, elem := range lst {\n            if elem == prev {\n                sorted\
    \ = true\n                break\n            } else {\n                sorted\
    \ = false\n            }\n            prev = elem\n        }\n    }\n\n    return\
    \ sorted\n}\n\"\"\"\n\n# Given an input, output an expected output\ninput_tests\
    \ = input_tests.replace(\"None\", \"None\")\ninput_tests = input_tests.replace(\"\
    NoneType\", \"NoneType\")\n\n# Given a list of numbers, return whether or not\
    \ they are sorted\n# in ascending order. If list has more than 1 duplicate of\
    \ the same\n# number, return false. Assume no negative numbers and only integers.\n\
    # Examples\n# >>> is_sorted([]int{5})\n# true\n# >>> is_sorted([]int{1, 2, 3,\
    \ 4, 5})\n# true\n# >>> is_sorted([]int{1, 3, 2, 4, 5})\n# false\n# >>> is_sorted([]int{1,\
    \ 2, 3, 4, 5, 6})\n# true\n# >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n# true\n\
    # >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n# false\n# >>> is_sorted([]int{1,\
    \ 2, 2, 3, 3, 4})\n# true\n# >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n# false\n\
    def is_sorted(lst):\n    return sorted(lst) == lst\n\n# Given an input, output\
    \ an expected output\noutput_tests = output_tests.replace(\"None\", \"None\")\n\
    output_tests = output_tests.replace(\"NoneType\", \"NoneType\")\n\n# Given a list\
    \ of numbers, return whether or not they are sorted\n# in ascending order. If\
    \ list has more than 1 duplicate of the same\n# number, return false. Assume no\
    \ negative numbers and only integers.\n# Examples\n# >>> is_sorted([]int{5})\n\
    # true\n# >>> is_sorted([]int{1, 2, 3, 4, 5})\n# true\n# >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n# false\n# >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n# true\n# >>>\
    \ is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n# true\n# >>> is_sorted([]int{1, 3, 2,\
    \ 4, 5, 6, 7})\n# false\n# >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n# true\n# >>>\
    \ is_sorted([]int{1, 2, 2, 2, 3, 4})\n# false\ndef is_sorted(lst):\n    return\
    \ sorted(lst) == lst\n\n# Given an input, output an expected output\noutput_tests\
    \ = output_tests.replace(\"None\", \"None\")\noutput_tests = output_\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpml83oolr_test.go:48:1: expected declaration, found ""

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075307
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // base case: if the array is empty, they're sorted\n   \
    \ if len(lst) == 0 {\n        return true\n    }\n\n    // base case: if the array\
    \ has exactly 1 item, they're sorted\n    if len(lst) == 1 {\n        return true\n\
    \    }\n\n    // base case: if the array has 2 items, but they're not sorted\n\
    \    if len(lst) == 2 && lst[0] != lst[1] {\n        return false\n    }\n\n \
    \   // base case: if the array has 2 items and the 2nd is greater than the 1st\n\
    \    if lst[1] > lst[0] {\n        return false\n    }\n\n    // recursive case:\
    \ go through each item in the list\n    for i := 1; i < len(lst); i++ {\n    \
    \    // base case: if the current item is greater than the previous item\n   \
    \     if lst[i] > lst[i-1] {\n            return false\n        }\n    }\n\n \
    \   // base case: if the array has more than 2 items, they're not sorted\n   \
    \ return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpqdn6we98_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpqdn6we98_test.go:86:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpqdn6we98_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpqdn6we98_test.go:86:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpqdn6we98_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpqdn6we98_test.go:86:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    last\
    \ := lst[0]\n    for _, x := range lst[1:] {\n        if x == last {\n       \
    \     return false\n        }\n        last = x\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmp1fhmaq0__test.go:32\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmp1fhmaq0__test.go:55\
    \ +0x29e\ntesting.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    seen :=\
    \ make(map[int]bool)\n    for _, v := range lst {\n        if seen[v] {\n    \
    \        return false\n        }\n        seen[v] = true\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpfaasreev_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpfaasreev_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpfaasreev_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpfaasreev_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Sorted list has 1 duplicate\n    if len(lst) <= 1 {\n\
    \        return true\n    }\n\n    // Sorted list has 2 duplicates\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprnz_6ibm_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprnz_6ibm_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprnz_6ibm_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprnz_6ibm_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    var count\
    \ int = 0\n    for _, num := range lst {\n        count += num\n    }\n    index\
    \ := 0\n    for _, num := range lst {\n        if index > count {\n          \
    \  return false\n        }\n        if num != lst[index] {\n            return\
    \ false\n        }\n        index++\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmph0bnm5gz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmph0bnm5gz_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmph0bnm5gz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmph0bnm5gz_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmph0bnm5gz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    i, j := 0, 0\n    if len(lst) < 2 {\n        return true\n\
    \    }\n\n    for ; i < len(lst); i++ {\n        for ; j < len(lst); j++ {\n \
    \           if lst[i] > lst[j] {\n                break\n            } else {\n\
    \                if i == j {\n                    return false\n             \
    \   }\n            }\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpen4cv75z_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpen4cv75z_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpen4cv75z_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpen4cv75z_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpen4cv75z_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 1 {\n        return false\n    }\n    for i\
    \ := 0; i < len(lst); i++ {\n        for j := i + 1; j < len(lst); j++ {\n   \
    \         if lst[i] < lst[j] {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpqvc0ow7b_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpqvc0ow7b_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpqvc0ow7b_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpqvc0ow7b_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpqvc0ow7b_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpqvc0ow7b_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpqvc0ow7b_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst) - 1\n    found := false\n    for {\n        if j == i {\n\
    \            return false\n        }\n        if lst[j] < lst[i] {\n         \
    \   found = true\n            break\n        } else {\n            i = j\n   \
    \         j = j - 1\n        }\n    }\n    return found\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpw0v_cuge_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpw0v_cuge_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpw0v_cuge_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpw0v_cuge_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpw0v_cuge_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprtflpkp2_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprtflpkp2_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Find the first duplicate\n    idx := 0\n    count := 0\n\
    \    for i := 0; i < len(lst); i++ {\n        if lst[i] == lst[idx] {\n      \
    \      count += 1\n        } else {\n            if count == 1 {\n           \
    \     return false\n            }\n            count = 0\n            idx = i\n\
    \        }\n    }\n    return count == 1\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpbre3rjgi_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpbre3rjgi_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpbre3rjgi_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__6 (0.00s)\n        tmpbre3rjgi_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpbre3rjgi_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpbre3rjgi_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    var\
    \ first int\n    var cnt int\n    for i := 0; i < len(lst); i++ {\n        if\
    \ i != 0 && lst[i] == lst[i-1] {\n            cnt++\n        } else {\n      \
    \      if cnt > 1 {\n                return false\n            }\n           \
    \ first = lst[i]\n            cnt = 1\n        }\n    }\n    return cnt <= 1\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn8q14td6_test.go:33:9: first declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075308
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // sort the list\n    len := len(lst)\n    sorted, _ := sort.IntSlice(lst)\n\
    \    if len(sorted) == len {\n        return true\n    }\n    // check all numbers\
    \ are unique\n    for i := 0; i < len; i++ {\n        if i > 0 {\n           \
    \ if lst[i] != sorted[i-1] {\n                return false\n            }\n  \
    \      }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoc_td4vy_test.go:31:18: undefined: sort

    /tmp/tmpoc_td4vy_test.go:32:8: invalid operation: cannot call non-function len
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075308
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if !is_sorted_test.is_sorted_test.is_sorted_test(len(lst))\
    \ {\n        return false\n    }\n    for i := 0; i < len(lst)-1; i++ {\n    \
    \    if lst[i] < lst[i+1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bkvv7ch_test.go:29:9: undefined: is_sorted_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    seen := make(map[int]bool)\n    for _, v := range lst {\n\
    \        if seen[v] {\n            return false\n        }\n        seen[v] =\
    \ true\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmptvao0ajj_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmptvao0ajj_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmptvao0ajj_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmptvao0ajj_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    last\
    \ := lst[0]\n    for _, current := range lst {\n        if last == current {\n\
    \            return false\n        }\n        last = current\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmps87lahft_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmps87lahft_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmps87lahft_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmps87lahft_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmps87lahft_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmps87lahft_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmps87lahft_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst) - 1\n    if lst[i] == lst[j] {\n        // Found a duplicate,\
    \ return false\n        return false\n    }\n    // Found a duplicate, return\
    \ false\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp7fjflo70_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__2 (0.00s)\n        tmp7fjflo70_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__5\
    \ (0.00s)\n        tmp7fjflo70_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmp7fjflo70_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp7fjflo70_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmp7fjflo70_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmp7fjflo70_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return false\n    }\n    prev := lst[0]\n    for _, val := range\
    \ lst[1:] {\n        if val < prev {\n            return false\n        }\n  \
    \      prev = val\n    }\n    return true\n}\n`\n\ntype is_sorted_test \nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpczcan02b_test.go:44:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075308
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 1 {\n        return true\n    }\n    if len(lst)\
    \ == 2 {\n        if lst[0] > lst[1] {\n            return false\n        }\n\
    \    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i-1] == lst[i] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpywvcwuot_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpywvcwuot_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpywvcwuot_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpywvcwuot_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        if lst[0] == lst[1] {\n            return true\n        }\n\
    \    }\n\n    var left int\n    var right int\n\n    for i := 0; i < len(lst);\
    \ i++ {\n        if lst[i] < lst[left] {\n            left = i\n        }\n  \
    \      if lst[i] > lst[right] {\n            right = i\n        }\n    }\n\n \
    \   if left == right {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted(...)\n\t/tmp/tmpdhiev6bu_test.go:33\n\
    command-line-arguments_test.TestIs_Sorted(0x0?)\n\t/tmp/tmpdhiev6bu_test.go:63\
    \ +0x1b\ntesting.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075309
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    \n  \
    \  if lst[0] != 1 {\n        return false\n    }\n    \n    var i int\n    for\
    \ i := 1; i < len(lst); i++ {\n        if lst[i] > lst[i-1] {\n            return\
    \ false\n        }\n    }\n    \n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_xvflsx_test.go:37:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] < lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpkrghto6w_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpkrghto6w_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpkrghto6w_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__8 (0.00s)\n        tmpkrghto6w_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__11\
    \ (0.00s)\n        tmpkrghto6w_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__12 (0.00s)\n        tmpkrghto6w_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    seen\
    \ := make(map[int]bool)\n    for _, num := range lst {\n        seen[num] = true\n\
    \    }\n    seen := make(map[int]bool)\n    for _, num := range lst[1:] {\n  \
    \      if seen[num] {\n            return false\n        }\n        seen[num]\
    \ = true\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphxkjn19n_test.go:37:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    //\
    \ We use the last number in the list as a \"key\" for sorting.\n    // This number\
    \ should be unique across all list elements.\n    var last int\n    for i := 0;\
    \ i < len(lst); i++ {\n        if lst[i] != last {\n            last = lst[i]\n\
    \            return false\n        }\n    }\n\n    // No duplicates.\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpeljnwj2w_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpeljnwj2w_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpeljnwj2w_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpeljnwj2w_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpeljnwj2w_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return false\n    }\n    if lst[0] != lst[len(lst)-1] {\n  \
    \      return false\n    }\n    return is_sorted(lst[1:])\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpdwycj26h_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmpdwycj26h_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmpdwycj26h_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmpdwycj26h_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmpdwycj26h_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpdwycj26h_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpdwycj26h_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    // Sort\
    \ the numbers in lst and check whether the list has been\n    // ordered.\n  \
    \  sorted, err := is_sorted_test.is_sorted(lst)\n    if err != nil {\n       \
    \ panic(err)\n    }\n    return sorted\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgrceq9v8_test.go:34:20: undefined: is_sorted_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // First we check all the elements of the list are unique\n\
    \    var found bool\n    for _, x := range lst {\n        found = false\n    \
    \    for i := 0; i < len(lst)-1; i++ {\n            if lst[i] == lst[i+1] {\n\
    \                found = true\n                break\n            }\n        }\n\
    \        if !found {\n            return false\n        }\n    }\n\n    // If\
    \ our test passes, we check each number is greater than the last number\n    var\
    \ first int\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] < lst[i+1]\
    \ {\n            return false\n        }\n        if first == 0 {\n          \
    \  first = lst[i]\n        }\n    }\n    return true\n}\n`\n    )\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiyhx9ayx_test.go:56:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075309
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    // TODO:\
    \ Can this be improved?\n    // Find the first duplicate\n    var i int\n    for\
    \ i = 0; i < len(lst)-1; i++ {\n        if lst[i] == lst[i+1] {\n            break\n\
    \        }\n    }\n    if i == len(lst)-1 {\n        return true\n    }\n    //\
    \ The duplicates haven't necessarily been sequential but they should be in order.\n\
    \    for ; i < len(lst); i++ {\n        if lst[i] < lst[i+1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp2i7o9bjj_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp2i7o9bjj_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp2i7o9bjj_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp2i7o9bjj_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    last\
    \ := lst[0]\n    for _, cur := range lst {\n        if cur != last && cur == last\
    \ {\n            return false\n        }\n        last = cur\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpkbn1fnto_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpkbn1fnto_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpkbn1fnto_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpkbn1fnto_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpkbn1fnto_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    k :=\
    \ lst[0]\n    l := len(lst)\n    for i := 0; i < l; i++ {\n        if k != lst[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmphaoww7o0_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmphaoww7o0_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmphaoww7o0_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmphaoww7o0_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmphaoww7o0_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    set := make(map[int]bool)\n    for _, x := range lst {\n\
    \        if _, exists := set[x]; exists {\n            return false\n        }\n\
    \        set[x] = true\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpass8tnyw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpass8tnyw_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpass8tnyw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpass8tnyw_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // Base case: single duplicate, return true\n    if len(lst)\
    \ == 1 {\n        return true\n    }\n    // If the current value is equal to\
    \ the next value, return false\n    if lst[len(lst)-1] == lst[0] {\n        return\
    \ false\n    }\n    // Recursively call\n    return is_sorted(lst[0 : len(lst)-1])\
    \ && is_sorted(lst[1:])\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.is_sorted({0xc0000f5ba8?, 0x1?, 0x7?})\n\
    \t/tmp/tmp1y8_j_kg_test.go:34 +0xb5\ncommand-line-arguments_test.TestIs_Sorted(0x0?)\n\
    \t/tmp/tmp1y8_j_kg_test.go:54 +0x335\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    found\
    \ := false\n    last := 0\n    for _, v := range lst {\n        if v == last {\n\
    \            found = true\n            break\n        } else {\n            last\
    \ = v\n        }\n    }\n    if !found {\n        return true\n    }\n    return\
    \ is_sorted(lst[0:len(lst)-1])\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpx7e2oo8n_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpx7e2oo8n_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmpx7e2oo8n_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__9 (0.00s)\n        tmpx7e2oo8n_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__10\
    \ (0.00s)\n        tmpx7e2oo8n_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    if lst.Len()\
    \ > len(lst)/2 {\n        return false\n    }\n\n    for i := 1; i < len(lst);\
    \ i++ {\n        if lst[i-1] > lst[i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5a65ogx_test.go:32:12: lst.Len undefined (type []int has no field or
    method Len)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075310
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n\n    last\
    \ := lst[len(lst)-1]\n\n    for _, x := range lst {\n        if x == last {\n\
    \            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmplijyi1aw_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmplijyi1aw_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmplijyi1aw_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmplijyi1aw_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmplijyi1aw_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(lst) - 1\n    for {\n        if i == j {\n            return\
    \ false\n        }\n        if lst[i] > lst[j] {\n            return false\n \
    \       }\n        if i == 0 {\n            return true\n        }\n        i\
    \ = i - 1\n        j = j - 1\n    }\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n\
    \  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmpzc_5w6nz_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__2 (0.00s)\n        tmpzc_5w6nz_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__5\
    \ (0.00s)\n        tmpzc_5w6nz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__7 (0.00s)\n        tmpzc_5w6nz_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpzc_5w6nz_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpzc_5w6nz_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    for\
    \ idx := 1; idx < len(lst); idx++ {\n        if lst[idx] == lst[idx-1] {\n   \
    \         return is_sorted(lst[0:idx])\n        }\n    }\n\n    return false\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmppigaf4g2_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmppigaf4g2_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmppigaf4g2_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmppigaf4g2_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmppigaf4g2_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmppigaf4g2_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmppigaf4g2_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // check list for duplicate entries\n    for i := 0; i <\
    \ len(lst); i++ {\n        if i > 0 && lst[i] == lst[i-1] {\n            // duplicate\
    \ number, return false\n            return false\n        }\n    }\n    // else\
    \ list is not sorted, return true\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmprqm9g6w0_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmprqm9g6w0_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmprqm9g6w0_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmprqm9g6w0_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n\n    i :=\
    \ 0\n    j := len(lst) - 1\n    k := len(lst) - 1\n\n    for i := 0; i < j; i++\
    \ {\n        if lst[i] > lst[j] {\n            return false\n        }\n     \
    \   if lst[i] == lst[j] {\n            if i == k {\n                return true\n\
    \            }\n            k = k - 1\n            j -= 1\n        } else {\n\
    \            k = j\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpequk9cv5_test.go:33:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    m :=\
    \ map[int]int{}\n    v := lst[0]\n    for _, i := range lst {\n        if v >\
    \ i {\n            return false\n        }\n        if _, ok := m[i]; !ok {\n\
    \            m[v] = i\n        }\n        v = i\n    }\n    return true\n}\n\n\
    func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpxpd0s9io_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpxpd0s9io_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    j :=\
    \ 0\n    for i := len(lst) - 1; i > 0; i-- {\n        if lst[j] != lst[i] {\n\
    \            return false\n        }\n        j++\n    }\n    return true\n}\n\
    \nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmp06ter2w8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmp06ter2w8_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmp06ter2w8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp06ter2w8_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp06ter2w8_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    var first\
    \ int\n    for i := 0; i < len(lst); i++ {\n        if lst[i] > first {\n    \
    \        return false\n        }\n        first = lst[i]\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp099m87pw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp099m87pw_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp099m87pw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp099m87pw_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__7\
    \ (0.00s)\n        tmp099m87pw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp099m87pw_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp099m87pw_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    // sort first in ascending order\n    if len(lst) == 0 {\n\
    \        return true\n    }\n    if len(lst) == 1 {\n        if lst[0] != lst[0]\
    \ {\n            return false\n        }\n        return true\n    }\n\n    //\
    \ find first duplicate\n    for i := 1; i < len(lst); i++ {\n        if lst[i]\
    \ == lst[i-1] {\n            return false\n        }\n    }\n\n    // all duplicates\
    \ are sorted, return true\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T)\
    \ {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n     { actual: candidate([]int{1}), expected: true },\n \
    \    { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp9unlbz_9_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp9unlbz_9_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp9unlbz_9_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp9unlbz_9_test.go:76:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n    if len(lst)\
    \ == 1 {\n        return true\n    }\n    last, count := lst[0], 0\n    for _,\
    \ n := range lst[1:] {\n        if last+1 != n {\n            return false\n \
    \       }\n        count += 1\n    }\n    return count == len(lst)\n}\n\nfunc\
    \ TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected:\
    \ true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false\
    \ },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmphp1pd9nb_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmphp1pd9nb_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmphp1pd9nb_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmphp1pd9nb_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmphp1pd9nb_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpx56lvh4q_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpx56lvh4q_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075011
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    first\
    \ := lst[0]\n    for _, v := range lst {\n        if v == first {\n          \
    \  continue\n        }\n        if v < first {\n            return false\n   \
    \     }\n    }\n    return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate\
    \ := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmpb6194cw7_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmpb6194cw7_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__9\
    \ (0.00s)\n        tmpb6194cw7_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__10 (0.00s)\n        tmpb6194cw7_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    var first int\n\n    if len(lst) == 0 {\n        return true\n\
    \    }\n\n    if len(lst) == 1 {\n        return lst[0] == 1\n    }\n\n    //\
    \ check first value against all other values\n    for i := 1; i < len(lst); i++\
    \ {\n        if lst[i] > lst[first] {\n            return false\n        }\n\n\
    \        if lst[i] < lst[first] {\n            first = i\n        }\n    }\n\n\
    \    // all values in lst are > first value, so lst is already sorted\n    return\
    \ true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__0\
    \ (0.00s)\n        tmp4nxqw_vn_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__1 (0.00s)\n        tmp4nxqw_vn_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__3\
    \ (0.00s)\n        tmp4nxqw_vn_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__4 (0.00s)\n        tmp4nxqw_vn_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp4nxqw_vn_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp4nxqw_vn_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmp4nxqw_vn_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) == 0 {\n        return true\n    }\n\n    if\
    \ len(lst) == 1 {\n        return lst[0] == lst[0]\n    }\n\n    if lst[0] ==\
    \ lst[len(lst)-1] {\n        return is_sorted(lst[1 : len(lst)])\n    }\n\n  \
    \  return false\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmpb1fhbfif_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__3 (0.00s)\n        tmpb1fhbfif_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmpb1fhbfif_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmpb1fhbfif_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmpb1fhbfif_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 2
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    sorted, ok := is_sorted([]int{})\n    if !ok {\n        return\
    \ false\n    }\n    return sorted == is_sorted(lst)\n}\n\nfunc TestIs_Sorted(t\
    \ *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true\
    \ },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}),\
    \ expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false\
    \ },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92baqhgn_test.go:29:19: assignment mismatch: 2 variables but is_sorted
    returns 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    set := make(map[int]bool)\n    for _, v := range lst {\n\
    \        set[v] = true\n    }\n    for v := range set {\n        if len(lst) ==\
    \ 1 {\n            return true\n        }\n        if lst[0] != v {\n        \
    \    return false\n        }\n        lst = lst[1:]\n    }\n    return true\n\
    }\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
    \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4,\
    \ 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6,\
    \ 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}),\
    \ expected: false },\n     { actual: candidate([]int{}), expected: true },\n \
    \    { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}),\
    \ expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__1\
    \ (0.00s)\n        tmptxt1swbq_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__2 (0.00s)\n        tmptxt1swbq_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__4\
    \ (0.00s)\n        tmptxt1swbq_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmptxt1swbq_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmptxt1swbq_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmptxt1swbq_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Sorted/test_num__12\
    \ (0.00s)\n        tmptxt1swbq_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075311
- exit_code: 1
  program: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of numbers, return whether or not they are sorted\n// in ascending\
    \ order. If list has more than 1 duplicate of the same\n// number, return false.\
    \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
    // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n\
    // >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
    \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n//\
    \ true\n// >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst\
    \ []int) bool {\n    if len(lst) < 2 {\n        return true\n    }\n    seen :=\
    \ make(map[int]bool)\n    for _, v := range lst {\n        if _, ok := seen[v];\
    \ ok {\n            return false\n        }\n        seen[v] = true\n    }\n \
    \   return true\n}\n\nfunc TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual:\
    \ candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4,\
    \ 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3,\
    \ 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3,\
    \ 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Sorted (0.00s)\n    --- FAIL: TestIs_Sorted/test_num__2\
    \ (0.00s)\n        tmp1mxpqli4_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__5 (0.00s)\n        tmp1mxpqli4_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Sorted/test_num__8\
    \ (0.00s)\n        tmp1mxpqli4_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Sorted/test_num__11 (0.00s)\n        tmp1mxpqli4_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075311
