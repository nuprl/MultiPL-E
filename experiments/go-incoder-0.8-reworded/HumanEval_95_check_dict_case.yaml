name: HumanEval_95_check_dict_case
language: go_test.go
prompt: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a map, return true if all keys are strings in lower \n// case or all\
  \ keys are strings in upper case, else return false.\n// The function should return\
  \ false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
  a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
  a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
  a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
  Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
  STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
  \ bool {\n"
tests: "func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
  , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
  p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
  \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
  , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
  Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
  \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
  }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
  Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
  \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(dict) == 0 {\n        return false\n    }\n\n    for k :=\
    \ range dict {\n        switch v := dict[k].(type) {\n        case string:\n \
    \           if strings.ToLower(k) == v {\n                return true\n      \
    \      }\n        case float64:\n            if strings.ToLower(k) == fmt.Sprint(v)\
    \ {\n                return true\n            }\n        case int64:\n       \
    \     if strings.ToLower(k) == fmt.Sprint(v) {\n                return true\n\
    \            }\n        }\n    }\n    return false\n}\n</code>\n<|/ a tags=go,dictionary\
    \ |>\n<| a dscore=2 tags=go,dictionary |>\nA simple solution would be:\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for k, v := range dict {\n        lowk\
    \ := strings.ToLower(k)\n        upk := strings.ToUpper(k)\n        if v != \"\
    \" {\n            if lowk != v {\n                return false\n            }\n\
    \        } else {\n            if upk != v {\n                return false\n \
    \           }\n        }\n    }\n    return true\n}\n", "    len := len(dict)\n\
    \    for k := range dict {\n        switch v.(type) {\n        case *string, *string:\n\
    \            if k != k.ToLower() && k != k.ToUpper() {\n                return\
    \ false\n            }\n        default:\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    for k, v := range dict {\n        if k == \"\" || k == v {\n   \
    \         return false\n        }\n\n        // Lower case all keys in lower case\n\
    \        if k == strings.ToLower(k) {\n            return true\n        }\n\n\
    \        // Upper case all keys in upper case\n        if k == strings.ToUpper(k)\
    \ {\n            return true\n        }\n    }\n    return false\n}\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n\n    for key, value := range\
    \ dict {\n        if key != fmt.Sprintf(\"%s\", key) {\n            return false\n\
    \        }\n\n        if value == \"\" {\n            return false\n        }\n\
    \n        // for strings with upper case, convert to lower case\n        if strings.HasPrefix(value,\
    \ strings.ToUpper(key)) {\n            return true\n        }\n\n        // for\
    \ strings with lower case, convert to upper case\n        if strings.HasPrefix(value,\
    \ strings.ToLower(key)) {\n            return true\n        }\n\n        return\
    \ false\n    }\n    return false\n}\n`\n\nvar checkDictCaseCasesTests = []Test{\n\
    \    {\n        Cases:   checkDictCaseCases,\n        Name:    \"Check Dict Case\
    \ Cases\",\n        Results: checkDictCaseCasesResults,\n    },\n}\n", "    if\
    \ dict == nil {\n        return false\n    }\n    for key := range dict {\n  \
    \      lowerKey := strings.ToLower(key)\n        upperKey := strings.ToUpper(key)\n\
    \        if key != lowerKey && key != upperKey {\n            return false\n \
    \       }\n    }\n    return true\n}", "    for k, v := range dict {\n       \
    \ if k == \"name\" || k == \"id\" {\n            continue\n        }\n       \
    \ if k != \"_\" && k[0] >= 'A' && k[0] <= 'Z' {\n            continue\n      \
    \  }\n        if k != \"_\" && k[0] >= 'a' && k[0] <= 'z' {\n            continue\n\
    \        }\n        fmt.Printf(\"check_dict_case fail with map[%s]=%s\", k, v)\n\
    \        return false\n    }\n    return true\n}\n</code>\n<|/ a tags=go |>\n\
    <| c |>\nThis seems to work with a case where all keys are either lower or upper\
    \ case. For example, `map[string]string{\"a\": \"apple\", \"B\": \"banana\"}`\
    \ returns false, but `map[string]string{\"a\": \"apple\", \"a\": \"apple\"}` returns\
    \ true.\n<|/ c |>\n<| c |>\n, Thanks for your comment. I updated the code to support\
    \ all keys.\n<|/ c |>\n<| c |>\nThis is an interesting idea, but I wouldn't call\
    \ it a clean solution. First, it's too fragile, as it relies on the underlying\
    \ Go language to provide predictable behavior for string case conversion; second,\
    \ it makes a lot of assumptions about the key names (whether they start with an\
    \ upper-case letter), which makes it a lot less portable than simply checking\
    \ whether the first character is an upper-case letter.\n<|/ c |>\n<| c |>\n, yes,\
    \ you are right. I think this solution may be too complicated for such simple\
    \ operation. Thanks for your comment.\n<|/ c |>\n<| a tags=go |>\nI know this\
    \ is a little late to the party, but I thought I'd share my solution. I think\
    \ it is the simplest, although it doesn't require the underscore character, so\
    \ I opted to use that as my delimiter. \n<code>\npackage main\n\nimport (\n  \
    \  \"fmt\"\n    \"strings\"\n)\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    for k, v := range dict {\n        if k != \"Name\" && k != \"Age\"\
    \ && k != \"City\" && k != \"STATE\" && k != \"ZIP\" && k != \"email\" {\n   \
    \         return false\n        }\n    }\n\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    trueDict := make(map[string]string)\n\
    \    for k, v := range dict {\n        trueDict[k] = strings.ToLower(k)\n    \
    \    trueDict[k+\":\"] = strings.ToUpper(k)\n    }\n    return trueDict == dict\n\
    }\n", "    if dict == nil || len(dict) == 0 {\n        return false\n    }\n \
    \   for k, v := range dict {\n        switch {\n        case k == \"STATE\" &&\
    \ !isInt(k):\n            return false\n        case k == \"ZIP\" && !isInt(k):\n\
    \            return false\n        case !isInt(k):\n            if k[0] < 'A'\
    \ || k[0] > 'Z' {\n                return false\n            }\n            if\
    \ k[1] < 'a' || k[1] > 'z' {\n                return false\n            }\n  \
    \      default:\n            if v != strings.ToLower(v) || strings.ToUpper(v)\
    \ != v {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n", "    if dict == nil {\n        return false\n    }\n    values :=\
    \ make([]string, len(dict))\n    for k, v := range dict {\n        if _, ok :=\
    \ dict[k]; ok && strings.Compare(k, strings.ToLower(k)) == 0 {\n            fmt.Println(k)\n\
    \            return true\n        }\n        if _, ok := dict[k]; ok && strings.Compare(k,\
    \ strings.ToUpper(k)) == 0 {\n            return true\n        }\n        values\
    \ = append(values, v)\n    }\n    return false\n}\n", "    if len(dict) == 0 {\n\
    \        return false\n    }\n    for k, v := range dict {\n        switch strings.ToLower(k)\
    \ {\n        case \"state\":\n        case \"zip\":\n        case \"name\":\n\
    \        case \"age\":\n        case \"city\":\n            continue\n       \
    \ }\n        switch strings.ToUpper(k) {\n        case \"STATE\":\n        case\
    \ \"ZIP\":\n        case \"NAME\":\n        case \"AGE\":\n        case \"CITY\"\
    :\n            continue\n        }\n        return false\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    \n    for key,\
    \ value := range dict {\n        if key == \"Name\" {\n            if value !=\
    \ fmt.Sprintf(\"%v\", dict[key]) {\n                return false\n           \
    \ }\n        }\n        \n        if key >= \"A\" && key <= \"Z\" {\n        \
    \    if value != fmt.Sprintf(\"%v\", dict[key]) {\n                return false\n\
    \            }\n        }\n        \n        if key >= \"a\" && key <= \"z\" {\n\
    \            if value != fmt.Sprintf(\"%v\", dict[key]) {\n                return\
    \ false\n            }\n        }\n    }\n    \n    return true\n}\n", "    switch\
    \ len(dict) {\n    case 0:\n        return false\n    case 1:\n        return\
    \ true\n    default:\n        first := true\n        for _, val := range dict\
    \ {\n            switch {\n            case first:\n                first = false\n\
    \            case strInLowerOrUpperCase(val):\n                continue\n    \
    \        default:\n                return false\n            }\n        }\n  \
    \      return true\n    }\n}\n", "    ok := true\n    for k, v := range dict {\n\
    \        if len(k) != 1 {\n            ok = false\n            break\n       \
    \ }\n        k = k[:1]\n        if k != strings.ToLower(k) {\n            ok =\
    \ false\n            break\n        }\n        if k != strings.ToUpper(k) {\n\
    \            ok = false\n            break\n        }\n    }\n    return ok\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for key, value\
    \ := range dict {\n        if key != string(value) {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for k := range dict {\n        if k, ok := k[0].(string);\
    \ ok {\n            if strings.ToLower(k) == k {\n                return true\n\
    \            }\n            if strings.ToUpper(k) == k {\n                return\
    \ true\n            }\n        }\n    }\n    return false\n}\n", "    if dict\
    \ == nil || len(dict) == 0 {\n        return false\n    }\n\n    for k, v := range\
    \ dict {\n        switch strings.ToLower(k) {\n        case \"name\", \"age\"\
    , \"city\":\n            continue // continue to next case\n        default:\n\
    \            return false\n        }\n    }\n\n    return true\n}\n</code>\n<|/\
    \ a dscore=1 tags=go |>\n<| a tags=go |>\n<code>\npackage check_dict_case_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    if len(dict) == 0 {\n   \
    \     return false\n    }\n    // get all keys of the map to compare\n    keys\
    \ := make([]string, 0)\n    for k := range dict {\n        keys = append(keys,\
    \ k)\n    }\n    if len(keys) > 1 {\n        sort.Strings(keys)\n    }\n    //\
    \ check if all keys are in lower or upper case (upper case is default)\n    containsAll\
    \ := true\n    for _, k := range keys {\n        containsAll = containsAll &&\
    \ ( strconv.ToLower(k) == k || strconv.ToUpper(k) == k )\n        if containsAll\
    \ {\n            break\n        }\n    }\n    return containsAll\n}\n</code>\n\
    <|/ a dscore=4 tags=dictionary,go |>\n<| a tags=dictionary,go dscore=2 |>\nJust\
    \ in case someone needs a simple solution that doesn't require importing packages\
    \ and doesn't require the use of slices or maps:\n<code>", '    cases := []',
  "    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict\
    \ {\n        if k == \"\" {\n            fmt.Println(\"The key name should not\
    \ be empty\")\n            return false\n        }\n        if k != strings.ToLower(k)\
    \ {\n            fmt.Println(\"The key name should contain lower case\")\n   \
    \         return false\n        }\n        if k != strings.ToUpper(k) {\n    \
    \        fmt.Println(\"The key name should contain upper case\")\n           \
    \ return false\n        }\n    }\n    return true\n}\n", "    if len(dict) ==\
    \ 0 {\n        return false\n    }\n    for k := range dict {\n        if k !=\
    \ string(k) {\n            return false\n        }\n    }\n    return true\n}\n",
  "    for k := range dict {\n        switch strings.ToLower(k) {\n        case \"\
    state\":\n        case \"zip\":\n        case \"city\":\n        default:\n  \
    \          continue\n        }\n\n        if strings.ToUpper(k) != k {\n     \
    \       return false\n        }\n    }\n\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for k := range dict {\n        if strings.ToLower(k)\
    \ != k {\n            return false\n        }\n    }\n    for k := range dict\
    \ {\n        if strings.ToUpper(k) != k {\n            return false\n        }\n\
    \    }\n    return true\n}\n</code>\nThe above function will check if the provided\
    \ map is in lower or upper case and will return true for both cases.\n<|/ a dscore=0\
    \ tags=dictionary,go |>\n<| a dscore=0 |>\nI ended up doing this.\n<code>", " \
    \   if len(dict) < 1 {\n        return false\n    }\n    for k := range dict {\n\
    \        if !isStringInLowerCase(k) || !isStringInUpperCase(k) {\n           \
    \ return false\n        }\n    }\n    return true\n}\n", "    if len(dict) ==\
    \ 0 {\n        return false\n    }\n    \n    for k := range dict {\n        if\
    \ len(k) > 0 {\n            if strings.Contains(k, \" \") {\n                return\
    \ false\n            }\n            if strings.Contains(k, \"-\") {\n        \
    \        return false\n            }\n            if strings.ToLower(k) != k {\n\
    \                return false\n            }\n            if strings.ToUpper(k)\
    \ != k {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k\
    \ := range dict {\n        var lowercase bool\n        var upercase bool\n   \
    \     if k[0] == '\"' {\n            k = k[1 : len(k)-1]\n            lowercase\
    \ = true\n        } else {\n            lowercase = unicode.IsLower(rune(k[0]))\n\
    \        }\n        if k[len(k)-1] == '\"' {\n            k = k[:len(k)-1]\n \
    \           upercase = true\n        } else {\n            upercase = unicode.IsUpper(rune(k[len(k)-1]))\n\
    \        }\n        if lowercase != upercase {\n            return false\n   \
    \     }\n    }\n    return true\n}\n", "    if dict == nil {\n        return false\n\
    \    }\n    switch len(dict) {\n        case 0:\n            return false\n  \
    \      case 1:\n            if _, ok := dict[0].(map[string]string); ok {\n  \
    \              return true\n            }\n            return false\n        case\
    \ 2:\n            if _, ok := dict[0].(map[string]string); ok {\n            \
    \    if _, ok := dict[1].(map[string]string); ok {\n                    return\
    \ true\n                }\n            }\n            return false\n        default:\n\
    \            if _, ok := dict[0].(map[string]string); ok {\n                if\
    \ _, ok := dict[1].(map[string]string); ok {\n                    if _, ok :=\
    \ dict[2].(map[string]string); ok {\n                        return true\n   \
    \                 }\n                }\n            }\n            return false\n\
    \    }\n}\n", "    if dict == nil {\n        return false\n    }\n    for key,\
    \ value := range dict {\n        if strings.ToLower(key) != key {\n          \
    \  return false\n        }\n        if strings.ToUpper(key) != key {\n       \
    \     return false\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n\n    for k, v := range dict {\n      \
    \  if !strings.EqualFold(k, k) || !strings.EqualFold(v, v) {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n", "    keysUpper := make([]string,\
    \ 0, len(dict))\n    keysLower := make([]string, 0, len(dict))\n    for k := range\
    \ dict {\n        keysUpper = append(keysUpper, k)\n        keysLower = append(keysLower,\
    \ strings.ToLower(k))\n    }\n    if len(keysUpper) == 0 {\n        return true\n\
    \    }\n    for _, k := range keysUpper {\n        if strings.ToUpper(k) == \"\
    \" {\n            return false\n        }\n    }\n    if len(keysLower) == 0 {\n\
    \        return true\n    }\n    for _, k := range keysLower {\n        if k ==\
    \ \"\" {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   ok := true\n    for _, v := range dict {\n        fmt.Printf(\"dict value\
    \ %#v %#v\\n\", v, dict[v])\n        if v, ok := v.(string); ok && v == dict[v]\
    \ {\n            fmt.Printf(\"match %#v\\n\", v)\n        } else {\n         \
    \   ok = false\n        }\n    }\n    return ok\n}\n</code>\n<|/ a |>\n<| a tags=go\
    \ |>\nAs of today (2020/03/15) you can now easily iterate over the map using for\
    \ range loop. This is the official go documentation for this feature.\nhttps://golang.org/ref/spec#For_range\n\
    <|/ a dscore=0 |>\n<| a |>\nI wrote a function that recursively walks through\
    \ nested maps and slices.\nIt uses the following features:\n\nIt checks the value\
    \ if it is a slice, if it is a slice it walks through its elements and calls itself\
    \ recursively on each element.\nIt checks the value if it is a map, if it is a\
    \ map it walks through its elements and calls itself recursively on each element.\n\
    If both above features are false the function returns nil.\n\n<code>\npackage\
    \ main\n\nimport \"fmt\"\n", "    if dict == nil {\n        return false\n   \
    \ }\n    for k := range dict {\n        switch v := dict[k].(type) {\n       \
    \ case string:\n            switch strings.ToLower(v) {\n            case \"true\"\
    , \"false\":\n                dict[k] = v\n            case \"\":\n          \
    \      dict[k] = v\n            default:\n                fmt.Printf(\"Warning:\
    \ dict case check failed for key %v\", k)\n            }\n        case float64:\n\
    \            if strings.Contains(string(v), \":\") {\n                dict[k]\
    \ = string(v)\n            } else {\n                dict[k] = string(v)\n   \
    \         }\n        default:\n            fmt.Printf(\"Warning: dict case check\
    \ failed for key %v\", k)\n        }\n    }\n    sort.Strings(dict)\n    return\
    \ reflect.DeepEqual(dict, map[string]string{})\n}\n", "    if len(dict) == 0 {\n\
    \        return false\n    }\n    trueVal := true\n    for key := range dict {\n\
    \        value := dict[key]\n        if key != strings.ToLower(key) {\n      \
    \      fmt.Printf(\"[Error]: %s => %s , %s\\n\", key, value, dict[key])\n    \
    \        trueVal = false\n        }\n    }\n    return trueVal\n}\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n\
    \        if k == string(k) {\n            continue\n        }\n        switch\
    \ k {\n        case \"AGE\", \"AGEE\", \"AGEEE\", \"AGEN\":\n            if v\
    \ != string(v) {\n                return false\n            }\n        default:\n\
    \            if v != string(k) {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for key, value := range dict {\n        if isString(key) &&\
    \ isString(value) {\n            continue\n        }\n        if isString(key)\
    \ && isUpperString(value) {\n            continue\n        }\n        if !isString(key)\
    \ && !isUpperString(value) {\n            return false\n        }\n    }\n   \
    \ return true\n}\n", "    if dict == nil {\n        return false\n    }\n\n  \
    \  for key, value := range dict {\n        if key == key {\n            return\
    \ false\n        }\n\n        switch key {\n        case \"state\", \"zip\":\n\
    \            switch value {\n            case \"NC\", \"12345\":\n           \
    \     continue\n            default:\n                return false\n         \
    \   }\n        default:\n            return true\n        }\n    }\n    return\
    \ true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\n    for\
    \ key, value := range dict {\n        if strings.ToLower(key) != key {\n     \
    \       return false\n        }\n\n        if strings.ToUpper(key) != key {\n\
    \            return false\n        }\n\n        if strings.ToLower(value) != key\
    \ {\n            return false\n        }\n\n        if strings.ToUpper(value)\
    \ != key {\n            return false\n        }\n    }\n\n    return true\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nHi this should be the accepted answer, it\
    \ actually works and is simple for anyone not too far into Go land.\n<|/ c |>\n\
    <| c |>\nThis fails for `\"a\": \"apple\", \"a\": \"apple\"` returning true.\n\
    <|/ c |>\n<| c |>\nAs of January 2020, this doesn't work. I've tried `checkDictCase(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})` and `checkDictCase(map[string]string{\"\
    a\": \"apple\", \"a\": \"apple\"})`. Both result in true.\n<|/ c |>\n<| a tags=go\
    \ |>\nThe way I check is just to check if there is an uppercase letter in the\
    \ keys and if the lowercase version doesn't exist anymore. \n<code>", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    \n    keys := make([]string,\
    \ 0, len(dict))\n    for k := range dict {\n        keys = append(keys, k)\n \
    \   }\n    sort.Strings(keys)\n    \n    for _, k := range keys {\n        if\
    \ isLower(k) || isUpper(k) {\n            return false\n        }\n    }\n   \
    \ \n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n  \
    \  }\n\n    lowerStringKeys := make(map[string]bool)\n    for k := range dict\
    \ {\n        lowerStringKeys[strings.ToLower(k)] = true\n    }\n    upperStringKeys\
    \ := make(map[string]bool)\n    for k := range dict {\n        upperStringKeys[strings.ToUpper(k)]\
    \ = true\n    }\n\n    for k := range lowerStringKeys {\n        if !upperStringKeys[k]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    if\
    \ dict == nil {\n        return false\n    }\n\n    keys := make([]string, 0)\n\
    \n    for k := range dict {\n        if k < 'A' || k >= 'Z' {\n            keys\
    \ = append(keys, k)\n        }\n    }\n\n    for _, k := range keys {\n      \
    \  if k != strconv.Itoa(int64(k)+1) {\n            return false\n        }\n \
    \   }\n\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    t := make(map[interface{}]string)\n    for k, v := range dict {\n\
    \        if k != \"\" {\n            t[k] = v\n        }\n    }\n    return dict_case(t)\
    \ == dict_case(dict)\n}\n", "    if len(dict) == 0 {\n        return false\n \
    \   }\n    for k, v := range dict {\n        if k == \"\" {\n            return\
    \ false\n        }\n        if v == \"\" {\n            return false\n       \
    \ }\n        if strings.ToLower(k) != strings.ToLower(k) || strings.ToUpper(k)\
    \ != strings.ToUpper(k) {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    for k := range dict {\n        if k != \"\" && isUpper(string(k[0]))\
    \ && isUpper(string(k[1])) {\n            return false\n        }\n    }\n   \
    \ return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\n\
    \    for k := range dict {\n        lower, ok := caseInsensitive.RuneToLower(k)\n\
    \        if !ok || lower==k {\n            return false\n        }\n        upper,\
    \ ok := caseInsensitive.RuneToUpper(k)\n        if !ok || upper==k {\n       \
    \     return false\n        }\n    }\n\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    \n    type testType ", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    key := true\n    first := true\n  \
    \  for k := range dict {\n        switch k := k.(type) {\n        case string:\n\
    \            if first {\n                first = false\n            } else {\n\
    \                key = false\n            }\n        case float64:\n         \
    \   if first {\n                first = false\n            } else {\n        \
    \        key = false\n            }\n        default:\n            if first {\n\
    \                first = false\n            } else {\n                key = false\n\
    \            }\n        }\n    }\n    return key\n}\n", "    if len(dict) == 0\
    \ {\n        return false\n    }\n    \n    var ok = true\n    for k, v := range\
    \ dict {\n        if k != \"\" && k[0] != '@' {\n            ok = ok && k == strings.ToLower(k)\n\
    \        }\n        if k == \"\" {\n            ok = false\n        } else {\n\
    \            ok = ok && k == strings.ToUpper(k)\n        }\n    }\n    return\
    \ ok\n}\n", "    for k, v := range dict {\n        if k == \"STATE\" || k == \"\
    ZIP\" {\n            if strings.ToLower(v) == strings.ToLower(dict[k]) {\n   \
    \             return true\n            }\n        } else {\n            if k ==\
    \ strings.ToLower(v) && strings.ToUpper(v) == strings.ToUpper(dict[k]) {\n   \
    \             return true\n            }\n        }\n    }\n    return false\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "    if len(dict) ==\
    \ 0 {\n        return false\n    }\n    for k := range dict {\n        if k ==\
    \ strings.ToLower(k) || k == strings.ToUpper(k) {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for k, v := range dict {\n        switch k.(type) {\n    \
    \    case string:\n            if v != strings.ToLower(v) || v != strings.ToUpper(v)\
    \ {\n                return false\n            }\n        default:\n         \
    \   if v != strings.ToLower(v) || v != strings.ToUpper(v) {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    k := \"nil\"\n    k := dict\n    value\
    \ := \"\"\n    value := dict\n    k := value\n    v := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n    k := value\n    k := value\n\
    \    k := value\n    k := value\n    k := value\n", "    var keys []interface{}\n\
    \    switch m := len(dict); m {\n    case 0:\n        return false\n    case 1:\n\
    \        keys = append(keys, dict[k])\n    case 2:\n        keys = append(keys,\
    \ dict[k])\n        keys = append(keys, dict[k])\n    case 3:\n        keys =\
    \ append(keys, dict[k])\n        keys = append(keys, dict[k])\n        keys =\
    \ append(keys, dict[k])\n    default:\n        return false\n    }\n\n    for\
    \ _, key := range keys {\n        val := dict[key]\n        if key != nil {\n\
    \            key := key.(string)\n            if _, ok := stringInCamelCase(key);\
    \ ok {\n                if val != nil {\n                    val := val.(string)\n\
    \                    if key != \"\" {\n                        val := strings.ToLower(val)\n\
    \                    }\n                } else {\n                    val := strings.ToLower(val)\n\
    \                }\n            } else {\n                if val != nil {\n  \
    \                  val := val.(string)\n                    if key != \"\" {\n\
    \                        val := strings.ToUpper(val)\n                    }\n\
    \                } else {\n                    val := strings.ToUpper(val)\n \
    \               }\n            }\n        } else {\n            if val != nil\
    \ {\n                val := val.(string)\n                if val != \"\" {\n \
    \                   val = strings.ToUpper(val)\n                }\n          \
    \  } else {\n                val = strings.ToUpper(val)\n            }\n     \
    \   }\n        if val == \"\" {\n            return false\n        }\n    }\n\n\
    \    return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \    lowerMap := map[string]string{}\n    for k, v := range dict {\n        lowerMap[strings.ToLower(k)]\
    \ = v\n    }\n    upperMap := map[string]string{}\n    for k, v := range dict\
    \ {\n        upperMap[strings.ToUpper(k)] = v\n    }\n    return lowerMap == upperMap\n\
    }\n", "    key := reflect.TypeOf(dict).Elem()\n    if key.Kind() != reflect.Map\
    \ {\n        return false\n    }\n\n    keyType := key.Elem().Type()\n    if keyType.Kind()\
    \ != reflect.String {\n        return false\n    }\n\n    for _, value := range\
    \ dict {\n        if keyType.Kind() == reflect.String {\n            lowerCase\
    \ := strings.ToLower(value)\n            upperCase := strings.ToUpper(value)\n\
    \            if lowerCase != upperCase {\n                return false\n     \
    \       }\n        } else {\n            lowerCase := strings.ToLower(value)\n\
    \            upperCase := strings.ToUpper(value)\n            if lowerCase !=\
    \ upperCase {\n                return false\n            }\n        }\n    }\n\
    \    return true\n}\n`\n)\n", "    if dict == nil {\n        return false\n  \
    \  }\n    for key, value := range dict {\n        if key != fmt.Sprint(key) ||\
    \ value != fmt.Sprint(value) {\n            return false\n        }\n    }\n \
    \   return true\n}\n</code>\n<|/ a tags=go,hashmap,dictionary |>\n<| a tags=go,hashmap,dictionary\
    \ |>\nIf you're happy with a map where the values are arrays of strings, then\
    \ this would do the trick:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n",
  "    result := true\n    for k, v := range dict {\n        if strutil.ToLower(v)\
    \ == strutil.ToLower(k) {\n            result = true\n            break\n    \
    \    }\n        if strutil.ToUpper(v) == strutil.ToUpper(k) {\n            result\
    \ = true\n            break\n        }\n    }\n    return result\n}\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n \
    \       if dict[k] == \"null\" {\n            return false\n        }\n      \
    \  if isLower(k) || isUpper(k) {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \n    for k, v := range dict {\n        switch v := v.(type) {\n        case string:\n\
    \            if k != strings.ToLower(k) || k != strings.ToUpper(k) {\n       \
    \         return false\n            }\n        case float64:\n            if k\
    \ != fmt.Sprintf(\"%v\", v) || k != fmt.Sprintf(\"%v\", float64(v)) {\n      \
    \          return false\n            }\n        }\n    }\n    return true\n}\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n\
    \        if _, ok := dict[k]; !ok {\n            return false\n        }\n   \
    \ }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n \
    \   }\n    for k := range dict {\n        lowerCaseK := strings.ToLower(k)\n \
    \       upperCaseK := strings.ToUpper(k)\n        if lowerCaseK != k || upperCaseK\
    \ != k {\n            return false\n        }\n    }\n    return true\n}\n`\n\
    \    }\n)\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k\
    \ := range dict {\n        switch strings.ToLower(k) {\n        case \"name\"\
    :\n        case \"age\", \"age\":\n        case \"age\":\n        case \"city\"\
    :\n        case \"state\", \"zip\", \"zip\":\n        default:\n            return\
    \ false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis answer is quite similar to the answer by JimB. However a much simpler\
    \ version: `return (dict != nil && len(dict) > 0 && all(map(isString, keys)))\
    \ || all(map(isString, keys))`\n<|/ c |>\n<| c |>\nI think that's pretty much\
    \ what JimB wrote, but you probably meant `return len(dict) > 0 && all(map(isString,\
    \ keys))`.\n<|/ c |>\n<| a |>\nThe answer by JimB is correct but a bit complicated.\
    \  Here is a simpler answer that works with Go 1.13 or newer:\n<code>", "    if\
    \ dict == nil {\n        return false\n    }\n    for k, v := range dict {\n \
    \       if k == \"\" {\n            return false\n        }\n        switch strings.ToLower(k)\
    \ {\n        case strings.ToLower(k):\n        case strings.ToUpper(k):\n    \
    \    default:\n            return false\n        }\n    }\n    return true\n}\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    first := true\n    for\
    \ key, value := range dict {\n        if !first {\n            return false\n\
    \        }\n        switch key {\n        case \"A\", \"B\", \"C\", \"D\", \"\
    E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"\
    P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\":\n \
    \           first = false\n        default:\n            if key != strings.ToLower(key)\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n", "    if len(dict) < 1 {\n        return false\n    }\n    for k\
    \ := range dict {\n        switch k.(type) {\n        case string:\n         \
    \   str = k.(string)\n        default:\n            str = k.(string)\n       \
    \ }\n        if str != \"\" {\n            str = strings.ToLower(str)\n      \
    \  }\n        if str != \"\" {\n            return true\n        }\n    }\n  \
    \  return false\n}\n</code>\n<|/ a dscore=2 tags=go,dictionary,casting |>\n<|\
    \ a tags=go,dictionary,casting |>\nI wanted to provide a little more detail to\
    \ 's answer. \n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype testStruct ",
  "    if len(dict) == 0 {\n        return false\n    }\n\n    allKeys := make([]string,\
    \ 0, len(dict))\n    for k := range dict {\n        allKeys = append(allKeys,\
    \ k)\n    }\n\n    lowerKeys := make([]string, 0, len(allKeys))\n    for _, k\
    \ := range allKeys {\n        lowerKeys = append(lowerKeys, strings.ToLower(k))\n\
    \    }\n\n    upperKeys := make([]string, 0, len(allKeys))\n    for _, k := range\
    \ allKeys {\n        upperKeys = append(upperKeys, strings.ToUpper(k))\n    }\n\
    \n    return true\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=go,dictionary\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype ByKey\
    \ []interface{}\n", "    if len(dict) == 0 {\n        return false\n    }\n\n\
    \    for k, v := range dict {\n        var hasLowerCase bool = false\n       \
    \ var hasUpperCase bool = false\n\n        if !strings.Contains(k, \" \") {\n\
    \            if strings.Contains(k, \"A\") {\n                hasLowerCase = true\n\
    \            } else if strings.Contains(k, \"B\") {\n                hasUpperCase\
    \ = true\n            }\n        } else {\n            hasLowerCase = true\n \
    \           hasUpperCase = true\n        }\n        if hasLowerCase {\n      \
    \      if v != strings.ToLower(v) {\n                return false\n          \
    \  }\n        }\n        if hasUpperCase {\n            if v != strings.ToUpper(v)\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n</code>\n<|/ a tags=go,testing dscore=1 |>\n<| a |>\nYou can use reflect.DeepEqual\
    \ and reflect.TypeOf like this:\n<code>\npackage main\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n    \"reflect\"\n)\n", "    for k, v := range dict {\n        if\
    \ !(strings.ToLower(k) == k) {\n            return false\n        }\n    }\n \
    \   for k, v := range dict {\n        if !(strings.ToUpper(k) == k) {\n      \
    \      return false\n        }\n    }\n    return true\n}\n", "    if dict ==\
    \ nil {\n        return false\n    }\n\n    for k := range dict {\n        switch\
    \ k := k.(type) {\n        case string:\n            if len(k) < 1 || len(k) >\
    \ 1 {\n                return false\n            }\n            if k == strings.ToLower(k)\
    \ {\n                return true\n            }\n            if k == strings.ToUpper(k)\
    \ {\n                return true\n            }\n            return false\n  \
    \      case float64:\n            return false\n        default:\n           \
    \ return false\n        }\n    }\n    return true\n}\n", "    if dict == nil {\n\
    \        return false\n    }\n    for k, _ := range dict {\n        // k is a\
    \ string, which means it cannot have uppercase letters.\n        // so if k is\
    \ in all upper case, then return false.\n        if strings.ToLower(k) != k {\n\
    \            return false\n        }\n    }\n    for k, v := range dict {\n  \
    \      // k is in all lower case, which means it cannot have uppercase letters.\n\
    \        // so if k is not in all upper case, then return false.\n        if strings.ToUpper(k)\
    \ != k {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   if len(dict) == 0 {\n        return false\n    }\n    \n    for k, v := range\
    \ dict {\n        if v == \"\" {\n            return false\n        }\n      \
    \  \n        if k == strings.ToLower(string(k[0])) {\n            return true\n\
    \        }\n        \n        if k == strings.ToUpper(string(k[0])) {\n      \
    \      return true\n        }\n    }\n    \n    return false\n}\n</cell>\n<cell>\n\
    # Check case for keys and values of a dict\n# Test cases:\n# >>> check_dict_case_test({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"\
    ZIP\": \"12345\"})\n# True\n# >>> check_dict_case_test({\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\", 8: \"banana\", \"a\": \"apple\"})\n# False\n\
    # >>> check_dict_case_test({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\", \"STATE\": \"NC\", \"ZIP\": \"12345\"})\n# False\n# >>> check_dict_case_test({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"\
    ZIP\": \"12345\"})\n# False\n# >>> check_dict_case_test({\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\
    # False\n# >>> check_dict_case_test({\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\", \"STATE\": \"NC\", \"ZIP\": \"12345\"})\n# False\n# >>> check_dict_case_test({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"\
    ZIP\": \"12345\"})\n# False\n</cell>\n<cell>\n# Check case for keys and values\
    \ of a dict\n# Test cases:\n# >>> check_dict_case_test({\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\
    # True\n# >>> check_dict_case_test({\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\", 8: \"banana\", \"a\": \"apple\"})\n# False\n# >>> check_dict_case_test({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"\
    ZIP\": \"12345\"})\n# False\n# >>> check_dict_case_test({\"Name\": \"John\", \"\
    Age\": \"36\", \"City\": \"Houston\", \"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\
    # False\n# >>> check_dict_case_test({\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\", \"STATE\": \"", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    for key := range dict {\n        if strings.ToLower(key) != key {\n\
    \            return false\n        }\n        if strings.ToUpper(key) != key {\n\
    \            return false\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for k, v := range dict {\n        lower,\
    \ err := strconv.ParseBool(strings.ToLower(k))\n        if err != nil {\n    \
    \        return false\n        }\n        upper, err := strconv.ParseBool(strings.ToUpper(k))\n\
    \        if err != nil {\n            return false\n        }\n        if lower\
    \ != upper {\n            return false\n        }\n    }\n    return true\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nGood catch on \"STATE\" key. You should add\
    \ `strings.ToLower(k)` to fix it\n<|/ c |>\n<| c |>\nWhy do you need to check\
    \ both lower and upper?\n<|/ c |>\n<| a |>\nThe simplest way to do it is to convert\
    \ the map to JSON, strip the quotes, and use that result as the map keys. Then\
    \ you can just use regular string comparison.\n<code>", "    if len(dict) == 0\
    \ {\n        return false\n    }\n\n    for k := range dict {\n        if strings.ToLower(k)\
    \ == k || strings.ToUpper(k) == k {\n            return false\n        }\n   \
    \ }\n\n    return true\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThe simplest\
    \ and best way is using regex. \n<code>", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n\n    keys := make([]string, 0, len(dict))\n    for key := range\
    \ dict {\n        keys = append(keys, key)\n    }\n\n    for _, key := range keys\
    \ {\n        if len(key) > 1 {\n            return false\n        }\n        if\
    \ dict[key] == \"\" {\n            return false\n        }\n    }\n\n    for _,\
    \ key := range keys {\n        s := strings.ToLower(key)\n        if len(s) !=\
    \ 1 {\n            return false\n        }\n    }\n\n    for _, key := range keys\
    \ {\n        s := strings.ToUpper(key)\n        if len(s) != 1 {\n           \
    \ return false\n        }\n    }\n\n    return true\n}\n`\nvar testPkgDoc = `package\
    \ check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    for\
    \ k, v := range dict {\n        if k == \"\" {\n            return false\n   \
    \     }\n        if v == \"\" {\n            return false\n        }\n       \
    \ if strings.ToLower(k) != k {\n            return false\n        }\n        if\
    \ strings.ToUpper(k) != k {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    for _, value := range dict {\n        switch v := value.(type)\
    \ {\n        case string:\n            if string(v) == v {\n                continue\n\
    \            }\n            if string(v)[0:1] != v[0:1] {\n                return\
    \ false\n            }\n            if string(v)[0:1] == v[0:1] && len(v) > 1\
    \ {\n                return true\n            }\n        case float64:\n     \
    \       if float64(v) == v {\n                continue\n            }\n      \
    \      if float64(v)%1 == 0 && float64(v) != v {\n                return false\n\
    \            }\n            if float64(v)%1 == 1 && float64(v) != v {\n      \
    \          return true\n            }\n        default:\n            return false\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=1\
    \ tags=go |>\nHere is an example for dict comprehension in golang:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n)\n\ntype User ", "    var hasKey = false\n \
    \   var hasUpperCase = false\n    var hasLowerCase = false\n    for k, v := range\
    \ dict {\n        if k == \"\" {\n            return false\n        }\n      \
    \  hasKey = true\n        hasUpperCase = hasUpper || strings.EqualFold(k, strings.ToLower(k))\n\
    \        hasLowerCase = hasLower || strings.EqualFold(k, strings.ToUpper(k))\n\
    \    }\n    return hasKey && hasUpper && hasLowerCase\n}\n", "    if dict == nil\
    \ {\n        return false\n    }\n    for key, value := range dict {\n       \
    \ if strings.ToLower(key) == key || strings.ToUpper(key) == key {\n          \
    \  continue\n        }\n        return false\n    }\n    return true\n}\n", " \
    \   if dict == nil {\n        return false\n    }\n    type keys []string\n  \
    \  var k keys\n    for k := range dict {\n        if k != \"\" {\n           \
    \ k = append(k, \"\")\n        }\n    }\n    return check_dict_case_helper(k,\
    \ dict)\n}\n", "    if dict == nil {\n        return false\n    }\n    for key,\
    \ value := range dict {\n        if key != \"\" {\n            if strings.ToLower(key)\
    \ == strings.ToLower(key) {\n                return true\n            }\n    \
    \        if strings.ToUpper(key) == strings.ToUpper(key) {\n                return\
    \ true\n            }\n        }\n    }\n    return false\n}\n`\n)\n\nvar tests\
    \ = []", "    for k, v := range dict {\n        if k == \"\" {\n            return\
    \ false\n        }\n        if k != strings.ToLower(k) || v != strings.ToUpper(v)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nThis is not what the OP asked for.\n<|/ c |>\n<| c\
    \ |>\nYes it is. It checks cases when both keys and values are both lowercase\
    \ or uppercase.\n<|/ c |>\n<| c |>\nThis does not answer what the OP asked for.\
    \ This is a code dump.\n<|/ c |>\n<| a |>\nYou can do it in one line if you don't\
    \ mind using an extra variable and using that to store the actual map value.\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    found := false\n    for k\
    \ := range dict {\n        if strings.ToLower(k) != k {\n            found = true\n\
    \            break\n        }\n    }\n    return found\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for k, v := range dict {\n        if\
    \ isLower(k) || isUpper(k) {\n            return false\n        }\n    }\n   \
    \ return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\n\
    \    for k, v := range dict {\n        if k == \"Name\" || k == \"Age\" || k ==\
    \ \"City\" {\n            if k != v {\n                return false\n        \
    \    }\n        } else {\n            if strings.ToLower(k) != strings.ToLower(v)\
    \ {\n                return false\n            }\n        }\n    }\n\n    return\
    \ true\n}\n", "    str := \"\"\n    for k, v := range dict {\n        str += fmt.Sprintf(\"\
    %#v\\n\", k)\n        str += fmt.Sprintf(\"%#v\\n\", v)\n        if str == \"\
    %#v\\n{}\\n%#v\\n{}\\n%#v\\n{}\\n%#v\\n{}\\n\" {\n            return false\n \
    \       }\n        if str == \"%#v\\n{}\\n%#v\\n{}\\n%#v\\n{}\\n%#v\\n{}\\n\"\
    \ {\n            return true\n        }\n    }\n    return false\n}\n`\n\tcheck_dict_case_test.T().Run(suite,\
    \ []testcase.TestCase{\n\t\t{\n\t\t\tName:   \"Should be true\",\n\t\t\tInput:\
    \  map[string]string{},\n\t\t\tOutput: true,\n\t\t},\n\t\t{\n\t\t\tName:   \"\
    Should be false\",\n\t\t\tInput:  map[string]string{\"a\": \"apple\", \"b\": \"\
    banana\"},\n\t\t\tOutput: false,\n\t\t},\n\t\t{\n\t\t\tName:   \"Should be false\"\
    ,\n\t\t\tInput:  map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\"\
    : \"apple\"},\n\t\t\tOutput: false,\n\t\t},\n\t\t{\n\t\t\tName:   \"Should be\
    \ true\",\n\t\t\tInput:  map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"},\n\t\t\tOutput: true,\n\t\t},\n\t\t{\n\t\t\tName:   \"\
    Should be true\",\n\t\t\tInput:  map[string]string{\"STATE\": \"NC\", \"ZIP\"\
    : \"12345\"},\n\t\t\tOutput: true,\n\t\t},\n\t})\n}\n", "    if len(dict) == 0\
    \ {\n        return false\n    }\n\n    // Check that all keys are lowercase strings.\n\
    \    for k := range dict {\n        l := strings.ToLower(k)\n        if l != k\
    \ {\n            return false\n        }\n    }\n\n    // Check that all keys\
    \ are uppercase strings.\n    for k := range dict {\n        u := strings.ToUpper(k)\n\
    \        if u != k {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n", "    if len(dict) < 1 {\n        return false\n    }\n\n    for\
    \ k, v := range dict {\n        if isLower(k) || isUpper(k) {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n", "    if len(dict) == 0 {\n\
    \        return false\n    }\n    for k := range dict {\n        var isString\
    \ bool\n        isString = isString(dict[k])\n        if isString {\n        \
    \    if unicode.IsLower(k) || unicode.IsUpper(k) {\n                return false\n\
    \            }\n        }\n        if !isString {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    for _, key := range dict {\n  \
    \      if key == key {\n            continue\n        }\n        if key[:1] ==\
    \ \"_\" && key[:1] != \"_\" {\n            continue\n        }\n        if key[:1]\
    \ == \"_\" && key[:1] == \"_\" {\n            continue\n        }\n        if\
    \ key > key {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n\
    \        if k == \"\" {\n            return false\n        }\n        if dict[k]\
    \ == \"\" {\n            return false\n        }\n        if strings.ToLower(k)\
    \ != strings.ToLower(dict[k]) {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \    for key, value := range dict {\n        if key != fmt.Sprintf(\"%s\", key)\
    \ {\n            return false\n        }\n        if key != strings.ToLower(key)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis has some bad behavior. If `dict` has duplicate keys, the\
    \ last `dict[key]` value will be returned.  I think you meant `if key != fmt.Sprintf(\"\
    %s\", key)`\n<|/ c |>\n<| c |>\nI think you meant `if key != fmt.Sprintf(\"%s\"\
    , key)` but this has some bad behavior. If you pass in a map with a string key\
    \ and integer value then the integer value will be returned instead of the string\
    \ key. I will put in a new answer that fixes this problem.\n<|/ c |>\n<| a |>\n\
    For anyone who wants a way to ignore all but the first value of a duplicate key\
    \ in a map, you can do something like:\n<code>\ntype IgnoreFirstValueOf map[string]string\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    \n    // Check key type\n\
    \    for k := range dict {\n        switch v := dict[k].(type) {\n        case\
    \ string:\n            if len(k) == 0 {\n                return false\n      \
    \      }\n            if len(k) > 0 && len(v) == 0 {\n                return false\n\
    \            }\n            if v != k {\n                return false\n      \
    \      }\n        case float64:\n            if v != float64(k) {\n          \
    \      return false\n            }\n        case int64:\n            if v != int64(k)\
    \ {\n                return false\n            }\n        case bool:\n       \
    \     if v != bool(k) {\n                return false\n            }\n       \
    \ case []interface{}:\n            if len(v) == 0 {\n                return false\n\
    \            }\n        case map[string]interface{}:\n            if len(v) ==\
    \ 0 {\n                return false\n            }\n        case nil:\n      \
    \      if len(k) == 0 {\n                return false\n            }\n       \
    \     if v != k {\n                return false\n            }\n        case map[interface{}]interface{}:\n\
    \            if len(v) == 0 {\n                return false\n            }\n \
    \       default:\n            return false\n        }\n    }\n    \n    return\
    \ true\n}\n", "    found := false\n    for _, value := range dict {\n        found\
    \ |= isStringInLowerCase(value) || isStringInUpperCase(value)\n    }\n    return\
    \ found\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    for\
    \ key, value := range dict {\n        if !isStringInLowerCase(key) {\n       \
    \     return false\n        }\n        if !isStringInUpperCase(key) {\n      \
    \      return false\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    mapCopy := map[string]string{}\n  \
    \  for key, value := range dict {\n        mapCopy[key] = value\n        if key\
    \ == key {\n            return true\n        }\n    }\n    for key, value := range\
    \ mapCopy {\n        if value == value {\n            return true\n        }\n\
    \    }\n    return false\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    for key, value := range dict {\n        if strings.ToLower(key) ==\
    \ key {\n            return false\n        }\n        if strings.ToUpper(key)\
    \ == key {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n\
    \        switch k {\n        case \"Age\", \"ZIP\":\n            return false\n\
    \        default:\n            if k != strings.ToLower(k) || k != strings.ToUpper(k)\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k,\
    \ v := range dict {\n        switch strings.ToLower(k) {\n        case strings.ToLower(k):\n\
    \            continue\n        case strings.ToUpper(k):\n            continue\n\
    \        default:\n            return false\n        }\n    }\n    return true\n\
    }\n</code>\n<|/ a tags=dictionary,go |>\n<| a |>\nThe \"clean\" way without unnecessary\
    \ loops is to sort the map by the keys and then iterate over the map checking\
    \ if the current key matches the next key in the sorted map. For example:\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n", "    if dict == nil\
    \ {\n        return false\n    }\n    keys := make([]string, 0, len(dict))\n \
    \   for k := range dict {\n        keys = append(keys, k)\n    }\n    return check_dict_case_impl(keys,\
    \ dict)\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    v :=\
    \ false\n    for k := range dict {\n        if strings.ToLower(k) != k && strings.ToUpper(k)\
    \ != k {\n            return false\n        }\n        if k != string(k) {\n \
    \           v = true\n        }\n    }\n    return v\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n\n    for key, value := range dict {\n\
    \        if value != key {\n            return false\n        }\n    }\n\n   \
    \ return true\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=dictionary,go\
    \ |>\nFor Go 1.9+ you may use the following package for that purpose:\n<code>\n\
    import \"github.com/joho/deep-check\"\n</code>\nAnd call it like that:\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"github.com/joho/deep-check\"\n)\n",
  "    if len(dict) == 0 {\n        return false\n    }\n\n    allLowerCase := true\n\
    \    allUpperCase := true\n    for k := range dict {\n        // TODO: Consider\
    \ special casing keys that\n        // are entirely uppercase.\n        if isLower(string(k))\
    \ {\n            allLowerCase = false\n        }\n        if isUpper(string(k))\
    \ {\n            allUpperCase = false\n        }\n    }\n\n    return allLowerCase\
    \ && allUpperCase\n}\n`\n", "    if len(dict) == 0 {\n        return false\n \
    \   }\n\n    for k, v := range dict {\n        if k == \"\" {\n            return\
    \ false\n        }\n        switch k {\n        case \"Name\":\n        case \"\
    City\":\n        case \"State\":\n        case \"ZIP\":\n        default:\n  \
    \          err := fmt.Errorf(\"Key '%s' is not a string in lower or upper case\"\
    , k)\n            log.Fatalf(err)\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \n    for k := range dict {\n        if k != strings.ToLower(k) {\n          \
    \  return false\n        }\n    }\n\n    return true\n}\n", "    for k := range\
    \ dict {\n        if k == \"\" {\n            return false\n        }\n      \
    \  switch {\n        case dict[k] == \"\":\n            return false\n       \
    \ case dict[k] == strings.ToLower(k):\n        case dict[k] == strings.ToUpper(k):\n\
    \        default:\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    truemap := make(map[string]bool)\n\
    \    for key, value := range dict {\n        if key >= 'A' && key <= 'Z' || key\
    \ >= 'a' && key <= 'z' {\n            truemap[key] = value\n        } else {\n\
    \            return false\n        }\n    }\n    if len(truemap) == len(dict)\
    \ {\n        return true\n    }\n    return false\n}\n</code>\n<|/ a tags=string,go,map,collections\
    \ |>\n<| c |>\nI understand that the asker was looking for a more elegant way\
    \ to solve this problem and this solution is nice and clean, but I think it's\
    \ not a general solution (meaning that it doesn't work for arbitrary key/value ",
  "    if len(dict) == 0 {\n        return false\n    }\n\n    for key, value := range\
    \ dict {\n        if key != fmt.Sprint(key) || value != fmt.Sprint(value) {\n\
    \            return false\n        }\n    }\n    return true\n}\n", "    if len\
    \ (dict) == 0 {\n        return false\n    }\n    for k := range dict {\n    \
    \    v := dict[k]\n        if v != \"\" && !(IsString(k) && IsString(v)) {\n \
    \           return false\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n\n    for k := range dict {\n        if\
    \ strings.ToLower(k) == k || strings.ToUpper(k) == k {\n            continue\n\
    \        }\n\n        return false\n    }\n\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for key, value := range dict {\n  \
    \      if value == \"\" {\n            return false\n        }\n        switch\
    \ key {\n        case \"state\", \"stateCode\", \"district\", \"districtCode\"\
    , \"area\", \"areaCode\", \"country\", \"countryCode\", \"postalCode\", \"postalAddress\"\
    :\n            if value != strings.ToLower(value) || value != strings.ToUpper(value)\
    \ {\n                return false\n            }\n        default:\n         \
    \   if value != strings.ToLower(value) || value != strings.ToUpper(value) {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range\
    \ dict {\n        if k == 0 {\n            continue\n        }\n        if k ==\
    \ 1 {\n            return true\n        }\n        if k == 2 {\n            return\
    \ true\n        }\n        if k == 3 {\n            return true\n        }\n \
    \       if k == 4 {\n            return true\n        }\n        if k == 5 {\n\
    \            return true\n        }\n        if k == 6 {\n            return true\n\
    \        }\n        if k == 7 {\n            return true\n        }\n        if\
    \ k == 8 {\n            return true\n        }\n        if k == 9 {\n        \
    \    return true\n        }\n        if k == 10 {\n            return true\n \
    \       }\n        if k == 11 {\n            return true\n        }\n        if\
    \ k == 12 {\n            return true\n        }\n        if k == 13 {\n      \
    \      return true\n        }\n        if k == 14 {\n            return true\n\
    \        }\n        if k == 15 {\n            return true\n        }\n       \
    \ if k == 16 {\n            return true\n        }\n        if k == 17 {\n   \
    \         return true\n        }\n        if k == 18 {\n            return true\n\
    \        }\n        if k == 19 {\n            return true\n        }\n       \
    \ if k == 20 {\n            return true\n        }\n        if k == 21 {\n   \
    \         return true\n        }\n        if k == 22 {\n            return true\n\
    \        }\n        if k == 23 {\n            return true\n        }\n       \
    \ if k == 24 {\n            return true\n        }\n        if k == 25 {\n   \
    \         return true\n        }\n        if k == 26 {\n            return true\n\
    \        }\n        if k == 27 {\n            return true\n        }\n       \
    \ if k == 28 {\n            return true\n        }\n        if k == 29 {\n   \
    \         return true\n        }\n        if k == 30 {\n            return true\n\
    \        }\n        if k == 31 {\n            return true\n        }\n       \
    \ if k == 32 {\n            return true\n        }\n        if k == 33 {\n   \
    \         return true\n        }\n        if k == 34 {\n            return true\n\
    \        }\n        if k == 35 {\n            return true\n        }\n       \
    \ if k == 36 {\n            return true\n        }\n        if k == 37 {\n   \
    \         return true\n        }\n        if k == 38 {\n            return true\n\
    \        }\n        if k == 39 {\n            return true\n        }\n       \
    \ if k == 40 == true {\n            return true\n        }\n        if k == 41\
    \ {\n            return true\n        }\n        if k == 42 {\n            return\
    \ true\n        }\n        if k == 43 {\n            return true\n        }\n\
    \        if k == 44 {\n            return true\n        }\n        if k == 45\
    \ {\n            return true\n        }\n        if k == 46 {\n            return\
    \ true\n        }\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \    for k, v := range dict {\n        if k == \"\" {\n            return false\n\
    \        }\n        switch k {\n        case \"a\":\n            if v == \"apple\"\
    \ {\n                return true\n            }\n        case \"b\":\n       \
    \     if v == \"banana\" {\n                return true\n            }\n     \
    \   case \"A\":\n            if v == \"banana\" {\n                return true\n\
    \            }\n        case \"B\":\n            if v == \"banana\" {\n      \
    \          return true\n            }\n        case \"8\":\n            if v ==\
    \ \"banana\" {\n                return true\n            }\n        default:\n\
    \            return false\n        }\n    }\n    return false\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for key := range dict {\n        if\
    \ key, ok := stringToLower(key); !ok || !stringInSlice(key, allKeysLowerCase)\
    \ {\n            return false\n        } else if key, ok := stringToUpper(key);\
    \ !ok || !stringInSlice(key, allKeysUpperCase) {\n            return false\n \
    \       }\n    }\n    return true\n}\n", "    if dict == nil { return false }\n\
    \n    for key := range dict {\n        if key != \"Name\" && key != \"Age\" &&\n\
    \            key != \"City\" && key != \"STATE\" && key != \"ZIP\" {\n       \
    \     return false\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for _, key := range dict {\n      \
    \  switch key {\n        case \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"\
    , \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\":\n        case key.toUpperCase():\n\
    \        default:\n            return false\n        }\n    }\n    return true\n\
    }\n", "    var keyLen int = len(dict)\n    if keyLen == 0 {\n        return false\n\
    \    }\n\n    for _, key := range dict {\n        keyInt, _ := strconv.Atoi(key)\n\
    \        if keyInt == keyInt + keyLen {\n            return false\n        }\n\
    \    }\n\n    return true\n}", "    if dict == nil {\n        return false\n \
    \   }\n\n    for k, v := range dict {\n        if !isLowerOrUpper(k) || !isLowerOrUpper(v)\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n", "  \
    \  if dict == nil {\n        return false\n    }\n\n    // Check for all keys\
    \ in lower case.\n    for k := range dict {\n        lowercase := string(k)\n\
    \        if lowercase != k && unicode.IsLower(k) {\n            return false\n\
    \        }\n    }\n\n    // Check for all keys in upper case.\n    for k := range\
    \ dict {\n        uppercase := string(k)\n        if uppercase != k && unicode.IsUpper(k)\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nI love golang so much that I hated golang's `for` loops,\
    \ I love golang's `range`. Just the lack of a `break` statement. Thanks for writing\
    \ this up, it helps a lot.\n<|/ c |>\n<| c |>\n: No worries, I really enjoy golang.\
    \ I also love golang's `range`. I just have to admit that range is a bit of an\
    \ unnatural function, and I find it to be the most confusing function to use in\
    \ my code. Sometimes I use it, but most of the time I don't. For example in Javascript\
    \ I use `for (i in collection)`, but in golang I use `range collection`.\n<|/\
    \ c |>\n<| a tags=go dscore=2 |>\nI wrote this function that checks whether a\
    \ map contains only strings that consist of lower or upper case characters:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n", " \
    \   if dict == nil {\n        return false\n    }\n    var found bool = false\n\
    \    for key, value := range dict {\n        if value == \"\" {\n            return\
    \ false\n        }\n        if key != strings.ToLower(key) {\n            return\
    \ false\n        }\n        if found {\n            return false\n        }\n\
    \        found = true\n    }\n    return true\n}\n", "    mapValues := reflect.ValueOf(dict)\n\
    \    mapKeys := mapValues.MapKeys()\n    if len(mapKeys) == 0 {\n        return\
    \ false\n    }\n    for _, k := range mapKeys {\n        val := mapValues.MapIndex(k)\n\
    \        if val.Type().Kind() != reflect.String {\n            return false\n\
    \        }\n        if strings.ToLower(k.String()) != k.String() {\n         \
    \   return false\n        }\n    }\n    for _, k := range mapKeys {\n        val\
    \ := mapValues.MapIndex(k)\n        if val.Type().Kind() != reflect.String {\n\
    \            return false\n        }\n        if strings.ToUpper(k.String()) !=\
    \ k.String() {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for key, val\
    \ := range dict {\n        if key == \"\" {\n            continue\n        }\n\
    \        if strings.ToLower(key) != key {\n            return false\n        }\n\
    \        if strings.ToUpper(key) != key {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    for k, v := range dict {\n        if strLower(k) == strLower(v) ||\
    \ strUpper(k) == strUpper(v) {\n            continue\n        }\n        return\
    \ false\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for k, v := range dict {\n        if !((k == string(v) ||\
    \ k == strings.ToLower(v) || k == strings.ToUpper(v))) &&\n            dict[k]\
    \ != v {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   for k, v := range dict {\n        if k, ok := k.(string); !ok || v, ok :=\
    \ v.(string); !ok {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n    for k\
    \ := range dict {\n        switch k {\n        case \"state\":\n        case \"\
    zip\":\n        case \"city\":\n        case \"age\":\n        case \"name\":\n\
    \            continue // ignore these keys\n        }\n        if len(k) == 0\
    \ {\n            return false // ignore empty keys\n        }\n        upperCase\
    \ := true\n        lowerCase := true\n        k := k + \"\"\n        for i :=\
    \ range k {\n            switch k[i] {\n            case ' ':\n              \
    \  upperCase = false\n            case lowerCase:\n                lowerCase =\
    \ false\n            case k[i]:\n                upperCase = false\n         \
    \       lowerCase = true\n            }\n        }\n        if lowerCase || upperCase\
    \ {\n            return false\n        }\n    }\n    return true\n}", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n\n    for k, v := range dict\
    \ {\n        if k == \"\" || v == \"\" {\n            return false\n        }\n\
    \n        if k == strings.ToLower(k) || k == strings.ToUpper(k) {\n          \
    \  continue\n        }\n\n        return false\n    }\n\n    return true\n}\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict\
    \ {\n        if v != strings.ToLower(v) || v != strings.ToUpper(v) {\n       \
    \     return false\n        }\n    }\n    return true\n}\n", "    // write code\
    \ here\n    if dict == nil {\n        return false\n    }\n    for key, value\
    \ := range dict {\n        if key == string(value) || string(value) == key {\n\
    \            continue\n        }\n        return false\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n\n    for k, v :=\
    \ range dict {\n        // We do not care about case for the keys\n        if\
    \ k == \"\" {\n            continue\n        }\n\n        // We do not care about\
    \ case for the values\n        if v == \"\" {\n            continue\n        }\n\
    \n        if strings.ToLower(k) != k {\n            return false\n        }\n\n\
    \        if strings.ToUpper(k) != k {\n            return false\n        }\n \
    \   }\n\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    for _, key := range dict {\n        if !strings.Contains(string(key),\
    \ string(strings.ToLower(string(key))) ||\n            !strings.Contains(string(key),\
    \ string(strings.ToUpper(string(key)))){\n            return false\n        }\n\
    \    }\n\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    l := len(dict)\n    for key, value := range dict {\n        if value\
    \ == \"\" {\n            return false\n        }\n        if strings.ToLower(key)\
    \ == key {\n            l--\n        } else {\n            l++\n        }\n  \
    \  }\n    return l == 0\n}\n</cell>\n<cell>\n%%writefile src/check_dict_case_test.go\n\
    package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n",
  "    if len(dict) == 0 {\n        return false\n    }\n    var firstKey string\n\
    \    for key := range dict {\n        if !(strings.ToLower(key) == key || strings.ToUpper(key)\
    \ == key) {\n            return false\n        }\n        if firstKey == \"\"\
    \ {\n            firstKey = key\n        }\n    }\n    return true\n}\n`\n\nvar\
    \ dictCaseTests = []testCase{\n    {\n        input:  \"check_dict_case(map[string]string{\\\
    \"Name\\\": \\\"John\\\", \\\"Age\\\": \\\"36\\\", \\\"City\\\": \\\"Houston\\\
    \"})\",\n        output: true,\n        comment: \"valid case example\",\n   \
    \ },\n    {\n        input:  \"check_dict_case(map[string]string{\\\"NAME\\\"\
    : \\\"John\\\", \\\"AGE\\\": \\\"36\\\", \\\"CITY\\\": \\\"Houston\\\"})\",\n\
    \        output: true,\n        comment: \"valid case example using underscore\"\
    ,\n    },\n    {\n        input:  \"check_dict_case(map[string]string{\\\"age\\\
    \": \\\"36\\\", \\\"city\\\": \\\"Houston\\\"})\",\n        output: false,\n \
    \       comment: \"invalid case example\",\n    },\n    {\n        input:  \"\
    check_dict_case(map[string]string{\\\"AGE\\\": \\\"36\\\", \\\"CITY\\\": \\\"\
    Houston\\\"})\",\n        output: false,\n        comment: \"invalid case example\
    \ with upper case\",\n    },\n    {\n        input:  \"check_dict_case(map[string]string{\\\
    \"AGE\\\": \\\"36\\\", \\\"CITY\\\": \\\"Houston\\\"})\",\n        output: true,\n\
    \        comment: \"invalid case example with mixed case\",\n    },\n    {\n \
    \       input:  \"check_dict_case(map[string]string{\\\"AGE\\\": \\\"36\\\", \\\
    \"CITY\\\": \\\"Houston\\\"})\",\n        output: true,\n        comment: \"invalid\
    \ case example with mixed case using underscore\",\n    },\n    {\n        input:\
    \  \"check_dict_case(map[string]string{\\\"STATE\\\": \\\"NC\\\", \\\"ZIP\\\"\
    : \\\"12345\\\"})\",\n        output: true,\n        comment: \"valid case example\
    \ with mixed case\",\n    },\n    {\n        input:  \"check_dict_case(map[interface{}]string{\\\
    \"state\\\": \\\"NC\\\", \\\"zip\\\": \\\"12345\\\"})\",\n        output: true,\n\
    \        comment: \"valid case example with mixed case\",\n    },\n}\n", "   \
    \ if len(dict) == 0 {\n        return false\n    }\n    first := true\n    for\
    \ k := range dict {\n        if first {\n            first = false\n        }\
    \ else {\n            switch k := k.(type) {\n            case *string:\n    \
    \            ok, err := checkStrCase(k, dict[k])\n                if err != nil\
    \ {\n                    fmt.Println(\"check_dict_case: checkStrCase error\",\
    \ err)\n                    return false\n                }\n                if\
    \ !ok {\n                    return false\n                }\n            case\
    \ *interface{}:\n                ok, err := checkObjCase(k, dict[k])\n       \
    \         if err != nil {\n                    fmt.Println(\"check_dict_case:\
    \ checkObjCase error\", err)\n                    return false\n             \
    \   }\n                if !ok {\n                    return false\n          \
    \      }\n            }\n        }\n    }\n    return true\n}\n", "    if len(dict)\
    \ < 1 {\n        return false\n    }\n    \n    for _, val := range dict {\n \
    \       if val != fmt.Sprintf(\"%s\", val) && val != fmt.Sprintf(\"%s\", strings.ToUpper(val))\
    \ {\n            return false\n        }\n    }\n    \n    return true\n}\n`\n\
    )\n", "    type testMap map[string]string\n    return testMap(stringMap(dict))\
    \ != testMap(stringMap(make(map[string]string, len(dict))))\n}\n", "    if dict\
    \ == nil {\n        return false\n    }\n    for k := range dict {\n        if\
    \ !isStringInLowerCaseOrUpperCase(k) || !isStringInLowerCaseOrUpperCase(strings.ToUpper(k))\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n\
    \        if k == \"\" || k == \"-\" {\n            continue\n        }\n     \
    \   if k != v {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n\n    for k := range\
    \ dict {\n        if _, ok := dict[k]; ok {\n            if k != strings.ToLower(k)\
    \ || k != strings.ToUpper(k) {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n</code>\n<|/ a tags=go |>\n<| a dscore=1\
    \ tags=go |>\nI used the answer by Joe Campbell but with some modifications. First\
    \ of all I added a function to check the string length and changed it to a package\
    \ function. This makes the function more readable and reusable.\n<code>\npackage\
    \ check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n\n    for k := range dict {\n\
    \        if strings.ToLower(k) != k {\n            return false\n        }\n \
    \   }\n\n    for k := range dict {\n        if strings.ToUpper(k) != k {\n   \
    \         return false\n        }\n    }\n\n    return true\n}\n", "    if len(dict)\
    \ == 0 {\n        return false\n    }\n    for key := range dict {\n        if\
    \ key != strings.ToLower(key) {\n            return false\n        }\n    }\n\
    \    for key := range dict {\n        if key != strings.ToUpper(key) {\n     \
    \       return false\n        }\n    }\n    return true\n}\n", "    keys1 := make([]string,\
    \ 0)\n    keys2 := make([]string, 0)\n    for key, value := range dict {\n   \
    \     if key == \"\" {\n            return false\n        }\n        if key >=\
    \ \"A\" && key <= \"Z\" {\n            keys1 = append(keys1, key)\n        }\n\
    \        if key >= \"a\" && key <= \"z\" {\n            keys2 = append(keys2,\
    \ key)\n        }\n    }\n    \n    if len(keys1) != 0 && len(keys2) != 0 {\n\
    \        return false\n    }\n    if len(keys1) == 0 && len(keys2) == 0 {\n  \
    \      return true\n    }\n    \n    return true\n}\n", "    for k := range dict\
    \ {\n        val := dict[k]\n        if val := strings.ToLower(val); val != val\
    \ {\n            return false\n        }\n    }\n    return true\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| a dscore=4 tags=case-insensitive,go |>\n<code>\npackage\
    \ check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n\n    var stringKeys []string\n\
    \    var stringValues []string\n\n    for key, value := range dict {\n       \
    \ stringKeys = append(stringKeys, key.(string))\n        stringValues = append(stringValues,\
    \ value.(string))\n    }\n\n    for i := 0; i < len(stringKeys); i++ {\n     \
    \   for j := i + 1; j < len(stringKeys); j++ {\n            if strings.ToLower(stringKeys[i])\
    \ == strings.ToLower(stringKeys[j]) {\n                if stringValues[i] == stringValues[j]\
    \ {\n                    continue\n                }\n            } else {\n \
    \               if strings.ToUpper(stringKeys[i]) == strings.ToUpper(stringKeys[j])\
    \ {\n                    if stringValues[i] == stringValues[j] {\n           \
    \             continue\n                    }\n                } else {\n    \
    \                return false\n                }\n            }\n        }\n \
    \   }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    for key := range dict {\n        if !IsString(key) {\n         \
    \   return false\n        }\n    }\n\n    for key := range dict {\n        if\
    \ IsString(key) {\n            if IsStringUpper(key) {\n                if key\
    \ != stringToLower(key) {\n                    return false\n                }\n\
    \            } else if IsStringLower(key) {\n                if key != stringToUpper(key)\
    \ {\n                    return false\n                }\n            } else {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for key, value\
    \ := range dict {\n        if key == \"\" {\n            return false\n      \
    \  }\n        switch key {\n        case \"A\":\n            key, _ = key.(string)\n\
    \            return true\n        case \"B\":\n            key, _ = key.(string)\n\
    \            return true\n        case \"a\":\n            key, _ = key.(string)\n\
    \            return true\n        case \"b\":\n            key, _ = key.(string)\n\
    \            return true\n        default:\n            return false\n       \
    \ }\n    }\n    return false\n}\n</code>\n<|/ a |>\n<| a tags=dictionary,go |>\n\
    I realized that this is a duplicate question, but none of the answers here work\
    \ for me. \nThe solution I found was to convert my map's keys to lower case, then\
    \ compare the results. \n<code>", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    for k := range dict {\n        lowKey := string(k)\n        upperKey\
    \ := string(k)\n        for i := 0; i < len(k); i++ {\n            if string(k[i])\
    \ >= 'a' && string(k[i]) <= 'z' {\n                upperKey = string(k)\n    \
    \            break\n            }\n            if string(k[i]) >= 'A' && string(k[i])\
    \ <= 'Z' {\n                lowKey = string(k)\n                break\n      \
    \      }\n        }\n        if (upperKey == \"\" && lowKey != \"\") || (upperKey\
    \ != \"\" && lowKey == \"\") {\n            return false\n        }\n    }\n \
    \   return true\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nMy Solution\
    \ for same problem as OP but with a little more fun.\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"strings\"\n)\n", "    if len(dict) == 0 {\n     \
    \   return false\n    }\n\n    for key, value := range dict {\n        if key\
    \ == \"Name\" || key == \"Age\" || key == \"City\" {\n            continue\n \
    \       }\n        switch key {\n        case \"STATE\":\n            if len(value)\
    \ != 2 {\n                return false\n            }\n            if value[0]\
    \ != value[1] {\n                return false\n            }\n        case \"\
    ZIP\":\n            if len(value) != 5 {\n                return false\n     \
    \       }\n            if value[0] != value[1] {\n                return false\n\
    \            }\n        case \"NAME\":\n            if len(value) > 30 {\n   \
    \             return false\n            }\n        }\n    }\n\n    return true\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for this, it's very informative.\
    \ Very educating, much appreciated.\n<|/ c |>\n<| a tags=dictionary,go |>\n<code>",
  "    if len(dict) == 0 {\n        return false\n    }\n    for _, value := range\
    \ dict {\n        if strings.ToLower(value) == value || strings.ToUpper(value)\
    \ == value {\n            return true\n        }\n    }\n    return false\n}\n",
  "    ok := true\n    for key, value := range dict {\n        if value == \"\" ||\
    \ value != strings.ToLower(value) || value != strings.ToUpper(value) {\n     \
    \       ok = false\n            break\n        }\n    }\n    return ok\n}\n</code>\n\
    <|/ a |>\n<| c |>\nYour code fails for `check_dict_case(map[string]string{\"a\"\
    : \"apple\", \"B\": \"banana\"})`. See the \"A\" case in the question. In your\
    \ code, it returns true for \"B\" too. It should return false for \"A\" case.\
    \ It also fails for `check_dict_case(map[string]string{\"a\": \"apple\", \"A\"\
    : \"banana\", \"B\": \"banana\"})`.\n<|/ c |>\n<| c |>\nyeah, I noticed that,\
    \ will update my answer\n<|/ c |>\n<| c |>\nThanks for your answer. My code was\
    \ failing because I wasn't able to convert the string to lowercase and uppercase.\n\
    <|/ c |>\n<| c |>\nNo problem, it happens sometimes. :) Happy coding!\n<|/ c |>\n\
    <| a |>\nHere is the working code in golang\n<code>", "    if len(dict) == 0 {\n\
    \        return false\n    }\n    for k := range dict {\n        if _, ok := dict[k];\
    \ ok {\n            if k == \"A\" || k == \"B\" {\n                return true\n\
    \            }\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n\n    for k, v :=\
    \ range dict {\n        if strings.ToLower(k) == k {\n            continue\n \
    \       }\n\n        if strings.ToUpper(k) == k {\n            continue\n    \
    \    }\n        \n        return false\n    }\n\n    return true\n}\n", "    for\
    \ k, v := range dict {\n        // check keys in lowercase\n        if k == strings.ToLower(k)\
    \ {\n            continue\n        }\n\n        // check keys in uppercase\n \
    \       if k == strings.ToUpper(k) {\n            continue\n        }\n\n    \
    \    return false\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| a tags=go,dictionary,function\
    \ |>\nHere's a solution that uses reflection to get the keys and values, which\
    \ are both maps and therefore can be treated as such:\n<code>\npackage main\n\n\
    import (\n    \"fmt\"\n    \"reflect\"\n)\n", "    if len(dict) == 0 {\n     \
    \   return false\n    }\n    mapCopy := make(map[string]string, len(dict))\n \
    \   for k, v := range dict {\n        mapCopy[strings.ToLower(k)] = v\n      \
    \  mapCopy[strings.ToUpper(k)] = v\n    }\n    for k, v := range mapCopy {\n \
    \       switch v := v.(type) {\n        case string:\n            ok, err := IsStringInStringSlice(v,\
    \ []string{\"A\", \"B\"})\n            if err != nil {\n                return\
    \ false\n            }\n            if ok {\n                return true\n   \
    \         }\n            return false\n        }\n    }\n    return false\n}\n",
  "    if dict == nil || len(dict) == 0 {\n        return false\n    }\n    for k,\
    \ v := range dict {\n        if k == string(k) || k == string(unicode.ToLower(k))\
    \ {\n            if v != string(k) || v != string(unicode.ToUpper(k)) {\n    \
    \            return false\n            }\n        }\n    }\n    return true\n\
    }\n</code>\n<|/ a tags=dictionary,go |>\n<| a dscore=2 |>\nJust found out that\
    \ there is a built-in function to check for a specific key:\n<code>\nvar a map[int]string",
  "    if len (dict) == 0 {\n        return false\n    }\n    for k, v := range dict\
    \ {\n        if k == nil {\n            fmt.Println(\"nil key is found\")\n  \
    \          return false\n        }\n        switch v := v.(type) {\n        case\
    \ string:\n            str = v\n        case float64:\n            str = strconv.Itoa(int(v))\n\
    \        default:\n            fmt.Println(\"string key is found\")\n        \
    \    return false\n        }\n        if k != str {\n            return false\n\
    \        }\n    }\n    return true\n}", "    k := \"\"\n    if k == \"\" {\n \
    \       return true\n    }\n    for _, value := range dict {\n        fmt.Println(k,\
    \ value)\n        if k != \"\" {\n            if k != tolowerStr(k) {\n      \
    \          return false\n            }\n            if k != toupperStr(k) {\n\
    \                return false\n            }\n        }\n        k = value\n \
    \   }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    var result bool\n\n    for key := range dict {\n        if key !=\
    \ \"\" && !is_upper_case(key) {\n            result = false\n        }\n    }\n\
    \n    return result\n}\n", "    if len(dict) == 0 {\n        return false\n  \
    \  }\n    for k := range dict {\n        val := dict[k]\n        if k != strings.ToLower(k)\
    \ || k != strings.ToUpper(k) {\n            return false\n        }\n    }\n \
    \   return true\n}\n</code>\n<|/ a |>\n<| c |>\nYou should also check that the\
    \ keys aren't empty string slices.\n<|/ c |>\n<| c |>\nThanks, your answer is\
    \ very helpful and very close to my question. I am just curious, is there any\
    \ way to avoid the for loop? As far as I know the only way to check if a map is\
    \ empty is with the `len` operator, right?\n<|/ c |>\n<| c |>\nI tested the above\
    \ solution on Go, and it passed the tests, but the answer I got from my friend\
    \ is using two for loops. I thought it would be better to avoid nested loops.\n\
    <|/ c |>\n<| c |>\nIt does avoid the nested for loops, but it also does a bunch\
    \ of other checks and that does add up sometimes. I added an answer with some\
    \ more ideas you can explore.\n<|/ c |>\n<| c |>\nThis is really clever use of\
    \ strings.ToLower() and strings.ToUpper() on the keys. I learned something new\
    \ today. I'll have to keep this in mind. Thanks!\n<|/ c |>\n<| a dscore=3 |>\n\
    Here is a solution that uses a single loop and a single conditional statement:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n)\n", "    if len(dict) == 0 {\n\
    \        return false\n    }\n    var first_lower bool\n    var first_upper bool\n\
    \    for key, value := range dict {\n        if first_lower && first_upper {\n\
    \            return false\n        }\n        if first_lower {\n            if\
    \ key < \"a\" {\n                return false\n            }\n            if key\
    \ > \"z\" {\n                return false\n            }\n            first_lower\
    \ = true\n        } else if first_upper {\n            if key < \"A\" {\n    \
    \            return false\n            }\n            if key > \"Z\" {\n     \
    \           return false\n            }\n            first_upper = true\n    \
    \    } else {\n            if key < \"a\" || key > \"z\" {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n", "    if dict\
    \ == nil {\n        return false\n    }\n    for key, value := range dict {\n\
    \        if key != \"\" {\n            if strings.ToLower(key) != key {\n    \
    \            return false\n            }\n        }\n        if value != \"\"\
    \ {\n            if strings.ToUpper(value) != value {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n", "    var isStringTrue\
    \ bool = false\n\n    for key, value := range dict {\n        if key == string(key)\
    \ {\n            fmt.Println(\"key:\", key, \"value:\", value)\n            fmt.Println(\"\
    isStringTrue:\", isStringTrue)\n            isStringTrue = true\n        } else\
    \ {\n            fmt.Println(\"key:\", key, \"value:\", value)\n            fmt.Println(\"\
    isStringTrue:\", isStringTrue)\n            isStringTrue = false\n        }\n\
    \    }\n    return isStringTrue\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n\n    for key, value := range dict {\n        if len(key) != 0\
    \ {\n            if key[0] < 'A' || key[0] > 'Z' {\n                return false\n\
    \            }\n        }\n    }\n\n    return true\n}\n", "    if len(dict) ==\
    \ 0 {\n        return false\n    }\n    for key := range dict {\n        val :=\
    \ dict[key]\n        if val := strconv.ToLower(val); val != val {\n          \
    \  return false\n        }\n    }\n    for key := range dict {\n        val :=\
    \ dict[key]\n        if val := strconv.ToUpper(val); val != val {\n          \
    \  return false\n        }\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=go dscore=2 |>\nI wrote a package to deal with dictionary cases. It takes\
    \ two or more dictionaries and compares their keys and values. For each dictionary\
    \ a boolean is returned indicating whether they are equal or not. Here is the\
    \ code:\n<code>\npackage dictcase\n\nimport (\n    \"errors\"\n    \"fmt\"\n \
    \   \"reflect\"\n    \"strings\"\n)\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for k := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            return false\n        }\n    }\n    for k := range dict {\n \
    \       if k != strings.ToUpper(k) {\n            return false\n        }\n  \
    \  }\n    return true\n}\n", "    \n    if len(dict) == 0 {\n        return false\n\
    \    }\n    \n    for key, value := range dict {\n        switch key {\n     \
    \   case key:\n            return false\n        case \"A\":\n        case \"\
    B\":\n        case \"C\":\n        case \"D\":\n        case \"E\":\n        case\
    \ \"F\":\n        case \"G\":\n        case \"H\":\n        case \"I\":\n    \
    \    case \"J\":\n        case \"K\":\n        case \"L\":\n        case \"M\"\
    :\n        case \"N\":\n        case \"O\":\n        case \"P\":\n        case\
    \ \"Q\":\n        case \"R\":\n        case \"S\":\n        case \"T\":\n    \
    \    case \"U\":\n        case \"V\":\n        case \"W\":\n        case \"X\"\
    :\n        case \"Y\":\n        case \"Z\":\n        case \"a\":\n        case\
    \ \"b\":\n        case \"c\":\n        case \"d\":\n        case \"e\":\n    \
    \    case \"f\":\n        case \"g\":\n        case \"h\":\n        case \"i\"\
    :\n        case \"j\":\n        case \"k\":\n        case \"l\":\n        case\
    \ \"m\":\n        case \"n\":\n        case \"o\":\n        case \"p\":\n    \
    \    case \"q\":\n        case \"r\":\n        case \"s\":\n        case \"t\"\
    :\n        case \"u\":\n        case \"v\":\n        case \"w\":\n        case\
    \ \"x\":\n        case \"y\":\n        case \"z\":\n            return false\n\
    \        default:\n            if strings.ToLower(value) == value {\n        \
    \        return true\n            }\n            return false\n        }\n   \
    \ }\n    return true\n}\n</code>\n<|/ a tags=case-insensitive,dictionary,go |>\n\
    <| c |>\nThis is a very neat solution, thank you.\n<|/ c |>\n<| c |>\nAs of go\
    \ 1.16, \"map\" can now be used as a composite literal. see \nhttps://stackoverflow.com/questions/42510491/is-there-a-way-to-specify-case-insensitive-keys-in-golang\n\
    <|/ c |>\n<| a tags=case-insensitive,dictionary,go |>\nYou can make use of the\
    \ strconv.Itoa function to convert the character string to upper case and then\
    \ compare with the original string in the map\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ works great! I used `strconv.Itoa` as I needed to ignore case for numbers. Thanks!\n\
    <|/ c |>\n<| c |>\nThis was perfect, thanks so much!\n<|/ c |>\n<| c |>", "  \
    \  if len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n\
    \        if k.IsString() && (k.IsUpper() || k.IsLower()) {\n            return\
    \ true\n        }\n    }\n    return false\n}\n", "    if len(dict) == 0 {\n \
    \       return false\n    }\n    \n    for k := range dict {\n        // Only\
    \ strings in lower case or upper case\n        if k != \"\" {\n            if\
    \ strings.ToLower(k) != k {\n                return false\n            }\n   \
    \         if strings.ToUpper(k) != k {\n                return false\n       \
    \     }\n        }\n    }\n\n    return true\n}\n", "    if len(dict) == 0 {\n\
    \        return false\n    }\n\n    result := false\n    for key, value := range\
    \ dict {\n        switch key {\n        case \"state\":\n            fmt.Println(\"\
    state\", value)\n            switch value {\n            case \"NC\":\n      \
    \      case \"CA\":\n            case \"CO\":\n            case \"WA\":\n    \
    \        case \"TX\":\n            case \"ID\":\n            case \"MT\":\n  \
    \              fmt.Println(\"true\")\n                result = true\n        \
    \    }\n        case \"zip\":\n            fmt.Println(\"zip\", value)\n     \
    \       switch value {\n            case \"12345\":\n            case \"23456\"\
    :\n            case \"34567\":\n            case \"45678\":\n            case\
    \ \"56789\":\n            case \"67890\":\n            case \"78901\":\n     \
    \       case \"89022\":\n            case \"90233\":\n            case \"91324\"\
    :\n            case \"92345\":\n            case \"93546\":\n            case\
    \ \"94567\":\n            case \"95678\":\n            case \"96698\":\n     \
    \       case \"97790\":\n            case \"98801\":\n            case \"99822\"\
    :\n            case \"99933\":\n            case \"100434\":\n            case\
    \ \"101435\":\n            case \"102346\":\n            case \"103457\":\n  \
    \          case \"104358\":\n            case \"105379\":\n            case \"\
    106390\":\n            case \"107401\":\n            case \"108421\":\n      \
    \      case \"109431\":\n            case \"110442\":\n            case \"111443\"\
    :\n            case \"112445\":\n            case \"113446\":\n            case\
    \ \"114575\":\n            case \"114568\":\n            case \"114879\":\n  \
    \          case \"115890\":\n            case \"116901\":\n            case \"\
    117912\":\n            case \"118923\":\n            case \"119845\":\n      \
    \      case \"120955\":\n            case \"121965\":\n            case \"122976\"\
    :\n            case \"123987\":\n            case \"124990\":\n            case\
    \ \"125911\":\n            case \"126921\":\n            case \"127932\":\n  \
    \          case \"128943\":\n            case \"129856\":\n            case \"\
    129977\":\n            case \"130990\":\n            case \"131992\":\n      \
    \      case \"132003\":\n            case \"132104\":\n            case \"132115\"\
    :\n            case \"132126\":\n            case \"132127\":\n            case\
    \ \"132128\":\n            case \"132129\":\n            case \"132130\":\n",
  "    if len(dict) == 0 {\n        return false\n    }\n\n    for k, v := range dict\
    \ {\n        if v != string(k) {\n            return false\n        }\n    }\n\
    \n    return true\n}\n</code>\n<|/ a tags=python |>\n<| a dscore=1 |>\n<code>\n\
    if any(isinstance(item, str) for item in d):\n    return all(isinstance(item,\
    \ str) for item in d)\n</code>\n<|/ a tags=python |>\n<| a tags=python |>\nIf\
    \ you're using python3, you can use a generator expression:\n<code>\nall((isinstance(k,\
    \ str) for k in yourDict))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou\
    \ can use a list comprehension to create a list containing only the values of\
    \ dictionary that are of type string, and then use a simple check to see if that\
    \ list is empty or not:\n<code>\n>>> d = {\"a\": \"apple\", \"b\": \"banana\"\
    , \"c\": 8}\n>>> all([isinstance(k, str) for k in d.values()])\nTrue\n>>> d =\
    \ {\"a\": \"apple\", \"b\": \"banana\", \"c\": \"hi\"}\n>>> all([isinstance(k,\
    \ str) for k in d.values()])\nFalse\n</code>\n<|/ a tags=python |>\n<| a dscore=0\
    \ |>\nYou can use the following code to check if all the keys are strings in a\
    \ dictionary:\n<code>\nprint(all(isinstance(key, str) for key in dict))\n</code>\n\
    <|/ a tags=python |>\n<| a |>\nHere is another solution:\n<code>\ndef is_dict_of_strings(d):\n\
    \    return all(isinstance(k, str) for k in d.keys())\n\nprint(is_dict_of_strings({'a':\
    \ 'apple', 'b': 'banana', 'c': 8})) # True\nprint(is_dict_of_strings({'a': 'apple',\
    \ 'b': 'banana', 'c': 8, 'd': 'donut'})) # False\n</code>\n<|/ a tags=python dscore=0\
    \ |>\n<| a |>\nAnother solution would be to iterate over your keys and check each\
    \ one against str\n<code>\nd = {'a': 'apple', 'b': 'banana', 'c': 'hi'}\ndef check_keys(d):\n\
    \  str_keys = []\n  for k in d:\n    if isinstance(k, str):\n      str_keys.append(k)\n\
    \  return not len(str_keys)\n\nprint(check_keys(d))\n</code>\n<|/ a dscore=0 tags=python\
    \ |>\n<| a |>\n<code>\ndef dict_of_str_keys(d):\n    for k, v in d.items():\n\
    \        if isinstance(k, str):\n            return True\n\n    return False \n\
    </code>\n<|/ a tags=python dscore=0 |>\n<| a |>\nFor Python3, you can simply check\
    \ like:\n<code>\n>>> d = {\"a\": \"apple\", \"b\": \"banana\", \"c\": ", "   \
    \ for k, v := range dict {\n        if _, err := strconv.Atoi(k); err == nil {\n\
    \            continue\n        }\n        switch {\n        case (string(k) ==\
    \ string(v)):\n        case (string(k) == stringToUpper(v)):\n        case (string(k)\
    \ == stringToLower(v)):\n        default:\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    for _, value := range dict {\n        key\
    \ := reflect.ValueOf(key).String()\n        value := reflect.ValueOf(value).String()\n\
    \        if strings.ToLower(key) == key || strings.ToUpper(key) == key {\n   \
    \         continue\n        }\n        return false\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    \n    keysString\
    \ := make(map[string]string)\n    keysUpper := make(map[string]string)\n    \n\
    \    for k, v := range dict {\n        if k == \"\" {\n            return false\n\
    \        }\n        switch k {\n        case \"Name\":\n            keysString[k.(string)]\
    \ = v.(string)\n        case \"Age\":\n            keysUpper[k.(string)] = v.(string)\n\
    \        default:\n            return false\n        }\n    }\n\n    for k :=\
    \ range keysString {\n        if keysString[k] != keysUpper[k] {\n           \
    \ return false\n        }\n    }\n    return true\n}\n", "    // O(n)\n    for\
    \ k, v := range dict {\n        if strings.ToLower(k) != k {\n            return\
    \ false\n        }\n        if strings.ToUpper(v) != v {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return\
    \ false\n    }\n    for key, value := range dict {\n        switch key.(type)\
    \ {\n        default:\n            return false\n        case string:\n      \
    \      if key != strings.ToLower(key) {\n                return false\n      \
    \      }\n        case *string:\n            if key != strings.ToUpper(*key) {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    \n    for k :=\
    \ range dict {\n        if strconv.Itoa(k) == k || !strconv.Itoa(k) == k {\n \
    \           return false\n        }\n    }\n    \n    return true\n}\n", "   \
    \ if len(dict) == 0 {\n        return false\n    }\n    for k := range dict {\n\
    \        switch k {\n        case \"STATE\":\n        case \"ZIP\":\n        case\
    \ \"ZIPCODE\":\n        case \"ZipCode\":\n        case \"zipCode\":\n       \
    \ case \"ZipCode4\":\n        case \"ZIPCODE4\":\n        case \"ZipCode4\":\n\
    \        case \"ZIPCODE4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZIPCODE4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"ZIPCODE4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n        case \"ZipCode4\":\n        case \"zipCode4\":\n        case \"ZipCode4\"\
    :\n        case \"zipCode4\":\n        case \"ZipCode4\":\n        case \"zipCode4\"\
    :\n", "    if dict == nil {\n        return false\n    }\n    for _, v := range\
    \ dict {\n        if strings.ToLower(v) == strings.ToLower(v) {\n            continue\n\
    \        }\n        return false\n    }\n    for k, v := range dict {\n      \
    \  if k == k || strings.ToUpper(v) == strings.ToUpper(v) {\n            continue\n\
    \        }\n        return false\n    }\n    return true\n}\n", "    if dict ==\
    \ nil {\n        return false\n    }\n    for k := range dict {\n        if strings.ToLower(k)\
    \ != k || strings.ToUpper(k) != k {\n            return false\n        }\n   \
    \ }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n \
    \   }\n    for key, value := range dict {\n        if key == key {\n         \
    \   return false\n        }\n        if isUpper(key) {\n            if isLower(value)\
    \ {\n                continue\n            } else {\n                return false\n\
    \            }\n        } else {\n            if isLower(value) {\n          \
    \      return false\n            } else {\n                continue\n        \
    \    }\n        }\n    }\n    return true\n}\n", "    if len(dict) == 0 {\n  \
    \      return false\n    }\n\n    str := reflect.TypeOf(dict).String()\n    for\
    \ key := range dict {\n        switch key {\n        case strconv.Itoa(key):\n\
    \        case strconv.Itoa(unicode.ToLower(key)):\n        case strconv.Itoa(unicode.ToUpper(key)):\n\
    \        default:\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for key, val\
    \ := range dict {\n        if isStringInLowerCase(val) {\n            if isStringInUpperCase(dict[key])\
    \ {\n                fmt.Printf(\"The dictionary value '%s' should be in lower\
    \ case and in upper case\\n\", val)\n                return false\n          \
    \  } else {\n                fmt.Printf(\"The dictionary value '%s' should be\
    \ in lower case\\n\", val)\n                return false\n            }\n    \
    \    } else if isStringInUpperCase(val) {\n            fmt.Printf(\"The dictionary\
    \ value '%s' should be in upper case\\n\", val)\n            return false\n  \
    \      }\n    }\n    fmt.Printf(\"All values are strings in lower case\\n\")\n\
    \    return true\n}\n", "    if len(dict) == 0 {\n        return false\n    }\n\
    \    for _, value := range dict {\n        if value != strings.ToLower(value)\
    \ && value != strings.ToUpper(value) {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    \n    for k := range dict {\n        if k == strings.ToLower(string(k))\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    if\
    \ len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict {\n\
    \        if k != \"Name\" && k != \"Age\" {\n            fmt.Println(k, v)\n \
    \           return false\n        }\n        if strings.ToLower(k) != strings.ToLower(k)\
    \ {\n            fmt.Println(k, v)\n            return false\n        }\n    \
    \    if strings.ToUpper(k) != strings.ToUpper(k) {\n            fmt.Println(k,\
    \ v)\n            return false\n        }\n    }\n    return true\n}\n", "   \
    \ if len(dict) == 0 {\n        return false\n    }\n    for k, v := range dict\
    \ {\n        if k == \"\" || k == \"0\" {\n            return false\n        }\n\
    \        if k[0] != k[0].toUpper() {\n            return false\n        }\n  \
    \  }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n    for key, value := range dict {\n        if len(key) != len(value)\
    \ {\n            return false\n        }\n        for i := 0; i < len(key); i++\
    \ {\n            if !isalpha(key[i]) {\n                return false\n       \
    \     }\n            if !isalpha(value[i]) {\n                return false\n \
    \           }\n        }\n    }\n    return true\n}\n", "    if len(dict) == 0\
    \ {\n        return false\n    }\n    var keys []string\n    var values []string\n\
    \    for k, v := range dict {\n        keys = append(keys, k)\n        values\
    \ = append(values, v)\n    }\n    sort.Strings(keys)\n    sort.Strings(values)\n\
    \    for _, k := range keys {\n        if k == string(unicode.ToLower(k)) {\n\
    \            return false\n        }\n    }\n    for _, k := range keys {\n  \
    \      if k == string(unicode.ToUpper(k)) {\n            return false\n      \
    \  }\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| a tags=python,dictionary\
    \ |>\n<code>\n>>> from collections import defaultdict, namedtuple\n>>> my_dict\
    \ = defaultdict(list)\n>>> my_dict[\"a\"].append(4)\n>>> my_dict[\"b\"].append(3)\n\
    >>> my_dict[\"c\"].append(2)\n>>> my_dict[\"d\"].append(1)\n>>> my_dict[\"e\"\
    ].append(0)\n>>> my_dict[\"a\"]\n[4]\n>>> my_dict[\"b\"]\n[3]\n>>> my_dict[\"\
    c\"]\n[2]\n>>> my_dict[\"d\"]\n[1]\n>>> my_dict[\"e\"]\n[0]\n>>> my_dict\ndefaultdict(<type\
    \ 'list'>, {'a': [4], 'b': [3], 'c': [2], 'd': [1], 'e': [0]})\n>>> my_dict =\
    \ defaultdict(list)\n>>> my_dict[\"a\"].append(4)\n>>> my_dict[\"b\"].append(3)\n\
    >>> my_dict[\"c\"].append(2)\n>>> my_dict[\"d\"].append(1)\n>>> my_dict[\"e\"\
    ].append(0)\n>>> my_dict[\"a\"]\n[4]\n>>> my_dict[\"b\"]\n[3]\n>>> my_dict[\"\
    c\"]\n[2]\n>>> my_dict[\"d\"]\n[1]\n>>> my_dict[\"e\"]\n[0]\n>>> my_dict\ndefaultdict(<type\
    \ 'list'>, {'a': [4], 'b': [3], 'c': [2], 'd': [1], 'e': [0]})\n>>> my_dict =\
    \ defaultdict(list)\n>>> my_dict[\"a\"].append(4)\n>>> my_dict[\"b\"].append(3)\n\
    >>> my_dict[\"c\"].append(2)\n>>> my_dict[\"d\"].append(1)\n>>> my_dict[\"e\"\
    ].append(0)\n>>> my_dict[\"a\"]\n[4]\n>>> my_dict[\"b\"]\n[3]\n>>> my_dict[\"\
    c\"]\n[2]\n>>> my_dict[\"d\"]\n[1]\n>>> my_dict[\"e\"]\n[0]\n>>> my_dict\ndefaultdict(<type\
    \ 'list'>, {'a': [4], 'b': [3], 'c': [2], 'd': [1], 'e': [0]})\n>>> my_dict =\
    \ defaultdict(list)\n>>> my_dict[\"a\"].append(4)\n>>> my_dict[\"b\"].append(3)\n\
    >>> my_dict[\"c\"].append(2)\n>>> ", "    if dict == nil || len(dict) == 0 {\n\
    \        return false\n    }\n    \n    for k, v := range dict {\n        // Check\
    \ the value is a string\n        if !isString(v) {\n            return false\n\
    \        }\n        \n        // Check the key is lowercase\n        if !isString(k)\
    \ || !strings.Contains(k, strings.ToLower(k)) {\n            return false\n  \
    \      }\n    }\n    \n    return true\n}\n", "    for key, value := range dict\
    \ {\n        // if value has upper case letter only or all letters are upper case,\
    \ return false.\n        if !hasLower(value) || !hasUpper(value) {\n         \
    \   return false\n        }\n    }\n    // else return true.\n    return true\n\
    }\n", "    if len(dict) < 1 {\n        return false\n    }\n\n    lowerCaseKeys\
    \ := make(map[string]bool)\n    upperCaseKeys := make(map[string]bool)\n    for\
    \ key, value := range dict {\n        if key != strings.ToLower(key) {\n     \
    \       lowerCaseKeys[key] = true\n        } else {\n            upperCaseKeys[key]\
    \ = true\n        }\n    }\n\n    return len(lowerCaseKeys) == len(dict) &&\n\
    \        len(upperCaseKeys) == len(dict)\n}\n", "    if len(dict) == 0 {\n   \
    \     return false\n    }\n    for k, v := range dict {\n        if v != \"\"\
    \ {\n            switch k {\n                case \"Name\", \"Age\", \"City\"\
    , \"state\", \"zip\":\n                default:\n                    return false\n\
    \            }\n        }\n    }\n    return true\n}\n", "    len := len(dict)\n\
    \    if len == 0 {\n        return false\n    }\n\n    for key := range dict {\n\
    \        if strings.ContainsAny(key, []string{\"A\", \"a\", \"B\", \"b\", \"C\"\
    , \"c\"}) {\n            continue\n        }\n\n        upper := strings.ToUpper(key)\n\
    \        if strings.ContainsAny(upper, []string{\"A\", \"a\", \"B\", \"b\", \"\
    C\", \"c\"}) {\n            continue\n        }\n\n        return false\n    }\n\
    \n    return true\n}\n</code>\n<|/ a |>\n<| c |>\nIf there are two of the same\
    \ keys, they might not end up being in the same case but that should be okay.\n\
    <|/ c |>\n<| c |>\nThe point is that `a` and `A` are not the same. `A` and `a`\
    \ differ by the first letter.\n<|/ c |>\n<| a tags=go |>\nIt is a nice and simple\
    \ way, you can use the following function:\n<code>", "    if len(dict) == 0 {\n\
    \        return false\n    }\n\n    for key, value := range dict {\n        if\
    \ isString(key) && isString(value) {\n            continue\n        } else if\
    \ !isString(key) && !isString(value) {\n            return false\n        }\n\
    \    }\n\n    return true\n}\n", "    for key, value := range dict {\n       \
    \ if strings.ToLower(key) == key {\n            return false\n        }\n    \
    \    if strings.ToUpper(key) == key {\n            return false\n        }\n \
    \   }\n    return true\n}\n", "    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    for k := range dict {\n        fmt.Printf(\"Checking %s is case\
    \ insensitive string %q\\n\", k, dict[k])\n        if !checkStringInsensitive(k,\
    \ dict[k]) {\n            return false\n        }\n    }\n\n    return true\n\
    }\n", "    if len(dict) == 0 {\n        return false\n    }\n    for key, value\
    \ := range dict {\n        if key == key {\n            continue\n        }\n\
    \        switch key {\n        case \"AGE\":\n            if value != \"36\" {\n\
    \                return false\n            }\n        case \"ZIP\":\n        \
    \    if value != \"12345\" {\n                return false\n            }\n  \
    \      case \"STATE\":\n            if value != \"NC\" {\n                return\
    \ false\n            }\n        default:\n            if key != strings.ToLower(key)\
    \ || value != strings.ToUpper(value) {\n                return false\n       \
    \     }\n        }\n    }\n    return true\n}\n", "    // Write your code here\n\
    \    // Check for a non empty map\n    if len(dict) == 0 {\n        return false\n\
    \    }\n\n    // For loop traversal to check for both upper and lower case strings.\n\
    \    for key, value := range dict {\n        // Convert the string values to a\
    \ lowercase string\n        lowerCase := strings.ToLower(value)\n        // Check\
    \ if the value has a length\n        if len(value) == 0 {\n            return\
    \ false\n        }\n        // Check if the value is a string in upper case\n\
    \        if strings.ToUpper(value) == value {\n            return false\n    \
    \    }\n        // Check if the value is equal to the lower case\n        if lowerCase\
    \ == value {\n            return false\n        }\n    }\n    return true\n}\n",
  "    var keys []string\n    for key := range dict {\n        keys = append(keys,\
    \ key)\n    }\n    sort.Strings(keys)\n    for i := 0; i < len(keys); i++ {\n\
    \        k := keys[i]\n        v := dict[k]\n        if k == \"\" {\n        \
    \    continue\n        }\n        if i >= len(keys)-2 {\n            return true\n\
    \        }\n        if v != keys[i+1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI liked this\
    \ solution but didn't want to use a function so I extended it\n<code>", "    if\
    \ dict == nil {\n        return false\n    }\n    for key, val := range dict {\n\
    \        if key == key {\n            continue\n        }\n        if strings.ToLower(val)\
    \ == val {\n            continue\n        }\n        if strings.ToUpper(val) ==\
    \ val {\n            continue\n        }\n        return false\n    }\n    return\
    \ true\n}\n</code>\n<|/ a tags=go dscore=4 |>\n<| c |>\nThis solution breaks in\
    \ Python 3. I tried it with Python 3, and I got `TypeError: string indices must\
    \ be integers`.\n<|/ c |>\n<| c |>\nIn Python 3 the dictionaries don't have a\
    \ \"key\" but instead a \"keys\". It is a tuple (of keys) in Python 3. So the\
    \ test would look like `if key == keys[0] ...`\n<|/ c |>\n<| a |>\nIn case someone\
    \ comes here searching how to get key of nested "]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
