name: HumanEval_27_flip_case
language: go_test.go
prompt: "package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n\
  // >>> flip_case(\"Hello\")\n// \"hELLO\"\nfunc flip_case(myString string) string\
  \ {\n"
tests: "func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"\
  Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights\
  \ have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    result := \"\"\n    currentIndex := 0\n    for currentIndex < len(myString)\
    \ {\n        nextIndex1 := currentIndex + 1\n        nextIndex2 := nextIndex1\
    \ + 1\n        nextIndex3 := nextIndex1 + 2\n        nextIndex4 := nextIndex1\
    \ + 3\n\n        // Uppercase first char\n        if nextIndex1 < len(myString)\
    \ && myString[nextIndex1] >= 'A' && myString[nextIndex1] <= 'Z' {\n          \
    \  result += myString[nextIndex1]\n            nextIndex1++\n        }\n\n   \
    \     // Uppercase first 2 chars\n        if nextIndex2 < len(myString) && myString[nextIndex2]\
    \ >= 'a' && myString[nextIndex2] <= 'z' {\n            result += string(unicode.ToUpper(myString[nextIndex2])\
    \ + 1)\n            nextIndex2++\n        }\n\n        // Uppercase first 3 chars\n\
    \        if nextIndex3 < len(myString) && myString[nextIndex3] >= 'A' && myString[nextIndex3]\
    \ <= 'Z' {\n            result += string(unicode.ToUpper(myString[nextIndex3])\
    \ + 1)\n            nextIndex3++\n        }\n\n        // Uppercase first 4 chars\n\
    \        if nextIndex4 < len(myString) && myString[nextIndex4] >= 'a' && myString[nextIndex4]\
    \ <= 'z' {\n            result += string(unicode.ToUpper(myString[nextIndex4])\
    \ + 1)\n            nextIndex4++\n        }\n\n        // Lowercase first char\n\
    \        if nextIndex1 < len(myString) && myString[nextIndex1] >= 'a' && myString[nextIndex1]\
    \ <= 'z' {\n            result += string(unicode.ToLower(myString[nextIndex1]))\n\
    \            nextIndex1++\n        }\n\n        // Lowercase first 2 chars\n \
    \       if nextIndex2 < len(myString) && myString[nextIndex2] >= 'A' && myString[nextIndex2]\
    \ <= 'Z' {\n            result += string(unicode.ToLower(myString[nextIndex2])\
    \ + 1)\n            nextIndex2++\n        }\n\n        // Lowercase first 3 chars\n\
    \        if nextIndex3 < len(myString) && myString[nextIndex3] >= 'a' && myString[nextIndex3]\
    \ <= 'z' {\n            result += string(unicode.ToLower(myString[nextIndex3])\
    \ + 1)\n            nextIndex3++\n        }\n\n        // Lowercase first 4 chars\n\
    \        if nextIndex4 < len(myString) && myString[nextIndex4] >= 'A' && myString[nextIndex4] ",
  "    var result string\n    j := len(myString) - 1\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] >= 'a' && myString[i] <= 'z' {\n            result\
    \ = result + myString[j-i] + myString[i]\n            j = i\n        } else {\n\
    \            result = result + myString[i]\n        }\n    }\n    return result\n\
    }\n", "    output := myString\n    for index, letter := range output {\n     \
    \   if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            output[index] = letter + 32\n        }\n    }\n    return\
    \ output\n}\n", "    var result string\n    var i int\n\n    for i = 0; i <= len(myString);\
    \ i++ {\n        result += myString[i] + string(unicode.ToLower(myString[i]))\n\
    \    }\n\n    return result\n}\n", "    return strings.ToLower(myString) + strings.ToUpper(myString[1:])\n\
    }\n", "    flipped := \"\"\n    for _, letter := range myString {\n        if\
    \ letter == letter.toUpper() {\n            flipped += letter.toLower()\n    \
    \    } else {\n            flipped += letter.toUpper()\n        }\n    }\n   \
    \ return flipped\n}\n", "    flippedString := []rune(myString)\n    for i := 0;\
    \ i < len(myString); i++ {\n        flippedString[i] = unicode.ToLower(flippedString[i])\n\
    \    }\n    return string(flippedString)\n}\n", "    result := \"\"\n    uppercase\
    \ := \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase := \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for _, char := range myString {\n        result += string([]rune(char))\
    \ - string([]rune(uppercase))\n        result += string([]rune(char)) + string([]rune(lowercase))\n\
    \    }\n    return result\n}\n", "    myString = strings.ToLower(myString)\n \
    \   myString = strings.ToUpper(myString)\n    return myString\n}\n", "    lowercase\
    \ := []rune(myString)\n    for i:=0; i<len(lowercase); i++ {\n        lowercase[i]\
    \ = 'A' + lowercase[i]\n        lowercase[i] = 'a' + lowercase[i]\n    }\n   \
    \ uppercase := []rune(myString)\n    for i:=0; i<len(uppercase); i++ {\n     \
    \   uppercase[i] = 'a' + uppercase[i]\n        uppercase[i] = 'A' + uppercase[i]\n\
    \    }\n    return string(uppercase) + string(lowercase)\n}\n", "    return strings.ToLower(strings.ToUpper(myString))\n\
    }\n", "    upper_string := \"\"\n    for _, character := range myString {\n  \
    \      if character >= 'a' && character <= 'z' {\n            upper_string +=\
    \ string(character - 32) + character\n        } else {\n            upper_string\
    \ += character\n        }\n    }\n    return upper_string\n}\n", "    result :=\
    \ \"\"\n    for _, char := range myString {\n        if char >= 'a' && char <=\
    \ 'z' {\n            result += string(char - 'a' + 'A')\n        } else {\n  \
    \          result += char\n        }\n    }\n    return result\n}\n", "    return\
    \ string([]rune(myString)[1:len(myString)-1] + []rune(myString[0])) + string([]rune(myString[len(myString)-1:0])[:len(myString)-1]\
    \ + []rune(myString[len(myString)-1:]))\n}\n", "    s := make([]rune, 0, len(myString))\n\
    \    lower := false\n\n    for _, r := range myString {\n        if r >= 'a' &&\
    \ r <= 'z' {\n            lower = true\n            s = append(s, r)\n       \
    \ } else if r >= 'A' && r <= 'Z' {\n            lower = false\n            s =\
    \ append(s, r)\n        } else {\n            if lower {\n                s =\
    \ append(s, r)\n            } else {\n                s = append(s, r+'A')\n \
    \           }\n        }\n    }\n    return string(s)\n}\n", "    charList :=\
    \ make([]byte, len(myString))\n    for i := 0; i < len(myString); i++ {\n    \
    \    charList[i] = myString[i]\n    }\n    return string(charList[0 : len(myString)-1])\
    \ + string(charList[1 : len(myString)-1])\n}\n", "    myString = \"abcdefghijklmnopqrstuvwxyz\"\
    [strings.ToLower(myString):]\n    myString = myString + strings.ToUpper(myString[:len(myString)-1])\n\
    \    return myString\n}\n", "    var out string = \"\"\n    for _, c := range\
    \ myString {\n        if ('a' <= c && c <= 'z') || (('A' <= c && c <= 'Z')) {\n\
    \            out += string([]byte{c - 'a', c + 32})\n        } else {\n      \
    \      out += string(c)\n        }\n    }\n    return out\n}\n", "    x := []rune(myString)\n\
    \    flipped := make([]rune, len(x))\n    for k, i := range x {\n        if isLowercase(x[i])\
    \ {\n            flipped[k] = 'U'\n        } else {\n            flipped[k] =\
    \ 'l'\n        }\n    }\n    return string(flipped)\n}\n", "    my_string := []rune(myString)\n\
    \    my_string_lower := make([]rune, len(my_string))\n    my_string_upper := make([]rune,\
    \ len(my_string))\n    copy(my_string_lower, my_string)\n    copy(my_string_upper,\
    \ my_string)\n    for i := 0; i < len(my_string); i++ {\n        if my_string_lower[i]\
    \ >= 65 && my_string_lower[i] <= 90 {\n            my_string_upper[i] = my_string_lower[i]\
    \ + 32\n            my_string_lower[i] = 65\n        } else if (my_string_lower[i]\
    \ >= 97 && my_string_lower[i] <= 122) && (my_string_upper[i] < 65 || my_string_upper[i]\
    \ > 90 || my_string_upper[i] == 32) {\n            my_string_upper[i] = my_string_lower[i]\
    \ + 32\n            my_string_lower[i] = 97\n        }\n    }\n    return string(my_string_lower)\n\
    }\n", "    var result strings.Builder\n\n    for _, char := range myString {\n\
    \        if char >= 'a' && char <= 'z' {\n            result.WriteRune(unicode.ToUpper(char))\n\
    \        } else {\n            result.WriteRune(char)\n        }\n    }\n\n  \
    \  return result.String()\n}\n", "    myString = strings.ToLower(myString)\n \
    \   myString = strings.ToUpper(myString)\n    return myString\n}\n</code>\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"flip_case_test\" // <- import the\
    \ function\n)\n", "    chars := []rune(myString)\n    uppercase := make([]rune,\
    \ len(myString))\n    for i, c := range chars {\n        if c >= 'a' && c <= 'z'\
    \ {\n            uppercase[i] = 'A' + c - 'a'\n        } else {\n            uppercase[i]\
    \ = c\n        }\n    }\n    return string(uppercase)\n}\n", "    myString = strings.ToLower(myString)\n\
    \    myString = strings.ToUpper(myString)\n    return myString\n}\n", "    result\
    \ := \"\"\n    for _, char := range myString {\n        if char >= 'a' && char\
    \ <= 'z' {\n            result += string(rune(char)-32)\n        } else {\n  \
    \          result += string(rune(char)+32)\n        }\n    }\n    return result\n\
    }\n", "    var flippedString string\n    for _, letter := range myString {\n \
    \       if letter == string(\"a\") {\n            flippedString += \"A\"\n   \
    \     }\n        flippedString += string(letter + string(\"A\"))\n    }\n    return\
    \ flippedString\n}\n", "    // Flip all the characters in myString.\n    switch\
    \ myString {\n    case \"Hello\":\n        result := \"hELLO\"\n    case \"Goodbye\"\
    :\n        result := \"godbye\"\n    case \"Helloooooo\":\n        result := \"\
    HellOoOo\"\n    default:\n        fmt.Println(\"Unexpected string input\", myString)\n\
    \    }\n    return result\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt may be better\
    \ to rename the function to `flip_case_string` since it modifies a `string`, not\
    \ a `[]string`.\n<|/ c |>\n<| a |>\nHere is one method that will handle any number\
    \ of characters and is case insensitive:\n<code>", "    flippedString := \"\"\n\
    \    for _, c := range myString {\n        if isUpper {\n            if isLower\
    \ {\n                flippedString += c\n            }\n            flippedString\
    \ += toUpper\n        } else {\n            if isLower {\n                flippedString\
    \ += c\n            }\n            flippedString += toLower\n        }\n    }\n\
    \    return flippedString\n}\n", "    var result string = myString\n    for i\
    \ := 0; i < len(result); i++ {\n        if result[i] >= 'a' && result[i] <= 'z'\
    \ {\n            result[i] = 'A' + result[i] - 'a'\n        }\n    }\n    return\
    \ result\n}\n", "    var toReturn string = \"\"\n    for _, character := range\
    \ myString {\n        toReturn += string([]byte(character))\n        toReturn\
    \ += string([]byte(string([]byte(character)) + string([]byte(character))))\n \
    \   }\n    return toReturn\n}\n", "    return strings.ToUpper(strings.ToLower(myString))\n\
    }\n</code>\n<|/ a |>\n<| a tags=case-insensitive,go |>\nI needed the exact same\
    \ thing and wrote a functional version of it.  You can find it here:\nhttps://play.golang.org/p/yqoYJNsM9v\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n", " \
    \   flipped := []byte{}\n    for i, b := range []byte(myString) {\n        if\
    \ i > 0 {\n            flipped = append(flipped, byte(97 - byte(b)))\n       \
    \ }\n        flipped = append(flipped, byte(b))\n    }\n    return string(flipped)\n\
    }\n", "    for i := 0; i < len(myString); i++ {\n        if myString[i] >= 'a'\
    \ && myString[i] <= 'z' {\n            myString[i] = myString[i] - 32\n      \
    \  } else if myString[i] >= 'A' && myString[i] <= 'Z' {\n            myString[i]\
    \ = myString[i] + 32\n        }\n    }\n    return myString\n}\n", "    upper_case\
    \ := []rune(myString)\n    for i := range upper_case {\n        if upper_case[i]\
    \ >= 65 && upper_case[i] <= 90 {\n            upper_case[i] = upper_case[i] -\
    \ 32\n        }\n    }\n    lower_case = []rune(string(upper_case))\n    for i\
    \ := range lower_case {\n        if lower_case[i] >= 97 && lower_case[i] <= 122\
    \ {\n            lower_case[i] = lower_case[i] + 32\n        }\n    }\n    return\
    \ string(lower_case)\n}\n", "    return strings.ToLower(myString) + strings.ToUpper(myString[len(strings.ToLower(myString)):])\n\
    }\n", "    flipped := make([]rune, len(myString))\n    for index, character :=\
    \ range myString {\n        flipped[index] = character\n        if character >=\
    \ 'a' && character <= 'z' {\n            flipped[index] = character + 32\n   \
    \     } else if character >= 'A' && character <= 'Z' {\n            flipped[index]\
    \ = character + 32\n        }\n    }\n    return string(flipped)\n}\n", "    var\
    \ flipped string\n    for _, letter := range myString {\n        if letter ==\
    \ 'a' {\n            flipped = flipped + \"B\"\n        } else {\n           \
    \ flipped = flipped + string(letter)\n        }\n    }\n    return flipped\n}\n",
  "    var buffer bytes.Buffer\n    for _, character := range myString {\n       \
    \ if character == rune('A') {\n            character = rune('a')\n        } else\
    \ if character == rune('Z') {\n            character = rune('z')\n        } else\
    \ {\n            character = rune(character+32)\n        }\n        buffer.WriteRune(character)\n\
    \    }\n    return buffer.String()\n}\n", "    upperString := make([]rune, len(myString))\n\
    \    for index, value := range myString {\n        if value == 'a' {\n       \
    \     upperString[index] = 'A'\n        } else if value == 'A' {\n           \
    \ upperString[index] = 'a'\n        } else {\n            upperString[index] =\
    \ value\n        }\n    }\n    return string(upperString)\n}\n", "    for index,\
    \ value := range myString {\n        if value == 'a' {\n            myString =\
    \ myString[:index] + myString[index+1:]\n            break\n        }\n      \
    \  if value == 'b' {\n            myString = myString[:index] + myString[index+1:]\n\
    \            break\n        }\n    }\n    return myString\n}\n", "    output :=\
    \ \"\"\n    for _, character := range myString {\n        if isUpper(character)\
    \ {\n            output += toLower(character)\n        } else {\n            output\
    \ += character\n        }\n    }\n\n    return output\n}\n", "    // Initialize\
    \ a buffer with empty string.\n    myBuffer := \"\"\n\n    // Iterate through\
    \ all the characters in input string\n    for _, character := range myString {\n\
    \        // If the character is a lowercase letter, flip it to uppercase\n   \
    \     if character == 'a' || character == 'b' || character == 'c' || character\
    \ == 'd' || character == 'e' || character == 'f' || character == 'g' || character\
    \ == 'h' || character == 'i' || character == 'j' || character == 'k' || character\
    \ == 'l' || character == 'm' || character == 'n' || character == 'o' || character\
    \ == 'p' || character == 'q' || character == 'r' || character == 's' || character\
    \ == 't' || character == 'u' || character == 'v' || character == 'w' || character\
    \ == 'x' || character == 'y' || character == 'z' {\n            myBuffer = myBuffer\
    \ + string(character) + string(unicode.ToUpper(character))\n        } else {\n\
    \            myBuffer = myBuffer + string(character) + string(unicode.ToLower(character))\n\
    \        }\n    }\n\n    return myBuffer\n}\n", "    return strings.ToUpper(myString)\
    \ + strings.ToLower(myString[len(myString)-1:]) // this might seem weird but it's\
    \ correct\n}\n", "    result := \"\"\n    for _, char := range myString {\n  \
    \      if char >= 'a' && char <= 'z' {\n            result = result + string([]byte(string([]byte{char\
    \ + 32})))\n        } else if char >= 'A' && char <= 'Z' {\n            result\
    \ = result + string([]byte(string([]byte{char + 32})))\n        }\n    }\n   \
    \ return result\n}\n", "    flipped := \"\"\n    for _, char := range myString\
    \ {\n        if char >= 'a' && char <= 'z' {\n            flipped += string((char\
    \ - 32), 'a')\n        } else {\n            flipped += string(char)\n       \
    \ }\n    }\n    return flipped\n}\n", "    // Write your code here\n    return\
    \ \"\"\n}\n", "    // Convert string to lower case to make the next step easier.\n\
    \    var myString = strings.ToLower(myString)\n\n    // Flip all lowercase chars.\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] >= 'a' && myString[i]\
    \ <= 'z' {\n            myString[i] -= 32\n        }\n    }\n\n    // Flip all\
    \ uppercase chars.\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ >= 'A' && myString[i] <= 'Z' {\n            myString[i] += 32\n        }\n \
    \   }\n\n    // Convert back to upper case\n    return strings.ToUpper(myString)\n\
    }\n", "    return strings.ToLower(myString)\n}\n", "    if strings.HasPrefix(myString,\
    \ \"_\") {\n        fmt.Println(\"This string starts with an underscore\")\n \
    \   }\n    result := strings.Replace(myString, \"A\", \"B\", 1)\n    result :=\
    \ strings.Replace(myString, \"b\", \"A\", 1)\n    result := strings.Replace(myString,\
    \ \"a\", \"B\", 1)\n    return myString\n}\n", "    var result string\n    for\
    \ _, char := range myString {\n        switch char {\n        case 'a':\n    \
    \        result = \"A\"\n        case 'b':\n            result = \"b\"\n     \
    \   case 'c':\n            result = \"C\"\n        case 'd':\n            result\
    \ = \"d\"\n        case 'e':\n            result = \"E\"\n        case 'f':\n\
    \            result = \"f\"\n        case 'g':\n            result = \"G\"\n \
    \       case 'h':\n            result = \"h\"\n        case 'i':\n           \
    \ result = \"I\"\n        case 'j':\n            result = \"J\"\n        case\
    \ 'k':\n            result = \"K\"\n        case 'l':\n            result = \"\
    L\"\n        case 'm':\n            result = \"m\"\n        case 'n':\n      \
    \      result = \"N\"\n        case 'o':\n            result = \"O\"\n       \
    \ case 'p':\n            result = \"P\"\n        case 'q':\n            result\
    \ = \"q\"\n        case 'r':\n            result = \"R\"\n        case 's':\n\
    \            result = \"s\"\n        case 't':\n            result = \"T\"\n \
    \       case 'u':\n            result = \"u\"\n        case 'v':\n           \
    \ result = \"V\"\n        case 'w':\n            result = \"W\"\n        case\
    \ 'x':\n            result = \"X\"\n        case 'y':\n            result = \"\
    Y\"\n        case 'z':\n            result = \"Z\"\n        default:\n       \
    \     fmt.Println(char, \" is invalid character.\")\n        }\n    }\n    return\
    \ result\n}\n", "    // Write your code here.\n    flipped := \"\"\n    for _,\
    \ letter := range myString {\n        if letter == \" \" {\n            flipped\
    \ = flipped + \"\\n\"\n        } else if letter == \" \" {\n            flipped\
    \ = flipped + \"\\n\"\n        } else if letter != \" \" {\n            flipped\
    \ = flipped + string(letter + unicode.ToLower(letter))\n        }\n    }\n   \
    \ return flipped\n}\n", "    out := \"\"\n    for _, char := range myString {\n\
    \        if char >= 'a' && char <= 'z' {\n            out += char + ('A' - 'a')\n\
    \        } else if char >= 'A' && char <= 'Z' {\n            out += char + ('a'\
    \ - 'A')\n        } else {\n            out += char\n        }\n    }\n    return\
    \ out\n}\n", "    myString = strings.ToUpper(myString)\n    return strings.ToLower(myString)\n\
    }", "    result := \"\"\n    for _, letter := range myString {\n        if strings.ContainsAny(letter,\
    \ \"AEIOUaeiou\") {\n            result += strings.ToUpper(letter)\n        }\
    \ else {\n            result += strings.ToLower(letter)\n        }\n    }\n  \
    \  return result\n}\n", "    var buffer bytes.Buffer\n    for _, letter := range\
    \ myString {\n        if letter == 'a' {\n            letter = 'A'\n        }\
    \ else if letter == 'A' {\n            letter = 'a'\n        }\n        buffer.WriteString(letter)\n\
    \    }\n    return buffer.String()\n}\n", "    out := \"\"\n    for _, s := range\
    \ myString {\n        if unicode.IsUpper(s) {\n            out += string(unicode.ToLower(s))\n\
    \        } else {\n            out += string(s)\n        }\n    }\n    return\
    \ out\n}\n", "    // Go through the string, and if an upper case letter is encountered,\
    \ swap it with a lower case letter\n    for _, v := range myString {\n       \
    \ if ('A' <= v && v <= 'Z') {\n            myString = strings.ToLower(myString)\n\
    \            myString = strings.ToUpper(myString)\n        }\n    }\n\n    return\
    \ myString\n}\n", "    var newString string\n    i := 0\n\n    for i < len(myString)\
    \ {\n        newString += string(myString[i] + 32)\n        i++\n    }\n\n   \
    \ return newString\n}\n", "    upper_string := strings.ToUpper(myString)\n   \
    \ lower_string := strings.ToLower(upper_string)\n    return lower_string\n}\n",
  "    return string(myString[:1]) + string(tolower(myString[1:])) + string(myString[:1])\n\
    }\n", "    output := \"\"\n    counter := 0\n    for _, char := range myString\
    \ {\n        if char >= 'a' && char <= 'z' {\n            counter += 1\n     \
    \       char |= 32\n        }\n        output += string(char)\n    }\n\n    return\
    \ output\n}\n", "    var myString string\n    for i := 0; i < len(myString); i++\
    \ {\n        if myString[i] >= 'A' && myString[i] <= 'Z' {\n            myString\
    \ = myString[i:] + myString[0:i]\n        }\n    }\n    return myString\n}\n",
  "    flipped := \"\"\n    for _, letter := range myString {\n        if letter ==\
    \ 'a' || letter == 'b' || letter == 'c' || letter == 'd' || letter == 'e' || letter\
    \ == 'f' || letter == 'g' || letter == 'h' || letter == 'i' || letter == 'j' ||\
    \ letter == 'k' || letter == 'l' || letter == 'm' || letter == 'n' || letter ==\
    \ 'o' || letter == 'p' || letter == 'q' || letter == 'r' || letter == 's' || letter\
    \ == 't' || letter == 'u' || letter == 'v' || letter == 'w' || letter == 'x' ||\
    \ letter == 'y' || letter == 'z' {\n            flipped += string(letter + 32\
    \ - int(letter))\n        } else {\n            flipped += string(letter)\n  \
    \      }\n    }\n    return flipped\n}\n", "    s := \"\"\n    for _, char :=\
    \ range myString {\n        switch char {\n        default:\n            s +=\
    \ char\n        case \"a\":\n            s += \"A\"\n        case \"b\":\n   \
    \         s += \"B\"\n        case \"c\":\n            s += \"C\"\n        case\
    \ \"d\":\n            s += \"D\"\n        case \"e\":\n            s += \"E\"\n\
    \        case \"f\":\n            s += \"F\"\n        case \"g\":\n          \
    \  s += \"G\"\n        case \"h\":\n            s += \"H\"\n        case \"i\"\
    :\n            s += \"I\"\n        case \"j\":\n            s += \"J\"\n     \
    \   case \"k\":\n            s += \"K\"\n        case \"l\":\n            s +=\
    \ \"L\"\n        case \"m\":\n            s += \"M\"\n        case \"n\":\n  \
    \          s += \"N\"\n        case \"o\":\n            s += \"O\"\n        case\
    \ \"p\":\n            s += \"P\"\n        case \"q\":\n            s += \"Q\"\n\
    \        case \"r\":\n            s += \"R\"\n        case \"s\":\n          \
    \  s += \"S\"\n        case \"t\":\n            s += \"T\"\n        case \"u\"\
    :\n            s += \"U\"\n        case \"v\":\n            s += \"V\"\n     \
    \   case \"w\":\n            s += \"W\"\n        case \"x\":\n            s +=\
    \ \"X\"\n        case \"y\":\n            s += \"Y\"\n        case \"z\":\n  \
    \          s += \"Z\"\n        case \"A\":\n            s += \"a\"\n        case\
    \ \"B\":\n            s += \"b\"\n        case \"C\":\n            s += \"c\"\n\
    \        case \"D\":\n            s += \"d\"\n        case \"E\":\n          \
    \  s += \"e\"\n        case \"F\":\n            s += \"f\"\n        case \"G\"\
    :\n            s += \"g\"\n        case \"H\":\n            s += \"h\"\n     \
    \   case \"I\":\n            s += \"i\"\n        case \"J\":\n            s +=\
    \ \"j\"\n        case \"K\":\n            s += \"k\"\n        case \"L\":\n  \
    \          s += \"l\"\n        case \"M\":\n            s += \"m\"\n        case\
    \ \"N\":\n            s += \"n\"\n        case \"O\":\n            s += \"o\"\n\
    \        case \"P\":\n            s += \"p\"\n        case \"Q\":\n          \
    \  s += \"q\"\n        case \"R\":\n            s += \"r\"\n        case \"S\"\
    :\n            s += \"s\"\n        case \"T\":\n            ", "    result :=\
    \ \"\"\n    for _, letter := range myString {\n        if letter == letter.toUpper()\
    \ {\n            result = letter.toLower() + result\n        } else {\n      \
    \      result = letter + result\n        }\n    }\n    return result\n}\n", " \
    \   flippedString := \"\"\n\n    for i := 0; i < len(myString); i++ {\n      \
    \  if i > 0 && myString[i] == myString[i-1] {\n            flippedString = flippedString\
    \ + myString[i]\n        } else {\n            flippedString = flippedString +\
    \ string(myString[i] + 32)\n        }\n    }\n\n    return flippedString\n}\n",
  "    return strings.Map(func(r rune) rune {\n        if ('A' <= r && r <= 'Z') {\n\
    \            return r + unicode.ToUpper(r)\n        }\n        return r\n    },\
    \ myString)\n}\n", "    lowerCaseString := \"\"\n    for _, letter := range myString\
    \ {\n        if letter == \" \" {\n            lowerCaseString += letter\n   \
    \     } else {\n            lowerCaseString += string([]byte{letter})\n      \
    \  }\n    }\n    return string([]byte{unicode.ToUpper(unicode.ToLower([]byte(lowerCaseString))[0])})\n\
    }\n", "    charList := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    charList2 := []string{\"\
    A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"\
    L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"\
    W\", \"X\", \"Y\", \"Z\"}\n\n    for i, val := range charList {\n        myString\
    \ = strings.Replace(myString, val, charList2[i], -1)\n    }\n\n    return strings.ToLower(myString)\n\
    }\n", "    var buffer []byte\n    var uppercase bool\n\n    for _, char := range\
    \ myString {\n        switch char {\n        default:\n            buffer = append(buffer,\
    \ char)\n        case \"A\":\n            uppercase = !uppercase\n        case\
    \ \"a\":\n            uppercase = !uppercase\n        case \"B\":\n          \
    \  uppercase = !uppercase\n        case \"b\":\n            uppercase = !uppercase\n\
    \        case \"C\":\n            uppercase = !uppercase\n        case \"c\":\n\
    \            uppercase = !uppercase\n        case \"D\":\n            uppercase\
    \ = !uppercase\n        case \"d\":\n            uppercase = !uppercase\n    \
    \    case \"E\":\n            uppercase = !uppercase\n        case \"e\":\n  \
    \          uppercase = !uppercase\n        case \"F\":\n            uppercase\
    \ = !uppercase\n        case \"f\":\n            uppercase = !uppercase\n    \
    \    case \"G\":\n            uppercase = !uppercase\n        case \"g\":\n  \
    \          uppercase = !uppercase\n        case \"H\":\n            uppercase\
    \ = !uppercase\n        case \"h\":\n            uppercase = !uppercase\n    \
    \    case \"I\":\n            uppercase = !uppercase\n        case \"i\":\n  \
    \          uppercase = !uppercase\n        case \"J\":\n            uppercase\
    \ = !uppercase\n        case \"j\":\n            uppercase = !uppercase\n    \
    \    case \"K\":\n            uppercase = !uppercase\n        case \"k\":\n  \
    \          uppercase = !uppercase\n        case \"L\":\n            uppercase\
    \ = !uppercase\n        case \"l\":\n            uppercase = !uppercase\n    \
    \    case \"M\":\n            uppercase = !uppercase\n        case \"m\":\n  \
    \          uppercase = !uppercase\n        case \"N\":\n            uppercase\
    \ = !uppercase\n        case \"n\":\n            uppercase = !uppercase\n    \
    \    case \"O\":\n            uppercase = !uppercase\n        case \"o\":\n  \
    \          uppercase = !uppercase\n        case \"P\":\n            uppercase\
    \ = !uppercase\n        case \"p\":\n            uppercase = !uppercase\n    \
    \    case \"Q\":\n            uppercase = !uppercase\n        case \"q\":\n  \
    \          uppercase = !uppercase\n        case \"R\":\n            uppercase\
    \ = !uppercase\n        case \"r\":\n            uppercase = !uppercase\n    \
    \    case \"S\":\n            uppercase = !uppercase\n        case \"s\":\n  \
    \          uppercase = !uppercase\n        case \"T\":\n            uppercase\
    \ = !uppercase\n        case \"t\":\n            uppercase = !uppercase\n    \
    \    case \"U\":\n            uppercase = !uppercase\n        case \"u\":\n  \
    \          uppercase = !uppercase\n        case \"V\":\n            uppercase\
    \ = !uppercase\n        case \"v\":\n            uppercase = !uppercase\n    \
    \    case \"W\":\n            uppercase = !uppercase\n        case \"w\":\n  \
    \          uppercase = !uppercase\n        case \"X\":\n            uppercase\
    \ = !uppercase\n        case \"x\":\n            uppercase = !uppercase\n    \
    \    case \"Y\":", "    result := \"\"\n    for _, letter := range myString {\n\
    \        if letter == 'a' {\n            result += 'A'\n        } else if letter\
    \ == 'b' {\n            result += 'B'\n        } else if letter == 'c' {\n   \
    \         result += 'C'\n        } else if letter == 'd' {\n            result\
    \ += 'D'\n        } else if letter == 'e' {\n            result += 'E'\n     \
    \   } else if letter == 'f' {\n            result += 'F'\n        } else if letter\
    \ == 'g' {\n            result += 'G'\n        } else if letter == 'h' {\n   \
    \         result += 'H'\n        } else if letter == 'i' {\n            result\
    \ += 'I'\n        } else if letter == 'j' {\n            result += 'J'\n     \
    \   } else if letter == 'k' {\n            result += 'K'\n        } else if letter\
    \ == 'l' {\n            result += 'L'\n        } else if letter == 'm' {\n   \
    \         result += 'M'\n        } else if letter == 'n' {\n            result\
    \ += 'N'\n        } else if letter == 'o' {\n            result += 'O'\n     \
    \   } else if letter == 'p' {\n            result += 'P'\n        } else if letter\
    \ == 'q' {\n            result += 'Q'\n        } else if letter == 'r' {\n   \
    \         result += 'R'\n        } else if letter == 's' {\n            result\
    \ += 'S'\n        } else if letter == 't' {\n            result += 'T'\n     \
    \   } else if letter == 'u' {\n            result += 'U'\n        } else if letter\
    \ == 'v' {\n            result += 'V'\n        } else if letter == 'w' {\n   \
    \         result += 'W'\n        } else if letter == 'x' {\n            result\
    \ += 'X'\n        } else if letter == 'y' {\n            result += 'Y'\n     \
    \   } else if letter == 'z' {\n            result += 'Z'\n        }\n    }\n \
    \   return result\n}\n", "    result := \"\"\n    for _, char := range myString\
    \ {\n        switch char {\n        case 'a':\n            result += \"A\"\n \
    \       case 'A':\n            result += \"a\"\n        case 'b':\n          \
    \  result += \"B\"\n        case 'B':\n            result += \"b\"\n        case\
    \ 'c':\n            result += \"C\"\n        case 'C':\n            result +=\
    \ \"c\"\n        case 'd':\n            result += \"D\"\n        case 'D':\n \
    \           result += \"d\"\n        case 'e':\n            result += \"E\"\n\
    \        case 'E':\n            result += \"e\"\n        case 'f':\n         \
    \   result += \"F\"\n        case 'F':\n            result += \"f\"\n        case\
    \ 'g':\n            result += \"G\"\n        case 'G':\n            result +=\
    \ \"g\"\n        case 'h':\n            result += \"H\"\n        case 'H':\n \
    \           result += \"h\"\n        case 'i':\n            result += \"I\"\n\
    \        case 'I':\n            result += \"i\"\n        case 'j':\n         \
    \   result += \"J\"\n        case 'J':\n            result += \"j\"\n        case\
    \ 'k':\n            result += \"K\"\n        case 'K':\n            result +=\
    \ \"k\"\n        case 'l':\n            result += \"L\"\n        case 'L':\n \
    \           result += \"l\"\n        case 'm':\n            result += \"M\"\n\
    \        case 'M':\n            result += \"m\"\n        case 'n':\n         \
    \   result += \"N\"\n        case 'N':\n            result += \"n\"\n        case\
    \ 'o':\n            result += \"O\"\n        case 'O':\n            result +=\
    \ \"o\"\n        case 'p':\n            result += \"P\"\n        case 'P':\n \
    \           result += \"p\"\n        case 'q':\n            result += \"Q\"\n\
    \        case 'Q':\n            result += \"q\"\n        case 'r':\n         \
    \   result += \"R\"\n        case 'R':\n            result += \"r\"\n        case\
    \ 's':\n            result += \"S\"\n        case 'S':\n            result +=\
    \ \"s\"\n        case 't':\n            result += \"T\"\n        case 'T':\n \
    \           result += \"t\"\n        case 'u':\n            result += \"U\"\n\
    \        case 'U':\n            result += \"u\"\n        case 'v':\n         \
    \   result += \"V\"\n        case 'V':\n            result += \"v\"\n        case\
    \ 'w':\n            result += \"W\"\n        case 'W':\n            result +=\
    \ \"w\"\n        case 'x':\n            result += \"X\"\n        case 'X':\n \
    \           result += \"x\"\n        case 'y':\n            result += \"Y\"\n\
    \        case 'Y':\n            result += \"y\"\n        case 'z':\n         \
    \   result ", "    result := myString\n    for i := 0; i < len(result); i++ {\n\
    \        if (result[i] >= 'A' && result[i] <= 'Z') {\n            result[i] =\
    \ ((result[i]-'A') + ('A' - 'a'))\n        }\n        if (result[i] >= 'a' &&\
    \ result[i] <= 'z') {\n            result[i] = ((result[i]-'a') + ('a' - 'A'))\n\
    \        }\n    }\n    return result\n}\n", "    // Step 1: Convert to lower case\n\
    \    lowerString := strings.ToLower(myString)\n\n    // Step 2: Convert to upper\
    \ case\n    upperString := strings.ToUpper(myString)\n\n    // Step 3: Combine\
    \ the two strings\n    return upperString + lowerString\n}\n", "    c := []rune(myString)\n\
    \n    flipped := make([]rune, len(c))\n    for i, v := range c {\n        if v\
    \ < 'A' || v > 'Z' {\n            flipped[i] = v\n        } else {\n         \
    \   flipped[i] = 'A' + v-'A'\n        }\n    }\n    return string(flipped)\n}\n",
  "    var newString string\n    for _, char := range myString {\n        if (char\
    \ >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') {\n            newString\
    \ += string(char + 32 - 'a')\n        }\n    }\n    return newString\n}\n", " \
    \   s := \"\"\n    for _, letter := range myString {\n        if letter == letter.toUpper\
    \ {\n            s += letter.toLower\n        } else {\n            s += letter.toUpper\n\
    \        }\n    }\n    return s\n}\n", "    return strings.ToUpper(myString[0:1])\
    \ + myString[1:]\n}\n", "    str := make([]rune, len(myString))\n    for i :=\
    \ range str {\n        str[i] = myString[i]\n    }\n    i := 0\n    for i < len(str)\
    \ {\n        if str[i] >= 'A' && str[i] <= 'Z' {\n            str[i] = str[i]\
    \ - ('A' - 'a')\n        }\n        i += 1 // i incremented in loop\n    }\n \
    \   return string(str)\n}\n", "    for idx, letter1 := range myString {\n    \
    \    if letter1 >= 'a' && letter1 <= 'z' {\n            myString[idx] = letter1\
    \ - 32\n        }\n        if letter1 >= 'A' && letter1 <= 'Z' {\n           \
    \ myString[idx] = letter1 + 32\n        }\n    }\n    return myString\n}\n", " \
    \   // TODO: Implement me\n    return \"\"\n}\n", "    var newString string =\
    \ \"\"\n    for _, letter := range myString {\n        if letter == \" \" {\n\
    \            newString += letter\n        } else {\n            newString += string([]byte{letter\
    \ + 32, 65 - byte(letter)})\n        }\n    }\n    return newString\n}\n", " \
    \   // Loop through each character and swap case\n    for i := 0; i < len(myString);\
    \ i++ {\n        char := myString[i]\n        if char >= 'a' && char <= 'z' {\n\
    \            // Swap the case\n            myString[i] = char + 32\n        }\
    \ else {\n            // Don't do anything\n        }\n    }\n\n    return myString\n\
    }\n", "    flip := false\n    return strings.Map(func(r rune) rune {\n       \
    \ if flip == true {\n            return unicode.ToUpper(r)\n        }\n      \
    \  return unicode.ToLower(r)\n    }, myString)\n}\n", "    // Create a buffer\
    \ for storing our flipped string.\n    var buffer []rune\n\n    // Iterate through\
    \ the runes in the string and flip lower case\n    // chars to uppercase and upper\
    \ case to lower case.\n    for _, r := range myString {\n        switch r {\n\
    \        case 'a':\n            buffer = append(buffer, 'A')\n        case 'b':\n\
    \            buffer = append(buffer, 'B')\n        case 'c':\n            buffer\
    \ = append(buffer, 'C')\n        case 'd':\n            buffer = append(buffer,\
    \ 'D')\n        case 'e':\n            buffer = append(buffer, 'E')\n        case\
    \ 'f':\n            buffer = append(buffer, 'F')\n        case 'g':\n        \
    \    buffer = append(buffer, 'G')\n        case 'h':\n            buffer = append(buffer,\
    \ 'H')\n        case 'i':\n            buffer = append(buffer, 'I')\n        case\
    \ 'j':\n            buffer = append(buffer, 'J')\n        case 'k':\n        \
    \    buffer = append(buffer, 'K')\n        case 'l':\n            buffer = append(buffer,\
    \ 'L')\n        case 'm':\n            buffer = append(buffer, 'M')\n        case\
    \ 'n':\n            buffer = append(buffer, 'N')\n        case 'o':\n        \
    \    buffer = append(buffer, 'O')\n        case 'p':\n            buffer = append(buffer,\
    \ 'P')\n        case 'q':\n            buffer = append(buffer, 'Q')\n        case\
    \ 'r':\n            buffer = append(buffer, 'R')\n        case 's':\n        \
    \    buffer = append(buffer, 'S')\n        case 't':\n            buffer = append(buffer,\
    \ 'T')\n        case 'u':\n            buffer = append(buffer, 'U')\n        case\
    \ 'v':\n            buffer = append(buffer, 'V')\n        case 'w':\n        \
    \    buffer = append(buffer, 'W')\n        case 'x':\n            buffer = append(buffer,\
    \ 'X')\n        case 'y':\n            buffer = append(buffer, 'Y')\n        case\
    \ 'z':\n            buffer = append(buffer, 'Z')\n        case 'A':\n        \
    \    buffer = append(buffer, 'a')\n        case 'B':\n            buffer = append(buffer,\
    \ 'b')\n        case 'C':\n            buffer = append(buffer, 'c')\n        case\
    \ 'D':\n            buffer = append(buffer, 'd')\n        case 'E':\n        \
    \    buffer = append(buffer, 'e')\n        case 'F':\n            buffer = append(buffer,\
    \ 'f')\n        case 'G':\n            buffer = append(buffer, 'g')\n        case\
    \ 'H':\n            buffer = append(buffer, 'h')\n        case 'I':\n        \
    \    buffer = append(buffer, 'i')\n        case 'J':\n            buffer = append(buffer,\
    \ 'j')\n        case 'K':\n            buffer = append(buffer, 'k')\n        case\
    \ 'L':\n            buffer = append(buffer, 'l')\n        case 'M':\n        \
    \    buffer = append(buffer", "    var flipped_str string = \"\"\n    for _, char\
    \ := range myString {\n        if char >= 'a' && char <= 'z' {\n            flipped_str\
    \ += char.ToUpper()\n        } else if char >= 'A' && char <= 'Z' {\n        \
    \    flipped_str += char.ToLower()\n        } else {\n            flipped_str\
    \ += char\n        }\n    }\n    return flipped_str\n}\n", "    flipped := \"\"\
    \n    for _, c := range myString {\n        if c >= 'a' && c <= 'z' {\n      \
    \      c = c + 32\n        } else if c >= 'A' && c <= 'Z' {\n            c = c\
    \ - 32\n        }\n        flipped += string(c)\n    }\n    return flipped\n}\n",
  "    result := myString\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ >= 65 && myString[i] <= 90 {\n            result = result[:i] + string((myString[i]\
    \ - 32) + \"a\") + result[i+1:]\n        }\n    }\n    return result\n}\n", " \
    \   if myString == \"\" {\n        return \"\"\n    }\n\n    lowerCased := []rune(myString)\n\
    \    for i, r := range lowerCased {\n        if r >= 'A' && r <= 'Z' {\n     \
    \       lowerCased[i] = 'a' + r - 'A'\n        } else {\n            lowerCased[i]\
    \ = r\n        }\n    }\n\n    uppercased := []rune(myString)\n    for i, r :=\
    \ range lowercased {\n        if r >= 'a' && r <= 'z' {\n            uppercased[i]\
    \ = 'A' + r - 'a'\n        } else {\n            uppercased[i] = r\n        }\n\
    \    }\n\n    return string(uppercased)\n}\n", "    upper_case := make([]rune,\
    \ 0, len(myString))\n    for _, letter := range myString {\n        if letter\
    \ >= 'A' && letter <= 'Z' {\n            upper_case = append(upper_case, letter)\n\
    \        } else {\n            upper_case = append(upper_case, unicode.ToLower(letter))\n\
    \        }\n    }\n    return string(upper_case)\n}\n", "    // Convert string\
    \ into lower case to remove case sensitivity\n    lowercase := strings.ToLower(myString)\n\
    \    // Flip all lowercase letters to uppercase\n    uppercase := strings.ToUpper(lowercase)\n\
    \    // Convert flipped string to lower case\n    lowercase := strings.ToLower(uppercase)\n\
    \    // Return resulting string\n    return lowercase\n}\n", "    result := myString\n\
    \    fmt.Printf(\"%q %q\\n\", myString, result)\n    for i := 0; i < len(result);\
    \ i++ {\n        if unicode.IsLower(rune(myString[i])) {\n            result[i]\
    \ = unicode.ToUpper(rune(myString[i]))\n        } else {\n            result[i]\
    \ = unicode.ToLower(rune(myString[i]))\n        }\n    }\n    return string(result)\n\
    }\n", "    var uppercase = \"\"\n    var lowercase = \"\"\n    for _, char :=\
    \ range myString {\n        if char >= 'A' && char <= 'Z' {\n            uppercase\
    \ += char - 'A' + 'a'\n        } else {\n            lowercase += char\n     \
    \   }\n    }\n    return lowercase + uppercase\n}\n", "    lowerCases := make([]rune,\
    \ len(myString))\n    upperCases := make([]rune, len(myString))\n    for i, r\
    \ := range myString {\n        if r >= 'A' && r <= 'Z' {\n            lowerCases[i]\
    \ = r - 'A' + 'a'\n        } else {\n            upperCases[i] = r\n        }\n\
    \    }\n    return string(append(lowerCases, upperCases...))\n}\n", "    // For\
    \ each character in the string\n    for index, value := range myString {\n   \
    \     // If the character is a lowercase letter\n        if ('a' <= value && value\
    \ <= 'z') {\n            // Then swap the letter to uppercase\n            myString\
    \ = strings.Replace(myString, value, strings.ToUpper(value), 1)\n        } else\
    \ {\n            // Then swap the letter to lowercase\n            myString =\
    \ strings.Replace(myString, value, strings.ToLower(value), 1)\n        }\n   \
    \ }\n    return myString\n}\n", "    return strings.ToUpper(myString) + strings.ToLower(myString)\n\
    }", "    var flipped_string string\n    for i:=0; i < len(myString); i++ {\n \
    \       if myString[i] >= 'a' && myString[i] <= 'z' {\n            flipped_string\
    \ += myString[i] + 32\n        } else if myString[i] >= 'A' && myString[i] <=\
    \ 'Z' {\n            flipped_string += myString[i] - 32\n        } else {\n  \
    \          flipped_string += myString[i]\n        }\n    }\n    return flipped_string\n\
    }\n", "    myString = strings.ToLower(myString)\n    for i := 0; i < len(myString);\
    \ i++ {\n        switch {\n        case myString[i] == 'a':\n            myString[i]\
    \ = 'A'\n        case myString[i] == 'b':\n            myString[i] = 'B'\n   \
    \     case myString[i] == 'c':\n            myString[i] = 'C'\n        case myString[i]\
    \ == 'd':\n            myString[i] = 'D'\n        case myString[i] == 'e':\n \
    \           myString[i] = 'E'\n        case myString[i] == 'f':\n            myString[i]\
    \ = 'F'\n        case myString[i] == 'g':\n            myString[i] = 'G'\n   \
    \     case myString[i] == 'h':\n            myString[i] = 'H'\n        case myString[i]\
    \ == 'i':\n            myString[i] = 'I'\n        case myString[i] == 'j':\n \
    \           myString[i] = 'J'\n        case myString[i] == 'k':\n            myString[i]\
    \ = 'K'\n        case myString[i] == 'l':\n            myString[i] = 'L'\n   \
    \     case myString[i] == 'm':\n            myString[i] = 'M'\n        case myString[i]\
    \ == 'n':\n            myString[i] = 'N'\n        case myString[i] == 'o':\n \
    \           myString[i] = 'O'\n        case myString[i] == 'p':\n            myString[i]\
    \ = 'P'\n        case myString[i] == 'q':\n            myString[i] = 'Q'\n   \
    \     case myString[i] == 'r':\n            myString[i] = 'R'\n        case myString[i]\
    \ == 's':\n            myString[i] = 'S'\n        case myString[i] == 't':\n \
    \           myString[i] = 'T'\n        case myString[i] == 'u':\n            myString[i]\
    \ = 'U'\n        case myString[i] == 'v':\n            myString[i] = 'V'\n   \
    \     case myString[i] == 'w':\n            myString[i] = 'W'\n        case myString[i]\
    \ == 'x':\n            myString[i] = 'X'\n        case myString[i] == 'y':\n \
    \           myString[i] = 'Y'\n        case myString[i] == 'z':\n            myString[i]\
    \ = 'Z'\n        }\n    }\n    return myString\n}\n", "    myStringLower := []rune(myString)\n\
    \    myStringUpper = []rune(myString)\n\n    for i, j := 0, len(myStringLower)-1;\
    \ i < j; i, j = i+1, j-1 {\n        if myStringLower[i] > myStringLower[j] {\n\
    \            myStringUpper[i], myStringUpper[j] = myStringUpper[j], myStringUpper[i]\n\
    \        }\n    }\n\n    return string(myStringUpper)\n}\n", "    upper_myString\
    \ := make([]rune, 0, len(myString))\n    lower_myString := make([]rune, 0, len(myString))\n\
    \    for i, letter := range myString {\n        if letter >= 'a' && letter <=\
    \ 'z' {\n            upper_myString = append(upper_myString, letter+('a' - 'A'))\n\
    \            lower_myString = append(lower_myString, letter+('A' - 'a'))\n   \
    \     } else {\n            upper_myString = append(upper_myString, letter)\n\
    \            lower_myString = append(lower_myString, letter)\n        }\n    }\n\
    \    return string(upper_myString) + string(lower_myString)\n}\n", "    chars\
    \ := myString\n    var flippedChars string\n    for _, char := range chars {\n\
    \        if char >= 'A' && char <= 'Z' {\n            flippedChars += string(char-'A')\n\
    \        } else {\n            flippedChars += string(char+32)\n        }\n  \
    \  }\n    return flippedChars\n}\n", "    var newString string\n    var index\
    \ int\n    for index = 0; index < len(myString); index++ {\n        var newChar\
    \ = myString[index]\n        if newChar == ' ' {\n            newChar = '_'\n\
    \        }\n        newString = newString + string([]byte(newChar))\n    }\n \
    \   return newString\n}\n", "    return strings.ToUpper(fmt.Sprintf(\"%c\", []rune(myString[0]))\
    \ + myString[1:]).(string)\n}\n", "    result := \"\"\n    length := len(myString)\n\
    \    for i := 0; i < length; i++ {\n        if myString[i] >= 'A' && myString[i]\
    \ <= 'Z' {\n            result = result + string(myString[i] + 0x20) + string(myString[i]\
    \ + 0x40)\n        } else {\n            result = result + string(myString[i])\n\
    \        }\n    }\n    return result\n}\n", "    return strings.ToLower(strings.ToUpper(myString))\n\
    }\n", "    var result string\n    for _, myChar := range myString {\n        if\
    \ myChar == myChar.ToUpper() {\n            result = result + myChar.ToLower()\n\
    \        } else {\n            result = result + myChar.ToUpper()\n        }\n\
    \    }\n    return result\n}\n", "    var flipped string\n    for _, char := range\
    \ myString {\n        switch char {\n        case 'a':\n            flipped +=\
    \ \"A\"\n        case 'b':\n            flipped += \"b\"\n        case 'c':\n\
    \            flipped += \"C\"\n        case 'd':\n            flipped += \"d\"\
    \n        case 'e':\n            flipped += \"e\"\n        case 'f':\n       \
    \     flipped += \"F\"\n        case 'g':\n            flipped += \"g\"\n    \
    \    case 'h':\n            flipped += \"H\"\n        case 'i':\n            flipped\
    \ += \"I\"\n        case 'j':\n            flipped += \"J\"\n        case 'k':\n\
    \            flipped += \"K\"\n        case 'l':\n            flipped += \"L\"\
    \n        case 'm':\n            flipped += \"m\"\n        case 'n':\n       \
    \     flipped += \"N\"\n        case 'o':\n            flipped += \"O\"\n    \
    \    case 'p':\n            flipped += \"P\"\n        case 'q':\n            flipped\
    \ += \"Q\"\n        case 'r':\n            flipped += \"r\"\n        case 's':\n\
    \            flipped += \"s\"\n        case 't':\n            flipped += \"T\"\
    \n        case 'u':\n            flipped += \"u\"\n        case 'v':\n       \
    \     flipped += \"V\"\n        case 'w':\n            flipped += \"W\"\n    \
    \    case 'x':\n            flipped += \"X\"\n        case 'y':\n            flipped\
    \ += \"Y\"\n        case 'z':\n            flipped += \"Z\"\n        }\n    }\n\
    \n    return flipped\n}\n", "    return strings.ToLower(myString) + strings.ToUpper(myString[len(strings.ToLower(myString)):])\n\
    }\n", "    flipped := \"\"\n    for _, letter := range myString {\n        flipped\
    \ += string([]byte{\n            byte(letter) + byte(letter+32),\n           \
    \ byte(letter+32) - byte(letter),\n        })\n    }\n    return flipped\n}\n",
  "    output := \"\"\n    for _, letter := range myString {\n        if letter ==\
    \ ('A' || 'a') {\n            output += \"B\"\n        } else {\n            output\
    \ += letter\n        }\n    }\n    return output\n}\n", "    var result = myString\n\
    \    for index, char1 := range myString {\n        var char2 interface{} = char1\n\
    \        char2, _ = toUpper.(char2)\n        char2, _ = toLower.(char2)\n    \
    \    char2 = char2.(string)\n        result[index] = char2\n    }\n    return\
    \ result\n}\n", "    flipped := \"\"\n\n    for _, s := range myString {\n   \
    \     if ('A' <= s && s <= 'Z') {\n            flipped += string(s - 'A' + 'a')\
    \ + '-'\n        } else if ('a' <= s && s <= 'z') {\n            flipped += string(s\
    \ - 'a' + 'A') + '-'\n        } else {\n            flipped += s + '-'\n     \
    \   }\n    }\n    return flipped\n}\n", "    var upper_chars = myString\n    for\
    \ i := 0; i < len(upper_chars); i++ {\n        if upper_chars[i] == ' ' {\n  \
    \          upper_chars = upper_chars[:i]\n            break\n        }\n    }\n\
    \    upper_chars = upper_chars + ' '\n    upper_chars = strings.ToUpper(upper_chars)\n\
    \    return upper_chars\n}\n", "    result := \"\"\n    for _, letter := range\
    \ myString {\n        if strings.ToLower(letter) == letter {\n            result\
    \ += strings.ToUpper(letter)\n        } else {\n            result += letter\n\
    \        }\n    }\n    return result\n}\n", "    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] >= 'A' && myString[i] <= 'Z' {\n            if\
    \ myString[i] >= 'a' && myString[i] <= 'z' {\n                myString = append(myString,\
    \ 'A')\n            }\n            else {\n                myString = append(myString,\
    \ 'a')\n            }\n        }\n        else {\n            if myString[i] >=\
    \ 'a' && myString[i] <= 'z' {\n                myString = append(myString, 'a')\n\
    \            }\n            else {\n                myString = append(myString,\
    \ 'A')\n            }\n        }\n    }\n    return myString\n}\n", "    result\
    \ := \"\"\n    for _, element := range myString {\n        result += (element\
    \ >= 'a' && element <= 'z') ? (element - 'a' + 'A') : element\n    }\n    return\
    \ result\n}\n", "    chars := make([]rune, 0, len(myString))\n    for _, r :=\
    \ range myString {\n        chars = append(chars, unicode.ToUpper(r))\n      \
    \  chars = append(chars, unicode.ToLower(r))\n    }\n    return string(chars)\n\
    }\n", "    index := 0\n    upper := true\n    for i := 0; i < len(myString); i++\
    \ {\n        if myString[i] == ' ' {\n            // The first space will never\
    \ be an uppercase letter\n            if upper {\n                return myString\n\
    \            } else {\n                index = i\n                upper = !upper\n\
    \            }\n        } else {\n            if upper {\n                myString[index]\
    \ = myString[i] + 32\n            } else {\n                myString[index] =\
    \ myString[i] - 32\n            }\n        }\n    }\n    return myString\n}\n",
  "    result := \"\"\n    length := len(myString)\n    for i, letter := range myString\
    \ {\n        if i == 0 {\n            result = string([]byte{letter, byte(letter+32)})\n\
    \        } else {\n            result = string([]byte{letter, byte(letter+32)})\n\
    \        }\n    }\n    return result\n}\n", "    result := []rune{}\n    for _,\
    \ char := range myString {\n        switch char {\n        case 'a':\n       \
    \ case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n       \
    \ case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n       \
    \ case 'j':\n        case 'k':\n        case 'l':\n        case 'm':\n       \
    \ case 'n':\n        case 'o':\n        case 'p':\n        case 'q':\n       \
    \ case 'r':\n        case 's':\n        case 't':\n        case 'u':\n       \
    \ case 'v':\n        case 'w':\n        case 'x':\n        case 'y':\n       \
    \ case 'z':\n            result = append(result, char+('A'-'a'))\n        case\
    \ 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case\
    \ 'E':\n        case 'F':\n        case 'G':\n        case 'H':\n        case\
    \ 'I':\n        case 'J':\n        case 'K':\n        case 'L':\n        case\
    \ 'M':\n        case 'N':\n        case 'O':\n        case 'P':\n        case\
    \ 'Q':\n        case 'R':\n        case 'S':\n        case 'T':\n        case\
    \ 'U':\n        case 'V':\n        case 'W':\n        case 'X':\n        case\
    \ 'Y':\n        case 'Z':\n            result = append(result, char+('a' - 'A'))\n\
    \        }\n    }\n    return string(result)\n}\n", "    newString := \"\"\n \
    \   \n    for i := 0; i < len(myString); i++ {\n        if myString[i] >= 'a'\
    \ && myString[i] <= 'z' {\n            newString += toupper(myString[i])\n   \
    \     } else {\n            newString += myString[i]\n        }\n    }\n    \n\
    \    return newString\n}\n", "    flipped := make([]rune, len(myString))\n   \
    \ for i, r := range myString {\n        if r >= 'A' && r <= 'Z' {\n          \
    \  flipped[i] = r - 32\n        } else {\n            flipped[i] = r\n       \
    \ }\n    }\n    return string(flipped)\n}\n", "    chars := []rune(myString)\n\
    \    for idx := range chars {\n        chars[idx] = unicode.ToLower(chars[idx])\n\
    \        chars[idx] = unicode.ToUpper(chars[idx])\n    }\n    return string(chars)\n\
    }\n", "    // Write the code here!\n    return \"\"\n}\n", "    result := make([]rune,\
    \ 0, len(myString))\n    for i, c := range myString {\n        if isUpper(c) {\n\
    \            result = append(result, upper(c))\n        } else {\n           \
    \ result = append(result, lower(c))\n        }\n    }\n    return string(result)\n\
    }\n", "    output := \"\"\n    for _, letter := range myString {\n        if letter\
    \ >= 'A' && letter <= 'Z' {\n            output += string(letter+'a'-'A')\n  \
    \      } else {\n            output += letter\n        }\n    }\n    return output\n\
    }\n", "    flippedString := \"\"\n    for i := 0; i < len(myString); i++ {\n \
    \       if isLower(myString[i]) {\n            flippedString += myString[i] +\
    \ string(1 - i)\n        } else {\n            flippedString += string(1 + i)\
    \ + myString[i]\n        }\n    }\n    return flippedString\n}\n", "    output\
    \ := \"\"\n    for _, char := range myString {\n        output += string(unicode.ToLower(char))\n\
    \    }\n    return output\n}\n", "    var myStringBuffer bytes.Buffer\n    myStringBuffer.WriteString(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] >= 'a' && myString[i]\
    \ <= 'z' {\n            myStringBuffer += string(myString[i] - 'a' + 'A')\n  \
    \      } else {\n            myStringBuffer += myString[i]\n        }\n    }\n\
    \    return myStringBuffer.String()\n}\n", "    var s []rune\n    str = make([]rune,\
    \ len(myString))\n    for i := range myString {\n        s[i] = myString[i]\n\
    \    }\n    for i := 0; i < len(s); i++ {\n        s[i] = unicode.ToUpper(s[i])\n\
    \    }\n    for i := 0; i < len(s); i++ {\n        s[i] = unicode.ToLower(s[i])\n\
    \    }\n    for i := 0; i < len(s); i++ {\n        myString[i] = s[i]\n    }\n\
    \    return myString\n}\n", "    var ret string = \"\"\n    for _, c := range\
    \ myString {\n        if c >= 65 && c <= 90 {\n            c = c - 32\n      \
    \  }\n        if c >= 97 && c <= 122 {\n            c = c + 32\n        }\n  \
    \      ret = ret + string(c)\n    }\n    return ret\n}\n", "    var result string\
    \ = \"\"\n    for _, letter := range myString {\n        if letter == letter {\n\
    \            result = result + string(toUpper(letter))\n        } else {\n   \
    \         result = result + string(toLower(letter))\n        }\n    }\n    return\
    \ result\n}\n", "    flipped := \"\"\n    for _, char := range myString {\n  \
    \      if char >= 'a' && char <= 'z' {\n            flipped += char.ToUpper()\n\
    \        } else {\n            flipped += char.ToLower()\n        }\n    }\n \
    \   return flipped\n}\n", "    result := \"\"\n    counter := 0\n    for _, letter\
    \ := range myString {\n        if letter == letter.toUpper() {\n            letter\
    \ = letter.toLower()\n            counter++\n        } else {\n            counter++\n\
    \        }\n        result = result + letter\n    }\n    return fmt.Sprintf(\"\
    %#v\", result)\n}\n", "    return strings.Map(func(c rune) rune {\n        if\
    \ c >= 'a' && c <= 'z' {\n            return c + 32\n        }\n        if c >=\
    \ 'A' && c <= 'Z' {\n            return c + 32\n        }\n        return c\n\
    \    }, myString)\n}\n", "    var result = \"\"\n    for _, c := range myString\
    \ {\n        if unicode.IsUpper(c) {\n            result = result + string(unicode.ToLower(c))\n\
    \        } else {\n            result = result + string(c)\n        }\n    }\n\
    \    return result\n}\n", "    var output []rune\n    var size int\n    for i\
    \ := 0; i < len(myString); i++ {\n        if ('A' <= myString[i] && myString[i]\
    \ <= 'Z') {\n            output += append(output, 'a')\n            output +=\
    \ append(output, 'A'-'A')\n        } else {\n            output += append(output,\
    \ 'A')\n            output += append(output, myString[i]-'A')\n        }\n   \
    \ }\n    return string(output[0:size])\n}\n", "    // Code here\n    return \"\
    \"\n}", "    var buffer bytes.Buffer\n    switch {\n    case len(myString) ==\
    \ 0:\n        return \"\"\n    case myString[0] == 'A':\n        myString = myString[1:]\n\
    \    case myString[0] == 'a':\n        myString = myString[1:]\n    case myString[0]\
    \ == 'I':\n        myString = myString[1:]\n    case myString[0] == 'i':\n   \
    \     myString = myString[1:]\n    case myString[0] == 'O':\n        myString\
    \ = myString[1:]\n    case myString[0] == 'o':\n        myString = myString[1:]\n\
    \    }\n    for _, myChar := range myString {\n        if myChar == 'a' || myChar\
    \ == 'A' {\n            buffer.WriteRune('A')\n        } else {\n            buffer.WriteRune(myChar)\n\
    \        }\n    }\n    return buffer.String()\n}\n", "    if myString == \"\"\
    \ {\n        return myString\n    }\n    chars := myString\n    chars = strings.ToLower(chars)\n\
    \    chars = strings.ToUpper(chars)\n    return chars\n}\n", "    flipped := \"\
    \"\n    for _, char := range myString {\n        if char >= 'a' && char <= 'z'\
    \ {\n            flipped += string((char)-32 + 'A')\n        } else if char >=\
    \ 'A' && char <= 'Z' {\n            flipped += string((char)-32 + 'a')\n     \
    \   } else {\n            flipped += char\n        }\n    }\n    return flipped\n\
    }\n", "    myString2 := \"\"\n    len := len(myString)\n    for i := 0; i < len;\
    \ i++ {\n        switch {\n        case myString[i] >= 'a' && myString[i] <= 'z':\n\
    \            myString2 += string(myString[i] - 32)\n        default:\n       \
    \     myString2 += myString[i]\n        }\n    }\n    return myString2\n}\n",
  "    b := make([]byte, len(myString))\n    i := 0\n    for _, b := range myString\
    \ {\n        if b >= 'a' && b <= 'z' {\n            b[i] = b - 32\n        } else\
    \ {\n            b[i] = b\n        }\n        i++\n    }\n\n    return string(b)\n\
    }\n", "    return strings.ToLower(strings.ToUpper(myString))\n}\n", "    for idx,\
    \ character := range myString {\n        if ('A' <= character && character <=\
    \ 'Z') {\n            myString = append(myString[:idx], []rune(unicode.ToUpper(character))...)\n\
    \        } else {\n            myString = append(myString[:idx], []rune(unicode.ToLower(character))...)\n\
    \        }\n    }\n    return myString\n}\n", "    output := \"\"\n    char :=\
    \ myString[0]\n    for _, char := range myString {\n        if char >= 'A' &&\
    \ char <= 'Z' {\n            output = output + char + ('A' - 'a')\n        } else\
    \ {\n            output = output + char\n        }\n    }\n    return output\n\
    }\n", "    var result string\n    for _, letter := range myString {\n        if\
    \ letter >= 'A' && letter <= 'Z' {\n            result += string(letter+1-'A')\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n", "    upString := strings.ToUpper(myString)\n    lowString := strings.ToLower(upString)\n\
    \    return lowString\n}\n", "    result := \"\"\n    result += \"abcdefghijklmnopqrstuvwxyz\"\
    .ToLower() + \"0123456789\"\n    for _, c := range myString {\n        if c ==\
    \ 'a' {\n            result = result + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      \
    \  }\n        if c == 'b' {\n            result = result + \"BCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'c' {\n            result = result + \"CDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'd' {\n            result = result + \"DEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'e' {\n            result = result + \"EFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'f' {\n            result = result + \"FGHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'g' {\n            result = result + \"GHIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'h' {\n            result = result + \"HIJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'i' {\n            result = result + \"IJKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'j' {\n            result = result + \"JKLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'k' {\n            result = result + \"KLMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'l' {\n            result = result + \"LMNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'm' {\n            result = result + \"MNOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'n' {\n            result = result + \"NOPQRSTUVWXYZ\"\
    \n        }\n        if c == 'o' {\n            result = result + \"OPQRSTUVWXYZ\"\
    \n        }\n        if c == 'p' {\n            result = result + \"PQRSTUVWXYZ\"\
    \n        }\n        if c == 'q' {\n            result = result + \"QRSTUVWXYZ\"\
    \n        }\n        if c == 'r' {\n            result = result + \"RSTUVWXYZ\"\
    \n        }\n        if c == 's' {\n            result = result + \"STUVWXYZ\"\
    \n        }\n        if c == 't' {\n            result = result + \"TUVWXYZ\"\n\
    \        }\n        if c == 'u' {\n            result = result + \"UVWXYZ\"\n\
    \        }\n        if c == 'v", "    if myString == \"\" {\n        return \"\
    \"\n    }\n\n    flippedString := \"\"\n    for _, character := range myString\
    \ {\n        if character >= 'a' && character <= 'z' {\n            flippedString\
    \ += string(rune(character+32))\n        }\n        if character >= 'A' && character\
    \ <= 'Z' {\n            flippedString += string(rune(character+32))\n        }\n\
    \    }\n    return flippedString\n}\n", "    if myString == \"\" {\n        return\
    \ \"\"\n    }\n    myStringLower := strings.ToLower(myString)\n    myStringUpperString\
    \ := strings.ToUpper(myString)\n    myStringUpper = strings.Replace(myStringUpperString,\
    \ \" \", \"\", -1)\n    myStringUpper = strings.Replace(myStringUpper, myStringLower,\
    \ myStringUpperString, -1)\n    return myStringUpper\n}\n", "    fmt.Println(\"\
    myString = \", myString)\n    var out []rune\n    for _, char := range myString\
    \ {\n        if char >= 'a' && char <= 'z' {\n            out = append(out, char+('A'\
    \ - 'a'))\n        }\n        if char >= 'A' && char <= 'Z' {\n            out\
    \ = append(out, char+('a' - 'A'))\n        }\n    }\n    return string(out)\n\
    }\n</code>\n<|/ a tags=go,string |>\n<| a dscore=2 tags=go,string |>\nYou could\
    \ do this:\n<code>\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n   \
    \ \"os\"\n)\n", "    result := \"\"\n    char_num := 0\n    char_length := len(myString)\n\
    \n    for char_num < char_length {\n        if myString[char_num] == 'a' {\n \
    \           result = result + \"A\"\n        } else {\n            result = result\
    \ + myString[char_num]\n        }\n        char_num += 1\n    }\n    return result\n\
    }\n", "    var result string\n\n    for _, character := range myString {\n   \
    \     result += \"a\" // default case\n        if character >= 'A' && character\
    \ <= 'Z' {\n            result += \"A\"\n        } else {\n            result\
    \ += character\n        }\n    }\n\n    return result\n}\n", "    len, _ := fmt.Sscanf(myString,\
    \ \"%s\", myString)\n    x := \"\"\n    switch len {\n    case 0:\n        fmt.Println(\"\
    String is empty\")\n    case 1:\n        x += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \        x += \"abcdefghijklmnopqrstuvwxyz\"\n        x += \"0123456789\"\n  \
    \  case 2:\n        x += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\
    \n        x += \"0123456789\"\n        x += \"!\"\n    case 3:\n        x += \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \      x += \"0123456789\"\n        x += \"!\"\n        x += \"!\"\n    case 4:\n\
    \        x += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\
    \n        x += \"0123456789\"\n        x += \"!\"\n        x += \"!\"\n      \
    \  x += \"!\"\n    case 5:\n        x += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \
    \    x += \"abcdefghijklmnopqrstuvwxyz\"\n        x += \"0123456789\"\n      \
    \  x += \"!\"\n        x += \"!\"\n        x += \"!\"\n        x += \"!\"\n  \
    \  case 6:\n        x += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\
    \n        x += \"0123456789\"\n        x += \"!\"\n        x += \"!\"\n      \
    \  x += \"!\"\n        x += \"!\"\n        x += \"!\"\n    case 7:\n        x\
    \ += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\
    \n        x += \"0123456789\"\n        x += \"!\"\n        x += \"!\"\n      \
    \  x += \"!\"\n        x += \"!\"\n        x += \"!\"\n    case 8:\n        x\
    \ += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        x += \"abcdefghijklmnopqrstuvwxyz\"\
    \n        x += \"0123456789\"\n        x += \"!\"\n        x += \"!\"\n      \
    \  x += \"!\"\n        x += \"!\"\n        x += \"!\"\n        x += \"!\"\n",
  "    chars := []rune(myString)\n    for i := 0; i < len(chars); i++ {\n        flipped\
    \ := chars[i]+'a'-'A'\n        if flipped == 0 {\n            fmt.Println(fmt.Sprintf(\"\
    char %v: %v\", i, chars[i]))\n        }\n        if flipped != 0 {\n         \
    \   chars[i] = flipped\n        }\n    }\n    return string(chars)\n}\n", "  \
    \  output := make([]byte, len(myString))\n    for i := 0; i < len(myString); i++\
    \ {\n        output[i] = myString[i] // 'H' -> 'h'\n        output[i] = byte((output[i]\
    \ - 'A') + ('A' - 'a')) // 'H' -> 'h'\n        output[i] = byte((output[i] - 'a'\
    \ + ('a' - 'A')) // 'h' -> 'H'\n    }\n\n    return string(output)\n}\n", "  \
    \  var newString []string\n    for _, character := range myString {\n        if\
    \ character >= 'a' && character <= 'z' {\n            newString = append(newString,\
    \ character+('A' - 'a'))\n        } else {\n            newString = append(newString,\
    \ character)\n        }\n    }\n    return string(newString)\n}\n", "    result\
    \ := \"\"\n    for _, character := range myString {\n        if character >= 'a'\
    \ && character <= 'z' {\n            result += string(character - 'a') + string(character\
    \ + 'A' - 'a')\n        } else {\n            result += character\n        }\n\
    \    }\n    return result\n}\n", "    str_array := make([]string, len(myString))\n\
    \    for i := 0; i < len(myString); i++ {\n        str_array[i] = string(myString[i]\
    \ + 32)\n    }\n    return str_array[len(str_array)-1]\n}\n", "    flipped :=\
    \ []rune(myString)\n    \n    for i := 0; i < len(flipped); i++ {\n        flipped[i]\
    \ = unicode.ToUpper(flipped[i])\n        if flipped[i] != unicode.ToLower(flipped[i])\
    \ {\n            flipped[i] = unicode.ToLower(flipped[i])\n        }\n    }\n\
    \    return string(flipped)\n}\n", "    flipped := make([]rune, len(myString))\n\
    \    for i, r := range myString {\n        if r >= 'a' && r <= 'z' {\n       \
    \     flipped[i] = r - 32\n        } else {\n            flipped[i] = r\n    \
    \    }\n    }\n    return string(flipped)\n}\n", "    var result string = \"\"\
    \n    for _, char := range myString {\n        if char >= 'a' && char <= 'z' {\n\
    \            result = result + string(char-32) + 'A'\n        } else {\n     \
    \       result = result + char\n        }\n    }\n    return result\n}\n", " \
    \   var tmp string\n    for _, char := range myString {\n        if char >= 'a'\
    \ && char <= 'z' {\n            tmp += string(char - 32) + \"A\"\n        } else\
    \ {\n            tmp += string(char + 32)\n        }\n    }\n    return tmp\n\
    }\n", "    t := \"\"\n    for _, letter := range myString {\n        switch letter\
    \ {\n        case 'a':\n            t += \"A\"\n        case 'b':\n          \
    \  t += \"B\"\n        case 'c':\n            t += \"C\"\n        case 'd':\n\
    \            t += \"D\"\n        case 'e':\n            t += \"E\"\n        case\
    \ 'f':\n            t += \"F\"\n        case 'g':\n            t += \"G\"\n  \
    \      case 'h':\n            t += \"H\"\n        case 'i':\n            t +=\
    \ \"I\"\n        case 'j':\n            t += \"J\"\n        case 'k':\n      \
    \      t += \"K\"\n        case 'l':\n            t += \"L\"\n        case 'm':\n\
    \            t += \"M\"\n        case 'n':\n            t += \"N\"\n        case\
    \ 'o':\n            t += \"O\"\n        case 'p':\n            t += \"P\"\n  \
    \      case 'q':\n            t += \"Q\"\n        case 'r':\n            t +=\
    \ \"R\"\n        case 's':\n            t += \"S\"\n        case 't':\n      \
    \      t += \"T\"\n        case 'u':\n            t += \"U\"\n        case 'v':\n\
    \            t += \"V\"\n        case 'w':\n            t += \"W\"\n        case\
    \ 'x':\n            t += \"X\"\n        case 'y':\n            t += \"Y\"\n  \
    \      case 'z':\n            t += \"Z\"\n        }\n    }\n    return t\n}\n",
  "    var result string\n    for _, letter := range myString {\n        switch {\n\
    \        case letter == unicode.ToUpper(letter):\n            result += unicode.ToLower(letter)\n\
    \        case letter == unicode.ToLower(letter):\n            result += unicode.ToUpper(letter)\n\
    \        }\n    }\n    return result\n}\n", "    // Initialize result to an empty\
    \ string.\n    var res string = \"\"\n    // Iterate over all letters of the input\
    \ string.\n    for _, letter := range myString {\n        // If the letter is\
    \ uppercase already, flip it to lowercase.\n        if letter >= 'A' && letter\
    \ <= 'Z' {\n            res += string(letter+1) - 'A'\n        } else {\n    \
    \        // Else, just append the letter.\n            res += letter\n       \
    \ }\n    }\n    // Return the result string.\n    return res\n}\n", "    return\
    \ strings.ToUpper(myString[0:1]) + strings.ToLower(myString[1:])\n}\n", "    flipped\
    \ := \"\"\n\n    for _, letter := range myString {\n        if letter == 'a' {\n\
    \            flipped += \"A\"\n        } else {\n            flipped += string([]byte{letter\
    \ + 32})\n        }\n    }\n\n    return flipped\n}\n", "    return strings.ToUpper(myString)\
    \ + strings.ToLower(myString[len(myString)-1:])\n}\n", "    var result string\n\
    \    for _, letter := range myString {\n        if letter == 'a' {\n         \
    \   result = 'A'\n        } else if letter == 'b' {\n            result = 'B'\n\
    \        } else if letter == 'c' {\n            result = 'C'\n        } else if\
    \ letter == 'd' {\n            result = 'D'\n        } else if letter == 'e' {\n\
    \            result = 'E'\n        } else if letter == 'f' {\n            result\
    \ = 'F'\n        } else if letter == 'g' {\n            result = 'G'\n       \
    \ } else if letter == 'h' {\n            result = 'H'\n        } else if letter\
    \ == 'i' {\n            result = 'I'\n        } else if letter == 'j' {\n    \
    \        result = 'J'\n        } else if letter == 'k' {\n            result =\
    \ 'K'\n        } else if letter == 'l' {\n            result = 'L'\n        }\
    \ else if letter == 'm' {\n            result = 'M'\n        } else if letter\
    \ == 'n' {\n            result = 'N'\n        } else if letter == 'o' {\n    \
    \        result = 'O'\n        } else if letter == 'p' {\n            result =\
    \ 'P'\n        } else if letter == 'q' {\n            result = 'Q'\n        }\
    \ else if letter == 'r' {\n            result = 'R'\n        } else if letter\
    \ == 's' {\n            result = 'S'\n        } else if letter == 't' {\n    \
    \        result = 'T'\n        } else if letter == 'u' {\n            result =\
    \ 'U'\n        } else if letter == 'v' {\n            result = 'V'\n        }\
    \ else if letter == 'w' {\n            result = 'W'\n        } else if letter\
    \ == 'x' {\n            result = 'X'\n        } else if letter == 'y' {\n    \
    \        result = 'Y'\n        } else if letter == 'z' {\n            result =\
    \ 'Z'\n        } else {\n            result = letter\n        }\n    }\n    return\
    \ result\n}\n", "    result := \"\"\n    for _, letter := range myString {\n \
    \       if letter == strings.ToUpper(letter) {\n            result += strings.ToUpper(letter)\n\
    \        } else {\n            result += strings.ToLower(letter)\n        }\n\
    \    }\n    return result\n}\n", "    var flipped string = \"\"\n    for _, character\
    \ := range myString {\n        if character >= 'a' && character <= 'z' {\n   \
    \         flipped = flipped + string(character + 32 - 'a')\n        } else {\n\
    \            flipped = flipped + string(character)\n        }\n    }\n    return\
    \ flipped\n}\n", "    var result string\n\n    for _, letter := range myString\
    \ {\n        result += \"A\" // uppercase letter\n        if letter != \"a\" {\n\
    \            result += letter\n        }\n    }\n\n    return result\n}\n</code>\n\
    <|/ a tags=uppercase,lowercase,go |>\n<| a tags=uppercase,lowercase,go |>\nThis\
    \ would do it:\n<code>\npackage main\n\nimport (\n  \"fmt\"\n  \"strings\"\n)\n",
  "    result := \"\"\n    for _, char := range myString {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string(char-'a'+26)\n        } else\
    \ {\n            result += char\n        }\n    }\n    return result\n}\n", " \
    \   flipped := \"\"\n    for _, c := range myString {\n        if c == 'a' {\n\
    \            flipped += \"A\"\n        } else if c == 'A' {\n            flipped\
    \ += \"a\"\n        } else {\n            flipped += string(c)\n        }\n  \
    \  }\n    return flipped\n}\n", "    upper_string := []rune(myString)\n    lower_string\
    \ := []rune(strings.ToLower(string(myString)))\n    lower_string[0] = unicode.ToUpper(lower_string[0])\n\
    \    fmt.Println(string(upper_string), string(lower_string))\n    return string(upper_string)\n\
    }\n", "    result := \"\"\n    len := len(myString)\n    for i := 0; i < len;\
    \ i++ {\n        switch myString[i] {\n        case 'a':\n            result +=\
    \ strings.ToUpper(myString[i+1:])\n            i += len - 1\n        case 'A':\n\
    \            result += strings.ToLower(myString[i+1:])\n            i += len -\
    \ 1\n        default:\n            result += myString[i]\n        }\n    }\n \
    \   return result\n}\n", "    return strings.ToUpper(myString) + strings.ToLower(strings.ToUpper(myString))\n\
    }\n", "    var uppercase = []rune(\"A\")\n    var lowercase = []rune(\"a\")\n\n\
    \    for _, c := range myString {\n        if isUppercase(c) {\n            uppercase\
    \ = append(uppercase, c)\n        } else {\n            lowercase = append(lowercase,\
    \ c)\n        }\n    }\n    return string(uppercase) + string(lowercase)\n}\n",
  "    var result string\n    for _, char := range myString {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string((char-'a') + 26)\n      \
    \  } else if char >= 'A' && char <= 'Z' {\n            result += string((char-'A')\
    \ + 26)\n        } else {\n            result += char\n        }\n    }\n    return\
    \ result\n}\n", "    // Convert string to lower case\n    lowercase_string :=\
    \ strings.ToLower(myString)\n\n    // Iterate over every character and check whether\
    \ it is lowercase\n    // If so, convert it to uppercase\n    upcase_string :=\
    \ \"\"\n    for _, character := range lowercase_string {\n        if character\
    \ == strings.ToLower(character) {\n            upcase_string += strings.ToUpper(character)\n\
    \        }\n    }\n\n    return upcase_string\n}\n", "    result := \"\"\n   \
    \ for _, char := range myString {\n        if char >= 'A' && char <= 'Z' {\n \
    \           result += char + 'a'\n        } else if char >= 'a' && char <= 'z'\
    \ {\n            result += char + 'A'\n        } else {\n            result +=\
    \ char\n        }\n    }\n    return result\n}\n", "    return strings.ToUpper(strings.ToLower(myString))\n\
    }\n", "    return strings.ToUpper(fmt.Sprintf(\"%v\", myString))\n}\n", "    myString\
    \ = strings.ToLower(myString)\n    myString = strings.ToUpper(myString)\n    return\
    \ myString\n}\n", "    for i := 0; i < len(myString); i++ {\n        myString[i]\
    \ = myString[i] + 32\n    }\n    myString[0] |= 32\n    return myString\n}\n",
  "    var result string\n    for _, char := range myString {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string(char - 'a') + string(char\
    \ - 'A')\n        } else {\n            result += char\n        }\n    }\n   \
    \ return result\n}\n", "    fmt.Printf(\"myString: %s\\n\", myString)\n    var\
    \ result string = \"\"\n    var index = 0\n    for {\n        if index >= len(myString)\
    \ {\n            return result\n        }\n        if myString[index] == '_' {\n\
    \            index++\n        } else {\n            result += string(unicode.ToLower(rune(myString[index])))\n\
    \            index++\n        }\n    }\n}\n", "    return myString[:1] + strings.ToUpper(myString[1:])\
    \ + myString[:1]\n}\n", "    // Start with the string with the first character\
    \ capitalized.\n    myString += strings.ToUpper(myString[0:1])\n    // Get the\
    \ rest of the string and capitalize all but the first character.\n    temp :=\
    \ myString\n    for i := 1; i < len(temp); i++ {\n        temp = strings.ToUpper(temp)\
    \ + temp[i:]\n    }\n    // Return our capitalized string.\n    return temp\n\
    }\n", "    result := \"\"\n    for _, v := range myString {\n        switch {\n\
    \        case v >= 'a' && v <= 'z':\n            result += string(v - 32) // uppercase\
    \ letter\n        case v >= 'A' && v <= 'Z':\n            result += string(v +\
    \ 32) // lowercase letter\n        default:\n            result += v\n       \
    \ }\n    }\n    return result\n}\n", "    output := string(myString)\n    switch\
    \ {\n        output == \"\" || output == \"\\t\":\n            return \"\"\n \
    \       case output[0] == 'a':\n            output += 'A'\n            return\
    \ output\n        case output[0] == 'b':\n            output += 'B'\n        \
    \    return output\n        case output[0] == 'c':\n            output += 'C'\n\
    \            return output\n        case output[0] == 'd':\n            output\
    \ += 'D'\n            return output\n        case output[0] == 'e':\n        \
    \    output += 'E'\n            return output\n        case output[0] == 'f':\n\
    \            output += 'F'\n            return output\n        case output[0]\
    \ == 'g':\n            output += 'G'\n            return output\n        case\
    \ output[0] == 'h':\n            output += 'H'\n            return output\n  \
    \      case output[0] == 'i':\n            output += 'I'\n            return output\n\
    \        case output[0] == 'j':\n            output += 'J'\n            return\
    \ output\n        case output[0] == 'k':\n            output += 'K'\n        \
    \    return output\n        case output[0] == 'l':\n            output += 'L'\n\
    \            return output\n        case output[0] == 'm':\n            output\
    \ += 'M'\n            return output\n        case output[0] == 'n':\n        \
    \    output += 'N'\n            return output\n        case output[0] == 'o':\n\
    \            output += 'O'\n            return output\n        case output[0]\
    \ == 'p':\n            output += 'P'\n            return output\n        case\
    \ output[0] == 'q':\n            output += 'Q'\n            return output\n  \
    \      case output[0] == 'r':\n            output += 'R'\n            return output\n\
    \        case output[0] == 's':\n            output += 'S'\n            return\
    \ output\n        case output[0] == 't':\n            output += 'T'\n        \
    \    return output\n        case output[0] == 'u':\n            output += 'U'\n\
    \            return output\n        case output[0] == 'v':\n            output\
    \ += 'V'\n            return output\n        case output[0] == 'w':\n        \
    \    output += 'W'\n            return output\n        case output[0] == 'x':\n\
    \            output += 'X'\n            return output\n        case output[0]\
    \ == 'y':\n            output += 'Y'\n            return output\n        case\
    \ output[0] == 'z':\n            output += 'Z'\n            return output\n  \
    \      default:\n            return output\n    }\n}\n", "    upcaseChar := false\n\
    \    downcaseChar := false\n\n    for _, char := range myString {\n        if\
    \ char == ' ' {\n            continue\n        }\n\n        if char >= 'a' &&\
    \ char <= 'z' {\n            upcaseChar = true\n            if downcaseChar {\n\
    \                myString = myString[:len(myString)-1]\n            }\n      \
    \  } else {\n            downcaseChar = true\n            if upcaseChar {\n  \
    \              myString = myString[:len(myString)-1]\n            }\n        }\n\
    \    }\n    return myString\n}\n", "    buf := []byte(myString)\n\n    for i,\
    \ b := range buf {\n        if b >= 'A' && b <= 'Z' {\n            buf[i] = b\
    \ - 'A' + 'a'\n        }\n        if b >= 'a' && b <= 'z' {\n            buf[i]\
    \ = b - 'a' + 'A'\n        }\n    }\n\n    return string(buf)\n}\n", "    buffer\
    \ := []rune(myString)\n\n    for i, j := 0, len(buffer)-1; i < j; i, j = i+1,\
    \ j-1 {\n        buffer[i], buffer[j] = buffer[j], buffer[i]\n    }\n    return\
    \ string(buffer)\n}\n", "    var result strings.Builder\n\n    for _, char :=\
    \ range myString {\n        if char >= 'a' && char <= 'z' {\n            result\
    \ = result.String() + string((char - 'a') + 26)\n        } else if char >= 'A'\
    \ && char <= 'Z' {\n            result = result.String() + string((char - 'A')\
    \ + 26)\n        } else {\n            result = result.String() + char\n     \
    \   }\n    }\n    return result.String()\n}\n", "    flipped := \"\"\n\n    for\
    \ _, c := range myString {\n        switch {\n        case isAsciiUpper(c):\n\
    \            flipped += toAsciiUpper(c)\n        case isAsciiLower(c):\n     \
    \       flipped += toAsciiLower(c)\n        default:\n            flipped += c\n\
    \        }\n    }\n    return flipped\n}\n", "    result := make([]rune, len(myString))\n\
    \    for i, char := range myString {\n        switch char {\n        case 'A':\n\
    \            result[i] = 'a'\n        case 'a':\n            result[i] = 'A'\n\
    \        case 'B':\n            result[i] = 'b'\n        case 'b':\n         \
    \   result[i] = 'B'\n        case 'C':\n            result[i] = 'c'\n        case\
    \ 'c':\n            result[i] = 'C'\n        case 'D':\n            result[i]\
    \ = 'd'\n        case 'd':\n            result[i] = 'D'\n        case 'E':\n \
    \           result[i] = 'e'\n        case 'e':\n            result[i] = 'E'\n\
    \        case 'F':\n            result[i] = 'f'\n        case 'f':\n         \
    \   result[i] = 'F'\n        case 'G':\n            result[i] = 'g'\n        case\
    \ 'g':\n            result[i] = 'G'\n        case 'H':\n            result[i]\
    \ = 'h'\n        case 'h':\n            result[i] = 'H'\n        case 'I':\n \
    \           result[i] = 'i'\n        case 'i':\n            result[i] = 'I'\n\
    \        case 'J':\n            result[i] = 'j'\n        case 'j':\n         \
    \   result[i] = 'J'\n        case 'K':\n            result[i] = 'k'\n        case\
    \ 'k':\n            result[i] = 'K'\n        case 'L':\n            result[i]\
    \ = 'l'\n        case 'l':\n            result[i] = 'L'\n        case 'M':\n \
    \           result[i] = 'm'\n        case 'm':\n            result[i] = 'M'\n\
    \        case 'N':\n            result[i] = 'n'\n        case 'n':\n         \
    \   result[i] = 'N'\n        case 'O':\n            result[i] = 'o'\n        case\
    \ 'o':\n            result[i] = 'O'\n        case 'P':\n            result[i]\
    \ = 'p'\n        case 'p':\n            result[i] = 'P'\n        case 'Q':\n \
    \           result[i] = 'q'\n        case 'q':\n            result[i] = 'Q'\n\
    \        case 'R':\n            result[i] = 'r'\n        case 'r':\n         \
    \   result[i] = 'R'\n        case 'S':\n            result[i] = 's';\n       \
    \ case 's':\n            result[i] = 'S'\n        case 'T':\n            result[i]\
    \ = 't'\n        case 't':\n            result[i] = 'T'\n        case 'U':\n \
    \           result[i] = 'u'\n        case 'u':\n            result[i] = 'U'\n\
    \        case 'V':\n            result[i] = 'v'\n        case 'v':\n         \
    \   result[i] = 'V'\n        case 'W':\n            result[i] = 'w'\n        case\
    \ 'w':\n            result[i] = 'W'\n        case 'X':\n            result[i]\
    \ = 'x'\n        case 'x':\n            result[i] = 'X'\n        case 'Y':\n \
    \           result[i] = 'y'\n        case 'y':\n            result[i] = 'Y'\n\
    \        case 'Z':", "    char := []rune(myString)\n    for i, j := range char\
    \ {\n        if i != j {\n            char[i] = char[j].upper()\n            char[j]\
    \ = char[i].lower()\n        }\n    }\n\n    return string(char)\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
