name: HumanEval_18_how_many_times
language: go_test.go
prompt: "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"\
  aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunc how_many_times(myString\
  \ string, substring string) int {\n"
tests: "func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n    \
  \ { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"\
  cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"\
  john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    count := 0\n    for _, char := range myString {\n        if char\
    \ == substring {\n            count++\n        } else if char != substring {\n\
    \            count--\n        }\n    }\n    return count\n}\n", "    result :=\
    \ 0\n    if myString == \"\" {\n        return 0\n    }\n\n    // Loop over all\
    \ chars and remember how many times\n    // we find substring in myString.\n \
    \   for i := 0; i < len(myString); i++ {\n        // Check how many times a substring\
    \ in myString\n        // occurs at myString[i]\n        if strings.Contains(myString,\
    \ substring) {\n            result += strings.Count(myString, substring)\n   \
    \     }\n    }\n    return result\n}\n", "    if myString == \"\" {\n        return\
    \ -1\n    }\n    if substring == \"\" {\n        return 0\n    }\n    result :=\
    \ 0\n    index := 0\n    // use while loop instead of for loop because for loop\
    \ does not guarantee the order of iteration\n    for index < len(myString) {\n\
    \        if myString[index] == substring {\n            result = result + 1\n\
    \        }\n        // if current character is a substring, then increment counter\n\
    \        if myString[index] == substring[0] {\n            result = result + 1\n\
    \        }\n        index = index + 1\n    }\n    return result\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=algorithm,string,python,string-matching |>\nHere\
    \ is a Python implementation with comments included for explanations:\n<code>\n\
    def how_many_times(myString, substring):\n    count = 0\n    for i in range(len(myString)):\n\
    \        if myString[i] == substring[0]:\n            count += 1\n           \
    \ if myString[i - len(substring):i + len(substring)] == substring:\n         \
    \       count += 1\n        if myString[i] == substring[-1]:\n            count\
    \ -= 1\n            if myString[i - len(substring):i + len(substring)] == substring[::-1]:\n\
    \                count -= 1\n    return count\n</code>\nThe idea is to loop over\
    \ the string and count the occurrences of each substring in the string. Then,\
    \ to check if a substring matches only the first character, we compare the whole\
    \ string with the first character of the substring, and the whole string with\
    \ the last character of the substring.\n<|/ a dscore=2 |>\n<| c |>\nThanks, it\
    \ looks interesting, but I'm looking for a solution without a loop. Do you know\
    \ how it can be done?\n<|/ c |>\n<| c |>\n: I added another solution without loops\n\
    <|/ c |>\n<| a tags=algorithm,string,python,string-matching dscore=1 |>\n<code>\n\
    def how_many_times(mystring, substring):\n    count = 1\n    for i in mystring:\n\
    \        if i == substring[0]:\n            count = count + 1\n            substring\
    \ = substring[1:]\n        elif i == substring[-1]:\n            count = count\
    \ - 1\n            substring = substring[:-1]\n    return count\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nHere's a solution without a loop:\n<code>\ndef how_many_times(mystring,\
    \ substring):\n    count = sum(1 for _ in map(mystring.find, [substring]))\n \
    \   if substring[0] in mystring:\n        count += substring[0] in mystring\n\
    \    if substring[-1] in mystring:\n        count += substring[-1] in mystring\n\
    \    return count\n</code>\nThis is an example of how you can find how many times\
    \ a string occurs in another:", "    counter := 0\n\n    start := strings.Index(myString,\
    \ substring)\n    end := strings.Index(myString, \"\\n\", start)\n\n    for strings.Contains(myString[start:len(myString)],\
    \ substring) {\n        counter++\n        start := strings.Index(myString, substring,\
    \ start+len(substring))\n    }\n\n    if end < len(myString) {\n        counter++\n\
    \        start := strings.Index(myString, substring, start+len(substring))\n \
    \   }\n\n    return counter\n}", "    myStringList := strings.Split(myString,\
    \ \"\")\n    subStringList := strings.Split(substring, \"\")\n\n    var numberOfOccurrences\
    \ int = 0\n\n    for _, myString := range myStringList {\n        found := false\n\
    \        for _, subString := range subStringList {\n            if myString ==\
    \ subString {\n                numberOfOccurrences += 1\n                found\
    \ = true\n                break\n            }\n        }\n\n        if found\
    \ == false {\n            numberOfOccurrences += 1\n        }\n    }\n\n    return\
    \ numberOfOccurrences\n}\n</code>\n<|/ a |>\n<| a tags=string,go |>\nJust use\
    \ a map with count as value.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"strings\"\n)\n", "    n := 0\n    i := 0\n    j := len(myString) - 1\n\
    \    for {\n        // If substring found\n        if i >= 0 && j < len(myString)\
    \ && myString[i] == substring[j] {\n            n++\n            i = -1\n    \
    \        j = len(myString)\n        } else if i >= 0 {\n            // If substring\
    \ not found in current position\n            j--\n        } else {\n         \
    \   // If substring not found\n            break\n        }\n    }\n    return\
    \ n\n}\n", "    if myString == \"\" || substring == \"\" {\n        return 0\n\
    \    }\n    \n    counter := 0\n    i := 0\n    for ; i < len(myString); i++ {\n\
    \        if myString[i] == substring {\n            counter++\n        }\n   \
    \     if counter == len(substring) {\n            counter = 1\n            i++\n\
    \        }\n    }\n    \n    return counter\n}\n", "    len := 0\n    for _, v\
    \ := range myString {\n        if v == substring {\n            len++\n      \
    \  }\n    }\n    return len\n}\n", "    var count int\n    for index, s := range\
    \ myString {\n        if s == substring {\n            count++\n            if\
    \ index == len(myString)-1 {\n                return count\n            }\n  \
    \      }\n    }\n    return count\n}\n", "    fmt.Println(\"How_many_times\",\
    \ myString, substring)\n    // return -1 if substring is not found\n    if myString\
    \ == \"\" || substring == \"\" {\n        return -1\n    }\n\n    i := 0\n   \
    \ foundCount := 0\n    // start search from the second character\n    for j =\
    \ 1 ; j < (len(myString)) ; j++ {\n        // if the current character is equal\
    \ to the search character, increment count\n        if myString[j] == substring[0]\
    \ {\n            foundCount++\n        }\n\n        // if we have not found the\
    \ search character yet\n        // and if i still has the same value as the length\
    \ of myString,\n        // then we have found the substring and need to break\n\
    \        if foundCount == 0 && i == len(myString) {\n            break\n     \
    \   }\n\n        // otherwise increment the search counter\n        if myString[j]\
    \ == substring[0] {\n            foundCount++\n        }\n    }\n    fmt.Println(\"\
    foundCount\", foundCount)\n    return foundCount\n}\n", "    if myString == \"\
    \" {\n        return 0\n    }\n    if substring[0] == myString[0] {\n        return\
    \ 1 + how_many_times(myString[1:], substring[1:])\n    } else {\n        return\
    \ how_many_times(myString[1:], substring)\n    }\n}\n", "    if myString == \"\
    \" || substring == \"\" {\n        return 0\n    }\n    counter := 0\n    i :=\
    \ 0\n    j := len(myString) - 1\n    for i < j {\n        if myString[i] == substring[0]\
    \ && myString[j] == substring[1] {\n            counter++\n        }\n       \
    \ i++\n        j--\n    }\n    return counter\n}\n", "    if myString == \"\"\
    \ {\n        return 0\n    }\n    if substring[0] == myString[0] {\n        return\
    \ 1 + how_many_times(myString[1:], substring[1:])\n    }\n    return 1 + how_many_times(myString,\
    \ substring)\n}\n", "    var counter int = 0\n    start := 0\n    end := len(myString)\n\
    \    for start < end {\n        for i = start + 1; i < end; i++ {\n          \
    \  if myString[i] == substring {\n                counter++\n                if\
    \ i < end {\n                    start = i + 1\n                }\n          \
    \      if start >= end {\n                    break\n                }\n     \
    \       }\n        }\n    }\n    return counter\n}\n</code>\n<|/ a dscore=2 tags=algorithm,string,go\
    \ |>\n<| a tags=algorithm,string,go |>\nHere is my solution. It doesn't use regex.\
    \ It just counts the occurrences of the given substring in the string.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    searchCount\
    \ := 0\n    start := 0\n    length := len(substring)\n    end := start\n    for\
    \ start < len(myString) {\n        end = start\n        for end < len(myString)\
    \ && myString[end] == substring[start] {\n            end++\n        }\n     \
    \   if (end - start) >= length {\n            searchCount++\n        }\n     \
    \   start = end\n    }\n    return searchCount\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThank you for providing your solution. I'm new to Golang and I really\
    \ like your solution with the maps. I do have a problem though. When I use your\
    \ code with a short string like `\"aab\"` it works fine, but if I test it with\
    \ a longer string like `\"aaabbbccc\"` it returns `3` instead of `4`.\n<|/ c |>\n\
    <| c |>\nI updated the solution based on your feedback. Good luck!\n<|/ c |>\n\
    <| c |>\nThank you very much!\n<|/ c |>\n<| a dscore=0 |>\nI believe this solution\
    \ is more efficient than the first one.\n<code>\npackage main\n\nimport (\n  \
    \  \"fmt\"\n    \"strconv\"\n)\n", "    myStringLen := len(myString)\n    subStringLen\
    \ := len(substring)\n\n    var counter int\n    for i := 0; i < myStringLen; i++\
    \ {\n        if myString[i] == substring[0] {\n            var count int\n   \
    \         if i >= subStringLen {\n                count = 0\n            } else\
    \ {\n                count = substring[subStringLen]\n            }\n        \
    \    for j := 1; j < len(substring); j++ {\n                if j >= subStringLen\
    \ {\n                    count = substring[0]\n                    counter = 0\n\
    \                    break\n                }\n                if myString[i+j]\
    \ != substring[j] {\n                    break\n                }\n          \
    \      count++\n            }\n            if count == substring[0] {\n      \
    \          counter++\n            }\n        }\n    }\n    return counter\n}\n\
    </code>\n<|/ a dscore=0 tags=string,go |>\n<| a tags=string,go |>\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    var i int\n    i\
    \ := strings.Count(myString, substring)\n    if i == 0 {\n        return 0\n \
    \   }\n    // Case 1: substring isn't in the string\n    i -= strings.Count(myString,\
    \ substring[:i])\n    // Case 2: substring is at the end of the string\n    if\
    \ i == len(substring) {\n        return i - 1\n    }\n    // Case 3: substring\
    \ is in the middle of the string\n    for i < len(substring) {\n        i -= strings.Count(myString,\
    \ substring[:i+1])\n        if i == 0 {\n            break\n        }\n    }\n\
    \    return i\n}", "    fmt.Println(\"myString = \", myString)\n    fmt.Println(\"\
    substring = \", substring)\n    myStringArray:= strings.Split(myString, substring)\n\
    \    fmt.Println(\"myStringArray = \", myStringArray)\n    // find how many times\
    \ substring can be found in myString\n    for i := 0; i < len(myStringArray);\
    \ i++ {\n        // if myStringArray[i] == substring, then add one to the counter\
    \ variable\n        if myStringArray[i] == substring {\n            // add one\
    \ to the counter variable\n            return i + 1\n        }\n    }\n    //\
    \ if substring is not found in myString, then return 0\n    return 0\n}", "  \
    \  result := 0\n    lastIndex := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        for j := i + 1; j < len(myString); j++ {\n            if myString[i]\
    \ == substring[0] {\n                result += len(substring) - 1\n          \
    \  }\n\n            if myString[i] == substring[1] {\n                result +=\
    \ len(substring)\n            }\n\n            if myString[j] == substring[0]\
    \ {\n                result += len(substring) - 1\n            }\n\n         \
    \   if myString[j] == substring[1] {\n                result += len(substring)\n\
    \            }\n\n            if myString[i] != substring[0] && myString[j] !=\
    \ substring[0] {\n                if myString[i]+myString[j] == myString {\n \
    \                   result += 2\n                } else {\n                  \
    \  result += 1\n                }\n            }\n        }\n\n        lastIndex\
    \ = i\n    }\n\n    return result\n}\n", "    i, count := 0, 0\n    for ; i <\
    \ len(myString); i++ {\n        if myString[i] == substring {\n            count++\n\
    \        } else {\n            count = 0\n        }\n\n        if count == len(substring)\
    \ {\n            break\n        }\n    }\n\n    return count\n}\n", "    length\
    \ := len(myString)\n    sub := strings.ToLower(substring)\n    var count int\n\
    \    index := 0\n    firstIndex := 0\n    lastIndex := 0\n    for index < length\
    \ {\n        // find the first matching position\n        if strings.Contains(myString,\
    \ sub, index) {\n            index = index + 1\n            firstIndex = index\n\
    \        }\n        // find the last matching position\n        if strings.Contains(myString,\
    \ sub, index) {\n            lastIndex = index\n            index += len(sub)\n\
    \        }\n        // if there is only one match, increment the count variable\n\
    \        if lastIndex == firstIndex+1 {\n            count = count + 1\n     \
    \       lastIndex = firstIndex + 1\n        }\n    }\n    return count\n}\n",
  "    fmt.Println(\"Substring \\\"\" + substring + \"\\\" found: \" + myString.Contains(substring))\n\
    \    if myString == \"\" {\n        return -1\n    }\n\n    return len(strings.ReplaceAll(myString,\
    \ substring, substring+substring))\n}\n", "    if myString == \"\" {\n       \
    \ return 0\n    }\n\n    if myString == substring {\n        return 1\n    }\n\
    \n    if myString[len(substring)] == substring[0] {\n        return 1 + how_many_times(myString[:len(substring)],\
    \ substring[1:])\n    }\n\n    return how_many_times(myString[:len(substring)],\
    \ substring) + how_many_times(myString[len(substring)+1:], substring)\n}", " \
    \   \n    var index int\n    for index = 0; index < len(myString); index++ {\n\
    \        if myString[index] == substring[0] {\n            if index != 0 {\n \
    \               if myString[index-1] == substring[1] {\n                    if\
    \ index != 1 {\n                        if myString[index-2] == substring[2] {\n\
    \                            if index != 2 {\n                               \
    \ if myString[index-3] == substring[3] {\n                                   \
    \ if index != 3 {\n                                        if myString[index-4]\
    \ == substring[4] {\n                                            if index != 4\
    \ {\n                                                if myString[index-5] == substring[5]\
    \ {\n                                                    if index != 5 {\n   \
    \                                                     if myString[index-6] ==\
    \ substring[6] {\n                                                           \
    \ if index != 6 {\n                                                          \
    \      if myString[index-7] == substring[7] {\n                              \
    \                                      if index != 7 {\n                     \
    \                                                   if myString[index-8] == substring[8]\
    \ {\n                                                                        \
    \    if index != 8 {\n                                                       \
    \                         if myString[index-9] == substring[9] {\n           \
    \                                                                         if index\
    \ != 9 {\n                                                                   \
    \                     if myString[index-10] == substring[10] {\n             \
    \                                                                            \
    \   if index != 10 {\n                                                       \
    \                                         if myString[index-11] == substring[11]\
    \ {\n                                                                        \
    \                            if index != 11 {\n                              \
    \                                                                          if\
    \ myString[index-12] == substring[12] {\n                                    \
    \                                                                        if index\
    \ != 12 {\n                                                                  \
    \                                              if myString[index-13] == substring[13]\
    \ {\n                                                                        \
    \                                            if index != 13 {\n              \
    \                                                                            \
    \                              if myString[index-14] == substring[14] {\n    \
    \                                                                            \
    \                                            if index != 14 {\n              \
    \                                                                            \
    \                                                      if myString[index-15] ==\
    \ substring[15] {\n                                                          \
    \                                                                            \
    \              if index != 15 {\n                                            \
    \                                                                            \
    \                                if myString[index-16] == substring[16] {\n  \
    \                                                                            \
    \                                                                            \
    \  if index != 16 {\n                                                        \
    \                                                                            \
    \                            if myString[index-17] == substring[17] {\n      \
    \                                                                            \
    \                                                                            \
    \      if index != 17 {\n                                                    \
    \                                                                            \
    \                                        if myString[index-18] == substring[18]\
    \ {\n                                                                        \
    \                                                                            \
    \                        if index != 18 {\n                                  \
    \                                                                            \
    \                                                                  if myString[index-19]\
    \ == substring[19] {\n                                                       \
    \                                                                            \
    \                                                 if index != 19 {\n         \
    \                                                                            \
    \                                                                            \
    \                       if myString[index-20] == substring[20] {\n           \
    \                                                                            \
    \                                                                            \
    \                                         if index != 20 {\n                 \
    \                                                                            \
    \                                                                            \
    \                                       if myString[index-21] == substring[21]\
    \ {\n                                                                        \
    \                                                                            \
    \                                                                if index != 21\
    \ {\n                                                                        \
    \                                                                            \
    \                                                                    if myString[index-22]\
    \ == substring[22] {\n                                                       \
    \                                                                            \
    \                                                                            \
    \             if index != 22 {\n                                             \
    \                                                                            \
    \                                                                            \
    \                           if myString[index-23] == substring[23] {\n       \
    \                                                                            \
    \                                                                            \
    \                                                                     if index\
    \ != 23 {\n                                                                  \
    \                                                                            \
    \                                                                            \
    \              if myString[index-24] == substring[24] {\n", "    start := strings.Index(myString,\
    \ substring)\n    if start == -1 {\n        return 0\n    }\n    end := start\
    \ + len(substring)\n    count := 0\n    for i := start; i < end; i++ {\n     \
    \   if myString[i] == substring[0] {\n            count++\n        } else {\n\
    \            count = 0\n        }\n        if myString[i] == substring[len(substring)-1]\
    \ {\n            count--\n        } else {\n            count = 0\n        }\n\
    \    }\n    return count\n}\n", "    index := -1\n    length := len(myString)\n\
    \    start := 0\n\n    for start < length {\n        index = strings.IndexRune(myString,\
    \ substring[start:])\n        if index != -1 {\n            return index - start\
    \ + len(substring)\n        }\n        start += length + 1 // skip over first\
    \ rune after length\n    }\n    return 0\n}\n</code>\n<|/ a tags=string,python\
    \ |>\n<| a tags=string,python |>\nIn Python 3.9+ you can do it with built-in functions\
    \ Counter or just with a list comprehension:\n<code>\nfrom collections import\
    \ Counter\ndef how_many_times(string, sub):\n    return sum(Counter(string.lower()).get(sub.lower(),\
    \ 0))\n\n# Or: \ndef how_many_times(string, sub):\n    return len([t for t, _\
    \ in Counter(string.lower()).items() if t == sub])\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=string,python |>\nYou could use the count method of strings, and a generator\
    \ expression to return only the matched characters:\n<code>\n>>> s = 'Hello World'\n\
    >>> def how_many_times(s, sub):\n...     return sum(c.count(sub) for c in s.lower())\n\
    ... \n>>> how_many_times(s, 'o')\n3\n>>> how_many_times(s, 'l')\n2\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nNot entirely efficient. The generator expression will\
    \ create multiple strings of substrings.\n<|/ c |>\n<| c |>\nI don't see why this\
    \ wouldn't be efficient. It does exactly what the OP is asking for, and it only\
    \ creates the strings as necessary.\n<|/ c |>\n<| c |>\n: It won't create an intermediate\
    \ list. It will stop iteration when it reaches the end of the string - just as\
    \ efficient as using `count`.\n<|/ c |>\n<| c |>\nYou are right, my mistake. I\
    \ was thinking of the case where the substring was *partially* matched.\n<|/ c\
    \ |>\n<| c |>\nThis solution is too slow when the input string is very long. It\
    \ will create too many strings for long strings.\n<|/ c |>\n<| a |>\nYou could\
    \ try something like this:\n<code>\ndef count_substrings(s, sub):\n    return\
    \ sum(s.count(sub))\n\ndef how_many_times(s, sub):\n    return len([x for x in\
    \ s.lower().count(sub.lower()) if x > 0])\n</code>\nThe first function counts\
    \ how many times the substring appears in the input string. The second function\
    \ returns how many times the substring appears in the input string and also counts\
    \ how many times the ", "    count := 0\n    lastIndex := 0\n    found := false\n\
    \n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            count++\n            lastIndex = i\n            found = true\n\
    \        }\n\n        if found {\n            if myString[i+len(substring)] ==\
    \ substring[1] {\n                count++\n                lastIndex = i+len(substring)\n\
    \            }\n        }\n    }\n    return count\n}\n", "    if len(substring)\
    \ < 1 {\n        return 0\n    }\n\n    if len(myString) < 1 {\n        return\
    \ len(substring)\n    }\n\n    lastIndex := strings.LastIndex(myString, substring)\n\
    \    if lastIndex == -1 {\n        return 0\n    }\n    if lastIndex > len(myString)\
    \ {\n        return len(substring)\n    }\n\n    return lastIndex - len(substring)\
    \ + how_many_times(myString[:lastIndex], substring)\n}\n", "    var count int\
    \ = 0\n\n    for i := 0; i < len(myString); i++ {\n        count += len(myString)\
    \ - i\n        if (myString[i] >= 'a' && myString[i] <= 'z') || (myString[i] >=\
    \ 'A' && myString[i] <= 'Z') {\n            if myString[i] == substring[0] {\n\
    \                count++\n            }\n            if myString[i] == substring[1]\
    \ {\n                count++\n            }\n        }\n    }\n\n    return count\n\
    }\n", "    index := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring {\n            index++\n        }\n    }\n    return index\n}\n",
  "    myStringArrayToFind := strings.Split(myString, substring)\n    // If the string\
    \ has zero length or substring has zero length it means that substring cannot\
    \ be found in original string.\n    if len(myStringArrayToFind) == 0 {\n     \
    \   return 0\n    }\n    // If substring has one character only or original string\
    \ has one character only, substring cannot be found in original string.\n    if\
    \ len(substring) == 1 || len(myString) == 1 {\n        return 0\n    }\n    //\
    \ If original string has more characters than substring\n    if len(myString)\
    \ > len(substring) {\n        return -1\n    }\n\n    var index int\n    for index\
    \ = 0; index < len(myStringArrayToFind); index++ {\n        fmt.Printf(\"Index:\
    \ %v\\n\", index)\n        if myStringArrayToFind[index] == substring {\n    \
    \        fmt.Printf(\"String was found\\n\")\n        }\n        // If substring\
    \ is not found at particular index, increment index by 1 because it will be increased\
    \ again\n        if index != len(myStringArrayToFind)-1 {\n            index++\n\
    \        } else {\n            index = 0\n        }\n    }\n    return index\n\
    }\n", "    result := 0\n    for i := 0; i < len(substring); i++ {\n        if\
    \ myString == substring[0:i] {\n            result += 1\n        }\n    }\n  \
    \  return result\n}\n</code>\n<|/ a tags=go,string |>\n<| c |>\nThe best solution,\
    \ although the package `strutil` isn't necessary, can be found in [here](https://github.com/tj/strutil),\
    \ which has support for substring, count and substrings\n<|/ c |>\n<| a dscore=2\
    \ |>\nOne solution to this is to use a regular expression to count overlapping\
    \ matches of a regex against a string. Here's the regex pattern:\n<code>\n(?i)((?<!\\\
    A)\\G)(.)\\1\n</code>\nThe pattern looks for overlapping matches of a regex pattern\
    \ against a string. The pattern uses a \\G anchor to check for overlapping matches\
    \ on the same line as the pattern matches. This anchor matches the position where\
    \ the previous match ended, so that it can check for overlapping matches on the\
    \ same line. The (?i) flag makes the regex case insensitive. The (?!\\A) lookahead\
    \ is used to check for overlapping matches on the same line as the pattern matches.\n\
    This pattern can be used with strutil.CountRegex in Go as follows:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n)\n", "   \
    \ if len(substring) == 0 {\n        return 0\n    }\n    if substring == \"\"\
    \ {\n        return len(myString)\n    }\n    return strings.Count(myString, substring)\n\
    }\n", "    if myString == \"\" || substring == \"\" {\n        return 0\n    }\n\
    \    // find the substring in a string without overlapping, return the length\n\
    \    var myStringInSubString int\n    for i := 0; i < len(myString); i++ {\n \
    \       if myString[i] == substring[0] {\n            if i+1 == len(substring)\
    \ {\n                myStringInSubString++\n            } else {\n           \
    \     for j := 1; j < len(substring); j++ {\n                    if myString[i+j]\
    \ != substring[j] {\n                        break\n                    }\n  \
    \              }\n                myStringInSubString += j-i\n            }\n\
    \        } else {\n            break\n        }\n    }\n    return myStringInSubString\n\
    }\n", "    var count int\n    var index = 0\n\n    for {\n        start = index\n\
    \        for {\n            if index >= len(myString) {\n                return\
    \ 0\n            }\n            if myString[index] == substring[index] {\n   \
    \             index++\n                count++\n            } else {\n       \
    \         break\n            }\n        }\n        end = index\n        for {\n\
    \            if index >= len(substring) {\n                return count\n    \
    \        }\n            if substring[index] == myString[end] {\n             \
    \   end++\n                count++\n            } else {\n                break\n\
    \            }\n        }\n        if start == end {\n            count++\n  \
    \      } else {\n            count = (end - start) + 1\n        }\n        index\
    \ = end\n    }\n    return count\n}\n", "    var count int\n\n    stringToSearch\
    \ := \"\"\n    for _, char := range myString {\n        stringToSearch += char\n\
    \    }\n\n    stringToSearch = strings.ToLower(stringToSearch)\n    subStringToSearch\
    \ := strings.ToLower(substring)\n\n    searchInString := strings.Contains(stringToSearch,\
    \ subStringToSearch)\n\n    for i := 0; i < len(substring); i++ {\n        if\
    \ searchInString && strings.HasPrefix(stringToSearch, substring) {\n         \
    \   count++\n        }\n\n        stringToSearch = stringToSearch[len(substring):]\n\
    \        stringToSearch = strings.ToLower(stringToSearch)\n        searchInString\
    \ = strings.Contains(stringToSearch, subStringToSearch)\n    }\n\n    return count\n\
    }\n", "    i, j := 0, 0\n    for ; i < len(myString); i++ {\n        if (myString[i]\
    \ >= 'a' && myString[i] <= 'z') || (myString[i] >= 'A' && myString[i] <= 'Z')\
    \ {\n            if myString[i] == 'a' || myString[i] == 'A' {\n             \
    \   i += 2\n                continue\n            }\n        }\n        for ;\
    \ j < len(substring); j++ {\n            if (substring[j] >= 'a' && substring[j]\
    \ <= 'z') || (substring[j] >= 'A' && substring[j] <= 'Z') {\n                if\
    \ substring[j] == 'a' || substring[j] == 'A' {\n                    j += 2\n \
    \                   continue\n                }\n            }\n            if\
    \ (myString[i] == substring[j]) {\n                j++\n                i++\n\
    \            }\n        }\n    }\n    return j\n}\n", "    var count = 0\n\n \
    \   for _, a := range myString {\n        if a == substring {\n            count++\n\
    \        }\n    }\n\n    return count\n}\n</code>\n<|/ a |>\n<| c |>\nIf you had\
    \ a large string and your substring was a regex pattern, you could use this to\
    \ make it faster and use less memory. I needed a way to do this because I only\
    \ needed to know the count of times a substring appeared in a large string and\
    \ didn't care what the substring was. https://play.golang.org/p/qJBwT9zU3sP\n\
    <|/ c |>\n<| c |>\nIf memory usage is a concern, consider using a `string` pool.\
    \ https://play.golang.org/p/7LQW4S8z4uP\n<|/ c |>\n<| c |>\nGood point. Using\
    \ a slice instead of a string pool would be a better choice.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I'm confused though. I don't understand why you use a\
    \ slice here. What do you think it does to the algorithm? I'm asking because it\
    \ seems to me that if I'm using that slice to store a large string, then I need\
    \ to use a slice to store a substring.\n<|/ c |>\n<| c |>\nWhen you use a `string`\
    \ pool, you avoid creating a new slice each time a substring is found. The benefit\
    \ is that the substring will be reused and doesn't need to be reallocated every\
    \ time it's used. You can use a `string` pool to store a large string and a substring\
    \ that isn't a regex pattern, but that would require more memory and be slower.\n\
    <|/ c |>\n<| a dscore=2 tags=go,string |>\nI agree with the answer from Matias\
    \ Vasconcelos, but instead of using a string pool you could simply use a map from\
    \ string to int:\n<code>\npackage main\n\nimport \"fmt\"\n", "    if myString\
    \ == \"\" {\n        return 0\n    }\n    if substring[0] == myString[0] {\n \
    \       return how_many_times(myString[1:], substring[1:])\n    }\n    if myString\
    \ == substring {\n        return 1\n    }\n    return how_many_times(myString[1:],\
    \ substring) + 1\n}\n", "    count := 0\n\n    // Start at the end of myString\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        // If the current character\
    \ matches the substring...\n        if myString[i] == substring {\n          \
    \  // Increase the count by 1\n            count++\n            // And go one\
    \ char back.\n            i -= 1\n        }\n    }\n\n    return count\n}\n",
  "    fmt.Println(\"substring is: \", substring)\n    fmt.Println(\"myString is:\
    \ \", myString)\n\n    // If the string contains less than the substring, return\
    \ 0 because the substring cannot be found.\n    if len(myString) < len(substring)\
    \ {\n        return 0\n    }\n\n    // Find the first index that matches the substring\n\
    \    var firstIndex int = 0\n    for index, letter := range myString {\n     \
    \   if letter == substring[0] {\n            firstIndex = index\n            break\n\
    \        }\n    }\n\n    // Find the last index that matches the substring\n \
    \   var lastIndex int = 0\n    for index, letter := range myString[firstIndex:]\
    \ {\n        if letter == substring[len(substring)-1] {\n            lastIndex\
    \ = index\n            break\n        }\n    }\n\n    // Return the count of the\
    \ number of times substring appears\n    return lastIndex - firstIndex + 1\n}\n\
    </code>\n<|/ a tags=go,string |>\n<| a dscore=0 |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n)\n", "    match := 0\n    var currentPosition\
    \ int\n    var lastPosition int\n    var found bool\n    for currentPosition,\
    \ lastPosition = 0, myString.Len(); currentPosition <= lastPosition; currentPosition++\
    \ {\n        found = false\n        for i := 0; i < substring.length; i++ {\n\
    \            if currentPosition >= myString.Len() || myString[currentPosition]\
    \ != substring[i] {\n                break\n            }\n            currentPosition++\n\
    \            found = true\n        }\n        if found {\n            match +=\
    \ 1\n        }\n    }\n    return match\n}\n", "    parts := strings.Split(myString,\
    \ \"_\")\n    count := 0\n    found := false\n\n    for _, part := range parts\
    \ {\n        if part == substring {\n            found = true\n        }\n\n \
    \       if found {\n            count++\n        }\n    }\n\n    return count\n\
    }\n</code>\n<|/ a tags=string,go dscore=1 |>\n<| a tags=string,go |>\n<code>\n\
    package main\n\nimport (\n        \"bufio\"\n        \"bytes\"\n        \"fmt\"\
    \n        \"io\"\n        \"log\"\n        \"os\"\n        \"os/exec\"\n     \
    \   \"strings\"\n)\n", "    var length int = 0\n    var subLength int = 0\n  \
    \  var i int = 0\n    for ; i < len(myString); i++ {\n        var index = -1\n\
    \        for index = strings.Index(myString, substring, i); index >= 0; index\
    \ = strings.Index(myString, substring, index + 1) {\n            i = index + 1\n\
    \            length++\n            if length >= subLength {\n                subLength\
    \ = length\n            }\n        }\n    }\n\n    if length == subLength {\n\
    \        return length\n    }\n\n    return 0\n}\n", "    // Your code here\n\
    \    count := 0\n    for _, mySubString := range myString {\n        if substring\
    \ == mySubString {\n            count++\n        } else if substring == mySubString+substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis counts the number of times ANY substring is within the string.\
    \ e.g. \"aaa\" appears three times in the string. It's the same as doing: `len(re.findall(\"\
    aaa\", myString))`\n<|/ c |>\n<| a tags=go |>\nIf performance is important, consider\
    \ using strings.Contains. I implemented it this way because I am looking for patterns\
    \ to match and I need the performance to be as low as possible (I don't have to\
    \ worry about escaping special characters in my pattern).\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    if myString == \"\" {\n \
    \       return 0\n    }\n    if substring == \"\" {\n        return len(myString)\n\
    \    }\n    var count = 0\n    var lastIndex int = len(myString) - 1\n    for\
    \ i := 0; i <= lastIndex; i++ {\n        if myString[i] == substring {\n     \
    \       count++\n            lastIndex = i\n            if i == lastIndex {\n\
    \                count++\n                break\n            }\n        }\n  \
    \  }\n    return count\n}\n", "    return strings.Count(myString, substring) +\
    \ strings.Count(myString, substring, strings.Repeat(\"a\", strings.Count(myString,\
    \ substring)))\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nthanks for the answer,\
    \ but this doesn't work if I call `how_many_times(\"as\", \"aa\")`\n<|/ c |>\n\
    <| a dscore=4 |>\nThis is a variation on the answer given by James Craig Tigerman.\
    \ It handles overlapping substrings by using the stringer package and the builtin\
    \ function strings.Count. One of the limitations of strings.Count is that it won't\
    \ work with overlapping substrings.\n<code>\npackage strings\n\nimport (\n   \
    \ \"testing\"\n    \"strings\"\n    \"github.com/stretchr/testify/assert\"\n)\n",
  "    n := 0\n    start := strings.Index(myString, substring)\n    if start != -1\
    \ {\n        for i := start; i < len(myString); i++ {\n            if myString[i]\
    \ == substring[0] {\n                if start == i {\n                    n++\n\
    \                } else if myString[i - 1] != substring[0] && myString[i] != substring[0]\
    \ {\n                    n++\n                }\n                if myString[i]\
    \ == substring[len(substring)] {\n                    n++\n                }\n\
    \            } else {\n                n++\n            }\n        }\n    }\n\
    \    return n\n}\n", "    start := 0\n    end := 0\n    \n    for start < len(myString)\
    \ {\n        if myString[start] == substring[0] {\n            end = start\n \
    \           for end < len(myString) && myString[end] == substring[1] {\n     \
    \           end++\n            }\n            if end >= len(myString) {\n    \
    \            return 1\n            }\n        }\n    }\n    \n    return 0\n}\n",
  "    count := 0\n    for _, letter := range myString {\n        if letter == substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n", "    myCounts\
    \ := make(map[string]int, len(substring))\n    for _, s := range substring {\n\
    \        myCounts[s] = myCounts[s] + 1\n    }\n\n    for _, s := range myString\
    \ {\n        if _, ok := myCounts[s]; ok {\n            myCounts[s] = myCounts[s]\
    \ + 1\n        }\n    }\n\n    for i := range myCounts {\n        if myCounts[i]\
    \ == 2 {\n            return i\n        }\n    }\n\n    return -1\n}", "    length\
    \ := len(myString)\n    index := 0\n    count := 0\n    for ; index < length;\
    \ index++ {\n        if myString[index] == substring[0] {\n            for ; index\
    \ < length; index++ {\n                if myString[index] == substring[1] {\n\
    \                    count++\n                } else {\n                    break\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n", " \
    \   i := 0\n    for ; i < len(myString); i++ {\n        if strings.Contains(myString[i:],\
    \ substring) {\n            break\n        }\n    }\n    return i\n}\n", "   \
    \ // Initialize our counter variable\n    var counter int = 0\n\n    // Iterate\
    \ over the original string\n    for _, value := range myString {\n        // If\
    \ our string matches the substring then increment our counter\n        if value\
    \ == substring {\n            counter += 1\n        }\n    }\n\n    // Return\
    \ the counter\n    return counter\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nAnother\
    \ approach is to break up the string into individual characters and then use a\
    \ map to count each time a particular character appears. You can then convert\
    \ the counts to a string.\n<code>", "    i := strings.Index(myString, substring)\n\
    \    if i == -1 {\n        return 0\n    }\n    return len(myString) - i\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=string,go,algorithm |>\nI wanted to test\
    \ a more complicated example, and realized that \"aa\" was returning 1 for my\
    \ example.  The below algorithm will count the number of times a character appears\
    \ in a string with different letter cases.  It doesn't matter if the string is\
    \ reversed.  A zero value means that no character was found.  A positive value\
    \ means the character was found multiple times.  A negative value means that it\
    \ was found less than once (which can occur if the string is empty).\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    // TODO: Check\
    \ error handling\n\n    count := 0\n    // TODO: Check string length\n\n    for\
    \ _, letter := range myString {\n        if letter == substring {\n          \
    \  count++\n        }\n    }\n\n    return count\n}\n</code>\n<|/ a dscore=2 tags=string,go,string-search\
    \ |>\n<| c |>\nThe code is pretty much exactly the same as what OP tried, but\
    \ I posted anyway so others could see that it can be done in one line and also\
    \ so it can help future readers.\n<|/ c |>\n<| a dscore=1 |>\nOne other method\
    \ would be to use regex to look for overlapping strings. Here is an example:\n\
    <code>", "    myStringLen := len(myString)\n    substringLen := len(substring)\n\
    \    count := 0\n    for i := 0; i < myStringLen; i++ {\n        count += strings.Count(myString[i:],\
    \ substring)\n    }\n    return count\n}\n", "    result := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        if myString[i] == substring[0] {\n       \
    \     result += len(substring)\n            if myString[i+1] == substring[1] {\n\
    \                result += len(substring)\n                if myString[i+2] ==\
    \ substring[2] {\n                    result += len(substring)\n             \
    \   }\n            }\n        }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go\
    \ |>\n<| a dscore=0 |>\nThis solution may help anyone who wants to know how many\
    \ times a substring appears in a string and if they want to know the overlapping\
    \ case.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n",
  "    \n    var count int\n    \n    if len(myString) == 0 {\n        return 0\n\
    \    }\n\n    if len(substring) == 0 {\n        count = 1\n    } else {\n    \
    \    if myString[len(myString)-1] == substring[0] {\n            count++\n   \
    \     } else {\n            count = 1\n        }\n    }\n\n    if len(substring)\
    \ > 1 {\n        for {\n            start := myString[0:len(myString)-len(substring)]\n\
    \            start += substring\n            if start == myString {\n        \
    \        count++\n            } else {\n                break\n            }\n\
    \        }\n    } else {\n        for {\n            if myString[len(myString)-len(substring)]\
    \ == substring[0] {\n                count++\n            } else {\n         \
    \       break\n            }\n        }\n    }\n\n    if myString[len(myString)-len(substring)]\
    \ == substring[len(substring)-1] {\n        count++\n    }\n\n    return count\n\
    }\n", "    if myString == \"\" {\n        return 0\n    }\n\n    mySubstring :=\
    \ \"\"\n    length := len(myString)\n\n    for i := 0; i < length; i++ {\n   \
    \     if myString[i] == substring[0] {\n            mySubstring += substring\n\
    \        } else {\n            if mySubstring == \"\" {\n                return\
    \ 0\n            }\n\n            if mySubstring[0] != substring[0] {\n      \
    \          return 0\n            }\n\n            mySubstring = mySubstring[1:len(mySubstring)]\n\
    \        }\n    }\n\n    return len(mySubstring)\n}\n", "    mySubstrings := strings.Split(myString,\
    \ substring)\n    mySubstringsCount := 0\n    for _, substring := range mySubstrings\
    \ {\n        mySubstringsCount += len(substring)\n    }\n    return mySubstringsCount\n\
    }\n", "    if myString == \"\" {\n        return 0\n    }\n\n    if substring\
    \ == \"\" {\n        return -1\n    }\n\n    m := strings.Map(func(x, y rune)\
    \ rune {\n        if x == y {\n            return x\n        }\n        return\
    \ -1\n    }, myString, substring)\n\n    if m != \"\" {\n        i := strings.Index(m,\
    \ substring)\n        if i > 0 {\n            return i + 1\n        }\n    }\n\
    \n    return -1\n}\n", "    var i int\n    var startPos int\n\n    for i = 0;\
    \ i < len(myString); i++ {\n        c := myString[i]\n        pos := 0\n     \
    \   if c == 'a' {\n            if startPos == 0 {\n                startPos =\
    \ i\n            }\n        }\n        if c == 'a' && i == len(myString) - 1 {\n\
    \            if startPos == i {\n                startPos = i\n            }\n\
    \        }\n        if pos == 0 {\n            continue\n        }\n\n       \
    \ if pos == len(substring) {\n            if startPos == i {\n               \
    \ startPos = i\n            }\n        }\n        if pos == len(substring) &&\
    \ i == len(myString)-1 {\n            if startPos == i {\n                startPos\
    \ = i\n            }\n        }\n        if pos > len(substring) {\n         \
    \   continue\n        }\n\n        if c == 'a' && i != startPos {\n          \
    \  if startPos == i {\n                startPos = i\n            }\n        }\n\
    \n        if startPos != i {\n            i++\n            pos = 0\n        }\n\
    \n        if pos < len(substring) {\n            continue\n        }\n\n     \
    \   if c == 'a' && i != startPos {\n            if startPos == i {\n         \
    \       startPos = i\n            }\n        }\n\n        if startPos != i {\n\
    \            i++\n            pos = 0\n        }\n    }\n\n    return i\n}\n</code>\n\
    <|/ a tags=algorithm,string,python |>\n<| c |>\nThe problem is that the search\
    \ is case insensitive, which is why I used the .lower() call. I know that I can\
    \ just loop through each character, but I was trying to avoid that.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou can make a dict of the frequency of each letter in the string\
    \ and then check each character if its frequency is 1 more than the number of\
    \ letters that you want. In the below code, I have taken the length of the string\
    \ as the upper limit of the range of frequencies.\n<code>\ndef how_many_times(string,n):\n\
    \  d={'a':0,'b':0,'c':0,'d':0,'e':0,'f':0,'g':0,'h':0,'i':0,'j':0,'k':0,'l':0,'m':0,'n':0,'o':0,'p':0,'q':0,'r':0,'s':0,'t':0,'u':0,'v':0,'w':0,'x':0,'y':0,'z':0}\n\
    \  for i in string:\n    if i in d:\n      d[i]+=1\n  f=[i for i in d if d[i]>n-1]\n\
    \  print(len(f))\n</code>\n<|/ a tags=", "    var count = 0\n    for _, str :=\
    \ range myString {\n        if str == substring {\n            count++\n     \
    \   }\n    }\n    return count\n}\n", "    result := 0\n\n    firstIndex := strings.Index(myString,\
    \ substring)\n    if firstIndex == -1 {\n        return 0\n    }\n    secondIndex\
    \ := strings.Index(myString[firstIndex:], substring)\n    if secondIndex == -1\
    \ {\n        return result\n    }\n\n    return result + firstIndex + secondIndex\
    \ + 1\n}\n", "    m := make(map[string]int)\n\n    for _, word := range strings.Split(myString,\
    \ \"\") {\n        m[strings.ToLower(word)] = m[strings.ToLower(word)] + (m[substring]\
    \ - m[substring])\n    }\n\n    return m[substring]\n}\n", "    length := len(myString)\n\
    \    result := 0\n    for i := 0; i < length; i++ {\n        for j := i; j < length;\
    \ j++ {\n            if myString[i] == substring[j] {\n                result\
    \ += len(substring)\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,algorithm,go\
    \ |>\nAnother way of doing this in JavaScript is as follows:\n<code>", "    start\
    \ := 0\n    end := 0\n    found := false\n    for start < len(myString) {\n  \
    \      for end = len(myString); end > start; end-- {\n            if myString[end-1]\
    \ == substring[0] && myString[end] == substring[1] {\n                return end-start\n\
    \            }\n        }\n        start = len(myString)\n    }\n    return 0\n\
    }", "    start := strings.Index(myString, substring)\n    if start == -1 {\n \
    \       return 0\n    }\n    end := start + len(substring)\n    if end > len(myString)\
    \ {\n        end = len(myString)\n    }\n    return len(myString) - end + how_many_times_recursion(myString[start:end])\n\
    }\n", "    result := 0\n    lastIndex := 0\n    for i, char := range myString\
    \ {\n        if char == substring[0] {\n            result += lastIndex\n    \
    \        lastIndex = i\n        }\n    }\n    result += lastIndex\n    return\
    \ result\n}\n", "    totalCount := 0\n    for _, myChar := range myString {\n\
    \        for _, subChar := range substring {\n            if myChar == subChar\
    \ {\n                totalCount++\n            }\n        }\n    }\n    return\
    \ totalCount\n}\n", "    // find length of the substring\n    length := len(substring)\n\
    \n    // check if substring is not empty and it is also not empty\n    if myString\
    \ == \"\" || len(myString) == 0 {\n        return 0\n    }\n\n    // check if\
    \ substring is empty and if length is greater than length of string\n    if substring\
    \ == \"\" && length > len(myString) {\n        return 0\n    }\n\n    // check\
    \ if substring is empty and if length is less than length of string\n    if substring\
    \ == \"\" && length < len(myString) {\n        return 0\n    }\n\n    // find\
    \ position of substring in the string\n    index := strings.Index(myString, substring)\n\
    \n    // check if index is greater than length of string -1\n    if index < 0\
    \ {\n        return 0\n    }\n\n    // if substring found return length of string\n\
    \    return index\n}\n</code>\nI tested this in Go Playground\n<|/ a tags=string,go,regex\
    \ |>\n<| c |>\nThanks for your solution! I'll be using this as a basis for my\
    \ implementation.\n<|/ c |>\n<| a dscore=2 |>\nHere's another solution, using\
    \ regex. \n<code>\npackage main\n\nimport (\n    \"regexp\"\n    \"fmt\"\n)\n",
  "    mySubstrings := make([]string, 0)\n    mySplitString := strings.Split(myString,\
    \ substring)\n    for _, s := range mySplitString {\n        if s != \"\" {\n\
    \            mySubstrings = append(mySubstrings, s)\n        }\n    }\n    mySubstrings\
    \ := append(mySubstrings, \"\")\n    mySubstrings := strings.Sort(mySubstrings)\n\
    \    return len(mySubstrings)\n}\n", "    count = 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            count += how_many_times(myString[i+1:],\
    \ substring[1:])\n        } else {\n            count += how_many_times(myString[1:i],\
    \ substring)\n        }\n    }\n    return count\n}\n", "    start := 0\n    end\
    \ := 0\n\n    for i := 0; i < len(myString); i++ {\n        if myString[i] ==\
    \ substring {\n            start = i\n            end = i\n        }\n       \
    \ if end == len(myString) {\n            return len(myString) - start\n      \
    \  }\n        if myString[i] != myString[end] {\n            end = end + 1\n \
    \       }\n    }\n\n    return 0\n}\n</code>\n<|/ a tags=go dscore=2 |>\n<| c\
    \ |>\nHow is this answer different from the one I posted?\n<|/ c |>\n<| a tags=go\
    \ |>\nThis works too, using regexp:\n<code>\npackage main\n\nimport (\n    \"\
    fmt\"\n    \"regexp\"\n)\n\nvar re = regexp.MustCompile(`([a-z]{3})`)\n", "  \
    \  firstIndex := strings.Index(myString, substring)\n    return strings.Count(myString[:firstIndex],\
    \ substring)\n}\n", "    i := strings.Count(myString, substring)\n    for i <\
    \ len(myString) {\n        if strings.Contains(myString[i:], substring) {\n  \
    \          i++\n        } else {\n            break\n        }\n    }\n    return\
    \ i\n}\n", "    s := make([]rune, len(myString))\n    for i, r := range myString\
    \ {\n        if r == substring {\n            s[i] = r\n        }\n    }\n   \
    \ return count(s, substring)\n}\n", "    chars := make([]rune, len(substring))\n\
    \    for i, r := range substring {\n        chars[i] = r\n    }\n    i := 0\n\
    \    found := 0\n    for i < len(myString) {\n        if myString[i] == chars[0]\
    \ {\n            i++\n            if i < len(myString) {\n                i++\n\
    \                found++\n                if myString[i] == chars[1] {\n     \
    \               i++\n                    if i < len(myString) {\n            \
    \            i++\n                        found++\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return found\n}\n", "  \
    \  if myString == \"\" {\n        return 0\n    }\n\n    start := 0\n    end :=\
    \ strings.Index(myString, substring)\n\n    if end < 0 {\n        return -1\n\
    \    }\n\n    count := 0\n    for start < end {\n        start = end + strings.Index(myString[start:],\
    \ substring)\n        end = start + strings.Index(myString[start:], substring)\n\
    \n        if start < 0 {\n            count--\n        }\n    }\n\n    return\
    \ count\n}\n", "    count := 0\n    for i := 0; i < len(myString); i++ {\n   \
    \     if myString[i] == substring[0] {\n            count++\n            for j\
    \ := 1; j < len(substring); j++ {\n                if myString[i+j] != substring[j]\
    \ {\n                    break\n                }\n                count++\n \
    \           }\n        }\n    }\n    return count\n}\n", "    myString += \"X\"\
    \n    substring += \"X\"\n    var result int = 0\n    found := false\n    for\
    \ i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0] {\n\
    \            found = true\n        }\n        if found {\n            if myString[i+len(substring)]\
    \ == substring[len(\"X\")] {\n                result += 2\n                i +=\
    \ len(substring)\n            } else {\n                result++\n           \
    \     i += len(substring) - 2\n            }\n            found = false\n    \
    \    }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,substring,go |>\n\
    <| c |>\nThe code is not really working; it may return wrong results if the input\
    \ string is the prefix of the substring, e.g. how_many_times(\"aaa\",\"ab\")\n\
    <|/ c |>\n<| a tags=string,substring,go dscore=4 |>\nOne way to do it would be:\n\
    <code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    result\
    \ := 0\n    for _, x := range myString {\n        if x == substring {\n      \
    \      result += 1\n        }\n    }\n    return result\n}\n", "    var myStringSlice\
    \ []rune\n    var mySubstringSlice []rune\n    var subStringLen int\n    var i\
    \ int\n    var k int\n    myStringSlice = strings.Split(string(myString), \"\\\
    000\")\n    mySubstringSlice = strings.Split(string(substring), \"\\000\")\n \
    \   for i := 0; i < len(myStringSlice); i++ {\n        for k = i + 1; k < len(myStringSlice);\
    \ k++ {\n            subStringLen = len(mySubstringSlice)\n            if strings.Contains(string(myStringSlice[i]),\
    \ string(mySubstringSlice)) {\n                subStringLen = subStringLen + 1\n\
    \            }\n            if strings.Contains(string(myStringSlice[k]), string(mySubstringSlice))\
    \ {\n                subStringLen = subStringLen + 1\n            }\n        \
    \    if strings.Contains(string(myStringSlice[i]), string(mySubstringSlice)) {\n\
    \                subStringLen = subStringLen + 1\n            }\n            if\
    \ strings.Contains(string(myStringSlice[k]), string(mySubstringSlice)) {\n   \
    \             subStringLen = subStringLen + 1\n            }\n            if strings.Contains(string(myStringSlice[i]),\
    \ string(mySubstringSlice)) {\n                subStringLen = subStringLen + 1\n\
    \            }\n            if strings.Contains(string(myStringSlice[k]), string(mySubstringSlice))\
    \ {\n                subStringLen = subStringLen + 1\n            }\n        \
    \    if strings.Contains(string(myStringSlice[i]), string(mySubstringSlice)) {\n\
    \                subStringLen = subStringLen + 1\n            }\n            if\
    \ strings.Contains(string(myStringSlice[k]), string(mySubstringSlice)) {\n   \
    \             subStringLen = subStringLen + 1\n            }\n        }\n    }\n\
    \    return subStringLen\n}", "    // Create a map of every substring found in\
    \ myString\n    counts := map[string]int{}\n\n    // Loop through myString\n \
    \   for _, v := range myString {\n        // If v exists in substring\n      \
    \  if v == substring {\n            // Increment count\n            counts[substring]++\n\
    \        }\n    }\n\n    // Return total count\n    return len(counts)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe string \"aaa\" will result in 0 because \"a\"\
    \ does not exist in the string\n<|/ c |>\n<| c |>\nThe string \"aaa\" will result\
    \ in 1 because \"a\" exists in the string\n<|/ c |>\n<| c |>\n, you're right.\
    \ I didn't realize that the substring could be the same. Thanks for pointing that\
    \ out!\n<|/ c |>\n<| a |>\nA slight modification to the accepted answer:\n<code>",
  "    var count = 0\n    i := strings.Index(myString, substring)\n    for ; i < len(myString);\
    \ i++ {\n        if strings.Contains(myString, myString[i+1:], substring, -1)\
    \ == true {\n            count = count + 1\n        }\n    }\n    return count\n\
    }\n", "    totalCount := 0\n    var indexCount map[string]int\n    indexCount\
    \ = make(map[string]int)\n\n    for i := 0; i < len(myString); i++ {\n       \
    \ count := 0\n\n        for j := 0; j < len(substring); j++ {\n            if\
    \ myString[i:i+len(substring)] == substring[j:j+len(substring)] {\n          \
    \      count++\n            }\n        }\n\n        if count > 0 {\n         \
    \   indexCount[myString[i]] = count\n            totalCount += count\n       \
    \ }\n    }\n\n    return totalCount\n}\n", "    count = 0\n    if len(myString)\
    \ < len(substring) {\n        return 0\n    }\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            count++\n     \
    \       myString = myString[1 : len(myString)-1]\n        }\n    }\n    if len(myString)\
    \ > len(substring) {\n        for i := 0; i < len(substring); i++ {\n        \
    \    if myString[len(myString)-len(substring)+i] == substring[i] {\n         \
    \       count++\n                myString = myString[:len(myString)-len(substring)+i]\n\
    \            }\n        }\n    }\n    return count\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nWhat is the best way of running this code on all files in a directory (including\
    \ subdirectories)?\n<|/ c |>\n<| c |>\nYou don't have to run the code in the main\
    \ function. Just put the code in a file called `how_many_times_test.go` and put\
    \ that in the directory where you want to run the code and then run `go test how_many_times_test`.\n\
    <|/ c |>\n<| c |>\nThis is just perfect for me. Thank you very much.\n<|/ c |>\n\
    <| a |>\nMy solution in go golang:\n<code>\npackage main\n\nimport (\n    \"io/ioutil\"\
    \n    \"log\"\n    \"math\"\n    \"regexp\"\n    \"strings\"\n    \"testing\"\n\
    )\n", "    idx := strings.Index(myString, substring)\n    if idx == -1 {\n   \
    \     return 0\n    }\n\n    idx += strings.Index(myString[:idx], substring)\n\
    \    return 1 + how_many_times(myString[idx:], substring)\n}\n", "    mySubString\
    \ := strings.ToLower(substring)\n    myString := strings.ToLower(myString)\n \
    \   regex := regexp.MustCompile(\"(?i)\" + mySubString + \"(.*?)(\" + mySubString\
    \ + \")\")\n    matches := regex.FindStringSubmatch(myString)\n    if matches\
    \ == nil {\n        return 0\n    }\n    return len(matches[1]) + 1\n}\n</code>\n\
    <|/ a |>\n<| a |>\nUsing regex you can do it like this\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    countA := 0\n    countB :=\
    \ 0\n    countC := 0\n\n    idx := 0\n\n    for idx = 0; idx < len(myString);\
    \ idx++ {\n        if idx == len(myString) {\n            break\n        }\n\n\
    \        switch myString[idx] {\n        case \"a\":\n            if idx+len(substring)\
    \ <= len(myString) {\n                countA += substring_count(myString, idx,\
    \ idx + len(substring)) - idx\n            }\n            break\n        case\
    \ \"b\":\n            if idx+len(substring) <= len(myString) {\n             \
    \   countB += substring_count(myString, idx, idx + len(substring)) - idx\n   \
    \         }\n            break\n        case \"c\":\n            if idx+len(substring)\
    \ <= len(myString) {\n                countC += substring_count(myString, idx,\
    \ idx + len(substring)) - idx\n            }\n            break\n        default:\n\
    \            break\n        }\n    }\n\n    if countA == 0 && countB == 0 && countC\
    \ == 0 {\n        return 0\n    }\n\n    if countA != 0 && countB == 0 && countC\
    \ == 0 {\n        return countA\n    }\n\n    if countA != 0 && countB != 0 &&\
    \ countC == 0 {\n        return countA + countB\n    }\n\n    if countA == 0 &&\
    \ countB != 0 && countC == 0 {\n        return countB\n    }\n\n    if countA\
    \ == 0 && countB == 0 && countC != 0 {\n        return countC\n    }\n\n    return\
    \ countA + countB + countC\n}\n", "    if substring == \"\" {\n        return\
    \ 0\n    }\n\n    if len(myString) < len(substring) {\n        return 0\n    }\n\
    \n    i := 0\n    for j := 0; j < len(substring); j++ {\n        if myString[i]\
    \ == substring[j] {\n            i++\n            continue\n        }\n\n    \
    \    cnt := 0\n        for k := i; k <= len(myString); k++ {\n            if myString[k]\
    \ == substring[j] {\n                cnt++\n                break\n          \
    \  }\n        }\n\n        if cnt > 0 {\n            i++\n        }\n\n      \
    \  if cnt == 0 {\n            return i\n        }\n    }\n\n    return -1\n}\n",
  "    return strings.Count(myString, substring)\n}\n", "    var count int\n    for\
    \ index, item := range myString {\n        if item == substring {\n          \
    \  count++\n            if index < len(myString) - 1 {\n                if myString[index+1]\
    \ == substring {\n                    count++\n                }\n           \
    \ }\n        }\n    }\n    return count\n}\n</code>\n<|/ a dscore=0 tags=go,string\
    \ |>\n<| a |>\nThis solution uses the go standard library:\n<code>\npackage main\n\
    \nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    result := 0\n    i := 0\n\
    \    for ; i < len(myString); i++ {\n        if myString[i] == substring[0] {\n\
    \            result += how_many_times(myString[i+1:], substring[1:])\n       \
    \ } else if myString[i] == substring[1] {\n            result += 2\n        }\
    \ else {\n            break\n        }\n    }\n    return result\n}\n</code>\n\
    <|/ a tags=algorithm,string,search,go |>\n<| c |>\nThis is great and extremely\
    \ fast, but what if I don't know the size of the substring? E.g. `string = 'asdf1234'`\
    \ and I want to find how many times \"1234\" occurs in that string?\n<|/ c |>\n\
    <| c |>\nHow about this? It works for me. I think it is fast enough too.\n<|/\
    \ c |>\n<| a tags=algorithm,string,search,go |>\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n)\n", "    var index int\n    var count int\n    for index,\
    \ c := range myString {\n        if c == substring {\n            count++\n  \
    \          if index+1 == len(myString) {\n                return count\n     \
    \       }\n        } else {\n            if index+1 == len(myString) {\n     \
    \           return count\n            }\n        }\n    }\n    return count\n\
    }\n", "    count := 0\n    for _, v := range myString {\n        if v == substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n", "    var counter\
    \ int\n\n    if strings.Count(myString, substring) == 0 {\n        return counter\n\
    \    }\n\n    i, j, k := 0, 0\n    for k := 0; k < len(myString); k++ {\n    \
    \    if i == 0 && myString[k] == substring[0] {\n            counter++\n     \
    \       j = 0\n        } else {\n            if j == 0 && myString[k] == substring[1]\
    \ {\n                counter++\n                j = 1\n            } else {\n\
    \                if k == len(myString) - 1 {\n                    counter++\n\
    \                }\n            }\n        }\n\n        i = j\n        j = k\n\
    \    }\n\n    return counter\n}\n", "    searchString := []rune(substring)\n \
    \   foundIndex := -1\n    start := 0\n    end := len(myString)\n    currentLength\
    \ := 0\n    repeat := false\n    for start <= end {\n        if currentLength\
    \ == len(searchString) {\n            foundIndex = start\n            break\n\
    \        }\n        if myString[start] == searchString[currentLength] {\n    \
    \        currentLength++\n        } else {\n            currentLength = 0\n  \
    \      }\n        start++\n    }\n    if currentLength != len(searchString) {\n\
    \        foundIndex = -1\n    }\n    return foundIndex\n}\n", "    result := 0\n\
    \    counter := 0\n\n    // if myString is empty\n    if len(myString) == 0 {\n\
    \        return 0\n    }\n\n    // substring not found in myString\n    if len(substring)\
    \ == 0 {\n        return result\n    }\n\n    // if myString contains substring\n\
    \    for i := 0; i < len(myString); i++ {\n        // if the character is found\
    \ in substring\n        if myString[i] == substring[0] {\n            // if we\
    \ reached the end of the substring\n            if len(substring) == 1 {\n   \
    \             // increment the result counter\n                result++\n    \
    \        }\n            // if there is a next character in substring\n       \
    \     if i < len(substring) {\n                // increment the result counter\
    \ with the count of the next character\n                result += how_many_times(myString[i+1:],\
    \ substring[1:])\n            }\n        }\n    }\n\n    return result\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nI made a little improvement to the already posted\
    \ solution.\n<code>\npackage main\n\nimport \"fmt\"\n", "    var foundStrings\
    \ int = 0\n    for _, s := range myString {\n        if s == substring {\n   \
    \         foundStrings++\n        }\n    }\n\n    return foundStrings\n}\n", " \
    \   fmt.Println(\"string\", myString)\n    fmt.Println(\"substring\", substring)\n\
    \n    stringToLookFor := myString\n    subStringToLookFor := substring\n\n   \
    \ counter := 0\n    if strings.Contains(stringToLookFor, subStringToLookFor) {\n\
    \        counter++\n    }\n\n    for strings.Contains(stringToLookFor, \"a\")\
    \ {\n        stringToLookFor = strings.Replace(stringToLookFor, \"a\", \"A\",\
    \ 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor, \"a\",\
    \ \"A\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"b\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"b\",\
    \ \"B\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"b\", \"B\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"c\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"c\",\
    \ \"C\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"c\", \"C\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"d\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"d\",\
    \ \"D\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"d\", \"D\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"e\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"e\",\
    \ \"E\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"e\", \"E\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"f\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"f\",\
    \ \"F\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"f\", \"F\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"g\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"g\",\
    \ \"G\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"g\", \"G\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"h\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"h\",\
    \ \"H\", 1)\n        subStringToLookFor = strings.Replace(subStringToLookFor,\
    \ \"h\", \"H\", 1)\n        counter++\n    }\n\n    for strings.Contains(stringToLookFor,\
    \ \"i\") {\n        stringToLookFor = strings.Replace(stringToLookFor, \"i\",\
    \ \"I\", 1)\n        subStringToLookFor = strings.Replace(", "    var count int\
    \ = 0\n    index := strings.Index(myString, substring)\n    if index < 0 {\n \
    \       return count\n    }\n    count++\n    substring = substring[index:]\n\
    \    // Look for a longer substring starting after that found one.\n    for strings.HasSuffix(myString,\
    \ substring) {\n        index = strings.Index(myString, substring)\n        if\
    \ index < 0 {\n            break\n        }\n        count += index\n        substring\
    \ = substring[index:]\n    }\n    return count\n}\n", "    var index int = 0\n\
    \    var count int = 0\n\n    for i := 0; i < len(myString); i++ {\n        if\
    \ myString[i] == substring {\n            index++\n            if index > 0 {\n\
    \                count++\n                index = 0\n            }\n        }\n\
    \    }\n\n    return count\n}\n", "    if myString == \"\" {\n        return 0\n\
    \    }\n\n    count := 0\n    firstIndex := strings.Index(myString, substring)\n\
    \    if firstIndex == -1 {\n        return 0\n    }\n\n    lastIndex := strings.LastIndex(myString,\
    \ substring)\n    if lastIndex == -1 {\n        lastIndex = myString.Len()\n \
    \   }\n\n    for index:= firstIndex + 1; index <= lastIndex; index++ {\n     \
    \   if myString[index] == substring[0] {\n            count++\n        }\n   \
    \ }\n\n    return count\n}", "    myString, substring := trim(myString), trim(substring)\n\
    \    if myString == \"\" {\n        return 0\n    }\n    if substring == \"\"\
    \ {\n        return len(myString)\n    }\n    start := 0\n    end := -1\n    index\
    \ := len(myString) - 1\n    for index >= 0 {\n        start += 1\n        index\
    \ = strings.IndexByte(myString[index:], substring[0])\n        if index < 0 {\n\
    \            break\n        }\n        end += 1\n        index += 1\n    }\n \
    \   if end == -1 {\n        return start\n    }\n    return end + (substring ==\
    \ substring[:end])\n}\n", "    count := 0\n    for _, ch := range myString {\n\
    \        if ch == substring {\n            count++\n        }\n    }\n    return\
    \ count\n}\n", "    if myString == \"\" {\n        return 0\n    }\n\n    subStringLen\
    \ := len(substring)\n    currentIndex := 0\n\n    var stringCount int = 0\n  \
    \  for currentIndex < len(myString) {\n        if myString[currentIndex] == substring[0]\
    \ {\n            stringCount += 1\n            for i := 1; i < subStringLen; i++\
    \ {\n                if myString[currentIndex+i] != substring[i] {\n         \
    \           break\n                }\n            }\n        } else {\n      \
    \      stringCount++\n        }\n        currentIndex += subStringLen\n    }\n\
    \n    return stringCount\n}\n`\nvar how_many_times_test string = `package how_many_times_test\n\
    \nimport (\n    \"testing\"\n    \"fmt\"\n)\n", "    myString = strings.ToLower(myString)\n\
    \    substring = strings.ToLower(substring)\n    if myString == \"\" || substring\
    \ == \"\" {\n        return 0\n    }\n    i, j := 0, 0\n    for ; i < len(myString)\
    \ && j < len(substring); i, j = i+1, j+1 {\n        if myString[i] != substring[j]\
    \ {\n            break\n        }\n    }\n    return j\n}\n", "    result := 0\n\
    \    start := 0\n    end := 0\n    start := strings.Index(myString, substring)\n\
    \    if start < 0 {\n        return -1\n    }\n    end := start + len(substring)\n\
    \    for i := start + 1; i < end; i++ {\n        if myString[i] == substring[start]\
    \ {\n            result++\n        }\n    }\n    return result\n}\n", "    myStringBytes\
    \ := []byte(myString)\n    substringBytes := []byte(substring)\n    size := len(myStringBytes)\n\
    \    start := 0\n    end := 0\n    i := 0\n    var count int = 0\n    for ; i\
    \ < size; i++ {\n        start += 1\n        end += 1\n        if myStringBytes[i]\
    \ == substringBytes[i] {\n            count += 1\n            continue\n     \
    \   }\n        if myStringBytes[i] == substringBytes[start] {\n            if\
    \ i+1 < size && myStringBytes[i+1] == substringBytes[end] {\n                count\
    \ += 1\n                i += 2\n                continue\n            }\n    \
    \    }\n        if myStringBytes[i] == substringBytes[end] {\n            if i+1\
    \ < size && myStringBytes[i+1] == substringBytes[start] {\n                count\
    \ += 1\n                i += 2\n                continue\n            }\n    \
    \    }\n    }\n    return count\n}\n", "    count := 0\n    for _, index := range\
    \ strings.Index(myString, substring) {\n        if index >= 0 {\n            count++\n\
    \        } else {\n            break\n        }\n    }\n    return count\n}\n\
    </code>\n<|/ a dscore=5 tags=go,string |>\n<| c |>\nThis should be the accepted\
    \ answer\n<|/ c |>\n<| c |>\nThis is perfect - and exactly what I was looking\
    \ for!\n<|/ c |>\n<| c |>\nThanks for sharing the code. I think it should be `if\
    \ index >= 0 {` otherwise it will return `count` as 1.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work for some strings: how_many_times(\"aaaa\", \"a\") returns 1, even\
    \ though it shouldn't because of the overlapping \"a\" in the original string.\n\
    <|/ c |>\n<| c |>\nI agree with you! It should not return 1 when the substring\
    \ is not found at all. I will edit the answer now.\n<|/ c |>\n<| a tags=go,string\
    \ |>\nI came up with a slight improvement over solution. Instead of checking each\
    \ character in the string, checking if the string contains only the substring\
    \ would significantly reduce the number of checks.\n<code>\npackage main\n\nimport\
    \ (\n    \"fmt\"\n    \"strings\"\n)\n", "    count := 0\n    if myString == \"\
    \" {\n        return count\n    }\n    if substring == \"\" {\n        return\
    \ count\n    }\n    start := 0\n    end := len(myString)\n    count := 0\n   \
    \ loop := true\n    repeat {\n        if myString[end-1] == substring {\n    \
    \        count += end - (start - 1)\n        } else {\n            count += end\
    \ - (start - 1)\n            end = start\n            start = end\n        }\n\
    \        loop = (end >= len(myString))\n        start += 1\n        end -= 1\n\
    \    }\n    return count\n}\n", "    matches := strings.Count(myString, substring)\n\
    \    return matches + strings.Count(myString, strings.ToUpper(substring))\n}\n",
  "    myStringArray := strings.Split(myString, \".\")\n    subStringArray := strings.Split(substring,\
    \ \".\")\n    i := 0\n    j := len(myStringArray) - 1\n    count := 0\n    for\
    \ ; i < j; {\n        if myStringArray[i] == subStringArray[0] {\n           \
    \ count = count + 1\n            i++\n        }\n        if myStringArray[i] ==\
    \ subStringArray[1] {\n            count = count + 1\n            i++\n      \
    \  }\n        if myStringArray[i] == subStringArray[2] {\n            count =\
    \ count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[3]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[4] {\n            count = count + 1\n            i++\n   \
    \     }\n        if myStringArray[i] == subStringArray[5] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[6]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[7] {\n            count = count + 1\n            i++\n   \
    \     }\n        if myStringArray[i] == subStringArray[8] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[9]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[10] {\n            count = count + 1\n            i++\n  \
    \      }\n        if myStringArray[i] == subStringArray[11] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[12]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[13] {\n            count = count + 1\n            i++\n  \
    \      }\n        if myStringArray[i] == subStringArray[14] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[15]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[16] {\n            count = count + 1\n            i++\n  \
    \      }\n        if myStringArray[i] == subStringArray[17] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[18]\
    \ {\n            count = count + 1\n            i++\n        }\n        if myStringArray[i]\
    \ == subStringArray[19] {\n            count = count + 1\n            i++\n  \
    \      }\n        if myStringArray[i] == subStringArray[20] {\n            count\
    \ = count + 1\n            i++\n        }\n        if myStringArray[i] == subStringArray[21]\
    \ {\n            count = ", "    var result int\n    start := 0\n    end := len(myString)\
    \ - len(substring) + 1 // Substring length is at least 1 and at most len(myString)\n\
    \    for start <= end {\n        middle1 := start + len(substring)\n        middle2\
    \ := middle1 + len(substring)\n        middle3 := middle2 + len(substring)\n \
    \       middle4 := middle3 + len(substring)\n        middle5 := middle4 + len(substring)\n\
    \n        if middle1 < middle2 && middle2 < middle3 && middle3 < middle4 && middle4\
    \ < middle5 && middle1 <= len(myString) {\n            if strings.EqualFold(myString[middle1],\
    \ substring) {\n                result++\n            }\n        }\n    }\n  \
    \  return result\n}\n", "    return 0\n}\n", "    start := 0\n    end := len(myString)\n\
    \    found := 0\n    for start < end {\n        i := strings.Index(myString, substring)\n\
    \        if i >= 0 {\n            found++\n            if i == 0 {\n         \
    \       start = end + 1\n            }\n        } else {\n            if start\
    \ == end {\n                return found\n            }\n            start++\n\
    \        }\n    }\n    return found\n}\n", "    count := 0\n    start := 0\n \
    \   end := 0\n    for start < len(myString) {\n        end := strings.Index(myString[start:],\
    \ substring)\n        if end == -1 {\n            end = len(myString[start:])\n\
    \        }\n        if end == -1 {\n            count++\n            start = end\n\
    \        } else {\n            if count%2 == 0 {\n                count++\n  \
    \          } else {\n                count--\n            }\n            start\
    \ = end\n        }\n    }\n    return count\n}\n", "    var count int\n\n    //\
    \ We use a slice to hold the substring\n    parts := []string{substring}\n\n \
    \   // We traverse the given string and keep track of the count\n    // and check\
    \ if a substring is found or not\n    for _, v := range myString {\n        //\
    \ If substring is found in current string we increase the count\n        if strings.Contains(v,\
    \ parts[0]) {\n            count++\n        }\n\n        // If the substring is\
    \ not found we increase the count\n        // and append to the slice\n      \
    \  if strings.Contains(v, parts[len(parts)-1]) {\n            count++\n      \
    \      parts = append(parts, substring)\n        }\n    }\n    return count\n\
    }\n", "    fmt.Println(myString, \"|\", substring, \"|\", strings.Count(myString,\
    \ substring))\n    return strings.Count(myString, substring)\n}\n", "    myStringArray\
    \ := strings.Split(myString, \"\\n\")\n    subStringArray := strings.Split(substring,\
    \ \"\\n\")\n    var count int\n\n    for _, subStr := range subStringArray {\n\
    \        for _, myStr := range myStringArray {\n            if strings.Contains(myStr,\
    \ subStr) {\n                count++\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    // Convert the substring to lower case\n    substring = strings.ToLower(substring)\n\
    \n    // Count how many times the substring can be found in the string\n    count\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        // If the current character\
    \ at string position is equal to the substring\n        if myString[i] == substring\
    \ {\n            count++\n            // If the current character at string position\
    \ is equal to the substring and the next character\n            // is equal to\
    \ the substring\n            if i < len(myString) - 1 && myString[i+1] == substring\
    \ {\n                count++\n            }\n        }\n    }\n\n    // Return\
    \ the number of times the substring can be found in the string\n    return count\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThis solution isn't as nice as the accepted\
    \ solution but it works with overlapping strings also.\n<code>", "    count :=\
    \ 0\n    i := 0\n    for ; i < len(myString) && myString[i] == substring[0]; i++\
    \ {\n        if myString[i] != substring[0] {\n            count = count\n   \
    \     } else {\n            count = count + 1\n        }\n    }\n\n    for ; i\
    \ < len(myString); i++ {\n        if myString[i] != substring[0] {\n         \
    \   count = count\n        } else {\n            count = count + 1\n        }\n\
    \    }\n\n    return count\n}\n", "    var count int = 0\n    var startPos int\n\
    \n    if substring == \"\" {\n        return 0\n    }\n\n    if myString == \"\
    \" {\n        return -1\n    }\n\n    for _, chara := range myString {\n     \
    \   if chara != substring[0] {\n            continue\n        }\n\n        startPos\
    \ = -1\n        for _, charb := range myString {\n            if charb == substring[0]\
    \ {\n                if startPos == -1 {\n                    startPos = charb\n\
    \                } else if charb != substring[1] {\n                    count++\n\
    \                }\n            } else {\n                if startPos != -1 {\n\
    \                    count++\n                }\n                startPos = charb\n\
    \            }\n        }\n    }\n\n    return count\n}\n", "    var mySubstring\
    \ []rune\n    var myStringCopy []rune\n\n    for i := 0; i < len(myString); i++\
    \ {\n        mySubstring = append(mySubstring, myString[i])\n        myStringCopy\
    \ = append(myStringCopy, myString[i])\n    }\n\n    for i := 0; i < len(substring);\
    \ i++ {\n        for j := 0; j < len(mySubstring); j++ {\n            if mySubstring[j]\
    \ == substring[i] {\n                for k = 0; k < i; k++ {\n               \
    \     if myStringCopy[k] != mySubstring[j] {\n                        myStringCopy[k]\
    \ = mySubstring[j]\n                        break\n                    }\n   \
    \             }\n                break\n            }\n        }\n    }\n\n  \
    \  return len(myStringCopy)\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,string,go\
    \ |>\nHere is my solution using regex\n<code>", "    var n int = 0\n    for _,\
    \ c := range myString {\n        if c == substring {\n            n = n + 1\n\
    \        } else {\n            if n+1 == len(substring) {\n                return\
    \ n\n            }\n        }\n    }\n    return 0\n}\n", "    var counter = 1\n\
    \    for _, char := range myString {\n        if char == substring {\n       \
    \     counter++\n        }\n    }\n    return counter\n}\n", "    myStringWithSubstring\
    \ := myString + substring\n    myStringWithoutSubstring := myString[:len(myString)-len(substring)]\n\
    \n    index := strings.Index(myStringWithoutSubstring, myStringWithSubstring)\n\
    \    if index == -1 {\n        return 0\n    }\n\n    count := 0\n    for i :=\
    \ 0; i < index; i++ {\n        count++\n    }\n\n    return count\n}\n", "   \
    \ start := 0\n    end := len(myString)\n    result := 0\n\n    for start < end\
    \ {\n        if myString[start] == substring[0] {\n            if myString[start]\
    \ == substring[1] {\n                result += 2\n            } else {\n     \
    \           result += 1\n            }\n            start += 1\n        } else\
    \ {\n            if myString[start] != substring[0] {\n                result\
    \ += 0\n            }\n            start += 1\n        }\n    }\n\n    return\
    \ result\n}\n", "    return strings.Count(myString, substring)\n}\n", "    \n\
    \    str_arr := make([]string, 1)\n    str_arr[0] = myString\n    \n    sub_arr\
    \ := make([]string, 1)\n    sub_arr[0] = substring\n    \n    start := 0\n   \
    \ end := 0\n    \n    sub_arr_len := len(sub_arr) - 1\n    str_arr_len := len(str_arr)\
    \ - 1\n    \n    found := false\n    \n    for start < str_arr_len {\n       \
    \ end = start + len(sub_arr[start])\n        \n        if end > str_arr_len {\n\
    \            break\n        }\n        \n        if str_arr[start] == sub_arr[start]\
    \ {\n            found = true\n            start = end + 1 // don't count this\
    \ char twice\n            continue\n        }\n        \n        if str_arr[start]\
    \ != sub_arr[start] {\n            found = false\n            break\n        }\n\
    \    }\n    \n    if !found {\n        return 0\n    }\n    \n    for start <\
    \ str_arr_len {\n        end = start + len(sub_arr[start])\n        \n       \
    \ if end > str_arr_len {\n            break\n        }\n        \n        if str_arr[start]\
    \ == sub_arr[start] {\n            found = true\n            start = end + 1 //\
    \ don't count this char twice\n            continue\n        }\n        \n   \
    \     if str_arr[start] != sub_arr[start] {\n            found = false\n     \
    \       break\n        }\n    }\n    \n    if !found {\n        return 0\n   \
    \ }\n    \n    for start < str_arr_len {\n        end = start + len(sub_arr[start])\n\
    \        \n        if end > str_arr_len {\n            break\n        }\n    \
    \    \n        if str_arr[start] == sub_arr[start] {\n            found = true\n\
    \            start = end + 1 // don't count this char twice\n            continue\n\
    \        }\n        \n        if str_arr[start] != sub_arr[start] {\n        \
    \    found = false\n            break\n        }\n    }\n    \n    if !found {\n\
    \        return 0\n    }\n    \n    for start < str_arr_len {\n        end = start\
    \ + len(sub_arr[start])\n        \n        if end > str_arr_len {\n          \
    \  break\n        }\n        \n        if str_arr[start] == sub_arr[start] {\n\
    \            found = true\n            start = end + 1 // don't count this char\
    \ twice\n            continue\n        }\n        \n        if str_arr[start]\
    \ != sub_arr[start] {\n            found = false\n            break\n        }\n\
    \    }\n    \n    if !found {\n        return 0\n    }\n    \n    for start <\
    \ str_arr_len {\n        end = start + len(sub_arr[start])\n        \n       \
    \ if end > str_arr_len {\n            break\n        }\n        \n        if str_arr[start]\
    \ == ", "    length := len(myString)\n    counts := make([]int, length)\n    index\
    \ := 0\n    found := false\n    for index < length {\n        if myString[index]\
    \ == substring {\n            counts[index]++\n            found = true\n    \
    \    } else {\n            if found {\n                counts[index]++\n     \
    \       }\n            index = index + 1\n        }\n    }\n    if !found {\n\
    \        return 0\n    }\n    for i := 1; i < length; i++ {\n        if counts[i]\
    \ > counts[i-1] {\n            return i - 1\n        }\n    }\n    return length\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI think this code has undefined behavior. In the\
    \ for loop `for i := 0; i < length-1; i++ {` you increment the loop variable `i`\
    \ twice per iteration. One of those increments could leave `i` at `length-1` when\
    \ the body is executed for the last time.\n<|/ c |>\n<| c |>\nYou're right. I\
    \ fixed that now.\n<|/ c |>\n<| a dscore=1 |>\nFor those who want to do it in\
    \ javascript, here is my solution:\n<code>", "    result := 0\n    currentPos\
    \ := 0\n    lastPos := len(myString) - 1\n    position := strings.Index(myString,\
    \ substring)\n    if position == -1 {\n        return -1\n    }\n    currentPos\
    \ = position\n    lastPos = position\n    for lastPos > currentPos {\n       \
    \ lastPos = currentPos\n        currentPos = strings.Index(myString[currentPos:],\
    \ substring)\n    }\n\n    for currentPos <= lastPos {\n        if myString[currentPos:lastPos+currentPos+1]\
    \ == substring {\n            result += 1\n        }\n    }\n    return result\n\
    }\n", "    var counter int = 0\n    for _, myChar := range myString {\n      \
    \  for _, subChar := range substring {\n            if myChar == subChar {\n \
    \               counter++\n            }\n        }\n    }\n    return counter\n\
    }\n", "    countString := myString\n    for i := 0; i < len(substring); i++ {\n\
    \        countString = countString[:strings.IndexAny(countString[:strings.IndexByte(countString,\
    \ substring)], substring, -1)]\n    }\n    return len(countString)\n}\n", "  \
    \  result := 0\n    if len(myString) == 0 {\n        return result\n    }\n  \
    \  if len(substring) == 0 {\n        return result\n    }\n\n    if myString[0]\
    \ >= substring[0] {\n        return result\n    }\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            result += how_many_times(myString[i:],\
    \ substring[1:])\n            if result == 0 {\n                return result\n\
    \            }\n        }\n    }\n    return result\n}\n", "    i := 0\n    for\
    \ j := 0; j < len(myString); j++ {\n        if myString[i] == substring[0] {\n\
    \            i++\n        }\n\n        if myString[i] == substring[1] {\n    \
    \        i++\n        }\n\n        if myString[i] == substring[2] {\n        \
    \    i++\n        }\n\n        if myString[i] == substring[3] {\n            i++\n\
    \        }\n    }\n\n    return i\n}\n", "    start := 0\n    end := len(myString)\
    \ - 1\n    i := 0\n    count := 0\n\n    while (i < len(substring) && start <=\
    \ end) {\n        if (myString[start] == substring[i]) {\n            count++\n\
    \            i++\n        }\n        else if (myString[start] <= substring[i])\
    \ {\n            start = i + 1\n        }\n        else if (myString[end] >= substring[i])\
    \ {\n            end = i - 1\n        }\n        else {\n            // No match\n\
    \            i++\n        }\n    }\n\n    return count\n}\n", "    \n    length\
    \ := 0\n    start := 0\n    end := 0\n    \n    index := strings.Index(myString,\
    \ substring)\n    if index == -1 {\n        return length\n    }\n    \n    start\
    \ = index\n    end = index\n    \n    length++\n    \n    for start < len(myString)\
    \ {\n        \n        index = strings.IndexAny(myString[start:], substring)\n\
    \        \n        if index == -1 {\n            length++\n            end = start\n\
    \            start = end + len(substring)\n        } else {\n            end =\
    \ index\n            length++\n        }\n    }\n    \n    return length\n}\n",
  "    if myString == \"\" {\n        return 0\n    }\n\n    posA := myString.Index(substring)\n\
    \    if posA == -1 {\n        return 0\n    }\n    return posA + substringLen\
    \ + how_many_times(myString[posA+substringLen:], substring)\n}\n", "    // Go\
    \ through the string and check if there is any overlaping case.\n    count :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            count += 1 + how_many_times(myString[i+1:], substring[1:])\n\
    \        }\n    }\n    return count\n}\n", "    if myString == \"\" {\n      \
    \  return 0\n    }\n    if substring == \"\" {\n        return 0\n    }\n    var\
    \ count = 0\n    length := len(substring)\n    for _, myCharChar := range myString\
    \ {\n        if strings.IndexRune(substring, myCharChar) != -1 {\n           \
    \ count++\n        }\n    }\n    return count\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThe only issue with this is the time complexity. You are doing `O(n)`,\
    \ where `n` is the number of characters in the string. You are also doing `O(n)`\
    \ string searches. If you had a very large string, this could take very long.\n\
    <|/ c |>\n<| a tags=string,go dscore=0 |>\nThe most elegant way to do this that\
    \ i know is by implementing two functions. Here is the implementation of it:\n\
    <code>", "    result := 0\n    index := -1\n    index := strings.Index(myString,\
    \ substring)\n    while index >= 0 {\n        result += 1\n        index = strings.Index(myString,\
    \ substring, index+1)\n    }\n    return result\n}\n", "    var count = 0\n  \
    \  for i := 0; i < len(myString); i++ {\n        if myString[i] == substring {\n\
    \            count++\n        }\n    }\n    return count\n}\n", "    // Use two\
    \ pointers to traverse the given string char by char.\n    pointer1 := 0\n   \
    \ pointer2 := 0\n    found := false\n    // While pointers are not equal to the\
    \ given string.\n    while pointer1 != len(myString) || pointer2 != len(substring)\
    \ {\n        if myString[pointer1] != substring[pointer2] {\n            // If\
    \ the given string is shorter than the substring then stop the loop.\n       \
    \     if pointer1 == len(myString) {\n                return 0\n            }\n\
    \            // If the given string is longer than the substring then stop the\
    \ loop.\n            if pointer2 == len(substring) {\n                return 0\n\
    \            }\n        }\n        // If the given string is found at the end\
    \ of the given string then stop the loop.\n        if myString[pointer1] == substring[pointer2]\
    \ {\n            found = true\n            break\n        }\n        // Move the\
    \ pointers to the next characters in the given string.\n        pointer1++\n \
    \       pointer2++\n    }\n    if found {\n        return pointer2 - pointer1\
    \ + 1\n    }\n    return 0\n}\n", "    start := 0\n    end := len(myString) -\
    \ 1\n\n    // Loop until we find the first index to begin searching or we find\
    \ our substring\n    for start < end {\n        middleIndex := start + int((end\
    \ - start) / 2)\n        // If our substring is longer than the string itself,\
    \ our match can't begin at middleIndex\n        if middleIndex > len(substring)\
    \ {\n            return end\n        }\n        // If the substring is longer\
    \ than our string, nothing we can do about it\n        if middleIndex > len(myString)\
    \ {\n            return end\n        }\n        // If we got here, our middle\
    \ index is within our string, we can begin searching\n        if myString[middleIndex]\
    \ == substring[middleIndex] {\n            start = middleIndex\n        } else\
    \ {\n            // If we got here, our middle index isn't part of our string,\
    \ we can move our search\n            end = middleIndex - 1\n        }\n    }\n\
    \n    // Once we return from this function and we haven't found our substring,\
    \ we know that our substring was found\n    return end - start + 1\n}\n</code>\n\
    <|/ a tags=go |>\n<| c |>\nThis works great. Thank you for the detailed explanation!\n\
    <|/ c |>\n<| a dscore=2 tags=go |>\nI made this simple function which returns\
    \ the number of times a string appears in another string.\n<code>", "    myStringCopy\
    \ := myString\n    if myStringCopy != \"\" {\n        var charIndex int\n    \
    \    for _, char := range myStringCopy {\n            if char == substring {\n\
    \                charIndex++\n            } else {\n                break\n  \
    \          }\n        }\n        return charIndex\n    } else {\n        return\
    \ -1\n    }\n}\n", "    count := 0\n    i := 0\n    for ; i < len(myString); i++\
    \ {\n        if myString[i] == substring[0] {\n            count++\n         \
    \   i := i + 1\n        } else if myString[i] == substring[1] {\n            count++\n\
    \            i := i + 1\n            i = i + 1\n        } else {\n           \
    \ i = 0\n        }\n    }\n    return count\n}\n", "    start := strings.Index(myString,\
    \ substring)\n    if start == -1 {\n        return 0\n    }\n    end := start\
    \ + len(substring)\n    return strings.Count(myString[start:end], substring)\n\
    }\n</code>\nI made some tests to compare with your function and mine \n<code>",
  "    count := 0\n    i := 0\n    for i < len(myString) {\n        if myString[i]\
    \ == substring[0] {\n            if i+len(substring) <= len(myString) {\n    \
    \            for _, char := range substring {\n                    if myString[i+len(substring)]\
    \ == char {\n                        count += 1 // overlapping cases\n       \
    \                 i += len(substring) // skip over overlapping cases\n       \
    \             }\n                }\n            } else {\n                count\
    \ += 1\n                i += len(substring)\n            }\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n", "    // Return\
    \ 0 if substring not found in the given string.\n    if len(substring) == 0 {\n\
    \        return 0\n    }\n    // Return number of occurrences of the substring\
    \ in the given string.\n    myStringLength := len(myString)\n    substringLength\
    \ := len(substring)\n    if substringLength == 0 {\n        return 0\n    }\n\
    \    overlappingCounter := 0\n    if substringLength > myStringLength {\n    \
    \    // Substring is longer than the string.\n        return overlappingCounter\n\
    \    }\n    if substringLength == 1 {\n        // Found the exact substring.\n\
    \        return int(myStringLength)\n    }\n\n    // Loop through the characters\
    \ of the given string, looking for the\n    // substring.\n    for i := 0; i <\
    \ myStringLength; i++ {\n        if myString[i] == substring[0] {\n          \
    \  // Check if substring starts at index 0.\n            if i == 0 {\n       \
    \         // Found the substring.\n                return overlappingCounter\n\
    \            } else {\n                // Found the substring.\n             \
    \   overlappingCounter++\n            }\n            // Check if substring at\
    \ index i can be matched against the remainder of the given string.\n        \
    \    for j := i; j < myStringLength; j++ {\n                if myString[j] ==\
    \ substring[1] {\n                    // Found the substring.\n              \
    \      return overlappingCounter\n                }\n            }\n        }\n\
    \    }\n    // No matching substring found.\n    return overlappingCounter\n}\n\
    </code>\n<|/ a tags=algorithm,search,string,go |>\n<| a tags=algorithm,search,string,go\
    \ |>\nI've implemented a solution in Python (for educational purposes, not for\
    \ production), and it passes all my tests:\n<code>\ndef count_chars(text, char):\n\
    \    count = 0\n    for i in range(len(text)):\n        if text[i] == char:\n\
    \            count += 1\n        else:\n            if count > 0:\n          \
    \      break\n    return count\n\ndef how_many_times(text, substring):\n    count\
    \ = 0\n    for i in range(len(text)):\n        if text[i] == substring[0]:\n \
    \           if count_chars(text[:i], substring[1]) > 0:\n                count\
    \ += count_chars(text[:i], substring[1])\n    return count\n\nif __name__ == \"\
    __main__\":\n    import sys\n\n    text = str(input())\n    substring = str(input())\n\
    \    result = how_many_times(text, substring)\n    print(result)\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=1 tags=algorithm,search,string,go |>\nIn Go, you\
    \ can use strings.Contains:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n \
    \   \"strings\"\n)\n", "    if myString == \"\" {\n        return 0\n    }\n\n\
    \    substringLen := len(substring)\n    currentSubIndex := 0\n    count := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[currentSubIndex]\
    \ {\n            count++\n            currentSubIndex++\n            if currentSubIndex\
    \ == substringLen {\n                return count\n            }\n        } else\
    \ {\n            count = 0\n            currentSubIndex = 0\n        }\n    }\n\
    \    return 0\n}\n", "    idx := strings.Index(myString, substring)\n    if idx\
    \ < 0 {\n        return -1\n    }\n    return strings.Count(myString[0:idx], substring)\
    \ + strings.Count(myString[idx+len(substring):len(myString)], substring)\n}\n",
  "    result := 0\n    if myString == \"\" {\n        return 0\n    }\n    if substring\
    \ == \"\" {\n        return 1\n    }\n    size := len(myString)\n    counter :=\
    \ 0\n    for i := 0; i < size; i++ {\n        if myString[i] == substring[0] {\n\
    \            for j := 0; j < len(substring); j++ {\n                if myString[i+j]\
    \ != substring[j] {\n                    break\n                }\n          \
    \  }\n            counter += 1\n            if j < len(substring) {\n        \
    \        i += j + 1\n            }\n        }\n    }\n    return counter\n}\n\
    </code>\n<|/ a tags=go,slice |>\n<| c |>\nNice, thanks for sharing. Although this\
    \ would not work if the string contains \"a\" multiple times. E.g. \"aaa\".\n\
    <|/ c |>\n<| c |>\nThanks for the heads up. I've updated my answer to account\
    \ for that possibility.\n<|/ c |>\n<| a tags=go,slice |>\nA possible solution\
    \ is to take your string and break it down into words and then find the number\
    \ of occurrences of a given word within it. Once you have the number of occurrences\
    \ of a word within each of your words, you can easily calculate an average.\n\
    For example: \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n\
    )\n", "    var result int = 0\n    for _, item := range myString {\n        if\
    \ (item == substring) {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n", "    var count int\n\n    // Loop from start position to end position\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring\
    \ {\n            count++\n        }\n\n        // Check if current character is\
    \ equal to the end of the string\n        if i == len(myString) - 1 {\n      \
    \      break\n        }\n\n        // Check if the substring is at the end of\
    \ the string\n        if myString[i+len(substring)] != substring {\n         \
    \   count = 0\n            break\n        }\n    }\n\n    return count\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nGood answer with a detailed explanation.  I just found\
    \ that this doesn't actually work if the input string has repeated characters.\
    \  For example, the following code: `strings.Repeat(\"a\", 5) + \"aaaa\"` will\
    \ return 1 instead of 3\n<|/ c |>\n<| a |>\nI've been playing around with Kent\
    \ Beck's idea, and came up with something that does work for repeated characters:\n\
    <code>", "    // Initialize count\n    count := 0\n    \n    // Iterate through\
    \ all characters in string\n    for _, myChar := range myString {\n        //\
    \ Iterate through all characters in substring\n        for _, subChar := range\
    \ substring {\n            // If characters match\n            if myChar == subChar\
    \ {\n                // Increase count\n                count++\n            }\n\
    \        }\n    }\n    \n    return count\n}\n", "    // Count overlaping cases\n\
    \    count := 0\n    start := 0\n    end := 0\n    for start < len(myString) &&\
    \ start < len(substring) {\n        start += strings.Index(myString[start:], substring[start:])\n\
    \        end = start + len(substring)\n        count += strings.Count(myString[start:end],\
    \ substring)\n    }\n    return count\n}\n", "    var i int\n    for ; i < len(myString);\
    \ i++ {\n        // Use a map for overlapping substring count\n        if myString[i]\
    \ == substring[0] {\n            if i == len(myString) {\n                // The\
    \ substring has been counted all and we are done\n                break\n    \
    \        }\n            if substring == myString[i:i+len(substring)] {\n     \
    \           i++\n                continue // Skip the rest of string as we are\
    \ done with that substring.\n            }\n            // Try with different\
    \ letter\n            i++\n            if myString[i] == substring[1] {\n    \
    \            if i == len(myString) {\n                    // The substring has\
    \ been counted all and we are done\n                    break\n              \
    \  }\n                if substring == myString[i:i+len(substring)] {\n       \
    \             i++\n                    continue // Skip the rest of string as\
    \ we are done with that substring.\n                }\n            }\n       \
    \ }\n    }\n    return i\n}\n</code>\nThe above function can be written in a more\
    \ compact way:\n<code>", "    parts := strings.Split(myString, substring)\n  \
    \  return len(parts)\n}\n", "    var count int\n    var length int\n    for i\
    \ := 0; i < len(myString); i++ {\n        length = length + 1\n        if myString[i:i+len(substring)]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    myStr := \"\"\n    if myString != \"\" {\n        myStr = myString\n    } else\
    \ {\n        myStr = substring\n    }\n    result := 0\n    for index, char :=\
    \ range myStr {\n        if substring == char {\n            result += index\n\
    \        }\n    }\n    return result\n}\n", "    return strings.Count(myString,\
    \ substring)\n}\n</code>\n<|/ a |>\n<| c |>\nThis works fine in Go 1.11 but not\
    \ in Go 1.9\n<|/ c |>\n<| c |>\nI agree, it worked fine in 1.11, but not in 1.9.\
    \  I revised the answer to use `strings.Count` instead.\n<|/ c |>\n<| c |>\nNice!\
    \ This also works fine with Go 1.12. Just in case anyone else is looking for this\
    \ answer in Go 1.13 (not yet released) the function name has been changed to `strings.Count(myString,\
    \ substring)`\n<|/ c |>\n<| a tags=string,go,count,substring |>\nHere's another\
    \ take on the problem, using regexps. It's not as elegant as some of the other\
    \ answers here, but it is pretty comprehensive and flexible.\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n", "    i := 0\n    for i\
    \ := 0; i < len(myString); i++ {\n        if (myString[i] == substring[0]) {\n\
    \            for j := 1; j < len(substring); j++ {\n                if (myString[i+j]\
    \ != substring[j]) {\n                    break\n                }\n         \
    \   }\n            if (j == len(substring)) {\n                return i\n    \
    \        }\n        }\n    }\n    return 0\n}\n", "    result := 0\n    var startIndex\
    \ int = 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] ==\
    \ substring[0] {\n            startIndex = i\n        }\n        if startIndex\
    \ > 0 {\n            if myString[i] == substring[len(substring)-1] {\n       \
    \         result = result + 1\n            }\n        }\n    }\n    return result\n\
    }\n", "    count := 0\n    start := 0\n    end := len(myString) - 1\n\n    for\
    \ start < end {\n        // Check all the substring positions are within the string.\n\
    \        end := strings.Index(myString[start:], substring)\n        if end < start\
    \ {\n            // Substring didn't occur.\n            continue\n        }\n\
    \        // Substring occurs.\n        count += end - start\n        start = end\
    \ + len(substring)\n    }\n    return count\n}\n", "    fmt.Printf(\"how_many_times(\\\
    \"%s\\\", \\\"%s\\\") => %d\\n\", myString, substring, myString.Count(substring))\n\
    \    return myString.Count(substring)\n}\n", "    i := 0\n    for {\n        if\
    \ myString[i] == substring {\n            i++\n        } else {\n            if\
    \ i == len(myString) {\n                return 0\n            }\n            i\
    \ = i + 1\n        }\n    }\n}", "    var count = 0\n    start := 0\n    for pos\
    \ := 0; pos <= len(myString); pos++ {\n        if myString[pos] == substring[0]\
    \ {\n            count++\n            start += 1\n        }\n        if myString[pos]\
    \ == substring[1] && start < pos {\n            count++\n            start = pos\
    \ + 1\n        }\n    }\n    return count\n}\n", "    return len(strings.Fields(myString))\
    \ - strings.Count(myString, substring)\n}\n", "    return strings.Count(myString,\
    \ substring)\n}\n", "    if len(substring) == 0 {\n        return 0\n    }\n\n\
    \    // find the starting index of the first substring\n    // start with the\
    \ first character in the original string\n    start := 0\n    for idx := 0; idx\
    \ < len(myString); idx++ {\n        if myString[idx] != substring[0] {\n     \
    \       break\n        }\n        start = idx\n    }\n\n    // find the ending\
    \ index of the substring\n    // find the last character of the substring that\
    \ is the same as the first\n    // character in the original string\n    end :=\
    \ 0\n    for idx := 0; idx < len(substring); idx++ {\n        if substring[idx]\
    \ != myString[start] {\n            break\n        }\n        end = idx\n    }\n\
    \n    // return number of characters in the original string that match substring\n\
    \    return len(myString) - end - start\n}\n", "    myStringSlice := strings.Split(myString,\
    \ substring)\n    stringCount := 0\n\n    for _, myStringElement := range myStringSlice\
    \ {\n        if myStringElement == \"\" {\n            stringCount++\n       \
    \ } else {\n            stringCount++\n            for _, myStringElement2 :=\
    \ range myStringSlice {\n                if myStringElement == myStringElement2\
    \ {\n                    stringCount++\n                    break\n          \
    \      }\n            }\n        }\n    }\n    return stringCount\n}\n", "   \
    \ fmt.Println(\"myString\", myString)\n    fmt.Println(\"substring\", substring)\n\
    \n    currentPosition := 0\n    substringLength := len(substring)\n    totalLength\
    \ := len(myString)\n\n    for currentPosition < totalLength {\n        fmt.Println(\"\
    currentPosition\", currentPosition)\n        if currentPosition < substringLength\
    \ && substring[currentPosition] == myString[currentPosition] {\n            currentPosition\
    \ += 1\n            continue\n        }\n\n        if currentPosition < substringLength\
    \ {\n            currentPosition += substringLength - currentPosition\n      \
    \  }\n        return currentPosition\n\n    }\n    return 0\n}\n", "    found\
    \ := 0\n    originalString := myString\n    lowercase := strings.ToLower(substring)\n\
    \    uppercase := strings.ToUpper(substring)\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            found++\n     \
    \       if strings.Contains(myString[:i], substring) {\n                found++\n\
    \            }\n            if strings.Contains(originalString[:i], lowercase)\
    \ {\n                found++\n            }\n            if strings.Contains(originalString[:i],\
    \ uppercase) {\n                found++\n            }\n            if originalString[i]\
    \ == substring[len(substring)-1] {\n                found++\n            }\n \
    \           if found > 0 {\n                originalString = myString[i:]\n  \
    \          }\n        }\n    }\n    return found\n}\n", "    return len(strings.IndexFunc(myString,\
    \ func(r rune) bool {\n        if r == substring[0] {\n            for _, c :=\
    \ range substring[1:] {\n                if r != c {\n                    return\
    \ false\n                }\n            }\n            return true\n        }\n\
    \        return false\n    }))\n}\n", "    var counter int\n    stringSlice :=\
    \ strings.Split(myString, substring)\n    for _, s := range stringSlice {\n  \
    \      counter++\n    }\n    return counter\n}\n", "    var count = 0\n    for\
    \ _, char := range myString {\n        if char == substring {\n            count++\n\
    \        } else {\n            if strings.Contains(myString, substring) {\n  \
    \              for _, mySubString := range strings.Split(myString, substring)\
    \ {\n                    count += how_many_times(mySubString, substring)\n   \
    \             }\n            }\n        }\n    }\n    return count\n}\n", "  \
    \  result := 0\n    for i := 0; i < len(myString); i++ {\n        start := i\n\
    \        end := i\n        for j := i + 1; j < len(myString); j++ {\n        \
    \    end++\n            if myString[j] != substring[start] {\n               \
    \ end = j\n                break\n            }\n        }\n        if start ==\
    \ i {\n            end = i\n        }\n        if end - start > result {\n   \
    \         result = end - start\n        }\n    }\n    return result\n}\n", " \
    \   // Use a map to record the number of times each string is found. \n    //\
    \ In order to achieve O(n) time complexity, use sorted map keys. \n    var mapKey\
    \ string\n    var mapVal *int\n    mapKey = substring\n    mapVal = &int(1)\n\
    \    m := make(map[string]*int)\n    m[mapKey] = mapVal\n    len1 := len(myString)\n\
    \    len2 := len(substring)\n    i, j := 0, 0\n    // Traverse through each character\
    \ of the original string. \n    for i < len1 && j < len2 {\n        // Increment\
    \ count if the character from the original string matches the substring.\n   \
    \     if myString[i] == substring[j] {\n            mapVal = &int(*(mapVal.Inc()))\n\
    \            // Increment the count if the substring matches the character in\
    \ the original string.\n            if substring == myString[i:] {\n         \
    \       mapVal = &int(*(mapVal.Inc()))\n            }\n            i++\n     \
    \       j++\n        }\n        // Increment count if the substring ends with\
    \ the character in the original string.\n        else if (j == len2) {\n     \
    \       mapVal = &int(*(mapVal.Inc()))\n            i++\n        }\n        //\
    \ Increment count if the substring starts with the character in the original string.\n\
    \        else if i == len1 {\n            j++\n        }\n    }\n    // Return\
    \ count of substrings.\n    return *mapVal\n}\n", "    var i int\n    for i =\
    \ 1; i < len(myString); i++ {\n        if myString[i] == substring[0] {\n    \
    \        for j := 0; j < len(substring); j++ {\n                if myString[i+j]\
    \ != substring[j] {\n                    break\n                }\n          \
    \  }\n            if j == len(substring) {\n                return i\n       \
    \     }\n        } else {\n            break\n        }\n    }\n    return 0\n\
    }\n", "    start := strings.Index(myString, substring)\n    if start == -1 {\n\
    \        return 0\n    }\n    end := start + len(substring)\n    found := 0\n\
    \    for i := start; i < end; i++ {\n        if myString[i] == substring[0] {\n\
    \            if i >= len(myString) {\n                found++\n            } else\
    \ {\n                found += how_many_times(myString[i+1:], substring[1:])\n\
    \            }\n        } else if myString[i] == substring[1] {\n            if\
    \ i >= len(myString) {\n                found++\n            } else {\n      \
    \          found += how_many_times(myString[i+1:], substring[2:])\n          \
    \  }\n        } else if myString[i] == substring[2] {\n            if i >= len(myString)\
    \ {\n                found++\n            } else {\n                found += how_many_times(myString[i+1:],\
    \ substring[3:])\n            }\n        } else {\n            found++\n     \
    \   }\n    }\n    return found\n}\n</code>\nThe results are as follows, as expected.\
    \ \n<code>\npackage how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n", "    myString = strings.ToLower(myString)\n    substring = strings.ToLower(substring)\n\
    \n    var count int\n\n    for _, letter := range strings.Split(myString, \"\"\
    ) {\n        if letter == substring {\n            count++\n        }\n    }\n\
    \n    return count\n}\n", "    var result int\n\n    if substring == \"\" {\n\
    \        return 0\n    }\n\n    for _, elem := range myString {\n        if elem\
    \ == substring {\n            result++\n        }\n    }\n\n    return result\n\
    }\n", "    result := 0\n\n    for _, myElement := range myString {\n        if\
    \ strings.Contains(myElement, substring) {\n            result += 1 // If found\
    \ in string, count as 1.\n        }\n    }\n\n    return result\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=string,go |>\nTo check if a string contains a substring,\
    \ you can use strings.Contains() which returns true if the string contains the\
    \ substring:\n<code>\nif strings.Contains(myString, \"mySubstring\") {\n    //\
    \ do something\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nFor my case it worked\
    \ as \nif strings.Contains(myString, \"mySubstring\") {\n    // do something\n\
    }\n<|/ c |>\n<| a tags=string,go dscore=4 |>\nHere is a simple solution\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n", "    if myString\
    \ == \"\" || substring == \"\" {\n        return 0\n    }\n\n    myStrLen := len(myString)\n\
    \    subStrLen := len(substring)\n    i, j := 0, 0\n    count := 0\n    for i\
    \ < myStrLen {\n        if i == 0 {\n            break\n        }\n        if\
    \ myString[i] == substring[j] {\n            count++\n            i++\n      \
    \      j++\n            continue\n        }\n        count += how_many_times(myString[i:],\
    \ substring)\n        if j < subStrLen {\n            count += how_many_times(myString[i:],\
    \ substring[j:])\n        }\n        i, j = 0, 0\n    }\n    return count\n}\n",
  "    var counter int\n    counter += strings.Count(myString, substring)\n    for\
    \ i := 0; i < len(myString); i++ {\n        if myString[i] == 'a' {\n        \
    \    continue\n        }\n        if strings.Contains(myString[i:i+len(substring)],\
    \ substring) {\n            counter++\n        }\n    }\n    return counter\n\
    }\n", "    return strings.Count(myString, substring)\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nHow do you make it case insensitive?\n<|/ c |>\n<| c |>\nIt's not\
    \ really a good idea to write your own package for case-insensitive string comparisons.\
    \  There are plenty of packages that do a fine job -- `strings.EqualFold` comes\
    \ to mind.  If you must write your own, I'd suggest making a small ", "    start\
    \ := 0\n    end := 0\n    length := 0\n    index := -1\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[index] {\n            if length ==\
    \ 0 {\n                start = i\n            }\n            length++\n      \
    \      if length == len(substring) {\n                end = i\n              \
    \  index = -1\n            }\n        } else {\n            if length > 0 {\n\
    \                length = 0\n            }\n        }\n    }\n    if length ==\
    \ 0 {\n        return 0\n    }\n    if length == len(substring) {\n        return\
    \ end - start + 1\n    }\n    return 0\n}\n", "    var count = 0\n    if len(myString)\
    \ == 0 || len(substring) == 0 {\n        return count\n    }\n    if substring\
    \ == myString[:len(substring)] {\n        return count\n    }\n    for i := 0;\
    \ i < len(myString); i++ {\n        if myString[i] == substring[0] {\n       \
    \     count += how_many_times(myString[i:], substring[1:])\n        }\n    }\n\
    \    return count\n}\n", "    if myString == \"\" {\n        return 0\n    }\n\
    \    if substring == \"\" {\n        return len(myString)\n    }\n\n    i := 0\n\
    \    foundString := \"\"\n    for {\n        if i == len(myString) {\n       \
    \     if foundString == substring {\n                return i + 1\n          \
    \  }\n            return 0\n        }\n        if myString[i] == substring[0]\
    \ {\n            foundString = foundString + substring[0]\n            i++\n \
    \           continue\n        }\n        if foundString == substring {\n     \
    \       return i + 1\n        }\n        i++\n    }\n    return 0\n}", "    var\
    \ counter = 1\n    for _, b := range substring {\n        for _, c := range myString\
    \ {\n            if b == c {\n                counter++\n            }\n     \
    \   }\n    }\n    return counter\n}\n", "    if myString == \"\" || substring\
    \ == \"\" {\n        return 0\n    }\n    // count overlapping cases\n    var\
    \ lastIndex int\n    var lastCount int\n    for index := 0; index < len(myString);\
    \ index++ {\n        if myString[index] == substring[0] {\n            lastIndex\
    \ = index\n            lastCount++\n            myString = myString[index+1:]\n\
    \        } else {\n            // myString doesn't match the substring. Need to\
    \ check if substring is overlapping with the previous substring\n            if\
    \ lastCount > 0 {\n                return lastCount\n            }\n         \
    \   // Found a unique substring. No need to check the previous ones\n        \
    \    lastIndex = index\n            lastCount = 1\n        }\n    }\n    if lastIndex\
    \ != 0 {\n        return lastCount\n    }\n    return 0\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nYour code will count the number of overlapping occurrences. However,\
    \ as per the example in the question, if the substring was 'aaa' and string was\
    \ 'aaaaa', the result should be 3. The above answer will return 1.\n<|/ c |>\n\
    <| c |>\n, thanks for the comment. I've updated the answer to fix the issue.\n\
    <|/ c |>\n<| c |>\nThank you for the update. It works perfectly for me now.\n\
    <|/ c |>\n<| c |>\nThis answer can be extended to take into account the fact that\
    \ substrings can be repeated, using the following algorithm: https://stackoverflow.com/a/65666535/1504394\n\
    <|/ c |>\n<| a tags=string,algorithm,python dscore=4 |>\nUsing itertools.groupby:\n\
    <code>\nfrom itertools import groupby\n\ndef count_substrings(string, substring):\n\
    \    return sum((len(list(g)) for k,g in groupby(string) if k==substring), \n\
    \               0)\n</code>\n<|/ a |>\n<| c |>\nThis is better than my answer\
    \ (upvoted), but fails to give the right answer if the string starts with the\
    \ substring, e.g. `count_substrings(\"aaaaa\",\"a\")` returns `2` instead of `1`.\
    \  Also fails when the substring occurs more than once in the string, e.g. `count_substrings(\"\
    aaa\",\"a\")` returns `3` instead of `1`.\n<|/ c |>\n<| c |>\nI like how you reuse\
    \ your groupby.\n<|/ c |>\n<| c |>\nI like how you use `sum` which gives the right\
    \ answer when the substring occurs more than once, even if the string is shorter\
    \ than the substring.  Great answer.\n<|/ c |>\n<| c |>\nYeah great answer.\n\
    <|/ c |>\n<| a dscore=", "    counter := 0\n    for _, character := range myString\
    \ {\n        if character == substring {\n            counter++\n        }\n \
    \   }\n    return counter\n}\n</code>\n<|/ a dscore=1 tags=string,go |>\n<| a\
    \ dscore=0 tags=string,go |>\nA variation of the solution from https://stackoverflow.com/a/41344788/1377135\
    \ with added error checking:\n<code>", "    var result int\n    if myString ==\
    \ \"\" {\n        return 0\n    }\n    if substring== \"\" {\n        return result\n\
    \    }\n    for i := 0; i < len(myString); i++ {\n        if i == len(myString)\
    \ {\n            result++\n        }\n        if myString[i] == substring[0] {\n\
    \            for j := 1; j < len(substring); j++ {\n                if (i+j) >\
    \ len(myString) {\n                    break\n                }\n            \
    \    if myString[i+j] == substring[j] {\n                    result++\n      \
    \          } else {\n                    break\n                }\n          \
    \  }\n        } else {\n            result++\n        }\n    }\n    return result\n\
    }\n", "    n := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            for j := 1; j < len(substring); j++ {\n     \
    \           if myString[i+j] == substring[j] {\n                    n++\n    \
    \            }\n            }\n        }\n    }\n    return n\n}\n", "    if len(myString)\
    \ == 0 {\n        return 0\n    }\n\n    lastIndex := strings.Index(myString,\
    \ substring)\n    if lastIndex == -1 {\n        return 0\n    }\n\n    count :=\
    \ 0\n    lastIndex := lastIndex + len(substring)\n    for i := 0; i < len(myString);\
    \ i++ {\n        if i == lastIndex {\n            count++\n            continue\n\
    \        }\n\n        if strings.Contains(myString[i:], substring) {\n       \
    \     count++\n        } else {\n            count = 0\n        }\n\n        break\n\
    \    }\n\n    return count\n}\n", "    result := 0\n    i := 0\n    for ; i <\
    \ len(myString); i++ {\n        if myString[i] == substring[0] {\n           \
    \ myString = myString[i:]\n            i = 0\n        } else if myString[i] !=\
    \ substring[0] {\n            break\n        }\n        if myString[i] == substring[1]\
    \ {\n            myString = myString[i:]\n            i = 0\n        } else if\
    \ myString[i] != substring[1] {\n            result += 1\n            myString\
    \ = myString[i:]\n            i = 0\n        }\n    }\n    return result\n}\n",
  "    start := 0\n    end := 0\n    for {\n        start += 1\n        if myString[start:start+len(substring)]\
    \ == substring {\n            end += 1 // End if first character matched\n   \
    \     } else if myString[start:start+len(substring)] == substring[:len(substring)-1]\
    \ {\n            end += 2 // End if last character matched\n        } else {\n\
    \            break\n        }\n    }\n    return end - start\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
