language: go_test.go
name: HumanEval_9_rolling_max
results:
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n\n    // Get first element\n    result := numbers[:len(numbers):len(numbers)]\n\
    \    firstMaxIdx := 0\n\n    // For each element get max index after the first\
    \ element\n    for idx, elem := range numbers[1:] {\n        firstMaxIdx = idx\
    \ + 1\n        if elem > result[firstMaxIdx] {\n            break\n        }\n\
    \    }\n\n    // Now we have the max in the first place\n    return result\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeeg_1g7i_test.go:19:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling := []int{}\n    prev := 0\n    for _, number := range numbers\
    \ {\n        if prev+number > len(numbers) {\n            rolling = append(rolling,\
    \ prev)\n        }\n        prev = prev + number\n    }\n    return rolling\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp5iz8lo8g_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=3) %!s(int=6)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp5iz8lo8g_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=7) %!s(int=9)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmp5iz8lo8g_test.go:40: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=5) %!s(int=8) %!s(int=108)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Find the rolling maximum from the first to the last element\
    \ in the list of given numbers, using given number as rolling maximum element\
    \ in the sequence\n    // Start rolling max at index 0, and increment by 1\n \
    \   var rollingMaxList []int\n    for i := range numbers {\n        rollingMaxList\
    \ = append(rollingMaxList, numbers[i])\n        // Stop rolling max when rolling\
    \ max reaches number equal to rollingMaxList[0]\n        if rollingMaxList[0]\
    \ > numbers[i] {\n            break\n        }\n    }\n\n    return rollingMaxList\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpcwb7fnyy_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpcwb7fnyy_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var current int\n    var maximum int\n    result := make([]int,\
    \ 0)\n    for _, num := range numbers {\n        if num > current {\n        \
    \    maximum = num\n        }\n        current = num\n        result = append(result,\
    \ maximum)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n\n    for _, n := range numbers {\n \
    \       for i := 0; i < n; i++ {\n            result = append(result, max(result))\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps6_93qkp_test.go:17:37: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, len(numbers))\n    current := numbers[0]\n\
    \    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > current {\n\
    \            current = numbers[i]\n            output[i] = current\n        }\n\
    \    }\n    return output\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp100y7deg_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp100y7deg_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max_elements := []int{}\n    rolling_max_index = -1\n \
    \   rolling_max_index = len(numbers)\n    for i := 0; i < rolling_max_index; i++\
    \ {\n        rolling_max_elements = append(rolling_max_elements, numbers[i])\n\
    \        if i == rolling_max_index-1 {\n            break\n        }\n       \
    \ if numbers[i] > numbers[i+1] {\n            rolling_max_elements = append(rolling_max_elements,\
    \ numbers[i+1])\n            rolling_max_index = i+1\n        }\n    }\n    return\
    \ rolling_max_elements\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiwuultxl_test.go:14:5: undefined: rolling_max_index

    /tmp/tmpiwuultxl_test.go:15:5: undefined: rolling_max_index

    /tmp/tmpiwuultxl_test.go:16:21: undefined: rolling_max_index

    /tmp/tmpiwuultxl_test.go:18:17: undefined: rolling_max_index

    /tmp/tmpiwuultxl_test.go:23:13: undefined: rolling_max_index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n    for _, num := range numbers {\n        max =\
    \ append(max, num)\n    }\n    for i := range max {\n        for _, j := range\
    \ numbers {\n            if j > max[i] {\n                max[i] = j\n       \
    \     }\n        }\n    }\n    return max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpc78if80a_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpc78if80a_test.go:43: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, 0)\n    result <-\
    \ max\n    for _, n := range numbers[1:] {\n        if n > max {\n           \
    \ max = n\n            result = append(result, n)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppq4hu5rg_test.go:15:5: invalid operation: cannot send to non-channel result
    (variable of type []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := []int{}\n\n    max := numbers[0]\n    i := 0\n\n    // we\
    \ find rolling max until we hit first element\n    for len(numbers) > 0 && i <\
    \ len(numbers) {\n        if numbers[i] >= max {\n            max = numbers[i]\n\
    \        } else {\n            res = append(res, max)\n            max = numbers[i]\n\
    \        }\n        i++\n    }\n\n    // we add last max if needed\n    if len(numbers)\
    \ > 0 && i < len(numbers) {\n        res = append(res, max)\n    }\n\n    return\
    \ res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp0mrhj8e4_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp0mrhj8e4_test.go:44\
    \ +0x18\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    var current []int\n    for _, number :=\
    \ range numbers {\n        if number > max {\n            current = []int{number}\n\
    \            max = number\n        } else {\n            current = append(current,\
    \ number)\n        }\n    }\n    return current\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpxlpsg81v_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpxlpsg81v_test.go:33\
    \ +0x18\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var index int = 0\n\n    for number := range\
    \ numbers {\n        result = append(result, number)\n        if index == 0 {\n\
    \            index = index + 1\n        } else {\n            if number > result[index-1]\
    \ {\n                index = index + 1\n            }\n        }\n    }\n\n  \
    \  return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpl4bhjkou_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpl4bhjkou_test.go:46: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpl4bhjkou_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    found := 0\n    for _,\
    \ n := range numbers {\n        if found+n > len(result) {\n            result\
    \ = append(result, n)\n            found++\n        } else {\n            result[found]\
    \ = n\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpjbq3ux7f_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpjbq3ux7f_test.go:42: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpjbq3ux7f_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    var max\
    \ int\n    i := 0\n    for ; i < len(numbers); i++ {\n        if numbers[i] >\
    \ max {\n            max = numbers[i]\n        }\n    }\n    var result []int\n\
    \    i := 0\n    for ; i < len(numbers); i++ {\n        if numbers[i] > max {\n\
    \            result = append(result, max)\n            max = numbers[i]\n    \
    \    }\n    }\n    for ; i < len(numbers); i++ {\n        result = append(result,\
    \ numbers[i])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttt8gjdj_test.go:24:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, len(numbers))\n  \
    \  for i, v := range numbers {\n        if v > max {\n            max = v\n  \
    \      }\n        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpsc3oni72_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpsc3oni72_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers);\
    \ i++ {\n        result[i] = numbers[i]\n    }\n    return rollingMax(result,\
    \ len(numbers)-1, 0)\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6zhomp7_test.go:17:12: undefined: rollingMax

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    var curmax int\n\n    for _, v := range\
    \ numbers {\n        if v > curmax {\n            rolling_max = append(rolling_max,\
    \ curmax)\n            curmax = v\n        } else {\n            curmax = v\n\
    \        }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpfcrux32o_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpfcrux32o_test.go:43: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0)]'\n    ---\
    \ FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpfcrux32o_test.go:43: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=0)\
    \ %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    number := numbers[0]\n    result := make([]int, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        if number == numbers[i] {\n\
    \            result[i] = number\n        } else {\n            result[i] = number\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmph6kwn4u9_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmph6kwn4u9_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    for _, v := range numbers {\n        if max <\
    \ v {\n            max = v\n        }\n    }\n    return []int{max}\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0\
    \ (0.00s)\n        tmpr2k02310_test.go:38: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpr2k02310_test.go:38:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpr2k02310_test.go:38:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpr2k02310_test.go:38:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    r := make([]int, len(numbers))\n    max := numbers[0]\n    for\
    \ i := 0; i < len(numbers); i++ {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        if i >= len(numbers)-1 {\n            break\n\
    \        }\n    }\n    for i := 0; i < len(numbers); i++ {\n        r[i] = max\n\
    \    }\n    return r\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp4ysoo2_0_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp4ysoo2_0_test.go:36\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return rolling_max(numbers, 0)\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr3yg6n03_test.go:13:33:\
    \ too many arguments in call to rolling_max\n\thave ([]int, number)\n\twant ([]int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    for _, number := range numbers {\n     \
    \   if number > max {\n            max = number\n        }\n    }\n    return\
    \ numbers[:0]\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpn9dkou9e_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpn9dkou9e_test.go:29\
    \ +0x18\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    var i int\n    for i = 0; i < len(numbers);\
    \ i++ {\n        if numbers[i] > numbers[len(numbers)-1] {\n            result\
    \ = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmppoobe50p_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmppoobe50p_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmppoobe50p_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074127
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    i := 0\n    for number := range numbers\
    \ {\n        if i < number {\n            result = append(result, numbers[i])\n\
    \            i++\n        } else {\n            result = append(result, numbers[i])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp1819ri7o_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmp1819ri7o_test.go:42: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp1819ri7o_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    var maxIndex int\n    var lastMaxIndex\
    \ int\n\n    for _, number := range numbers {\n        // find previous maximum\
    \ index\n        if lastMaxIndex != -1 {\n            if lastMaxIndex < number\
    \ {\n                lastMaxIndex = number\n            }\n        }\n\n     \
    \   if number > numbers[maxIndex] {\n            maxIndex = number\n         \
    \   lastMaxIndex = number\n        }\n\n        result = append(result, lastMaxIndex)\n\
    \    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [100] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [100] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpooase8uk_test.go:25\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpooase8uk_test.go:46\
    \ +0x72b\ntesting.tRunner(0xc0001a0340, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var start int\n    for _, val := range numbers\
    \ {\n        start = val\n        result = append(result, val)\n    }\n    for\
    \ _, val := range result {\n        for i := start; i <= val; i++ {\n        \
    \    numbers = append(numbers, i)\n        }\n    }\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp0utybswj_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmp0utybswj_test.go:43: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n\n    max\
    \ := numbers[0]\n    result := make([]int, len(numbers))\n    for idx, _ := range\
    \ result {\n        result[idx] = max\n        if idx == 0 {\n            continue\n\
    \        }\n        if result[idx] < numbers[idx-1] {\n            result[idx]\
    \ = numbers[idx-1]\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpvqaao8jr_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpvqaao8jr_test.go:48: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_numbers = make([]int, 0)\n    max_numbers = append(max_numbers,\
    \ numbers...)\n    if len(max_numbers) == 1 {\n        return max_numbers\n  \
    \  }\n\n    rolling_max_found := make([]int, 0)\n    rolling_max_found := append(rolling_max_found,\
    \ max_numbers...)\n    if len(rolling_max_found) == 1 {\n        return rolling_max_found\n\
    \    }\n\n    max_to_find := max_numbers[0]\n    for _, number := range max_numbers\
    \ {\n        max_to_find = number\n        if max_numbers[len(max_numbers)-1]\
    \ < max_to_find {\n            rolling_max_found[len(rolling_max_found)-1] = max_to_find\n\
    \        }\n    }\n\n    return rolling_max_found\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpps_znd3x_test.go:20:23: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := numbers[:0]\n    rolling_max_idx := 0\n    for idx\
    \ := range numbers {\n        if idx > rolling_max_idx {\n            rolling_max\
    \ = append(rolling_max, numbers[idx])\n            rolling_max_idx = idx\n   \
    \     }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpun4uv1qb_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpun4uv1qb_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpun4uv1qb_test.go:40: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n\n    j := 0\n    currentMax\
    \ := numbers[0]\n    for _, n := range numbers {\n        if n > currentMax {\n\
    \            currentMax = n\n            j = i + 1\n        }\n        if j ==\
    \ len(numbers) {\n            break\n        }\n        result[j] = currentMax\n\
    \        j++\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9k6gv6zc_test.go:20:17: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n\n    for _, number := range numbers\
    \ {\n        if number < len(result) {\n            result = append(result, result[number])\n\
    \        }\n\n        result = append(result, number)\n    }\n\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp6q178rx2_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=1)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp6q178rx2_test.go:42:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Find the rolling maximum value that could fit in given numbers\
    \ list\n    max := numbers[0]\n    for _, value := range numbers {\n        if\
    \ (value > max) {\n            max = value\n        }\n    }\n\n    // Generate\
    \ a list of values before max\n    result := make([]int, 0)\n    for _, value\
    \ := range numbers {\n        if value == max {\n            break\n        }\n\
    \        result = append(result, value)\n    }\n\n    // Generate a list of values\
    \ after max\n    for _, value := range numbers[len(numbers)-1:] {\n        if\
    \ value == max {\n            break\n        }\n        result = append(result,\
    \ value)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpdfj8n6bj_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpdfj8n6bj_test.go:48\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Sort numbers to improve lookup performance.\n    sort.Ints(numbers)\n\
    \n    // Start with rolling minimum, maximum and minimum index.\n    // For maximum,\
    \ the previous maximum is the starting point.\n    minimumIndex := 0\n    maximum\
    \ := numbers[0]\n    maximumIndex := 1\n    // For minimum, the previous minimum\
    \ is the starting point.\n    minimum = numbers[0]\n    minimumIndex = 1\n\n \
    \   // For each number in numbers, calculate the rolling maximum and minimum.\n\
    \    for _, n := range numbers {\n        current := n\n        // Start rolling\
    \ minimum.\n        minimum = minimumIndex == 1 ? current : minimum\n        //\
    \ Update minimumIndex.\n        if current < minimum {\n            minimumIndex\
    \ = minimumIndex + 1\n        }\n\n        // Start rolling maximum.\n       \
    \ maximum = maximumIndex == len(numbers) ? current : maximum\n        // Update\
    \ maximumIndex.\n        if current > maximum {\n            maximumIndex = maximumIndex\
    \ + 1\n        }\n    }\n\n    return numbers[:maximumIndex]\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8lt4zw1u_test.go:29:37: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074129
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return rolling_max_recursive(numbers, 0, 0, len(numbers))\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7t4biujg_test.go:13:12: undefined: rolling_max_recursive

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    max := numbers[0]\n    for _, n :=\
    \ range numbers {\n        if n > max {\n            max = n\n        }\n    \
    \    result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpe651t7gj_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpe651t7gj_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    rolling_max_list := make([]int, 0, 10)\n\
    \    for _, value := range numbers {\n        if value > max {\n            rolling_max_list\
    \ = append(rolling_max_list, max)\n            max = value\n        } else {\n\
    \            max = value\n        }\n    }\n    rolling_max_list = append(rolling_max_list,\
    \ max)\n    return rolling_max_list\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp2j8glv4r_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp2j8glv4r_test.go:34\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    for _, number := range numbers {\n\
    \        result = append(result, number)\n        if len(result) > len(numbers)\
    \ {\n            result = result[len(numbers):]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmprj_uv5rk_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmprj_uv5rk_test.go:39: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, 0, len(numbers))\n    if len(numbers)\
    \ == 0 {\n        return rolling_max\n    }\n\n    for i, number := range numbers\
    \ {\n        // Add current number to rolling max\n        rolling_max = append(rolling_max,\
    \ number)\n\n        // Iterate over the rest of the numbers and keep rolling\
    \ max until\n        // it reaches the current number\n        for _, numberAfter\
    \ := range numbers[i+1:] {\n            if numberAfter > number {\n          \
    \      rolling_max = append(rolling_max, numberAfter)\n            } else {\n\
    \                break\n            }\n        }\n    }\n\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpyeoqddgn_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpyeoqddgn_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpyeoqddgn_test.go:52: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)\
    \ %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rollingMax := []int{}\n    rollingMax = append(rollingMax, numbers[0])\n\
    \    for _, number := range numbers[1:] {\n        rollingMax = append(rollingMax,\
    \ numbers[len(rollingMax)-1])\n    }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjm6hc1sx_test.go:15:12: number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max_i := []int{}\n    i := 0\n\n    if len(numbers) ==\
    \ 0 {\n        return []int{}\n    }\n    for _, number := range numbers {\n \
    \       for ; i < number; i++ {\n            rolling_max_i = append(rolling_max_i,\
    \ number)\n        }\n    }\n\n    return rolling_max_i\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmps3jvmm2v_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)\
    \ %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    for i, v := range numbers {\n        result[i]\
    \ = v\n    }\n    for i := 1; i < len(numbers); i++ {\n        result[i] = max(result[i-1],\
    \ result[i])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9wlebr19_test.go:21:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    found := false\n    i := 0\n    for i < len(numbers)\
    \ {\n        number := numbers[i]\n        if len(result) == 0 {\n           \
    \ result = append(result, number)\n        } else if number > result[len(result)-1]\
    \ {\n            result = append(result, number)\n        } else {\n         \
    \   if number == result[len(result)-1] {\n                continue\n         \
    \   } else {\n                result = append(result, number)\n            }\n\
    \        }\n        found = true\n    }\n    if !found {\n        result = append(result,\
    \ numbers[i])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp38_6fv4o_test.go:32\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp38_6fv4o_test.go:44\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // initialize result list\n    result := make([]int, 0)\n    //\
    \ initialize maximum number\n    max := numbers[0]\n    // iterate through the\
    \ numbers and keep track of maximum number\n    for _, v := range numbers {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    // append max\
    \ to the result\n    result = append(result, max)\n    // iterate through numbers\
    \ again and keep track of which number in the list is the largest so far\n   \
    \ for _, v := range numbers {\n        if v == max {\n            result = append(result,\
    \ v)\n        }\n    }\n    // return the result\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmparps6zle_test.go:16\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmparps6zle_test.go:42\
    \ +0x2f\ntesting.tRunner(0xc0001991e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, n := range numbers {\n        if n < min {\n            min = n\n\
    \        }\n        if n > max {\n            max = n\n        }\n    }\n    for\
    \ i, n := range numbers {\n        if n < min {\n            continue\n      \
    \  }\n        if n > max {\n            result = append(result, min)\n       \
    \     break\n        }\n        if n == max {\n            result = append(result,\
    \ max)\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2xr7l6jp_test.go:24:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    var maxValues\
    \ []int\n    var maxNumber int = 0\n    for _, v := range numbers {\n        if\
    \ v > maxNumber {\n            maxNumber = v\n            maxValues = []int{v}\n\
    \        } else {\n            maxValues = append(maxValues, v)\n        }\n \
    \   }\n\n    for _, maxValue := range maxValues {\n        numbers = append(numbers,\
    \ maxValue)\n    }\n    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpqj_lt7b1_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=4)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqj_lt7b1_test.go:49:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqj_lt7b1_test.go:49: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    result\
    \ := make([]int, 0, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n \
    \       number := numbers[i]\n        var maxNumber int\n        for j := 0; j\
    \ < len(result); j++ {\n            if result[j] > number {\n                maxNumber\
    \ = result[j]\n            }\n        }\n        result = append(result, maxNumber)\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpl8wp1jci_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpl8wp1jci_test.go:46: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpl8wp1jci_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    moment := 0\n\n    for _, number := range\
    \ numbers {\n        // If new moment is greater than given moment, continue with\
    \ new moment\n        if number > moment {\n            moment = number\n    \
    \        continue\n        }\n\n        // Append current number to result\n \
    \       result = append(result, number)\n\n        // Move moment by one and continue\
    \ if new moment is greater than given moment\n        moment = number + 1\n  \
    \  }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpbwx1xu84_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpbwx1xu84_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpbwx1xu84_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    var rolling_max []int\n\n    for i := 1;\
    \ i < len(numbers); i++ {\n        if max < numbers[i] {\n            max = numbers[i]\n\
    \        }\n        rolling_max = append(rolling_max, max)\n    }\n    return\
    \ rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpe8ntz4lc_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpe8ntz4lc_test.go:32\
    \ +0x18\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // To store the rolling max element found so far\n    result :=\
    \ make([]int, 0)\n\n    // For loop to iterate through given sequence\n    for\
    \ _, number := range numbers {\n        switch number {\n        case 0:\n   \
    \         result = append(result, number)\n            break\n        case 1:\n\
    \            result = append(result, number)\n            break\n        case\
    \ 2:\n            result = append(result, number)\n            break\n       \
    \ case 3:\n            result = append(result, number)\n            break\n  \
    \      case 4:\n            result = append(result, number)\n            break\n\
    \        default:\n            result := append(result, number)\n        }\n \
    \   }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf789f03_test.go:35:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n\n    if len(numbers) < 2 {\n       \
    \ return result\n    }\n\n    result.Sort()\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        j := i\n\n        for j > 0 && numbers[j-1] > numbers[j] {\n\
    \            j, result = j, result[:j]\n        }\n        result = append(result,\
    \ numbers[j])\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1_jmkk4h_test.go:19:12: result.Sort undefined (type []int has no field
    or method Sort)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Initialize output array \n    var output []int\n    \n    //\
    \ Initialize max \n    max := numbers[0]\n    \n    // Iterate through numbers\
    \ \n    for _, number := range numbers {\n        // If current number is greater\
    \ than max \n        if number > max {\n            // Set max to current number\
    \ \n            max = number\n        }\n    }\n    \n    // Add max to the output\
    \ list \n    output = append(output, max)\n    \n    // Iterate through numbers\
    \ \n    for _, number := range numbers {\n        // If current number is less\
    \ than the max, then \n        // append the current number to the output list\
    \ \n        if number < max {\n            output = append(output, number)\n \
    \       }\n    }\n    \n    // Return output list \n    return output\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpaepewx5j_test.go:17\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpaepewx5j_test.go:51\
    \ +0x18\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return nil\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmppkqh2aav_test.go:32: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmppkqh2aav_test.go:32: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmppkqh2aav_test.go:32:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maximum []int\n\n    for _, number := range numbers {\n   \
    \     if !contains(maximum, number) {\n            maximum = append(maximum, number)\n\
    \        }\n    }\n\n    return maximum\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_rpopr_c_test.go:16:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_list []int\n    max := numbers[0]\n    number := 0\n\n\
    \    for _, element := range numbers {\n        if element == max {\n        \
    \    max_list = append(max_list, max)\n            number += 1\n            max\
    \ = element\n            continue\n        }\n\n        if number > 0 {\n    \
    \        max_list = append(max_list, max)\n            number += 1\n        }\n\
    \n        max = element\n    }\n\n    if number > 0 {\n        max_list = append(max_list,\
    \ max)\n        number += 1\n    }\n\n    return max_list\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 19 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmppnmnd70__test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmppnmnd70__test.go:48\
    \ +0x18\ntesting.tRunner(0xc000103380, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    for i, v := range numbers {\n        for j\
    \ := i + 1; j <= len(numbers); j++ {\n            if numbers[j] > v {\n      \
    \          result[i] = numbers[j]\n                break\n            }\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp1sl9gxi8_test.go:19\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp1sl9gxi8_test.go:36\
    \ +0x547\ntesting.tRunner(0xc0001a0340, 0x528020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    return\
    \ rolling_max(numbers[1:], numbers[0])\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp4qx1mjk_test.go:16:37:\
    \ too many arguments in call to rolling_max\n\thave ([]int, int)\n\twant ([]int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int = 0\n    var rolling []int\n    for _, number := range\
    \ numbers {\n        if number > max {\n            max = number\n           \
    \ rolling = make([]int, 0, max)\n            rolling = append(rolling, number)\n\
    \        } else if number == max {\n            rolling = append(rolling, number)\n\
    \        }\n    }\n    return rolling\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpfby83_xk_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpfby83_xk_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpfby83_xk_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n    for _, number := range numbers {\n        if\
    \ max != nil {\n            if numbers[len(max)-1] < number {\n              \
    \  max = append(max, number)\n            }\n        } else {\n            max\
    \ = append(max, number)\n        }\n    }\n    return max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp1h_j3r6u_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmp1h_j3r6u_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    current := 0\n    max\
    \ := numbers[0]\n    for _, n := range numbers[1:] {\n        if n > max {\n \
    \           max = n\n            result = append(result, max)\n        } else\
    \ {\n            current = n\n        }\n    }\n    result = append(result, max)\n\
    \    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnz95chb_test.go:14:5: current declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil || len(numbers) == 0 {\n        return numbers\n\
    \    }\n    max := numbers[0]\n    i := 1\n    for len(numbers) > 0 && i < len(numbers)\
    \ {\n        if max < numbers[i] {\n            max = numbers[i]\n        }\n\
    \        i++\n    }\n    return numbers[:i]\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp64p6o4r9_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmp64p6o4r9_test.go:43: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return []int{numbers[0]}\n    }\n\
    \    max := numbers[0]\n    numbers := numbers[1:]\n    for _, number := range\
    \ numbers {\n        if max < number {\n            max = number\n        }\n\
    \    }\n    return []int{max}\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzqo8294__test.go:17:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    ret := make([]int, 0)\n    for i := 0; i < len(numbers); i++ {\n\
    \        numbersInCurrentRoll := numbers[i: i+min(len(numbers), (i+1)-len(numbers))]\n\
    \        if len(numbersInCurrentRoll) > 0 {\n            ret = append(ret, numbersInCurrentRoll[0])\n\
    \        }\n    }\n    return ret\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7k9zbvtr_test.go:15:46: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    n := 0\n    max := numbers[0]\n    rolling := make([]int, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        if max < numbers[i] {\n    \
    \        max = numbers[i]\n            n++\n        }\n        rolling[n] = max\n\
    \    }\n    return rolling\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp2wrbi1zu_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp2wrbi1zu_test.go:33\
    \ +0x18\ntesting.tRunner(0xc00019e000, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    for i, number := range\
    \ numbers {\n        result = append(result, number)\n        if i == len(numbers)-1\
    \ {\n            break\n        }\n        for _, v := range result {\n      \
    \      if number > v {\n                result = append(result,v)\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpdyf2l892_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpdyf2l892_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpdyf2l892_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=2)\
    \ %!s(int=100) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=3)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max = numbers[0]\n    for _, number := range numbers {\n  \
    \      if number > max {\n            max = number\n        }\n    }\n    return\
    \ []int{max}\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5c9e4xme_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5c9e4xme_test.go:29\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    \n  \
    \  numbers := append([]int{}, numbers...)\n    \n    max := numbers[0]\n    i\
    \ := 1\n    for len(numbers) > 0 {\n        if max < numbers[i] {\n          \
    \  max = numbers[i]\n        }\n        numbers = numbers[i:]\n        i = i +\
    \ 1\n    }\n    \n    return numbers[0:i]\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1jn00esr_test.go:17:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_numbers []int\n    for _, number := range numbers {\n \
    \       max_numbers = append(max_numbers, number)\n    }\n\n    max_numbers =\
    \ rolling_max_recur(max_numbers, 0, len(numbers))\n    return max_numbers\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkvoy3du4_test.go:18:19: undefined: rolling_max_recur

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    numbers := make([]int, len(numbers))\n    for i := 0; i < len(numbers);\
    \ i++ {\n        numbers[i] = numbers[len(numbers)-1-i]\n    }\n    return numbers\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ndz0eh6_test.go:13:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, 0, len(numbers))\n\
    \    for _, num := range numbers {\n        if num > max {\n            result\
    \ = append(result, max)\n            max = num\n        } else {\n           \
    \ max = num\n        }\n    }\n    result = append(result, max)\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp_l8doee6_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp_l8doee6_test.go:34\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    max := numbers[0]\n    for _, number\
    \ := range numbers[1:] {\n        max = number > max ? number : max\n        rolling_max\
    \ = append(rolling_max, max)\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgnz3cj41_test.go:16:28: illegal character U+003F ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074132
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    for _, number := range numbers {\n     \
    \   if number > max {\n            max = number\n        }\n    }\n    result\
    \ := []int{}\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] !=\
    \ max {\n            result = append(result, max)\n        }\n        max = numbers[i]\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp8x5j4xyx_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp8x5j4xyx_test.go:36\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    index := 0\n    max_index := 0\n\n    // Initialize rolling max\
    \ with first element\n    rolling_max := numbers[index]\n\n    // Iterate over\
    \ all elements until the index\n    for index := 1; index < len(numbers); index++\
    \ {\n        if rolling_max < numbers[index] {\n            rolling_max = numbers[index]\n\
    \            max_index = index\n        }\n    }\n\n    return rolling_max\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnrjtwkss_test.go:14:5: max_index declared but not used

    /tmp/tmpnrjtwkss_test.go:27:12: cannot use rolling_max (variable of type int)
    as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074133
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    max := numbers[0]\n\
    \    max := numbers[0]\n    for _, num := range numbers {\n        if num > max\
    \ {\n            max = num\n        }\n    }\n    max := max\n    for _, num :=\
    \ range numbers {\n        if num > max {\n            max = num\n        } else\
    \ {\n            result = append(result, max)\n            max = num\n       \
    \ }\n    }\n    return append(result, max)\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplkyxt2bw_test.go:15:9: no new variables on left side of :=

    /tmp/tmplkyxt2bw_test.go:21:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074133
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // initialize new array and add the first number\n    var rollingMax\
    \ []int = []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n       \
    \ // if the current number is larger than the last one in the rolling max\n  \
    \      if numbers[i] > rollingMax[len(rollingMax)-1] {\n            // add it\
    \ to the new rolling max array\n            rollingMax = append(rollingMax, numbers[i])\n\
    \        }\n    }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp2hed82i9_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp2hed82i9_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := numbers[:0]\n    rolling_max = append(rolling_max,\
    \ numbers[0])\n    for _, number := range numbers[1:] {\n        if number > rolling_max[len(rolling_max)-1]\
    \ {\n            rolling_max = append(rolling_max, number)\n        }\n    }\n\
    \    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpugrtrs9k_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpugrtrs9k_test.go:30\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074134
- exit_code: null
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, len(numbers))\n    current := 0\n    start\
    \ := 0\n    for current < len(numbers) {\n        switch current {\n        case\
    \ len(numbers):\n            output[start] = numbers[start]\n            break\n\
    \        default:\n            output[start] = numbers[current]\n        }\n\n\
    \        current++\n\n        if current == len(numbers)-1 {\n            current\
    \ = 0\n            start = current + 1\n        }\n    }\n\n    return output\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074147
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rollingMax := make([]int, len(numbers))\n    i := 0\n    for range\
    \ numbers {\n        rollingMax[i] = numbers[i]\n        if i+1 == len(numbers)\
    \ {\n            break\n        }\n        i++\n    }\n    return rollingMax\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpqgioi3yx_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpqgioi3yx_test.go:41: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling := []int{}\n    for i := 0; i < len(numbers); i++ {\n \
    \       if numbers[i] != rolling[len(rolling)-1] {\n            rolling = append(rolling,\
    \ numbers[i])\n        }\n    }\n    return rolling\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmptozotfti_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmptozotfti_test.go:30\
    \ +0x6dc\ntesting.tRunner(0xc0001a0340, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // The list of rolling max element found until now is the same\
    \ as original numbers list except for the last element.\n    rolling_max := numbers[:len(numbers)-1]\n\
    \n    // Generate rolling max elements from the list until given moment.\n   \
    \ for i := len(numbers) - 1; i >= 0; i-- {\n        // Calculate the current rolling\
    \ max element found at current index.\n        rolling_max = append(rolling_max,\
    \ numbers[i])\n\n        // If the current rolling max element found at current\
    \ index equal to the given moment in given list.\n        if rolling_max[len(rolling_max)-1]\
    \ == numbers[i] {\n            // Break the current loop.\n            break\n\
    \        }\n    }\n\n    // Return the current list of rolling max element found\
    \ until given moment.\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnvjexsfp_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnvjexsfp_test.go:39\
    \ +0x1c\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n\n    if len(numbers) < 1 {\n        return max\n\
    \    }\n\n    for _, num := range numbers {\n        var max_found int\n     \
    \   for i := 0; i < len(numbers)-max; i++ {\n            if numbers[i] > num {\n\
    \                max_found++\n                if max_found > len(max) {\n    \
    \                max = make([]int, max_found)\n                }\n           \
    \     max := append(max, numbers[i])\n                break\n            }\n \
    \       }\n    }\n\n    return max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd3x9tzyt_test.go:21:25: invalid operation: len(numbers) - max (mismatched
    types int and []int)

    /tmp/tmpd3x9tzyt_test.go:27:17: max declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maxes []int\n    var max int\n    for _, number := range numbers\
    \ {\n        max = number\n        if max > max {\n            maxes = make([]int,\
    \ 0)\n        }\n        maxes = append(maxes, max)\n    }\n    return maxes\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpgobxrsn5_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpgobxrsn5_test.go:41: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    n := len(numbers)\n    current := 0\n    output := make([]int,\
    \ n)\n\n    for i := 0; i < n; i++ {\n        currentMax, current := findMax(current,\
    \ numbers)\n        output[i] = currentMax\n    }\n    return output\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg9syrbnr_test.go:18:32: undefined: findMax

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    max := numbers[0]\n\n    for _, number :=\
    \ range numbers {\n        if number > max {\n            result = append(result,\
    \ max)\n            max = number\n        } else {\n            max = number\n\
    \        }\n    }\n\n    return append(result, max)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpk38p7y1n_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpk38p7y1n_test.go:35\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_number int\n    var max_idx int\n    var max_value int\n\
    \    var i int\n    for i = 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > numbers[max_idx] {\n            max_value = numbers[i]\n            max_idx\
    \ = i\n        }\n    }\n    max_value = numbers[max_idx]\n    numbers = numbers[:max_idx]\n\
    \    max_value = numbers[max_idx]\n    numbers = append(numbers, max_value)\n\
    \    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpexlugq24_test.go:13:9: max_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    max :=\
    \ numbers[0]\n    rollingMax := numbers[:0]\n    for i, number := range numbers\
    \ {\n        if number > max {\n            rollingMax = append(rollingMax, max)\n\
    \            max = number\n        } else {\n            max = number\n      \
    \  }\n    }\n    return append(rollingMax, max)\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnl_sukxz_test.go:18:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    max := numbers[0]\n    for _, v := range\
    \ numbers {\n        if v > max {\n            max = v\n        }\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpikbmv5qy_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpikbmv5qy_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result\
    \ := []int{}\n    current := numbers[0]\n    for _, n := range numbers {\n   \
    \     if n > current {\n            result = append(result, current)\n       \
    \     current = n\n        } else {\n            current = n\n        }\n    }\n\
    \    result = append(result, current)\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpr6wj121z_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpr6wj121z_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    i := 0\n    for _, number := range\
    \ numbers {\n        numbers = numbers[i:number]\n        number := numbers[i]\n\
    \        if number > result {\n            result = number\n        }\n      \
    \  i = number + 1\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6uibkn4b_test.go:18:21: invalid operation: number > result (mismatched
    types int and []int)

    /tmp/tmp6uibkn4b_test.go:19:22: cannot use number (variable of type int) as type
    []int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    numbers\
    \ := make([]int, len(numbers))\n    rollingMax := numbers[0]\n    i := 0\n   \
    \ for _, v := range numbers {\n        if v > rollingMax {\n            rollingMax\
    \ = v\n        }\n        numbers[i] = rollingMax\n        i++\n    }\n    return\
    \ numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkue9mu4_test.go:16:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    max := numbers[0]\n\
    \    var currentMaxIndex int\n    for _, number := range numbers {\n        if\
    \ number > max {\n            result = append(result, max)\n            max =\
    \ number\n            currentMaxIndex = 1\n        } else {\n            result\
    \ = append(result, number)\n        }\n        currentMaxIndex++\n    }\n    result\
    \ = append(result, max)\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpzvzciutb_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpzvzciutb_test.go:37\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    // Base case: we reached the end of the\
    \ list\n    if len(numbers) == 0 {\n        return result\n    }\n\n    // Recursion:\
    \ add current element\n    result = append(result, numbers[0])\n\n    // Compute\
    \ rolling maximum for the rest of the list\n    i := 1\n    for ; i < len(numbers);\
    \ i++ {\n        if numbers[i] > result[len(result)-1] {\n            result =\
    \ append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpk9vj8m0__test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpk9vj8m0__test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil {\n        return []int{}\n    }\n\n    result\
    \ := []int{}\n    numberFound := false\n\n    for _, n := range numbers {\n  \
    \      if n >= 2 {\n            numberFound = true\n            result = append(result,\
    \ n)\n        }\n        if numberFound {\n            result[len(result)-1] =\
    \ n\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmphq2u5p7s_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmphq2u5p7s_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmphq2u5p7s_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100)\
    \ %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var max_found int\n    for _, number := range\
    \ numbers {\n        result = append(result, number)\n        if max_found < number\
    \ {\n            max_found = number\n        }\n    }\n    return append(result,\
    \ max_found)\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0\
    \ (0.00s)\n        tmp29gkug57_test.go:40: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp29gkug57_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp29gkug57_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp29gkug57_test.go:40:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=100)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074135
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n\n    //\
    \ First find the current maximum element with current max index\n    var maxValue\
    \ int = 0\n    var maxIndex int = 0\n    for index := 0; index < len(numbers);\
    \ index++ {\n        if numbers[index] > maxValue {\n            maxValue = numbers[index]\n\
    \            maxIndex = index\n        }\n    }\n\n    var maxSlice []int\n  \
    \  maxSlice = make([]int, 0, 6)\n\n    // Add the current maximum to the result\n\
    \    maxSlice = append(maxSlice, maxValue)\n\n    // Get the remaining elements\
    \ with current max index\n    for index := index + 1; index < len(numbers); index++\
    \ {\n        if numbers[index] > maxValue {\n            maxValue = numbers[index]\n\
    \            maxIndex = index\n        }\n    }\n\n    for index := 0; index <\
    \ len(numbers); index++ {\n        if index > maxIndex {\n            break\n\
    \        }\n\n        maxSlice = append(maxSlice, numbers[index])\n    }\n\n \
    \   return maxSlice\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps4d9qmob_test.go:34:18: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074135
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maxIndex int\n    var current int\n    var found bool\n   \
    \ \n    for index, current := range numbers {\n        if found {\n          \
    \  if current > numbers[maxIndex] {\n                maxIndex = index\n      \
    \      }\n        } else {\n            found = index == maxIndex\n        }\n\
    \    }\n    \n    return numbers[:maxIndex+1]\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ka4henn_test.go:14:9: current declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074135
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    ret := []int{}\n    i := 0\n    for _, v := range numbers {\n \
    \       if v < i {\n            break\n        }\n        ret = append(ret, v)\n\
    \        i++\n    }\n    return ret\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpvzcdjnhc_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpvzcdjnhc_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_rolling_numbers []int\n    var index int\n    var number\
    \ int\n    var max_number int\n    for index = 0; index < len(numbers); index++\
    \ {\n        number = numbers[index]\n        max_number = number\n        max_rolling_numbers\
    \ = append(max_rolling_numbers, number)\n        for number = max_number + 1;\
    \ number < numbers[index+1]; number++ {\n            if max_rolling_numbers[index]\
    \ > max_rolling_numbers[number] {\n                max_rolling_numbers[index]\
    \ = max_rolling_numbers[number]\n            }\n        }\n    }\n    return max_rolling_numbers\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpuq2nsueo_test.go:21\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpuq2nsueo_test.go:38\
    \ +0x792\ntesting.tRunner(0xc000198ea0, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n\n    for _, number :=\
    \ range numbers {\n        result = append(result, number)\n    }\n\n    current\
    \ := 0\n    max := result[0]\n    for i := 1; i < len(numbers); i++ {\n      \
    \  if numbers[i] > max {\n            max = numbers[i]\n            current =\
    \ i\n        }\n    }\n\n    return result[0:current+1]\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp2ymj5fpk_test.go:20\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp2ymj5fpk_test.go:38\
    \ +0x2f\ntesting.tRunner(0xc0001964e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, len(numbers))\n  \
    \  for i := 0; i < len(numbers); i++ {\n        if numbers[i] > max {\n      \
    \      max = numbers[i]\n            result = make([]int, 0)\n        }\n    \
    \    result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpn7s9gj3d_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpn7s9gj3d_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpzawi3_4y_test.go:32: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpzawi3_4y_test.go:32: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    m := 0\n    max := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number > max {\n            m = 1\n            max = number\n\
    \        } else {\n            m++\n        }\n    }\n    var result []int\n \
    \   for i := 0; i < m; i++ {\n        result = append(result, max)\n    }\n  \
    \  return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpdifxblgs_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpdifxblgs_test.go:37\
    \ +0x18\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    i := 0\n    rolled_max := numbers[0]\n    rolled_max_index := 0\n\
    \    for _, number := range numbers {\n        if number > rolled_max {\n    \
    \        rolled_max = number\n            rolled_max_index = i\n        }\n  \
    \      i++\n    }\n    return numbers[0:rolled_max_index+1]\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpgppz5byw_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpgppz5byw_test.go:33\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Write your code here\n    var max int\n    max := numbers[0]\n\
    \    output := make([]int, len(numbers))\n    for i := 1; i < len(numbers); i++\
    \ {\n        if max < numbers[i] {\n            max = numbers[i]\n        }\n\
    \        output[i-1] = max\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq0fbmh7__test.go:15:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074136
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolledMax := make([]int, 0)\n    numberIndex := 0\n    max := numbers[0]\n\
    \n    for numberIndex < len(numbers) {\n        max := numbers[numberIndex]\n\
    \        if numbers[numberIndex] == max {\n            rolledMax = append(rolledMax,\
    \ max)\n        } else {\n            if max > rolledMax[len(rolledMax)-1] {\n\
    \                rolledMax = append(rolledMax, max)\n            }\n        }\n\
    \        numberIndex++\n    }\n\n    return rolledMax\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb9ibjw7y_test.go:15:5: max declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolled, maxRolled := make([]int, 0, len(numbers)), 0\n    for _,\
    \ number := range numbers {\n        if number > maxRolled {\n            rolled\
    \ = append(rolled, number)\n            maxRolled = number\n        } else {\n\
    \            rolled = append(rolled, maxRolled)\n            rolled = append(rolled,\
    \ number)\n            maxRolled = number\n        }\n    }\n\n    return rolled\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp7bzjlwrx_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp7bzjlwrx_test.go:44:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=3) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    rolling := false\n    for _, x :=\
    \ range numbers {\n        if rolling {\n            result = append(result, x)\n\
    \        }\n        if x == numbers[0] {\n            rolling = true\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpsd_i6rex_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpsd_i6rex_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpsd_i6rex_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil || len(numbers) == 0 {\n        return []int{}\n\
    \    }\n    var maxes []int\n    var idx int\n    max := numbers[0]\n    maxes\
    \ = make([]int, 0)\n    for idx, number := range numbers {\n        if number\
    \ > max {\n            max = number\n            maxes = make([]int, 0)\n    \
    \    }\n        maxes = append(maxes, number)\n        if idx == len(numbers)-1\
    \ {\n            maxes = append(maxes, max)\n        }\n    }\n    return maxes\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamlkvy65_test.go:17:9: idx declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    i := len(numbers)\n    result := []int{}\n\n    for ; i > 0; i--\
    \ {\n        max := numbers[i-1]\n        if numbers[i-1] != max {\n         \
    \   max = numbers[i]\n            result = append(result, max)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpq24pospa_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpq24pospa_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpq24pospa_test.go:42:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil {\n        return nil\n    }\n    result := make([]int,\
    \ len(numbers))\n    i := 0\n    for j := 0; j < len(numbers); j++ {\n       \
    \ max = numbers[i]\n        min = numbers[i]\n        i++\n        for k := i\
    \ + 1; k < len(numbers); k++ {\n            if numbers[k] > max {\n          \
    \      max = numbers[k]\n            }\n            if numbers[k] < min {\n  \
    \              min = numbers[k]\n            }\n        }\n        result[j] =\
    \ max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi2whdtnk_test.go:19:9: undefined: max

    /tmp/tmpi2whdtnk_test.go:20:9: undefined: min

    /tmp/tmpi2whdtnk_test.go:23:29: undefined: max

    /tmp/tmpi2whdtnk_test.go:24:17: undefined: max

    /tmp/tmpi2whdtnk_test.go:26:29: undefined: min

    /tmp/tmpi2whdtnk_test.go:27:17: undefined: min

    /tmp/tmpi2whdtnk_test.go:30:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Initialize rolling max as nil.\n    var rolling_max []int\n\
    \    if len(numbers) == 0 {\n        return rolling_max\n    }\n    rolling_max\
    \ = make([]int, len(numbers))\n    for i := range rolling_max {\n        rolling_max[i]\
    \ = numbers[i]\n    }\n    for i := range numbers {\n        // Search for the\
    \ next maximum\n        i := i\n        for true {\n            rolling_max[i]++\n\
    \            if rolling_max[i] > numbers[i] {\n                rolling_max[i]\
    \ = numbers[i]\n            }\n            if i == 0 {\n                break\n\
    \            }\n            i++\n        }\n    }\n    return rolling_max\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpo81p4t48_test.go:26\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpo81p4t48_test.go:47\
    \ +0x5c5\ntesting.tRunner(0xc0001a0340, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return nil\n    }\n\n    var largestNum\
    \ = numbers[0]\n\n    for _, num := range numbers {\n        if num > largestNum\
    \ {\n            largestNum = num\n        }\n    }\n\n    result := make([]int,\
    \ 0, len(numbers)+1)\n    result[0] = largestNum\n    for _, num := range numbers\
    \ {\n        result[len(result)-1] = num\n        if num == largestNum {\n   \
    \         break\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpuj8jkas5_test.go:26\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpuj8jkas5_test.go:45\
    \ +0x45\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    rolling_max := make([]int, 0)\n    for _,\
    \ number := range numbers {\n        if number > max {\n            rolling_max\
    \ = append(rolling_max, max)\n        }\n        max = number\n    }\n    rolling_max\
    \ = append(rolling_max, max)\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp572jee1h_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp572jee1h_test.go:32\
    \ +0x18\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    size := len(numbers)\n    max := numbers[size-1]\n    result :=\
    \ make([]int, size)\n\n    for i := 0; i < size; i++ {\n        result [i] = max\n\
    \        if numbers[i] >= max {\n            max = numbers[i]\n        }\n   \
    \ }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpe2m6t51m_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpe2m6t51m_test.go:34\
    \ +0x1c\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var res []int\n\n    if len(numbers) == 0 {\n        return nil\n\
    \    }\n\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > numbers[i-1]\
    \ {\n            numbers[i-1] = numbers[i]\n        }\n    }\n\n    res = append(res,\
    \ numbers[0])\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 34 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpuuwo7c3f_test.go:20\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpuuwo7c3f_test.go:37\
    \ +0x5f2\ntesting.tRunner(0xc000199040, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n    for _, n := range numbers {\n        if n >\
    \ max {\n            max = append(max, n)\n        }\n    }\n    return max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvjoq1b_3_test.go:15:16: invalid operation: n > max (mismatched types int
    and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    for i := range rolling_max\
    \ {\n        rolling_max[i] = numbers[i]\n    }\n\n    rolling_max = append(rolling_max,\
    \ numbers...)\n    rolling_max = append(rolling_max, rolling_max...)\n    rolling_max\
    \ = append(rolling_max, rolling_max...)\n    rolling_max = append(rolling_max,\
    \ rolling_max...)\n\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpmp6t8iqu_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpmp6t8iqu_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4)\
    \ %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4)\
    \ %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmp6t8iqu_test.go:42:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2)\
    \ %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=3) %!"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    if len(numbers)\
    \ == 1 {\n        return []int{numbers[0]}\n    }\n    current := numbers[0]\n\
    \    result := make([]int, len(numbers))\n    i := 0\n    for _, number := range\
    \ numbers {\n        if number > current {\n            i++\n            result[i]\
    \ = number\n        }\n        current = number\n    }\n    return result\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp7a08g31j_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmp7a08g31j_test.go:48: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp7a08g31j_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=0) %!s(int=3) %!s(int=100) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    for _, number := range numbers[1:] {\n \
    \       if number > max {\n            max = number\n        }\n    }\n    return\
    \ []int{max}\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpxweb5ssf_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpxweb5ssf_test.go:29\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var output []int\n    var sum int\n    for i := 0; i < len(numbers);\
    \ i++ {\n        sum = sum + numbers[i]\n        if sum > numbers[i] {\n     \
    \       sum = sum - numbers[i]\n        }\n        output = append(output, sum)\n\
    \    }\n    return output\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpyte8ad8s_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpyte8ad8s_test.go:41: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    for _, number := range\
    \ numbers {\n        result = append(result, number)\n    }\n\n    k := len(numbers)\
    \ - 1\n    i := 0\n    max := numbers[k]\n    found := false\n    for {\n    \
    \    if k > 0 {\n            if numbers[k] > max {\n                max = numbers[k]\n\
    \                i = k - 1\n            }\n        }\n\n        if i >= 0 {\n\
    \            if numbers[i] > max {\n                max = numbers[i]\n       \
    \         i = i - 1\n            } else {\n                found = found || (numbers[i]\
    \ != max)\n            }\n        }\n\n        if i == -1 {\n            break\n\
    \        }\n        k = i\n    }\n\n    if !found {\n        return result\n \
    \   } else {\n        return result[i:]\n    }\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max({0xc0000c45e8, 0x0, 0x5d40d0?})\n\
    \t/tmp/tmp00hxyume_test.go:20 +0x16d\ncommand-line-arguments_test.TestRolling_Max(0x0?)\n\
    \t/tmp/tmp00hxyume_test.go:59 +0x4b\ntesting.tRunner(0xc0001a01a0, 0x529020)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    result := make([]int, length)\n   \
    \ result := append(result, numbers[0])\n    for i := 1; i < length; i++ {\n  \
    \      result[len(result)-1] = rolling_max(result[len(result)-1], numbers[i])\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpblaj_cbb_test.go:15:12:\
    \ no new variables on left side of :=\n/tmp/tmpblaj_cbb_test.go:17:33: cannot\
    \ use rolling_max(result[len(result) - 1], numbers[i]) (value of type []int) as\
    \ type int in assignment\n/tmp/tmpblaj_cbb_test.go:17:68: too many arguments in\
    \ call to rolling_max\n\thave (int, int)\n\twant ([]int)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074138
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil {\n        return []int{}\n    }\n    var result\
    \ []int\n    for _, number := range numbers {\n        result = append(result,\
    \ number)\n    }\n\n    result := result[:0]\n    var max_value int\n    var current_max_index\
    \ int\n    for index, number := range numbers {\n        if number > max_value\
    \ {\n            max_value = number\n            current_max_index = index\n \
    \       }\n    }\n    for index, number := range numbers {\n        if index >\
    \ current_max_index {\n            result = append(result, number)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo3rtqu9q_test.go:21:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074138
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0, len(numbers))\n    for _, number := range\
    \ numbers {\n        result := append(result, number)\n    }\n    for _, number\
    \ := range numbers {\n        result = append(result, number) // add current number\
    \ in the result list\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsq5mbrd7_test.go:15:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max_element := make([]int, 0)\n    rolling_max_last_index\
    \ := make([]int, 0)\n\n    // Set starting rolling maximum element and index of\
    \ that element.\n    // The element will stay on the top of the stack.\n    rolling_max_element[0]\
    \ = numbers[0]\n    rolling_max_last_index[0] = numbers[0]\n\n    for i := 1;\
    \ i < len(numbers); i++ {\n        if numbers[i] > rolling_max_element[rolling_max_last_index[0]]\
    \ {\n            rolling_max_element[0] = numbers[i]\n            rolling_max_last_index[0]\
    \ = i\n        }\n    }\n\n    return rolling_max_element\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpasopg9fh_test.go:18\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpasopg9fh_test.go:38\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var max int\n    for _, number := range numbers\
    \ {\n        if (number > max) {\n            max = number\n        }\n    }\n\
    \    for _, number := range numbers {\n        if number > max {\n           \
    \ result = append(result, max)\n        }\n        if number == max {\n      \
    \      result = append(result, number)\n        }\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp8xw0yoge_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp8xw0yoge_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmp8xw0yoge_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Generate rolling maximum element using binary search to find\
    \ largest number in the sequence\n    // and then removing all elements from that\
    \ position until we reach the given moment\n    // If no such moment is found,\
    \ we return empty sequence\n    if len(numbers) < 2 {\n        return []int{}\n\
    \    }\n\n    var result []int\n    found := false\n    pos := 0\n    for pos\
    \ < (len(numbers)-1) {\n        largestNumber := numbers[pos]\n        pos++\n\
    \n        if pos == len(numbers) {\n            return result\n        }\n   \
    \     if numbers[pos] > largestNumber {\n            largestNumber = numbers[pos]\n\
    \            found = true\n        }\n        pos = binarySearchUntil(numbers,\
    \ pos, largestNumber, found)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpas4nhfb6_test.go:34:15: undefined: binarySearchUntil

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074138
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Store the largest number found.\n    var max int\n    // Store\
    \ the index of the last found largest number.\n    var maxIndex int\n    // Loop\
    \ through the numbers and find their largest number.\n    for index, number :=\
    \ range numbers {\n        if number > max {\n            max = number\n     \
    \       maxIndex = index\n        }\n    }\n\n    // Create a list of numbers\
    \ until this index.\n    // Since max is found, new numbers appended after index\
    \ will be the max number.\n    numbers := make([]int, len(numbers))\n    for i\
    \ := 0; i < maxIndex; i++ {\n        numbers = append(numbers, numbers[i])\n \
    \   }\n\n    // Append the max number\n    numbers = append(numbers, max)\n\n\
    \    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu21orrbt_test.go:27:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    rolling_max_element := numbers[0]\n\
    \    for _, element := range numbers {\n        if element > rolling_max_element\
    \ {\n            rolling_max_element = element\n        }\n    }\n    rolling_max\
    \ = append(rolling_max, rolling_max_element)\n    for _, element := range numbers\
    \ {\n        if element == rolling_max_element {\n            continue\n     \
    \   }\n        element -= rolling_max_element\n        rolling_max_element = element\n\
    \        rolling_max = append(rolling_max, element)\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpjflos4yx_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpjflos4yx_test.go:39\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, 0)\n    for _, value\
    \ := range numbers {\n        if value > max {\n            result = append(result,\
    \ max)\n        } else {\n            result = append(result, value)\n       \
    \ }\n        max = value\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpmiaeba0o_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpmiaeba0o_test.go:33\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    current := numbers[0]\n    result := append(result,\
    \ current)\n    for _, next := range numbers[1:] {\n        if next > current\
    \ {\n            result = append(result, next)\n            current = next\n \
    \       } else {\n            result = append(result, current)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpugney1_o_test.go:15:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    i := 0\n    for j := len(numbers)-1;\
    \ j >=0; j-- {\n        if i > 0 && numbers[j] > numbers[i] {\n            result[i]\
    \ = numbers[j]\n            i++\n        } else {\n            result[i] = numbers[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpu6j0spl__test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpu6j0spl__test.go:42: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpu6j0spl__test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    for _, x := range numbers {\n        if\
    \ x > max {\n            max = x\n        }\n    }\n    return []int{max}\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp4fmzcovp_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp4fmzcovp_test.go:29\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    for _, value := range numbers {\n        if value\
    \ > max {\n            max = value\n        }\n    }\n    var rollingMax []int\n\
    \    for _, value := range numbers {\n        if value == max {\n            rollingMax\
    \ = append(rollingMax, max)\n        } else {\n            rollingMax = append(rollingMax,\
    \ value)\n        }\n    }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpyb72blf1_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpyb72blf1_test.go:46: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    l := 0\n    max := numbers[0]\n    for _, n := range numbers {\n\
    \        if n > max {\n            max = n\n        }\n    }\n    l := 0\n   \
    \ max1 := numbers[0]\n    for _, n := range numbers {\n        if n > max1 {\n\
    \            max1 = n\n        }\n        if n == max {\n            l = l + 1\n\
    \        }\n    }\n    r := []int{}\n    for j := 1; j < l; j ++ {\n        if\
    \ numbers[j] == max {\n            r = append(r, max)\n        } else {\n    \
    \        r = append(r, numbers[j])\n        }\n    }\n    if l == l {\n      \
    \  r = append(r, max)\n    }\n    return r\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9kixnrr6_test.go:20:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    for _, number := range numbers {\n      \
    \  result = append(result, number)\n    }\n    for _, number := range result {\n\
    \        var min int\n        var maxIndex int\n        for index, elem := range\
    \ result {\n            if elem > number {\n                min = number\n   \
    \             maxIndex = index\n                break\n            }\n       \
    \ }\n        for index, elem := range result {\n            if index != maxIndex\
    \ && elem == number {\n                result[index] = number\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps9hw9n4o_test.go:18:13: min declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    rolling_max = append(rolling_max, numbers[0])\n\
    \    for _, number := range numbers[1:] {\n        rolling_max = append(rolling_max,\
    \ max(number, rolling_max[len(rolling_max)-1]))\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8y6_ajoo_test.go:16:43: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074139
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    numbers := make([]int, len(numbers))\n    var max_pos int = -1\n\
    \    for i, number := range numbers {\n        if max_pos == -1 || number > numbers[max_pos]\
    \ {\n            max_pos = i\n        }\n    }\n    max_pos -= max_pos > len(numbers)/2\n\
    \    for i := 0; i < max_pos; i++ {\n        numbers[i] = numbers[i+1]\n    }\n\
    \    numbers := append(numbers, numbers[len(numbers)-1])\n    return numbers\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdjcclk7j_test.go:13:13: no new variables on left side of :=

    /tmp/tmpdjcclk7j_test.go:20:5: invalid operation: max_pos -= max_pos > len(numbers)
    / 2 (mismatched types int and untyped bool)

    /tmp/tmpdjcclk7j_test.go:24:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074139
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    rolling_max := numbers[0]\n    for _, value\
    \ := range numbers {\n        if value > rolling_max {\n            result = append(result,\
    \ rolling_max)\n            rolling_max = value\n        } else {\n          \
    \  rolling_max = value\n        }\n    }\n    return append(result, rolling_max)\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp2q5ef6xf_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp2q5ef6xf_test.go:33\
    \ +0x18\ntesting.tRunner(0xc000198ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074140
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, 0)\n    number :=\
    \ 0\n    for _, val := range numbers {\n        if val > max {\n            max\
    \ = val\n            result = append(result, max)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmtymaqv__test.go:15:5: number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    rolling_max_value := numbers[0]\n    for\
    \ _, number := range numbers {\n        if number > rolling_max_value {\n    \
    \        result = append(result, rolling_max_value)\n            rolling_max_value\
    \ = number\n        } else {\n            rolling_max_value = number\n       \
    \ }\n    }\n    result = append(result, rolling_max_value)\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmptccgkw6b_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmptccgkw6b_test.go:34\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074140
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    result := rolling_max_test(numbers)\n   \
    \ return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcleoe11w_test.go:14:12: no new variables on left side of :=

    /tmp/tmpcleoe11w_test.go:14:15: undefined: rolling_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, 0, len(numbers))\n\n    if len(numbers) ==\
    \ 0 {\n        return nil\n    }\n\n    for _, number := range numbers {\n   \
    \     maxIndex := -1\n\n        for i := range output {\n            if number\
    \ > output[i] {\n                maxIndex = i\n                break\n       \
    \     }\n        }\n\n        if maxIndex >= 0 {\n            output[maxIndex]\
    \ = number\n        } else {\n            output = append(output, number)\n  \
    \      }\n    }\n\n    return output\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp1wv94m_7_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp1wv94m_7_test.go:55: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmp1wv94m_7_test.go:55: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100)\
    \ %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil {\n        return nil\n    }\n    maxima := make([]int,\
    \ 0, len(numbers))\n    for _, n := range numbers {\n        if n > maxima[len(maxima)-1]\
    \ {\n            maxima = append(maxima, n)\n        }\n    }\n    return maxima\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpvac66hck_test.go:18\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpvac66hck_test.go:33\
    \ +0x6b5\ntesting.tRunner(0xc0001a0340, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    rollingMax := []int{}\n    for _, value\
    \ := range numbers {\n        if value > max {\n            max = value\n    \
    \    } else {\n            rollingMax = append(rollingMax, max)\n        }\n \
    \   }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnx3zxkme_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnx3zxkme_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maximum []int\n    var found bool\n    for _, n := range numbers\
    \ {\n        if found {\n            if n > maximum[len(maximum)-1] {\n      \
    \          maximum = append(maximum, n)\n            } else {\n              \
    \  maximum[len(maximum)-1] = n\n                found = false\n            }\n\
    \        } else {\n            if n == maximum[len(maximum)-1] {\n           \
    \     found = true\n            }\n        }\n    }\n    return maximum\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpur6jfp6z_test.go:24\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpur6jfp6z_test.go:40\
    \ +0x7d5\ntesting.tRunner(0xc0001a01a0, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n\n    var\
    \ output []int\n    output = append(output, numbers[0])\n\n    var max_number\
    \ int\n    max_number = numbers[0]\n    for _, n := range numbers[1:] {\n    \
    \    if n > max_number {\n            max_number = n\n        }\n    }\n\n   \
    \ output = append(output, max_number)\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpc7k0ymct_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpc7k0ymct_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpc7k0ymct_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp4vtjy56o_test.go:32: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmp4vtjy56o_test.go:32: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp4vtjy56o_test.go:32:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    max := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number > max {\n            result = append(result,\
    \ max)\n            max = number\n        } else {\n            max = number\n\
    \        }\n    }\n    return append(result, max)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpihtx3c4h_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpihtx3c4h_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    var\
    \ max int\n    var last_number int\n    var max_found bool = false\n    for _,\
    \ number := range numbers {\n        if number > max {\n            max = number\n\
    \            last_number = number\n        }\n\n        if number == max && !max_found\
    \ {\n            max_found = true\n        } else {\n            if max_found\
    \ {\n                numbers[last_number] = max\n            }\n        }\n  \
    \  }\n    return numbers[:last_number+1]\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmphl_eqryd_test.go:30\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmphl_eqryd_test.go:45\
    \ +0x545\ntesting.tRunner(0xc0001924e0, 0x528020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    var temp_max int\n    var count int\n\
    \n    for i := 0; i < len(numbers); i++ {\n        temp_max = numbers[i]\n   \
    \     count = 1\n\n        for j = 1; j < i; j++ {\n            if numbers[j-1]\
    \ > temp_max {\n                temp_max = numbers[j]\n                count =\
    \ 1\n            } else {\n                count++\n            }\n        }\n\
    \        if count > 1 {\n            rolling_max = append(rolling_max, temp_max)\n\
    \        }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp730of1v_test.go:21:13: undefined: j

    /tmp/tmpp730of1v_test.go:22:24: undefined: j

    /tmp/tmpp730of1v_test.go:23:36: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074140
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    if len(numbers) == 0 {\n        return\
    \ result\n    }\n    largest, index, result := numbers[0], 0\n    for i := 1;\
    \ i < len(numbers); i++ {\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n            result = append(result, largest)\n            index\
    \ = i\n        }\n    }\n    for i := index; i < len(numbers); i++ {\n       \
    \ result = append(result, numbers[i])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptaxzoeak_test.go:17:31: assignment mismatch: 3 variables but 2 values

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074140
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := []int{}\n    for _, number := range numbers {\n\
    \        rolling_max = append(rolling_max, number)\n    }\n    rolling_max = append(rolling_max,\
    \ numbers[len(numbers)-1])\n\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpxtj4z0sx_test.go:17\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpxtj4z0sx_test.go:29\
    \ +0x1c\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil || len(numbers) == 0 {\n        return []int{}\n\
    \    }\n\n    first := numbers[0]\n    next := numbers[0]\n    for _, value :=\
    \ range numbers {\n        switch next {\n        case value > first:\n      \
    \      return numbers\n        case value >= first:\n            next = value\n\
    \        }\n    }\n    return append([]int{first}, numbers...)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpygsjt71s_test.go:21:14: cannot convert value > first (untyped bool value)
    to int

    /tmp/tmpygsjt71s_test.go:23:14: cannot convert value >= first (untyped bool value)
    to int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    lastMax := 0\n    for _, n := range numbers\
    \ {\n        if n > lastMax {\n            lastMax = n\n            result = append(result,\
    \ lastMax)\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpkaabnkww_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpkaabnkww_test.go:40: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Write your code here\n    max := numbers[0]\n    for _, n :=\
    \ range numbers {\n        if n > max {\n            max = n\n        }\n    }\n\
    \    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp75bp1z4n_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp75bp1z4n_test.go:30\
    \ +0x18\ntesting.tRunner(0xc0001031e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var max_number int\n    var max_index int\n\
    \n    // Initialization phase\n    // The first element is the first rolling max\
    \ element found\n    max_number = numbers[0]\n    max_index = 0\n\n    // Main\
    \ phase\n    for i := 1; i < len(numbers); i++ {\n        max_index = i\n    \
    \    if numbers[i] > max_number {\n            max_number = numbers[i]\n     \
    \   }\n    }\n\n    // Finalization phase\n    result = append(result, max_number)\n\
    \    for i := 1; i < len(numbers); i++ {\n        max_index = i\n        if numbers[max_index]\
    \ > max_number {\n            max_number = numbers[max_index]\n        }\n   \
    \     result = append(result, max_number)\n    }\n\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max({0xc0000be5e8?, 0x4b3193?, 0x5d40d0?})\n\
    \t/tmp/tmpl1kigf5o_test.go:19 +0x114\ncommand-line-arguments_test.TestRolling_Max(0x0?)\n\
    \t/tmp/tmpl1kigf5o_test.go:50 +0x4b\ntesting.tRunner(0xc0001031e0, 0x529020)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    current := []int{}\n    max := numbers[0]\n    for _, number :=\
    \ range numbers {\n        if number > max {\n            max = number\n     \
    \   }\n    }\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] ==\
    \ max {\n            current = append(current, max)\n        }\n    }\n    return\
    \ current\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmprbw7njbm_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmprbw7njbm_test.go:35\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    for _, number := range numbers[1:] {\n \
    \       if number > max {\n            max = number\n        }\n    }\n    return\
    \ []int{max}\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpxweb5ssf_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpxweb5ssf_test.go:29\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074138
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Start with the first element in the list to be the rolling max\
    \ element found until that moment.\n    rolling_max_elem := numbers[0]\n    rolling_max_index\
    \ := 0\n\n    // Continue until all elements have been rolled up to their rolling\
    \ max element found at that moment.\n    for i := 1; i < len(numbers); i++ {\n\
    \        if numbers[i] > rolling_max_elem {\n            rolling_max_elem = numbers[i]\n\
    \            rolling_max_index = i\n        }\n    }\n\n    return numbers[0:rolling_max_index+1]\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp7fzhkoh6_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp7fzhkoh6_test.go:35\
    \ +0x18\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074141
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result := append(result, numbers[0])\n   \
    \ for i := 0; i < len(numbers); i++ {\n        index := i\n        for index <\
    \ len(numbers) && numbers[index] >= numbers[i] {\n            index++\n      \
    \  }\n        result[i] = numbers[i]\n        for index < len(numbers) && numbers[index]\
    \ > result[i] {\n            index++\n        }\n        result[i] = numbers[index]\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn9ijte8o_test.go:17:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074141
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    for i, n := range numbers\
    \ {\n        max = numbers[i]\n        for i := range numbers {\n            if\
    \ numbers[i] > max {\n                max = numbers[i]\n                res[i]\
    \ = max\n            }\n        }\n    }\n    return res\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmposvb7oy7_test.go:14:12: n declared but not used

    /tmp/tmposvb7oy7_test.go:15:9: undefined: max

    /tmp/tmposvb7oy7_test.go:17:29: undefined: max

    /tmp/tmposvb7oy7_test.go:18:17: undefined: max

    /tmp/tmposvb7oy7_test.go:19:26: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074141
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    current := 0\n    max := numbers[0]\n\n    for _, number := range\
    \ numbers {\n        if number > max {\n            max = number\n        }\n\
    \        if number == max {\n            current++\n        }\n    }\n\n    result\
    \ := make([]int, 0, current)\n    for i := 0; i < current; i++ {\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpt4w4nwy3_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpt4w4nwy3_test.go:39\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074142
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n    \n  \
    \  max := numbers[0]\n    \n    for _, number := range numbers[1:] {\n       \
    \ if number > max {\n            max = number\n        }\n    }\n    \n    return\
    \ append(numbers[:1], max)\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpwwvthla__test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpwwvthla__test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpwwvthla__test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074142
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := []int{}\n    for _, number := range numbers {\n\
    \        rolling_max = append(rolling_max, number)\n    }\n\n    if len(rolling_max)\
    \ == 0 {\n        return nil\n    }\n    for _, number := range rolling_max {\n\
    \        rolling_max = append(rolling_max, number)\n    }\n    rolling_max = rolling_max[:len(rolling_max)-1]\n\
    \n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmprqwkg5ma_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmprqwkg5ma_test.go:45:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmprqwkg5ma_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100)\
    \ %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074142
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rollingMax []int\n    for _, number := range numbers {\n  \
    \      rollingMax = append(rollingMax, number)\n    }\n    return rollingMax\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp0kusqwpf_test.go:36: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmp0kusqwpf_test.go:36: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maxElement int\n    var maxCount int\n    var maxIndex int\n\
    \    var maxCount int\n    for _, number := range numbers {\n        maxElement\
    \ = number\n        maxCount = 0\n        maxIndex = -1\n        maxCount = 1\n\
    \        for index, number := range numbers {\n            if number == maxElement\
    \ {\n                maxCount++\n                maxIndex = index\n          \
    \  }\n        }\n        if maxCount > maxCount {\n            maxCount = maxCount\n\
    \            maxIndex = maxIndex\n        }\n    }\n    return numbers[:maxIndex+1]\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1lsj5s24_test.go:16:9:\
    \ maxCount redeclared in this block\n\t/tmp/tmp1lsj5s24_test.go:14:9: other declaration\
    \ of maxCount\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074142
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    max := numbers[0]\n    for _, number :=\
    \ range numbers {\n        if number > max {\n            max = number\n     \
    \   }\n    }\n    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoclyrkyb_test.go:14:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074142
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    for _, element := range numbers {\n\
    \        result = append(result, element)\n    }\n    for _, element := range\
    \ numbers {\n        for i := range result {\n            if result[i] > element\
    \ {\n                result[i] = element\n            }\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp5ezc2ceh_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmp5ezc2ceh_test.go:43: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp5ezc2ceh_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Base case\n    if len(numbers) == 1 {\n        return numbers\n\
    \    }\n\n    // Initialize temporary variables\n    var maxTemp int\n    var\
    \ maxIndexTemp int\n\n    // Find max element in the first element of the list\n\
    \    maxTemp = numbers[0]\n    maxIndexTemp = 0\n\n    // For each element of\
    \ the list\n    for i := 1; i < len(numbers); i++ {\n\n        // If the element\
    \ is greater than the current maximum\n        if numbers[i] > maxTemp {\n\n \
    \           // Then update the max\n            maxTemp = numbers[i]\n\n     \
    \       // And update the index of the max element\n            maxIndexTemp =\
    \ i\n        }\n    }\n\n    // Add the current max\n    numbers = append(numbers,\
    \ maxTemp)\n\n    // Add the remaining elements\n    for i := 0; i < maxIndexTemp;\
    \ i++ {\n        numbers = append(numbers, numbers[i])\n    }\n\n    return numbers\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpj397ozmh_test.go:23\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpj397ozmh_test.go:58\
    \ +0x18\ntesting.tRunner(0xc0001031e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // initialize a result to return\n    var result []int\n\n    max\
    \ := numbers[0]\n\n    for _, number := range numbers {\n        if number > max\
    \ {\n            max = number\n            result = append(result, max)\n    \
    \    } else {\n            result = append(result, number)\n        }\n    }\n\
    \n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp4dktds5f_test.go:16\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp4dktds5f_test.go:37\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rollingMax := make([]int, 0, len(numbers))\n    if len(numbers)\
    \ < 1 {\n        return rollingMax\n    }\n    rollingMax = append(rollingMax,\
    \ numbers[0])\n    if len(numbers) == 1 {\n        return rollingMax\n    }\n\n\
    \    currentMax := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n     \
    \   if currentMax < numbers[i] {\n            rollingMax = append(rollingMax,\
    \ currentMax)\n            currentMax = numbers[i]\n        } else {\n       \
    \     currentMax = numbers[i]\n        }\n    }\n    return rollingMax\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpyvnjbw9y_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpyvnjbw9y_test.go:50: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    ---\
    \ FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyvnjbw9y_test.go:50: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return rolling_max_n(numbers, 0)\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2d9e1_n3_test.go:13:12: undefined: rolling_max_n

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074142
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    numbers\
    \ := numbers\n    rolling_max := []int{}\n    for i := range numbers {\n     \
    \   rolling_max = append(rolling_max, numbers[i])\n    }\n    for i := range rolling_max\
    \ {\n        rolling_max[i] = rolling_max[i-1]\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkvgmna_v_test.go:16:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074142
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    for _, number := range numbers {\n\
    \        result = append(result, max(number))\n    }\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg0qo4lte_test.go:15:33: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := []int{}\n    max := numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if max < numbers[i] {\n            max = numbers[i]\n       \
    \ } else {\n            result = append(result, max)\n            max = numbers[i]\n\
    \        }\n    }\n    return append(result, max)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp0m7ntbsr_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp0m7ntbsr_test.go:33\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := []int{}\n    max := numbers[0]\n    for _, num := range\
    \ numbers[1:] {\n        if num > max {\n            res = append(res, max)\n\
    \            max = num\n        } else {\n            max = num\n        }\n \
    \   }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp8qz5z6ra_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp8qz5z6ra_test.go:33\
    \ +0x18\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i := range result\
    \ {\n        result[i] = numbers[0]\n    }\n    for i := len(numbers) - 1; i >=\
    \ 0; i-- {\n        for j := 0; j < i; j++ {\n            if numbers[i] >= numbers[j]\
    \ {\n                result[i] = numbers[i]\n                break\n         \
    \   }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpyp2svzq1_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    size := len(numbers)\n    if size == 0 {\n        return []int{}\n\
    \    }\n\n    result := make([]int, size)\n    max, j := numbers[0], 0\n    for\
    \ i := 0; i < size; i++ {\n        if numbers[i] >= max {\n            result[j]\
    \ = numbers[i]\n            max = numbers[i]\n        } else {\n            max\
    \ = numbers[i]\n        }\n        j++\n    }\n\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpmvyepbx4_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpmvyepbx4_test.go:49: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=0) %!s(int=3) %!s(int=100) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 2 {\n        return numbers\n    }\n\n    max\
    \ := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ >= max {\n            max = numbers[i]\n        } else {\n            break\n\
    \        }\n    }\n    result := make([]int, 0, len(numbers))\n    for _, number\
    \ := range numbers {\n        if number >= max {\n            result = append(result,\
    \ max)\n        } else {\n            result = append(result, number)\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpxt811oc0_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpxt811oc0_test.go:52: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return numbers\n    }\n    rolling_max\
    \ := numbers[len(numbers)-1]\n    next_number := numbers[0]\n    next_number +=\
    \ 1\n    for _, number := range numbers[1:] {\n        rolling_max = number\n\
    \        if number > next_number {\n            next_number = number\n       \
    \ }\n    }\n    return append([]int{next_number}, rolling_max)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmptm86x5cx_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmptm86x5cx_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmptm86x5cx_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, 0, len(numbers))\n\
    \    rolling := false\n    for _, number := range numbers {\n        if number\
    \ > max {\n            rolling = true\n            max = number\n            result\
    \ = append(result, max)\n            continue\n        }\n        if rolling {\n\
    \            rolling = false\n            result = append(result, max)\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpu6akzrg1_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpu6akzrg1_test.go:38\
    \ +0x18\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var lastValue int\n\n    // Keep a rolling\
    \ max value\n    lastValue = numbers[0]\n\n    // Roll over rolling max value\n\
    \    for _, number := range numbers {\n        if number > lastValue {\n     \
    \       result = append(result, lastValue)\n            lastValue = number\n \
    \       } else {\n            lastValue = number\n        }\n    }\n\n    // Append\
    \ the last value\n    result = append(result, lastValue)\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp6k_n7l34_test.go:17\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp6k_n7l34_test.go:41\
    \ +0x18\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074143
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_index int\n    var max_value int\n    var max_number int\n\
    \    for i := 0; i < len(numbers); i++ {\n        if numbers[i] > max_number {\n\
    \            max_number = numbers[i]\n            max_index = i\n        }\n \
    \   }\n    max_value = max_number\n    return append([]int{}, numbers[0:max_index+1],\
    \ numbers[max_index+1:], max_value)\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpag36lek7_test.go:23:35: cannot use numbers[0:max_index + 1] (value of
    type []int) as type int in argument to append

    /tmp/tmpag36lek7_test.go:23:59: cannot use numbers[max_index + 1:] (value of type
    []int) as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074143
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n    for _, number := range numbers {\n        max\
    \ = append(max, number)\n    }\n    return max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpqqnam4ga_test.go:36: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpqqnam4ga_test.go:36: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return rolling_max_test(numbers, len(numbers))\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcryme94y_test.go:13:12: undefined: rolling_max_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_elements []int\n    k := 0\n\n    for _, element := range\
    \ numbers {\n        max_elements[k] = element\n        k++\n    }\n\n    k :=\
    \ k - 1\n\n    for i := k; i >= 0; i-- {\n        if max_elements[i] > max_elements[i+1]\
    \ {\n            max_elements[i] = max_elements[i+1]\n        } else {\n     \
    \       max_elements[i] = max_elements[0]\n        }\n    }\n\n    return max_elements\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4s2vbyx_test.go:21:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Initialize the result slice with empty values\n    var result\
    \ []int\n    // Iterate through the input list and add the element to result if\
    \ it has the highest value up to that moment\n    for _, number := range numbers\
    \ {\n        if number > result[len(result)-1] {\n            result = append(result,\
    \ number)\n        }\n    }\n    // Return the result\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp1l1b0dcf_test.go:17\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp1l1b0dcf_test.go:33\
    \ +0x6d8\ntesting.tRunner(0xc0001924e0, 0x529020)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    var max_number int\n    var result []int\n   \
    \ for _, number := range numbers {\n        if number > max_number {\n       \
    \     max_number = number\n            result = append(result, number)\n     \
    \   } else if number == max_number {\n            result = append(result, number)\n\
    \        } else {\n            result = append(result, max_number)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgorvfini_test.go:13:9: max declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if i == 0 || numbers[i-1] > numbers[i] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = numbers[i-1]\n     \
    \   }\n    }\n    return append(result, numbers...)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpdwt8p4nl_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpdwt8p4nl_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpdwt8p4nl_test.go:40:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[%!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=2)\
    \ %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    size := len(numbers)\n    if size == 0 {\n        return nil\n\
    \    }\n    result := make([]int, size+1)\n    result[0], result[1] = numbers[0],\
    \ numbers[1]\n    i := 2\n    for ; i <= size; i++ {\n        result[i] = max(result[i-1],\
    \ result[i-2])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvokir9jz_test.go:21:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    return rolling_max_(numbers, 0, len(numbers)-1)\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzb6z3rmp_test.go:13:12: undefined: rolling_max_

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    if length == 0 {\n        return []int{}\n\
    \    }\n    max := numbers[0]\n    result := make([]int, length)\n    i := 0\n\
    \    for ; i+1 < length; i += 2 {\n        if numbers[i+1] > max {\n         \
    \   max = numbers[i+1]\n            result = append(result, max)\n        }\n\
    \    }\n    if i+1 < length {\n        if numbers[i+1] > max {\n            max\
    \ = numbers[i+1]\n            result = append(result, max)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp_bv91iws_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=4)]'\n\
    \    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp_bv91iws_test.go:51:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp_bv91iws_test.go:51: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var maxSoFar int\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if numbers[i] > maxSoFar {\n            maxSoFar = numbers[i]\n\
    \            result = append(result, maxSoFar)\n        }\n    }\n\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpgj6zv2p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpgj6zv2p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    index := 0\n    // go\
    \ through each element in the numbers array\n    for _, number := range numbers\
    \ {\n        // check if the current number is the largest one so far\n      \
    \  if number > result[len(result)-1] {\n            // if so, append the new one\n\
    \            result[len(result)-1] = number\n        } else {\n            //\
    \ otherwise, continue searching\n            index = index + 1\n            for\
    \ ; index >= 0 && index < len(result); index++ {\n                if number >\
    \ result[index] {\n                    result[index] = number\n              \
    \  }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpzlw35p3c_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpzlw35p3c_test.go:50: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=3)\
    \ %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpzlw35p3c_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=0) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=100)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rollingMaxArray []int\n    for _, number := range numbers {\n\
    \        rollingMaxArray = append(rollingMaxArray, number)\n    }\n    return\
    \ rollingMaxArray\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmp_rif7ags_test.go:36: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmp_rif7ags_test.go:36: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    ret := make([]int, 0)\n    for _, v := range numbers {\n      \
    \  ret = append(ret, v)\n    }\n    idx := len(ret) - 1\n    for {\n        idx\
    \ -= rolling_maxidx(ret, idx)\n        if idx > 0 {\n            break\n     \
    \   }\n    }\n    return ret\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp586yceld_test.go:19:16: undefined: rolling_maxidx

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    n\
    \ := numbers[0]\n\n    // Start from the second element and repeat the previous\
    \ step.\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > n {\n\
    \            n = numbers[i]\n        }\n    }\n\n    result := []int{}\n    for\
    \ i := 0; i < len(numbers); i++ {\n        if numbers[i] == n {\n            result\
    \ = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpn01e0sp7_test.go:52: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpn01e0sp7_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmpn01e0sp7_test.go:52: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, 0)\n    for _, v := range numbers {\n   \
    \     for _, vv := range result {\n            if v > vv {\n                v\
    \ = vv\n            } else {\n                break\n            }\n        }\n\
    \        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp4ps1n4wc_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmp4ps1n4wc_test.go:43: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp4ps1n4wc_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    for number := 0; number < len(numbers); number++\
    \ {\n        result = append(result, numbers[number])\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpmcm7l9p9_test.go:36: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpmcm7l9p9_test.go:36: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074144
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximum := numbers[0]\n    var rollingMax []int\n    for _, number\
    \ := range numbers {\n        if number > maximum {\n            rollingMax =\
    \ append(rollingMax, maximum)\n        }\n        rollingMax = append(rollingMax,\
    \ number)\n        maximum = number\n    }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpmugtz6_z_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpmugtz6_z_test.go:32\
    \ +0x18\ntesting.tRunner(0xc000112680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074144
