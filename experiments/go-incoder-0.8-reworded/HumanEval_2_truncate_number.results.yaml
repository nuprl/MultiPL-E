language: go_test.go
name: HumanEval_2_truncate_number
results:
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart := number % 1\n    decimals := float64(number) - intPart\n  \
    \  return intPart / 1\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmputkpinl1_test.go:15:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 1.0 {\n        return number\n    }\n    numberInt := float64(number)\n\
    \    if numberInt % 1.0 != 0 {\n        return number\n    }\n    numberFloat\
    \ := float64(numberInt)\n    decimals := (numberFloat - numberInt) / numberFloat\n\
    \    if decimals < 0 {\n        return numberInt\n    }\n    return numberFloat\
    \ - decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7jjcteq_test.go:19:8: invalid operation: operator % not defined on numberInt
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := float64(math.Ceil(float64(number)))\n    decimal := float64(math.Trunc(number))\n\
    \    if decimal < 1 {\n        decimal = 1\n    }\n    return decimal / integer\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0jgcysc_test.go:15:24: undefined: math

    /tmp/tmps0jgcysc_test.go:16:24: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        fmt.Println(\"Number is negative\")\n      \
    \  return -1\n    }\n    decimals := number % 1\n    intPart := number / 1\n \
    \   if intPart > 1 {\n        return intPart\n    }\n    return decimals\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa2to_565_test.go:19:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return math.Trunc(number)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqj3aazcr_test.go:15:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        number /= -1\n    }\n\n    number -= float64(math.Trunc(number))\n\
    \    number -= float64(math.Floor(number))\n    return number\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx63yh53w_test.go:19:23: undefined: math

    /tmp/tmpx63yh53w_test.go:20:23: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    parts := float64(number).Truncate(float64(1))\n    if parts < 0.5 {\n\
    \        return parts\n    }\n    return parts - 1\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb8xwkyak_test.go:15:30: float64(number).Truncate undefined (type float64
    has no field or method Truncate)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    sign := number < 0\n    if sign {\n        number = -number\n    }\n\
    \    integerPart := trunc(number)\n    decimalPart := number - integerPart\n \
    \   if decimalPart < 0.5 {\n        decimalPart += 1\n    }\n    if decimalPart\
    \ > 0.5 {\n        decimalPart -= 1\n    }\n    return sign * integerPart + decimalPart\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6p6_hqj6_test.go:19:20: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / float64(math.Pow10(math.Floor(math.Log10(number))))\n\
    \    return integer\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp409tta0__test.go:15:33: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimals := math.Modf(number*100)\n    return math.Trunc(number/100)\
    \ / 100\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3bumfr_4_test.go:15:26: undefined: math

    /tmp/tmp3bumfr_4_test.go:16:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: Handle corner case where number < 0.\n    integer := float64(math.Floor(number))\n\
    \    decimals := float64(math.Ceil(number-integer))\n    return decimal + decimals\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplv2zwczj_test.go:16:24: undefined: math

    /tmp/tmplv2zwczj_test.go:17:25: undefined: math

    /tmp/tmplv2zwczj_test.go:18:12: undefined: decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimals := number - float64(integer)\n \
    \   return float64(integer) + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpeq08_5cm_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpeq08_5cm_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpeq08_5cm_test.go:35: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075126
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number -= float64(trunc(number))\n    decimal := number%1\n    if decimal\
    \ != 0 {\n        number -= float64(decimal)\n    }\n    return number\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmk59si1c_test.go:15:23: undefined: trunc

    /tmp/tmpmk59si1c_test.go:16:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / float64(10)\n    return integer % float64(10)\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr80dgw1q_test.go:16:12: invalid operation: operator % not defined on integer
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    decimals := number - math.Floor(number)\n    return decimals\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpirerd4q__test.go:15:26: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int64(trunc(number))\n    decimal := number - float64(integer)\n\
    \    return float64(integer) + float64(decimal)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpejruv1ay_test.go:15:22: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimal := number - integer\n    if decimal\
    \ < 1 {\n        return integer\n    } else {\n        return integer\n    }\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8s_3g15b_test.go:16:16: invalid operation: number - integer (mismatched
    types float64 and int)

    /tmp/tmp8s_3g15b_test.go:18:16: cannot use integer (variable of type int) as type
    float64 in return statement

    /tmp/tmp8s_3g15b_test.go:20:16: cannot use integer (variable of type int) as type
    float64 in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // find integer part and decimal part\n    integer := number\n    decimal\
    \ := number - integer\n    if integer < 1 {\n        decimal = 0\n    }\n\n  \
    \  // find highest integer smaller then given number\n    intParts := []int{}\n\
    \    intPart := 1\n    for intPart*10 < number {\n        intParts = append(intParts,\
    \ intPart)\n        intPart++\n    }\n\n    // if last integer is smaller than\
    \ given number, make integer part larger\n    if intPart*10 > number {\n     \
    \   intParts = append(intParts, number-intPart*10)\n    }\n\n    // if decimal\
    \ part is smaller than 1, make it zero\n    if decimal < 1 {\n        decimal\
    \ = 0\n    }\n\n    return float64(intParts[len(intParts)-1]) / float64(intParts[len(intParts)-2])*decimal\
    \ + float64(intParts[len(intParts)-1]) % float64(intParts[len(intParts)-2])\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3kibrjv8_test.go:25:22: invalid operation: intPart * 10 < number (mismatched
    types int and float64)

    /tmp/tmp3kibrjv8_test.go:31:21: invalid operation: intPart * 10 > number (mismatched
    types int and float64)

    /tmp/tmp3kibrjv8_test.go:32:37: invalid operation: number - intPart * 10 (mismatched
    types float64 and int)

    /tmp/tmp3kibrjv8_test.go:40:94: invalid operation: operator % not defined on float64(intParts[len(intParts)
    - 1]) (value of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return truncate_number_test.TruncateNumber(number)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxcl_l4xt_test.go:15:12: undefined: truncate_number_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := number / float64(10)\n    frac_part := number % float64(10)\n\
    \n    return frac_part\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5i50zgl2_test.go:15:5: int_part declared but not used

    /tmp/tmp5i50zgl2_test.go:16:18: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number -= number % 1\n    decimals := int(math.Ceil(math.Log10(number)))\n\
    \    if decimals > 0 {\n        return number / float64(10 ** decimals)\n    }\n\
    \    return 0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp07diifla_test.go:15:15: invalid operation: operator % not defined on number
    (variable of type float64)

    /tmp/tmp07diifla_test.go:16:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var truncated float64\n\n    decimals := float64(number) - float64(truncated)\n\
    \    if decimals < 0 {\n        // Truncation does not make sense\n        return\
    \ number\n    }\n\n    if decimals > 0.5 {\n        truncated = float64(number)\
    \ - float64(truncated)\n    }\n\n    truncated /= 10\n    return truncated\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpo97x2k7h_test.go:46: expected '%!s(float64=0.5)', got '%!s(float64=0.35)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpo97x2k7h_test.go:46:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0.125)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpo97x2k7h_test.go:46: expected '%!s(float64=0)', got '%!s(float64=12.3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // The floor part of a number is the largest integer less than or equal\
    \ to\n    // the number itself, i.e. the largest integer less than 3.5.\n    floor\
    \ := math.Floor(number)\n    // The decimal part is the remainder after division\
    \ by 1,\n    // i.e. the remainder is 0.5 if 3.5 divided by 1 is an integer.\n\
    \    decimals := number - floor\n    // The integer part is the largest integer\
    \ less than or equal to\n    // the remainder after division by 1,\n    // i.e.\
    \ the integer part is 3.\n    integer := math.Ceil(decimals)\n    return float64(floor)\
    \ + float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwj94rxo2_test.go:17:14: undefined: math

    /tmp/tmpwj94rxo2_test.go:24:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := number - float64(math.Trunc(number))\n    if truncated !=\
    \ number {\n        truncated = truncated + 1.0\n    }\n    return truncated\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppuebqrjx_test.go:15:35: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := number\n    decimal := float64(0)\n    while (integer_part\
    \ != 0 || decimal == 0.0) {\n        decimal += float64(integer_part)\n      \
    \  integer_part *= 10\n    }\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfwxbv7pu_test.go:17:49: expected '';'', found ''{''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075274
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    i := number / float64(10)\n    return float64(i) * float64(10) / (float64(10)\
    \ + i)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmps8rflvwh_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0.33816425120772947)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmps8rflvwh_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0.12345679012345678)'\n    ---\
    \ FAIL: TestTruncate_Number/test_num__2 (0.00s)\n        tmps8rflvwh_test.go:34:\
    \ expected '%!s(float64=0)', got '%!s(float64=5.5156950672645735)'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return float64(number) / float64(math.Pow10(float64(TruncateDecimalPlace(number))))\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjoq9d1lg_test.go:15:38: undefined: math

    /tmp/tmpjoq9d1lg_test.go:15:57: undefined: TruncateDecimalPlace

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number - float64(integer(number))\n    decimal := number -\
    \ float64(integer)\n    if integer < 0.5 {\n        return float64(decimal)\n\
    \    }\n    return float64(decimal) + 0.5\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp69naoij7_test.go:15:33: undefined: integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := number - (number % 1)\n    return truncated\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnma56gdx_test.go:15:28: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, _ := TruncateFloat64ToInt64(number)\n    return float64(integer)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpan_nopzw_test.go:15:19: undefined: TruncateFloat64ToInt64

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Convert floating point number to integer (largest integer smaller\
    \ than given number)\n    integer := int64(number)\n    integer_part := integer\
    \ % 1\n\n    // Get decimal part\n    fractional := number - integer_part\n  \
    \  decimal_part := fractional / 1\n\n    // Return decimal part\n    return decimal_part\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzsyi59lq_test.go:20:19: invalid operation: number - integer_part (mismatched
    types float64 and int64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(number%1)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmvw9bfo_test.go:15:29: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number -= float64(number%1)\n    return number / 1\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk3fnafet_test.go:15:23: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimals := math.Modf(number)\n    return math.Trunc(decimals)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_7wsxirl_test.go:15:26: undefined: math

    /tmp/tmp_7wsxirl_test.go:16:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer float64\n    var decimals float64\n    if number <= 0 {\n\
    \        fmt.Printf(\"negative number: %.16f\\n\", number)\n        return number\n\
    \    }\n    integer = float64(math.Trunc(number))\n    decimals = float64(math.Ceil(math.Abs(number)))\n\
    \    return integer + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5dpoaj7v_test.go:21:23: undefined: math

    /tmp/tmp5dpoaj7v_test.go:22:24: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return number\n    }\n\n    if number == 0 {\n\
    \        return number\n    }\n\n    intPart := int(number)\n    decimals := number\
    \ - float64(intPart)\n    return intPart + decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmlgqq5il_test.go:25:12: invalid operation: intPart + decimals (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    x := number - (float64)(number)\n    x /= 10\n    return float64(x)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpyk_27erw_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpyk_27erw_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075276
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return math.Trunc(number*1000) / 1000\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9myfzfna_test.go:15:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number_int, number_fraction := math.Trunc(number), number - float64(number_int)\n\
    \    return number_fraction\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk5m2qvad_test.go:15:36: undefined: math

    /tmp/tmpk5m2qvad_test.go:15:73: undefined: number_int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number > 0 {\n        return number / 10\n    }\n    return number\
    \ / 10\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp52mftv4y_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=0.35)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp52mftv4y_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0.125)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp52mftv4y_test.go:36: expected '%!s(float64=0)', got '%!s(float64=12.3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075276
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part, decimals := math.Trunc(number), math.Floor(number)\n    return\
    \ decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpok079o36_test.go:15:27: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart, decimalpart := math.Trunc(number)\n    return decimalpart\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps3up86yp_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := float64(0)\n    decimal_part := float64(0)\n    i :=\
    \ 0\n    for i < 50 {\n        i ++\n        integer_part += float64(number) -\
    \ (float64(number) % (float64(i+1)))\n        decimal_part = float64(number) -\
    \ (float64(number) % (float64(i+1)))\n        if decimal_part < float64(0) {\n\
    \            break\n        }\n    }\n    return decimal_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwup32anj_test.go:20:44: invalid operation: operator % not defined on float64(number)
    (value of type float64)

    /tmp/tmpwup32anj_test.go:21:43: invalid operation: operator % not defined on float64(number)
    (value of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    sign, exponent := math.Abs(number)\n    integer := number / math.Pow10(exponent)\n\
    \    decimal := number - float64(integer) * math.Pow10(exponent)\n    if math.IsNaN(decimal)\
    \ {\n        fmt.Printf(\"truncate_number(%v) = %v\\n\", number, decimal)\n  \
    \  }\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8__b0erc_test.go:15:23: undefined: math

    /tmp/tmp8__b0erc_test.go:16:25: undefined: math

    /tmp/tmp8__b0erc_test.go:17:44: undefined: math

    /tmp/tmp8__b0erc_test.go:18:8: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := int64(number)\n    decimal := number - int64(int_part)\n\n\
    \    parts := []float64{decimal}\n\n    for i := 1; i < 6; i++ {\n        int_part\
    \ = int64(int_part*10 + 0.5)\n        decimal = decimal / 10\n        parts =\
    \ append(parts, decimal)\n    }\n\n    return parts[len(parts)-1]\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa4nek_ox_test.go:16:16: invalid operation: number - int64(int_part) (mismatched
    types float64 and int64)

    /tmp/tmpa4nek_ox_test.go:21:40: 0.5 (untyped float constant) truncated to int64

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart := float64(number-int(number))\n    if intpart >= 1.0 {\n   \
    \     return intpart - 1\n    }\n    return intpart\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplstnb2rx_test.go:15:24: invalid operation: number - int(number) (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // The largest integer smaller than the given number x is just\n    //\
    \ the floor of (x - floor(x / x)). Subtracting that is x % x.\n    x := float64(number\
    \ - math.Floor(number / number))\n    // The decimal part of a number x is x %\
    \ 1.\n    x -= x % 1\n    return x\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq7qc2o9t_test.go:17:27: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075276
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := float64(0)\n    decimals := float64(0)\n    exponent := float64(0)\n\
    \    exponent += float64(exponent/3) * float64(1/3)\n    for number >= 1<<10 {\n\
    \        integer += number\n        number -= number<<10\n        exponent++\n\
    \    }\n    exponent -= float64(exponent/3)\n    if number == 0 {\n        return\
    \ float64(integer)\n    }\n    integer += float64(integer)\n    if number < 1<<5\
    \ {\n        decimals = float64(integer)\n    } else {\n        decimals = float64(integer)\
    \ + float64(number)/float64(1<<(5 - exponent))\n    }\n    return decimals\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2qswt2o3_test.go:21:19: invalid operation: shifted operand number (variable
    of type float64) must be integer

    /tmp/tmp2qswt2o3_test.go:32:66: invalid operation: shift count (5 - exponent)
    (value of type float64) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    n := float64(number)\n    decimals := n - float64(trunc(n))\n    return\
    \ decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps7dbu3ez_test.go:16:29: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return 0.0\n    }\n    decimals := float64(number)\n\
    \    if number == 0 {\n        return 0.0\n    }\n    if number < 1.0 {\n    \
    \    decimals = 1 - decimals\n    }\n    return decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp0yh3j7vh_test.go:43: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp0yh3j7vh_test.go:43:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp0yh3j7vh_test.go:43: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return float64(number % 1)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbuxhdtyx_test.go:15:20: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var fraction float64\n    if number < 0 {\n        fraction = -math.Ceil(math.Log10(-number))\n\
    \    } else {\n        fraction = math.Ceil(math.Log10(number))\n    }\n\n   \
    \ return number / fraction\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc7kdmtnq_test.go:17:21: undefined: math

    /tmp/tmpc7kdmtnq_test.go:19:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := number - float64(number)\n    if int_part < 0 {\n       \
    \ int_part = -int_part\n    }\n    frac_part := float64(number) - int_part\n \
    \   if frac_part < 0 {\n        return int_part + (frac_part * float64(-1))\n\
    \    }\n    return int_part\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpn22p6xpt_test.go:41: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpn22p6xpt_test.go:41:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075278
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part    := number / float64(100)\n    trunc_part := number - int_part\
    \ * float64(100)\n    return trunc_part\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpl97k6wic_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=-4.440892098500626e-16)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpl97k6wic_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    decimals := float64(0)\n    if number > 0 {\n        exponent, fraction\
    \ := math.Modf(number)\n        if exponent != 0 {\n            decimals = fraction\
    \ / math.Pow10(exponent)\n        }\n    }\n    return number\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf5s19sw1_test.go:17:31: undefined: math

    /tmp/tmpf5s19sw1_test.go:19:35: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6cjlcj7_test.go:15:29: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / math.Pow10(10)\n    return math.Trunc(integer) *\
    \ math.Pow10(10-1) + math.Floor(number)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppf_phlyj_test.go:15:25: undefined: math

    /tmp/tmppf_phlyj_test.go:16:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer = number / float64(10)\n    decimal = number - float64(integer)\
    \ * float64(10)\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pq_cv45_test.go:15:5: undefined: integer

    /tmp/tmp3pq_cv45_test.go:16:5: undefined: decimal

    /tmp/tmp3pq_cv45_test.go:16:32: undefined: integer

    /tmp/tmp3pq_cv45_test.go:17:12: undefined: decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part, decimals := truncate_number_helper(number)\n    return number-int_part\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoldlws_i_test.go:15:27: undefined: truncate_number_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := math.Trunc(number)\n    decimal := number - integer\n    decimal\
    \ /= 10\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuuwp81kk_test.go:15:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part, decimals := math.Trunc(number), 64 - math.Ceil(float64(decimals))\n\
    \    return int_part / 10 * 10 + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvl4j5hvk_test.go:15:27: undefined: math

    /tmp/tmpvl4j5hvk_test.go:15:70: undefined: decimals

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := number - float64(math.Trunc(number))\n    if truncated <\
    \ 0 {\n        truncated = math.Trunc(truncated)\n    }\n    return truncated\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplmv6b6z9_test.go:15:35: undefined: math

    /tmp/tmplmv6b6z9_test.go:17:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimals := number - float64(integer)\n \
    \   if decimals < 0.0000000000001 {\n        decimals = 0.0000000000001\n    }\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmppsauj2r7_test.go:38: expected '%!s(float64=0)', got '%!s(float64=1e-13)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 1 {\n        return number\n    }\n    truncated := float64(0)\n\
    \    integral := number\n    decimal := number\n    for true {\n        if integral\
    \ > truncated {\n            return decimal\n        }\n        decimal += float64(10*decimal)/float64(10)\n\
    \        integral /= 10\n    }\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg1kso_l8_test.go:28:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return trunc(number) - number\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkucy6zi7_test.go:15:12: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    exponent := int(float64(number))\n    decimal := number - float64(exponent)\n\
    \    integer := float64(exponent)\n    if decimal < 0 || number == 0 {\n     \
    \   return number\n    }\n    number /= 10\n    return number\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1xa4u1wl_test.go:17:5: integer declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart := number\n    if intPart < 1 {\n        intPart = 1\n    }\n\
    \n    decimalPart := number - intPart\n    if decimalPart < 0 {\n        decimalPart\
    \ = 1\n    }\n\n    return decimalPart\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpfwvoxewp_test.go:43: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpfwvoxewp_test.go:43:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    precision, fraction, exponent := float64(0), float64(0), 0\n    number\
    \ -= float64(math.Trunc(number))\n    if math.Abs(number) >= 1 {\n        precision,\
    \ fraction = float64(math.Ceil(number)), float64(number - math.Trunc(number))\n\
    \    }\n    if math.Abs(fraction) >= 1 {\n        exponent = math.Floor(math.Log10(math.Abs(fraction)))\n\
    \        fraction = math.Mod(fraction, math.Pow10(exponent))\n    }\n    if exponent\
    \ < 0 {\n        fraction = 0\n    }\n    return math.Pow10(precision + exponent)\
    \ + fraction\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpilxvtmzd_test.go:16:23: undefined: math

    /tmp/tmpilxvtmzd_test.go:17:8: undefined: math

    /tmp/tmpilxvtmzd_test.go:18:39: undefined: math

    /tmp/tmpilxvtmzd_test.go:20:8: undefined: math

    /tmp/tmpilxvtmzd_test.go:21:20: undefined: math

    /tmp/tmpilxvtmzd_test.go:22:20: undefined: math

    /tmp/tmpilxvtmzd_test.go:27:12: undefined: math

    /tmp/tmpilxvtmzd_test.go:27:23: invalid operation: precision + exponent (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number % 1\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwepx86ps_test.go:15:12: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / float64(1e9)\n    integer -= integer % float64(1e9)\n\
    \    return float64(integer) * 1e9\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvqxga9nx_test.go:16:16: invalid operation: operator % not defined on integer
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := number % 1\n    decimals := number - integer_part\n \
    \   decimals *= 10\n    return integer_part + decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmsujk85_test.go:15:21: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := number / float64(10)\n    decimals := number % float64(10)\n\
    \    return integer_part * float64(10) + decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqxm5auf7_test.go:16:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart := int(number)\n    decimals := float64(number - intPart)\n \
    \   if decimals < 0 {\n        return intPart\n    }\n    return intPart + 1\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7jdkh42y_test.go:16:25: invalid operation: number - intPart (mismatched
    types float64 and int)

    /tmp/tmp7jdkh42y_test.go:18:16: cannot use intPart (variable of type int) as type
    float64 in return statement

    /tmp/tmp7jdkh42y_test.go:20:12: cannot use intPart + 1 (value of type int) as
    type float64 in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    x := float64(number)\n    integer := x\n    decimal := x - integer\n\
    \    if decimal > 0 {\n        // Decimal part larger than zero, shift decimal\
    \ part to left.\n        integer = integer + (decimal-1)\n        decimal = 0\n\
    \    } else {\n        // Decimal part smaller than zero, shift decimal part to\
    \ right.\n        integer = integer + (decimal+1)\n        decimal = 0\n    }\n\
    \    return integer\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpha448jzc_test.go:45: expected '%!s(float64=0.5)', got '%!s(float64=4.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpha448jzc_test.go:45:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=2.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpha448jzc_test.go:45: expected '%!s(float64=0)', got '%!s(float64=124)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number == 0.0 {\n        return number\n    }\n    integer, decimals\
    \ := math.Modf(number)\n    return decimal + number-integer\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw0xwt33__test.go:18:26: undefined: math

    /tmp/tmpw0xwt33__test.go:19:12: undefined: decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := number / float64(100)\n    remaining_number := number\
    \ % float64(100)\n    if remaining_number > 0 {\n        return integer_part +\
    \ float64(remaining_number)\n    }\n    return integer_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj2lhoegk_test.go:16:25: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        number *= -1\n    }\n    return float64(math.Trunc(number))\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe_mz04hd_test.go:18:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 1 {\n        number *= 1.0\n    }\n    return number\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpu3eq09ce_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpu3eq09ce_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpu3eq09ce_test.go:36: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number == 0.0 {\n        return number\n    }\n    return number /\
    \ math.Pow10(math.Floor(math.Log10(number)))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2zdjyy82_test.go:18:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return math.Trunc(number*100) / 100\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcpc408wa_test.go:15:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart, decimalpart := math.Trunc(number), math.Ceil(number*100)\n \
    \   if decimalpart == 0 {\n        return intpart\n    }\n    return intpart/decimalpart\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplt9yr1pa_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number_as_string := fmt.Sprintf(\"%f\", number)\n    number_index :=\
    \ strings.Index(number_as_string, \".\")\n    if number_index < 0 {\n        return\
    \ number\n    }\n    left_over_part := strings.Index(number_as_string[:number_index],\
    \ \".\") - 1\n    integer_part := number_index + 1\n    return float64(integer_part)\
    \ / float64(left_over_part)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprz15aqx6_test.go:16:21: undefined: strings

    /tmp/tmprz15aqx6_test.go:20:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integerPart float64\n    var decimalPart float64\n    if number >=\
    \ 0 {\n        integerPart = floor(number)\n        decimalPart = number-integerPart\n\
    \    } else {\n        integerPart = ceil(number)\n        decimalPart = number-integerPart\n\
    \    }\n    return decimalPart\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9jq0vif3_test.go:18:23: undefined: floor

    /tmp/tmp9jq0vif3_test.go:21:23: undefined: ceil

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number == 0 {\n        return number\n    }\n\n    // The largest\
    \ integer smaller than number\n    var biggest float64\n    for i := 0; i < 64;\
    \ i++ {\n        if number <= float64(i) {\n            biggest = float64(i)\n\
    \            break\n        }\n    }\n\n    parts := biggest/float64(number)\n\
    \    rest := biggest - parts*float64(number)\n    return parts + rest\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpt6typqb3_test.go:48: expected '%!s(float64=0.5)', got '%!s(float64=1.1428571428571428)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpt6typqb3_test.go:48:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.6)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return float64(number) / float64(math.Pow10(float64(len(fmt.Sprintf(\"\
    %.1f\", number)))))\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpil32m6un_test.go:15:38: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := math.Floor(number*10 + 0.5)\n    decimal := number - float64(integer)*10\n\
    \    return float64(decimal)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvm4xtcns_test.go:15:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return -1\n    }\n    return float64(number)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpagwxs1ca_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpagwxs1ca_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpagwxs1ca_test.go:36: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integ, exp := math.Modf(number)\n    if exp < 0 {\n        integ = 1\n\
    \        exp = 0\n    }\n    return math.Trunc(float64(integ))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzeiav14e_test.go:15:19: undefined: math

    /tmp/tmpzeiav14e_test.go:20:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    parts := float64(number).Truncate(1).Div(-2)\n    if parts < 1 {\n  \
    \      return 0.0;\n    }\n    return parts;\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk4rl8kvd_test.go:15:30: float64(number).Truncate undefined (type float64
    has no field or method Truncate)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        number = -number\n    }\n\n    i := float64(0)\n\
    \    l := float64(math.Trunc(number))\n\n    if l < i {\n        i, l = l, i\n\
    \    }\n    return number - l\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfd4wcrvm_test.go:20:18: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0.0 {\n        fmt.Println(\"Truncating to zero\")\n    \
    \    return 0.0\n    }\n    int_part := int(number)\n    decimal_part := number\
    \ - float64(int_part)\n    return float64(int_part) + decimal_part/float64(10)\n\
    }\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpu435t7uy_test.go:38: expected '%!s(float64=0.5)', got '%!s(float64=3.05)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpu435t7uy_test.go:38:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.025)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpu435t7uy_test.go:38: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return float64(number) - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmp749hn8_test.go:15:38: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - (number%1)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0i5b8msy_test.go:15:22: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var intPart float64\n    var decimals float64\n    if number < 0.0 {\n\
    \        intPart = -number\n        decimals = 0.\n    } else {\n        intPart\
    \ = number\n        decimals = 0.\n    }\n    for decimals <= 0 && intPart > 0.0\
    \ {\n        intPart -= math.Floor(intPart)\n    }\n    return intPart\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprk73p60j_test.go:25:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return math.Trunc(number * 100) / 100\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdgs8a18_test.go:15:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer float64\n    var decimals float64\n    math.Abs(number)\n\
    \    number = number - math.Floor(number)\n    integer = math.Trunc(number)\n\
    \    decimals = number - math.Trunc(number)\n    integer = integer + math.Floor(decimals)\n\
    \    return integer + math.Floor(decimals)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdi20k0l__test.go:17:5: undefined: math

    /tmp/tmpdi20k0l__test.go:18:23: undefined: math

    /tmp/tmpdi20k0l__test.go:19:15: undefined: math

    /tmp/tmpdi20k0l__test.go:20:25: undefined: math

    /tmp/tmpdi20k0l__test.go:21:25: undefined: math

    /tmp/tmpdi20k0l__test.go:22:22: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Decompose number into integer and decimal parts.\n    var int int\n\
    \    var decimals int\n    if number >= 0 {\n        int, decimals = math.Ceil(number),\
    \ 0\n    } else {\n        int, decimals = math.Floor(number), 0\n    }\n\n  \
    \  // Truncate decimal parts such that there are only two decimal places.\n  \
    \  return math.Trunc(number*100)/100.0\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdt7gk3h0_test.go:17:18: int (variable of type int) is not a type

    /tmp/tmpdt7gk3h0_test.go:19:25: undefined: math

    /tmp/tmpdt7gk3h0_test.go:21:25: undefined: math

    /tmp/tmpdt7gk3h0_test.go:25:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    decimals := math.Trunc(number*10)/10\n    return number - decimals\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi249lvq4_test.go:15:17: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part   := math.Floor(number)\n    fractional := number - int_part\n\
    \    return fractional\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmd68e52x_test.go:15:19: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimal := number - float64(integer)\n\n\
    \    return float64(integer)*10 + float64(decimal)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp3g9rdgqn_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=30.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp3g9rdgqn_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=10.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp3g9rdgqn_test.go:36: expected '%!s(float64=0)', got '%!s(float64=1230)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part, decimal_part = math.Modf(number)\n    return decimal_part\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptdxfhk50_test.go:15:5: undefined: integer_part

    /tmp/tmptdxfhk50_test.go:15:19: undefined: decimal_part

    /tmp/tmptdxfhk50_test.go:15:34: undefined: math

    /tmp/tmptdxfhk50_test.go:16:12: undefined: decimal_part

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number % 1\n    decimal := number - integer\n    return integer\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mbw0t5p_test.go:15:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Ensure that the number is positive.\n    if number < 0 {\n       \
    \ return number\n    }\n    number -= float64(trunc(number))\n    number /= float64(trunc(number))\n\
    \    number += 0.5\n    return number\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr1o5ccuw_test.go:19:23: undefined: trunc

    /tmp/tmpr1o5ccuw_test.go:20:23: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number % 1\n    decimal := number - integer\n    return decimal\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmp1w1l_x_test.go:15:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    i := int64(math.Trunc(number))\n    return float64(i) / float64(i)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7c2kj58g_test.go:15:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integerPart float64\n    var decimalPart float64\n    if number <\
    \ 0 {\n        number *= -1\n    }\n    if number == 0.0 {\n        return 0\n\
    \    }\n    integerPart = float64(math.Ceil(number))\n    decimalPart = float64(number\
    \ - math.Trunc(number))\n    return decimalPart\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz24krjbg_test.go:23:27: undefined: math

    /tmp/tmpz24krjbg_test.go:24:36: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart:= number - int(number)\n    decimalPart := number - intPart\n\
    \    return decimalPart\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp014kabjg_test.go:15:15: invalid operation: number - int(number) (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := float64(integer(number))\n    fractional := number - integer\n\
    \    fraction := float64(fractional(fractional))\n    return fraction\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiarf826o_test.go:15:24: undefined: integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPartDiff := number % 1\n    decimalsPart := number - intPartDiff\n\
    \n    intPart := float64(intPartDiff)\n\n    return intPart + decimalsPart\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnycrlgmk_test.go:15:20: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var intPart float64\n    var decimals float64\n    var exponent int\n\
    \n    if number <= 0 {\n        fmt.Fprintf(os.Stderr, \"number must be positive\"\
    )\n        os.Exit(1)\n    }\n\n    decimals = math.Trunc(number)\n    intPart\
    \ = number - decimals\n    exponent = math.Floor(math.Log(intPart) / math.Log(10))\n\
    \n    return decimals + float64(exponent) * math.Pow(10, exponent)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0mznn9dl_test.go:20:21: undefined: os

    /tmp/tmp0mznn9dl_test.go:21:9: undefined: os

    /tmp/tmp0mznn9dl_test.go:24:16: undefined: math

    /tmp/tmp0mznn9dl_test.go:26:16: undefined: math

    /tmp/tmp0mznn9dl_test.go:28:43: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number % 1\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwepx86ps_test.go:15:12: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075278
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // We use floor for negative numbers to prevent a divide by zero error.\n\
    \    return floor(number * 100) / 100\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplqv98u15_test.go:16:12: undefined: floor

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return -0.0\n    }\n    return number\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp3u7m9rnv_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp3u7m9rnv_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp3u7m9rnv_test.go:36: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075282
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    result := number / float64(10000000)\n    return result / float64(10)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpj819wsty_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=3.4999999999999996e-08)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpj819wsty_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25e-08)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpj819wsty_test.go:34: expected '%!s(float64=0)', got '%!s(float64=1.23e-06)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number <= 0 {\n        return math.NaN()\n    }\n    integer := math.Trunc(number)\n\
    \    decimal := number - integer\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_8ffb_q2_test.go:16:16: undefined: math

    /tmp/tmp_8ffb_q2_test.go:18:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := trunc(number)\n    return number - trunc(number)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpawy_p1iv_test.go:15:16: undefined: trunc

    /tmp/tmpawy_p1iv_test.go:16:21: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integerPart float64\n    var decimalPart float64\n    var powerOf10\
    \ float64\n\n    if number < 0 {\n        decimalPart = -1\n    } else {\n   \
    \     powerOf10 = math.Pow(10.0, float64(number))\n        integerPart = math.Floor(number/powerOf10)\n\
    \        decimalPart = number - integerPart * powerOf10\n    }\n    return decimalPart\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqawh5oy_test.go:22:21: undefined: math

    /tmp/tmpmqawh5oy_test.go:23:23: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return math.Copysign(1, number)\n    }\n   \
    \ return math.Trunc(number)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv885rpe9_test.go:16:16: undefined: math

    /tmp/tmpv885rpe9_test.go:18:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    if integer < 0 {\n        integer = 0\n \
    \   }\n    return number - float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    n := math.Trunc(number)\n    if n > 0 {\n        x := math.Floor(number)\n\
    \        return x\n    } else {\n        x := math.Ceil(number)\n        return\
    \ x\n    }\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp51_l7tg5_test.go:15:10: undefined: math

    /tmp/tmp51_l7tg5_test.go:17:14: undefined: math

    /tmp/tmp51_l7tg5_test.go:20:14: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number - float64(Truncate(number, 0))\n    return integer\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzp5zxwmb_test.go:15:33: undefined: Truncate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number <= 0.0 {\n        return 0.0\n    }\n\n    if number < 1.0\
    \ {\n        return number\n    }\n\n    if number == 1.0000000001 {\n       \
    \ return 0.9999999999999999\n    }\n\n    integer := float64(int64(number))\n\
    \    decimals := number - float64(integer)\n    decimal := math.Trunc(decimals)\n\
    \n    return decimal + float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzlgrqjrz_test.go:29:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimals := math.Modf(number)\n    return number - math.Trunc(number)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprdpnfp3g_test.go:15:26: undefined: math

    /tmp/tmprdpnfp3g_test.go:16:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Ensure number is positive.\n    if number < 0 {\n        return number\n\
    \    }\n    // Ensure number is smaller than 1.\n    if number > 1 {\n       \
    \ return number\n    }\n    // Get integer part.\n    integer := int(number)\n\
    \    // Get decimal part.\n    decimal := number - float64(integer)\n    // Return\
    \ decimal part.\n    return float64(decimal)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpwajkhsd8_test.go:46: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpwajkhsd8_test.go:46:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpwajkhsd8_test.go:46: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart, _ := truncate_decimal(number, 1)\n    decimalpart, _ := truncate_decimal(number\
    \ - intpart, -1)\n    return decimalpart\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphizzxkgq_test.go:15:19: undefined: truncate_decimal

    /tmp/tmphizzxkgq_test.go:16:23: undefined: truncate_decimal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    sign := number < 0\n    number -= sign * float64(trunc_int(number))\n\
    \    integer := trunc_int(number)\n    decimals := number - trunc_int(number)\n\
    \    if decimals == 0 {\n        return trunc_int(number)\n    }\n    return sign\
    \ * float64(integer)*math.Pow10(decimals)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcbsogchq_test.go:16:30: undefined: trunc_int

    /tmp/tmpcbsogchq_test.go:17:16: undefined: trunc_int

    /tmp/tmpcbsogchq_test.go:18:26: undefined: trunc_int

    /tmp/tmpcbsogchq_test.go:20:16: undefined: trunc_int

    /tmp/tmpcbsogchq_test.go:22:36: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // get the smallest integer smaller than the number\n    var smallest_integer\
    \ float64 = 1\n    if number < smallest_integer {\n        smallest_integer =\
    \ number\n    }\n\n    // get decimal part by dividing the number by its smallest\
    \ integer\n    var decimal_part float64 = number/smallest_integer\n\n    // add\
    \ 1 to the decimal part if it is smaller than 1\n    if decimal_part < 1 {\n \
    \       decimal_part += 1\n    }\n\n    // truncate decimal part\n    return decimal_part\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpph38naui_test.go:48: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpph38naui_test.go:48:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpph38naui_test.go:48: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075284
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    result := 0\n    exponent := 0\n    if number == 0.0 {\n        return\
    \ 0\n    }\n    if number > 0.0 {\n        // get exponent\n        if number%1\
    \ < 1e-6 {\n            exponent = 0\n        }\n        else {\n            exponent\
    \ = int(math.Log10(number))\n        }\n        // get digits\n        number\
    \ = number/10\n        result += number%1 * float64(10**(exponent - 1))\n    \
    \    result /= float64(10**(exponent + 1))\n    }\n    return result\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd8l1uhfs_test.go:25:9: expected statement, found ''else''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(number%1)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmvw9bfo_test.go:15:29: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6cjlcj7_test.go:15:29: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075277
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := floorf(number)\n    decimal := number - integer\n    if decimal\
    \ < 0 {\n        decimal *= -1\n    }\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptve6e6n7_test.go:15:16: undefined: floorf

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := float64(number)\n    decimal_part := float64(number)\
    \ - integer_part\n    return integer_part\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3g59zhd3_test.go:16:5: decimal_part declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    decimals := float64(number%1)\n    intPart := float64(number/decimals)\n\
    \    intPart = float64(intPart%1)\n    return intPart + decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxi8m5tjy_test.go:15:25: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    parts := fmt.Sprintf(\"%f\", number)\n    parts := strings.Split(parts,\
    \ \"E\")\n    if len(parts) > 2 {\n        // the number is too large to be represented\
    \ as a float64\n        // It will be truncated to fit into float64 type\n   \
    \     parts = parts[:len(parts)-1]\n    }\n    if parts[0] == \"-\" {\n      \
    \  parts[0] = \"\"\n    }\n    return fmt.Sprintf(\"%f\", float64(parts[0])+parts[1])\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdhd3rxd0_test.go:16:11: no new variables on left side of :=

    /tmp/tmpdhd3rxd0_test.go:16:14: undefined: strings

    /tmp/tmpdhd3rxd0_test.go:22:20: invalid operation: parts[0] == "-" (mismatched
    types byte and untyped string)

    /tmp/tmpdhd3rxd0_test.go:23:9: cannot assign to parts[0] (value of type byte)

    /tmp/tmpdhd3rxd0_test.go:25:12: cannot use fmt.Sprintf("%f", float64(parts[0])
    + parts[1]) (value of type string) as type float64 in return statement

    /tmp/tmpdhd3rxd0_test.go:25:30: invalid operation: float64(parts[0]) + parts[1]
    (mismatched types float64 and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / float64(math.Pow10(math.Floor(math.Log10(number))))\n\
    \    return integer * float64(math.Pow10(math.Floor(math.Log10(integer))))\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8dncj8bg_test.go:15:33: undefined: math

    /tmp/tmp8dncj8bg_test.go:16:30: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    exponent := int(math.Floor(math.Log(number, 10)))\n    exponent -= len(fmt.Sprintf(\"\
    %.0f\", number))\n    decimal := number % 1\n    if decimal > 0 {\n        decimal\
    \ = 1\n    }\n    return float64(number) / float64(10^exponent)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4smplm3_test.go:15:21: undefined: math

    /tmp/tmpq4smplm3_test.go:17:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := math.Trunc(number)\n    decimal := number - integer\n    if\
    \ decimal < 1 {\n        return 0.0\n    }\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx4air4dl_test.go:15:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimals := math.Modf(number)\n    return number-float64(integer+decimals)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpps4h1oko_test.go:15:26: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return math.Trunc(number * 100)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp0prexb9_test.go:15:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - math.Floor(number)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpo50jhi_test.go:15:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number <= 0 {\n        return float64(0)\n    }\n    int_part, decimals\
    \ := float64(0), float64(0)\n    for i := float64(0); i < number; i++ {\n    \
    \    int_part += float64(digit(i))\n    }\n    if number < 10 {\n        decimals\
    \ = float64(digit(number))\n    } else {\n        decimals = float64(digit(number)-int(log10(number)))\n\
    \    }\n    return int_part + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfpu3wvh3_test.go:20:29: undefined: digit

    /tmp/tmpfpu3wvh3_test.go:23:28: undefined: digit

    /tmp/tmpfpu3wvh3_test.go:25:28: undefined: digit

    /tmp/tmpfpu3wvh3_test.go:25:46: undefined: log10

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return number\n    }\n    intPart := int(number)\n\
    \    decimalPart := number - float64(intPart)\n    return decimalPart\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    exponent := math.Floor(math.Log(number, 10))\n    decimal := number /\
    \ math.Pow10(exponent)\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4o0ke90w_test.go:15:17: undefined: math

    /tmp/tmp4o0ke90w_test.go:16:25: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number // number is the floating point number\n    decimal\
    \ := number - math.Floor(number)\n    if decimal > 0 {\n        return math.Ceil(number)\
    \ / 10\n    } else {\n        return math.Floor(number) / 10\n    }\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl6imnj2u_test.go:15:5: integer declared but not used

    /tmp/tmpl6imnj2u_test.go:16:25: undefined: math

    /tmp/tmpl6imnj2u_test.go:18:16: undefined: math

    /tmp/tmpl6imnj2u_test.go:20:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimals := number - float64(integer)\n \
    \   if decimals > 0 {\n        return integer\n    }\n    return 0\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9f9wwc1r_test.go:18:16: cannot use integer (variable of type int) as type
    float64 in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimals := number - float64(integer)\n \
    \   return float64(integer)+decimals\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp3ojygom4_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp3ojygom4_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp3ojygom4_test.go:35: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integerPart := math.Trunc(number)\n    decimalPart := number - integerPart\n\
    \    return decimalPart\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvf0k28g4_test.go:15:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Get the integer part\n    var int_part float64\n    if number < 1\
    \ {\n        return 1.0\n    }\n    if number < 1.0 {\n        int_part = number\n\
    \    } else {\n        int_part = float64(math.Floor(number))\n    }\n\n    //\
    \ Get the decimals\n    var decimals float64\n    if number < 1 {\n        return\
    \ 1.0\n    }\n    if number < 1.0 {\n        decimals = number - int_part\n  \
    \  } else {\n        decimals = float64(math.Ceil(number))\n    }\n\n    return\
    \ int_part + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_ukjb2f_test.go:23:28: undefined: math

    /tmp/tmpf_ukjb2f_test.go:34:28: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(number%1)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmvw9bfo_test.go:15:29: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075275
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // The smallest number we could truncate to is the number itself.\n \
    \   if number < 0 {\n        return number\n    }\n    // If we are rounding to\
    \ zero, return zero.\n    if number == 0 {\n        return 0\n    }\n    // If\
    \ the number is equal to or greater than 1, then we know\n    // that it is non-zero\
    \ and truncate it to zero.\n    if number > 1 {\n        return 0\n    }\n   \
    \ // If the number is equal to 1, then we have 1 fraction and\n    // we know\
    \ that truncating it will leave no fraction.\n    if number == 1 {\n        return\
    \ number\n    }\n    // If the number is 0, then we know that it is non-zero\n\
    \    // and truncating it will leave no fraction.\n    if number == 0 {\n    \
    \    return number\n    }\n    // We are rounding to some fraction.  Divide by\
    \ 10\n    // to get a base-10 approximation of the fraction.\n    numerator :=\
    \ math.Trunc(number) / float64(10)\n    // Round to 2 decimal places.\n    return\
    \ math.Round(numerator * float64(100))\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17sbgey6_test.go:40:18: undefined: math

    /tmp/tmp17sbgey6_test.go:42:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return math.NaN()\n    }\n\n    decimal_part\
    \ := number % 1\n    integer_part := math.Floor(number) - decimal_part\n\n   \
    \ return float64(integer_part) + decimal_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_ip0vwp_test.go:16:16: undefined: math

    /tmp/tmpz_ip0vwp_test.go:19:21: invalid operation: operator % not defined on number
    (variable of type float64)

    /tmp/tmpz_ip0vwp_test.go:20:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    big, _ := math.Modf((float64)(number), 1.0)\n    return big\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpid91d_kz_test.go:15:15: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := float64(number % 1)\n    decimal := number - integer\n   \
    \ return integer + decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp924gudz9_test.go:15:24: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Return truncated floating point number. \n    // Truncating a number\
    \ that cannot be represented with 32 bits\n    // does not throw an error. For\
    \ example, truncating a number of\n    // the form -0x1.fffffffp throws an exception,\
    \ because of the \n    // presence of minus sign in the fraction part.\n    var\
    \ result float64\n    result := number / math.Pow(10, math.Floor(math.Log10(number)))\n\
    \    return result\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0gicc4kl_test.go:21:12: no new variables on left side of :=

    /tmp/tmp0gicc4kl_test.go:21:24: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number / float64(math.Pow10(float64(len(fmt.Sprintf(\"%.1f\"\
    , number)))))\n    return integer\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp73xmbd0o_test.go:15:33: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part_int := int(number)\n    int_part_fract := number - float64(int_part_int)\n\
    \    decimal_part := number - int_part_int\n    return decimal_part\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpilt62ks4_test.go:16:5: int_part_fract declared but not used

    /tmp/tmpilt62ks4_test.go:17:21: invalid operation: number - int_part_int (mismatched
    types float64 and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return -1 * number\n    }\n\n    if number ==\
    \ 0 {\n        return 0\n    }\n\n    integer := 0\n    decimals := 0\n    exponent\
    \ := 0\n    fraction := number\n\n    fraction = float64(fraction)\n\n    fraction\
    \ = fraction / 10\n    fraction = math.Trunc(fraction)\n\n    if fraction != 0\
    \ {\n        decimals = 10\n    }\n\n    for fraction <= 0 || fraction > 10 {\n\
    \        if exponent == 0 {\n            integer++\n        }\n\n        fraction\
    \ = fraction * 10\n        fraction = math.Trunc(fraction)\n\n        if fraction\
    \ != 0 {\n            decimals++\n        }\n\n        exponent--\n    }\n\n \
    \   return float64(integer+decimals)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8le4_5bs_test.go:31:16: undefined: math

    /tmp/tmp8le4_5bs_test.go:43:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integr := number / float64(10)\n    decimals := number % float64(10)\n\
    \    return integr * float64(10) + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnczy8i9g_test.go:16:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integral := number\n    integral /= 10\n    decimal := number - integral\n\
    \    if decimal < 1 {\n        decimal = 1\n    }\n    return decimal\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpbcagjiym_test.go:39: expected '%!s(float64=0.5)', got '%!s(float64=3.15)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpbcagjiym_test.go:39:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.125)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpbcagjiym_test.go:39: expected '%!s(float64=0)', got '%!s(float64=110.7)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number <= 0 {\n        return 0.0\n    }\n    // Convert decimal part\
    \ (leftover part) to a positive integer.\n    // This integer should never be\
    \ bigger than the given number.\n    // It is used to make sure decimal part is\
    \ always smaller than 1.\n    decimal := math.Trunc(number * float64(1e2)) / 1e2\n\
    \    // Get the integer part (the largest integer smaller than given number).\n\
    \    // It should be bigger than the given number.\n    integer := math.Ceil(number)\n\
    \    // Return the integer part multiplied by 10^decimal.\n    return integer\
    \ * float64(10e2) + (decimal - 0.5)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9bzh7343_test.go:21:16: undefined: math

    /tmp/tmp9bzh7343_test.go:24:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    number -= float64(number%1)\n    integer := number%1\n    decimals :=\
    \ number/float64(integer)\n    return decimals\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprb7ibknh_test.go:15:23: invalid operation: operator % not defined on number
    (variable of type float64)

    /tmp/tmprb7ibknh_test.go:16:16: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    precision, mantissa := math.Modf(number)\n    integer := int(mantissa)\n\
    \    if mantissa > 0 {\n        return number - math.Mod(number, 1) * precision\n\
    \    }\n    decimals := precision - mantissa\n    return float64(integer) + decimals\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjn9vaam0_test.go:15:28: undefined: math

    /tmp/tmpjn9vaam0_test.go:18:25: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // If the input number is negative, just return it.\n    if number <\
    \ 0 {\n        return number\n    }\n\n    // Get the integer part of the number\n\
    \    integer := int(number)\n\n    // If the number is smaller than the integer\
    \ part, add one to the\n    // integer part and truncate the number again.\n \
    \   if integer < number {\n        integer += 1\n        number -= int64(integer)\n\
    \    }\n\n    // Return the integer part of the number\n    return float64(integer)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu5cwea6i_test.go:25:18: invalid operation: integer < number (mismatched
    types int and float64)

    /tmp/tmpu5cwea6i_test.go:27:9: invalid operation: number -= int64(integer) (mismatched
    types float64 and int64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int64(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075287
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := int(number)\n    fractional_part := number - float64(int_part)\n\
    \    \n    return fractional_part\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimal := number - float64(integer)\n  \
    \  if decimal <= 0 {\n        return integer\n    }\n    return integer\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix4i3ldj_test.go:18:16: cannot use integer (variable of type int) as type
    float64 in return statement

    /tmp/tmpix4i3ldj_test.go:20:12: cannot use integer (variable of type int) as type
    float64 in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncate_part_float := number % 1\n    integer := number / 1\n    return\
    \ truncate_part_float * 1\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7b70fwln_test.go:15:28: invalid operation: operator % not defined on number
    (variable of type float64)

    /tmp/tmp7b70fwln_test.go:16:5: integer declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integral := number % 1\n    if integral < 0.5 {\n        return integral\n\
    \    }\n    decimal := number - integral\n    integral /= 10\n    if integral\
    \ >= 0.5 {\n        return 0.5 + integral\n    }\n    return decimal + 1.0\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7v_2pr8s_test.go:15:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    bignumber := NewBigFloat(number)\n    i := bignumber.Int() //bignumber.Int()\
    \ will return a bigint instance\n    d := bignumber.Dec()\n    i := bignumber.Int()\
    \ //bignumber.Int() will return a bigint instance\n    f := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d := bignumber.Dec()\n\
    \    d := bignumber.Dec()\n    d := bignumber.Dec()\n    d \nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpulb77jti_test.go:77:6: expected ''('', found TestTruncate_Number

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi802lrwj_test.go:15:29: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075273
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number/float64(10.0)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp9pfq4awc_test.go:33: expected '%!s(float64=0.5)', got '%!s(float64=0.35)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp9pfq4awc_test.go:33:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0.125)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmp9pfq4awc_test.go:33: expected '%!s(float64=0)', got '%!s(float64=12.3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := floor(number)\n    decimal := number - integer\n    decimal\
    \ /= 10\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqf4mx5me_test.go:15:16: undefined: floor

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := math.Trunc(number)\n    decimal := number - integer\n    return\
    \ integer+decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1zxyu5f6_test.go:15:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := number - float64(floor(number))\n    int_part_is_odd := int_part\
    \ % 2 == 0\n    dec_part := number - int_part\n    dec_part_is_even := dec_part\
    \ % 2 == 0\n    int_part -= int_part_is_odd\n    dec_part -= dec_part_is_even\n\
    \    return float64(int_part) / float64(pow(10, dec_part))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp45hmyjyu_test.go:15:34: undefined: floor

    /tmp/tmp45hmyjyu_test.go:21:40: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Check if number is an integer\n    if number == floor(number) {\n\
    \        return floor(number)\n    }\n\n    // Extract integer part\n    integerPart\
    \ := floor(number)\n\n    // Decompose the floating point number\n    decimalPart\
    \ := number - integerPart\n\n    // The final result is the decimal part rounded\
    \ to the nearest integer\n    // If there's no fractional part, return 0\n   \
    \ if decimalPart == 0 {\n        return 0\n    }\n\n    return floor(decimalPart)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppkfhtuea_test.go:16:18: undefined: floor

    /tmp/tmppkfhtuea_test.go:17:16: undefined: floor

    /tmp/tmppkfhtuea_test.go:21:20: undefined: floor

    /tmp/tmppkfhtuea_test.go:32:12: undefined: floor

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := number / float64(10)\n    decimals := number % float64(10)\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp69hz6j6_test.go:15:5: integer_part declared but not used

    /tmp/tmpp69hz6j6_test.go:16:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    sign, exponent := math.Copysign(1, number)\n    exponent += int(math.Log10(number))\n\
    \    integer := math.Trunc(number)\n    if integer != number {\n        return\
    \ number\n    }\n    return integer - sign * (int(number) - sign * exponent)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbxi6dwv9_test.go:15:23: undefined: math

    /tmp/tmpbxi6dwv9_test.go:16:21: undefined: math

    /tmp/tmpbxi6dwv9_test.go:17:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    decimals := number % 1\n    integer := number / 1\n    return float64(integer)\
    \ + decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_7ijdx6u_test.go:15:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number % 1\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwepx86ps_test.go:15:12: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075278
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return float64(-number)\n    }\n    return number\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpg9p3k4k6_test.go:36: expected '%!s(float64=0.5)', got '%!s(float64=3.5)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpg9p3k4k6_test.go:36:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.25)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpg9p3k4k6_test.go:36: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := number % 1\n    return number - truncated\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1i75aggz_test.go:15:18: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integral := int(number)\n    decimal := number - float64(integral)\n\
    \    return float64(integral) + (float64(decimal)*(1.0/float64(10)))\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpmdpssq6k_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=3.05)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpmdpssq6k_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1.025)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpmdpssq6k_test.go:35: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart := number / float64(math.Pow(10.0, float64(math.Floor(math.Log10(number))))\n\
    \    decimalpart := number - intpart*float64(math.Pow(10.0, float64(math.Floor(math.Log10(number))))\n\
    \n    if decimalpart > 0.5 {\n        return intpart + float64(1)\n    } else\
    \ {\n        return intpart\n    }\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppm9g09jh_test.go:15:88: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := float64(number)\n    decimal_part := float64(number -\
    \ integer_part)\n    \n    // The result should be 0 if integer part is 0 and\
    \ fraction is 0.\n    if integer_part == 0 {\n        return 0\n    }\n    \n\
    \    // The result should be 1 if fraction is 0.\n    if decimal_part == 0 {\n\
    \        return 1\n    }\n\n    return decimal_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpp2m4xuac_test.go:46: expected '%!s(float64=0.5)', got '%!s(float64=1)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpp2m4xuac_test.go:46:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpp2m4xuac_test.go:46: expected '%!s(float64=0)', got '%!s(float64=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return 0\n    }\n\n    number -= float64(number%1)\n\
    \    number /= 10\n    return number\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpykxtmxts_test.go:19:23: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := number - float64(Truncate(number))\n    decimal := number\
    \ - float64(Truncate(integer))\n    if number > 0 {\n        return number - float64(Truncate(decimal))\n\
    \    }\n    return 0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcaa6dp71_test.go:15:33: undefined: Truncate

    /tmp/tmpcaa6dp71_test.go:16:33: undefined: Truncate

    /tmp/tmpcaa6dp71_test.go:18:33: undefined: Truncate

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - math.Trunc(number) - 1\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdd0yibax_test.go:15:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        fmt.Println(\"Negative number, cannot truncate\"\
    )\n        return number\n    }\n\n    // Find largest integer smaller than given\
    \ number\n    integer := number / float64(10)\n    // Find number of decimals\
    \ to remove from the right (always smaller than\n    // 1)\n    decimals := number\
    \ % float64(10) + 1\n\n    // Return the value of the decimals\n    return float64(decimals)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf4r_m40z_test.go:21:5: integer declared but not used

    /tmp/tmpf4r_m40z_test.go:24:17: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return number\n    }\n    number -= float64(trunc(number))\n\
    \    number /= float64(trunc(number))\n    return number\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp73joylit_test.go:18:23: undefined: trunc

    /tmp/tmp73joylit_test.go:19:23: undefined: trunc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part, decimals := math.Modf(number)\n    truncated := math.Trunc(number)\n\
    \    return truncated * math.Pow10(decimals)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw5168jqc_test.go:15:27: undefined: math

    /tmp/tmpw5168jqc_test.go:16:18: undefined: math

    /tmp/tmpw5168jqc_test.go:17:24: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integrand, decimalPart := math.Trunc(number), math.Ceil(number*10)\n\
    \    if decimalPart < 1 {\n        return number + float64(decimalPart)\n    }\n\
    \    return integrand\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdssmp4_2_test.go:15:31: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integ := floor(number)\n    if integ > number {\n        fmt.Println(\"\
    number is larger than integer\")\n    }\n    decimal := number - integ\n    decimal\
    \ /= 10\n    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg046iv2b_test.go:15:14: undefined: floor

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intpart := int(number)\n    if intpart == number {\n        return number\n\
    \    }\n    if intpart < number {\n        return number\n    }\n    return number\
    \ - float64(intpart)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu3n6amc4_test.go:16:19: invalid operation: intpart == number (mismatched
    types int and float64)

    /tmp/tmpu3n6amc4_test.go:19:18: invalid operation: intpart < number (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // If number is the integral part of zero, return it.\n    if number\
    \ == 0 {\n        return number\n    }\n    // If number is negative, return its\
    \ absolute value.\n    if number < 0 {\n        return -number\n    }\n    sign\
    \ := 1\n    // Divide number by 10 to get the integer part (largest integer smaller\
    \ than given number).\n    int_part := number / 10\n    // Divide number by 100\
    \ to get the decimal part (leftover part always smaller than 1).\n    decimal_part\
    \ := number % 10\n    // Multiply decimal_part by 10 to get the decimal part in\
    \ the range [0 - 9] (smallest possible number).\n    decimal_part = decimal_part\
    \ * 10\n    // If number is bigger than 10 return it.\n    if int_part > 10 {\n\
    \        return number\n    }\n    // Return decimal part multiplied by 10 + sign\
    \ (1 for negative, -1 for positive).\n    return decimal_part + sign\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_jnlt3zi_test.go:27:21: invalid operation: operator % not defined on number
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - truncate_number(math.Trunc(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32kquz77_test.go:15:37: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
