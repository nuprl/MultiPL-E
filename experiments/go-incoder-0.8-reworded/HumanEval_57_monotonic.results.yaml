language: go_test.go
name: HumanEval_57_monotonic
results:
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n\n    for i\
    \ := range l {\n        if l[i] < l[i-1] {\n            return false\n       \
    \ }\n    }\n    return true\n}\n</code>\nTest cases:\n<code>\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb68_iam0_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    switch {\n\
    \    case l[0] > l[1]:\n        // Increasing list.\n        return monotonic(l[1:])\n\
    \    case l[1] > l[0]:\n        // Decreasing list.\n        return monotonic(l[2:])\n\
    \    case l[0] == l[1]:\n        // List is monotonically increasing or decreasing.\n\
    \        return true\n    default:\n        // List is either entirely increasing\
    \ or entirely decreasing.\n        return false\n    }\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpdg57txr9_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpdg57txr9_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l := sortList(l)\n    if len(l) <= 2 {\n        return true\n\
    \    }\n    return l[len(l)-1] < l[0] || l[len(l)-2] < l[len(l)-1]\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8n5a1x8_test.go:16:7: no new variables on left side of :=

    /tmp/tmpt8n5a1x8_test.go:16:10: undefined: sortList

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var last = 0\n    for _, v := range l {\n        if v > last\
    \ {\n            return true\n        }\n        last = v\n    }\n    return false\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nA slight variation on Paul R.\
    \ Pulkkin's answer that only checks for the first and last elements, rather than\
    \ the whole list. \n<code>\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt7jysuak_test.go:25:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    // If\
    \ the list is increasing, we're done.\n    if len(l) == 1 {\n        return true\n\
    \    }\n\n    // If the list is decreasing, we swap the first and last elements,\
    \ and iterate\n    // over the rest. This is a linear time operation.\n    last\
    \ := l[len(l)-1]\n    t := l[len(l)-2]\n\n    // If they're equal, the list is\
    \ monotonically increasing.\n    if last == t {\n        return true\n    }\n\n\
    \    // If they're not equal, swapping them means we're decreasing.\n    if t\
    \ > last {\n        t, last = last, t // Swap elements.\n    }\n\n    // Iterate\
    \ until we find the first element that's out of order.\n    for i := len(l) -\
    \ 1; i >= 0; i-- {\n        if l[i] < t {\n            // Found an out of order\
    \ element.\n            return false\n        }\n    }\n\n    // We're done. List\
    \ is monotonically increasing.\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpqigf0ajb_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpqigf0ajb_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpqigf0ajb_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    i := 0\n    min := l[0]\n    for i < len(l) && (min > l[i]\
    \ || l[i] == min) {\n        i++\n    }\n    return i == len(l)\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpk_qge4jq_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpk_qge4jq_test.go:44:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpk_qge4jq_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n\n    var left\
    \ int\n    var right int\n    var ok bool\n    for i := 0; i < len(l); i++ {\n\
    \        ok = true\n        for j = i + 1; j < len(l); j++ {\n            if l[i]\
    \ < l[j] {\n                ok = false\n                break\n            }\n\
    \            if l[i] > l[j] {\n                break\n            }\n        }\n\
    \        if ok {\n            left = i\n        }\n    }\n\n    if left >= len(l)\
    \ {\n        return true\n    }\n\n    ok = true\n    for j = len(l) - 1; j >\
    \ left; j-- {\n        ok = false\n        for i = left + 1; i < j; i++ {\n  \
    \          if l[i] < l[j] {\n                ok = false\n                break\n\
    \            }\n            if l[i] > l[j] {\n                break\n        \
    \    }\n        }\n        if ok {\n            right = j\n        }\n    }\n\n\
    \    if right < len(l) {\n        return true\n    }\n\n    return false\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptg151s55_test.go:25:13: undefined: j

    /tmp/tmptg151s55_test.go:26:25: undefined: j

    /tmp/tmptg151s55_test.go:30:25: undefined: j

    /tmp/tmptg151s55_test.go:44:9: undefined: j

    /tmp/tmptg151s55_test.go:46:13: undefined: i

    /tmp/tmptg151s55_test.go:46:31: undefined: j

    /tmp/tmptg151s55_test.go:46:34: undefined: i

    /tmp/tmptg151s55_test.go:47:18: undefined: i

    /tmp/tmptg151s55_test.go:47:25: undefined: j

    /tmp/tmptg151s55_test.go:51:18: undefined: i

    /tmp/tmptg151s55_test.go:51:18: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n\n    var (\n\
    \        minInd      = -1\n        maxInd      = -1\n        minIndPos = -1\n\
    \        maxIndPos = -1\n    )\n\n    for i := 0; i < len(l); i++ {\n        if\
    \ l[i] < l[minInd] {\n            minInd = i\n            minIndPos = i\n    \
    \    }\n        if l[i] > l[maxInd] {\n            maxInd = i\n            maxIndPos\
    \ = i\n        }\n    }\n\n    if minInd == maxInd {\n        return minInd ==\
    \ 0\n    }\n\n    // Find a range of elements whose values are monotonically increasing\
    \ or decreasing.\n    // Note: We do not use binary search because we expect the\
    \ list to be short. O(log n)\n    // for finding min and max values.\n    for\
    \ i := 0; i < len(l); i++ {\n        // If we find a min and max that are both\
    \ monotonically increasing or decreasing,\n        // and we've found a range\
    \ that is non-empty, assume that it is monotonic.\n        if minInd != -1 &&\
    \ maxInd != -1 && minInd != i && maxInd != i {\n            if l[i] >= l[maxInd]\
    \ && l[i] <= l[minInd] {\n                return true\n            }\n       \
    \ }\n    }\n\n    return false\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpapufmlwg_test.go:23:9: minIndPos declared but not used

    /tmp/tmpapufmlwg_test.go:24:9: maxIndPos declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Sort for comparison.\n    sort.Sort(IntSlice(l))\n\n \
    \   // Start with first element.\n    prev, curr := l[0], l[0]\n    // Start at\
    \ second element.\n    for i, v := range l[1:] {\n        if curr < v {\n    \
    \        return false\n        }\n        if curr > v {\n            prev = curr\n\
    \            curr = v\n        }\n    }\n    return prev > curr\n}\n</code>\n\
    <|/ a tags=arrays,go,sorting,algorithm |>\n<| a dscore=1 |>\nI took Nick's solution\
    \ and converted it to go code so I could test the results.\n<code>\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpanf6lx3x_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var last int\n    for _, v := range l {\n        if v < last\
    \ {\n            return false\n        }\n        last = v\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpvy9et891_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpvy9et891_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    // Initialize\
    \ a running minimum value.\n    var min int\n    for _, v := range l {\n     \
    \   if v < min {\n            min = v\n        }\n    }\n\n    // If all elements\
    \ are the same, return true.\n    if min == l[0] {\n        return true\n    }\n\
    \n    for _, v := range l {\n        if v < min {\n            return false\n\
    \        }\n\n        min = v\n    }\n\n    // Return true to indicate that all\
    \ the elements are strictly increasing.\n    return true\n}\n</code>\n<|/ a dscore=4\
    \ tags=sorting,go |>\n<| a |>\nI used the algorithm from the following post to\
    \ sort an array of integers. I used it in golang to sort an array of strings.\
    \ I added a method so that you can sort strings as well as integers. \n<code>\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9eusaze_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    n := len(l)\n\
    \    if n < 1 {\n        return false\n    }\n    d := make([]int, 0, n)\n   \
    \ for i := 0; i < n; i++ {\n        d := append(d, l[i])\n    }\n    switch x\
    \ := d[len(d)-1]; {\n    case x == nil && n > 1 && len(d) != 2:\n        return\
    \ false\n    case x > 0 && len(d) == 1 && x&1 != 0:\n        return false\n  \
    \  case x == 0 && (d[0] > 0 || d[0] == x) && len(d) != 2:\n        return false\n\
    \    case x == 0 && len(d) == 2 && d[1]&1 != 0:\n        return false\n    case\
    \ x&1 == 0 && d[0] > 0 && d[1] > 0 && (d[1]&(d[0]-1) != 0 || d[0] > d[1]):\n \
    \       return false\n    case x&1 == 0 && d[0] > 0 && d[1] > 0 && (d[0]&(d[1]-1)\
    \ != 0 || d[1] > d[0]):\n        return false\n    case x&1 == 0 && d[0] > 0 &&\
    \ d[1] > 0 && (d[1]&(d[0]-1) != 0 || d[0] > d[1]):\n        return false\n   \
    \ case x&1 == 0 && d[0] > 0 && d[1] > 0 && (d[0]&(d[1]-1) != 0 || d[1] > d[0]):\n\
    \        return false\n    default:\n        return true\n    }\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefflz7yb_test.go:25:9: d declared but not used

    /tmp/tmpefflz7yb_test.go:28:15: invalid operation: x == nil (mismatched types
    int and untyped nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    l := l[:len(l)-1]\n\
    \    diff := func(i, j int) int {\n        if l[i] < l[j] {\n            return\
    \ -1\n        }\n        return 1\n    }\n    return sort.SliceStable(l, func(i,\
    \ j int) bool {\n        diffVal, _ := diff(i, j)\n        return diffVal != 0\n\
    \    })\n}\n</code>\n<|/ a tags=list,python |>\n<| c |>\nI like the monotonic\
    \ idea, but I think `sorted` would be faster since it just sorts a copy of the\
    \ list rather than actually sorting it.\n<|/ c |>\n<| c |>\nGood point.  I should\
    \ have said that it would not be faster in all cases.  That is why I said \"in\
    \ all cases\".\n<|/ c |>\n<| a |>\nIf you have to use python, how about:\n<code>\n\
    def increasing(x):\n  return all([x[i-1] <= x[i] for i in xrange(len(x))])\n</code>\n\
    <|/ a tags=list,python dscore=1 |>\n<| c |>\nI like this solution. It works, but\
    \ I wish there were a more concise solution.\n<|/ c |>\n<| c |>\nIt does not work:\
    \ `increasing([1,1,1])` returns `True`.\n<|/ c |>\n<| a tags=list,python |>\n\
    <code>\n>>> a = range(10)\n>>> a\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> all(x<y\
    \ for x, y in zip(a[1:], a[:-1]))\nTrue\n>>> all(x>y for x, y in zip(a[1:], a[:-1]))\n\
    False\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is an efficient approach, but\
    \ not as fast as some of the other solutions.\n<|/ c |>\n<| c |>\nYeah. But what\
    \ does this do? Why does it work?\n<|/ c |>\n<| c |>\nIt works because `all` returns\
    \ False as soon as it finds something not equal to `False`.\n<|/ c |>\n<| a tags=list,python\
    \ |>\nHere is an example with generators:\n<code>\n>>> def is_increasing(a):\n\
    ...     i = next(i for i in xrange(len(a)) if a[i] < a[i-1])\n...     return True\n\
    ...     \n>>> is_increasing([1,2,3])\nFalse\n>>> is_increasing([1,3,2])\nTrue\n\
    >>> is_increasing([3,1,2])\nFalse\n>>> is_increasing([3,2,1])\nFalse\n>>> is_increasing\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpksoc9rl0_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n    a, b :=\
    \ l[0], l[len(l)-1]\n    for i := 1; i < len(l); i++ {\n        c, d := l[i],\
    \ l[i-1]\n        if c > b {\n            return false\n        }\n        if\
    \ b > d {\n            return false\n        }\n        if b < a {\n         \
    \   return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpwq23bwr7_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpwq23bwr7_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpwq23bwr7_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpwq23bwr7_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpwq23bwr7_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpwq23bwr7_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n    // sort\
    \ the list to make it easier to check monotonicity\n    sort.Slice(l, func(i,\
    \ j int) bool {\n        return l[i] < l[j]\n    })\n    prev, current, current\
    \ := l[0], l[0], 1\n    for _, e := range l[1:] {\n        if e < prev {\n   \
    \         return false\n        } else if e > current {\n            return false\n\
    \        }\n        prev, current = current, e\n    }\n    return current > prev\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis fails to detect when the list is monotonically\
    \ decreasing. Example: `monotonic([]int{1, 2, 4, 20})` returns false. Should be\
    \ true in this case.\n<|/ c |>\n<| c |>\n: My mistake. Fixed.\n<|/ c |>\n<| a\
    \ tags=go,algorithm |>\nOne option is to sort the list, and compare the results.\
    \ If the lists are equal, they are always monotonic, otherwise compare their elements\
    \ to the first and last elements of the sorted list and see which is lesser.\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nIf you can use the sort package, the function\
    \ sort.Slice() will allow you to sort any slice.\n<code>\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0e4n5ixg_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    prev\
    \ := l[0]\n    lastVal := l[0]\n    for _, val := range l[1:] {\n        if val\
    \ > prev {\n            return false\n        }\n        if val > lastVal {\n\
    \            lastVal = val\n        }\n        prev = val\n    }\n\n    return\
    \ true\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy are you using `sort` when\
    \ all you do is remove duplicates? You can just return the `slice` directly without\
    \ using `sort`. Also, what happens if the first element in the slice is greater\
    \ than the last? Then the function returns false, which means you'll never iterate\
    \ over the whole list.\n<|/ c |>\n<| c |>\nYou still need a boolean flag.\n<|/\
    \ c |>\n<| c |>\nIf you just want to remove duplicates from the list then you\
    \ could just use `len(set(l))` which is slightly faster. Also see [this post](http://stackoverflow.com/questions/9640220/why-does-golangs-slice-comparison-return-false-when-elements-have-the-same-val).\n\
    <|/ c |>\n<| c |>\nGood point about the flag but I assumed the OP was going to\
    \ be using some kind of sorting algorithm in their code. Your code would also\
    \ handle the `[]int{20, 4, 1, 1}` case but OP wasn't explicitly asking about it.\
    \ I suppose it's just a matter of personal preference on what to prefer. Thanks\
    \ for your help!\n<|/ c |>\n<| a dscore=0 |>\n<code>\npackage monotonic_test\n\
    \nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl8loviyc_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    min := 0\n    max := 0\n    for i := 0; i < len(l); i++ {\n\
    \        if l[i] < min {\n            min = l[i]\n        }\n        if l[i] >\
    \ max {\n            max = l[i]\n        }\n    }\n    if min < 0 {\n        return\
    \ false\n    }\n    if max < 0 {\n        return true\n    }\n    return min <=\
    \ max\n}\n</code>\n<|/ a dscore=2 tags=go,arrays |>\n<| a |>\nThis is how I would\
    \ approach it. It doesn't use any extra packages and uses less code than other\
    \ answers.\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsc6gimgn_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074939
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n\n    head\
    \ := l[0]\n    tail := l[1:]\n    tailMonotonic, found := monotonic(tail)\n\n\
    \    if !found {\n        return false\n    }\n\n    return head >= tailMonotonic\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpovpi7uax_test.go:22:29: assignment mismatch: 2 variables but monotonic
    returns 1 value

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return false\n    }\n\
    \n    var prev int\n    for i := 1; i < n; i++ {\n        if l[i-1] < l[i] {\n\
    \            return false\n        }\n        if l[i-1] > l[i] {\n           \
    \ prev = i\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpew_xnt48_test.go:21:9: prev declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    lastElem := l[0]\n    min := lastElem\n    max := lastElem\n\
    \    for _, elem := range l {\n        if elem < min {\n            min = elem\n\
    \        }\n        if elem > max {\n            max = elem\n        }\n    }\n\
    \    return min < max\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpb_tr645y_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpb_tr645y_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpb_tr645y_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    max :=\
    \ l[0]\n    for _, v := range l[1:] {\n        if v > max {\n            return\
    \ false\n        }\n        max = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp5te3mjy3_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp5te3mjy3_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp5te3mjy3_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var prev int\n    for _, v := range l {\n        if v < prev\
    \ {\n            return false\n        }\n        prev = v\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpcz84a2lt_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpcz84a2lt_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074941
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // The first comparison needs to be non-decreasing, so sort\
    \ first.\n    sortedL, err := mergeSort(l)\n    if err != nil {\n        return\
    \ false\n    }\n    if !isIncreasingSequence(sortedL) {\n        return false\n\
    \    }\n\n    sortedR := mergeSort(reverseIntList(sortedL))\n    if !isIncreasingSequence(sortedR)\
    \ {\n        return false\n    }\n    if !isDecreasingSequence(sortedR) {\n  \
    \      return false\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_dr7d8dv_test.go:17:21: undefined: mergeSort

    /tmp/tmp_dr7d8dv_test.go:21:9: undefined: isIncreasingSequence

    /tmp/tmp_dr7d8dv_test.go:25:16: undefined: mergeSort

    /tmp/tmp_dr7d8dv_test.go:25:26: undefined: reverseIntList

    /tmp/tmp_dr7d8dv_test.go:26:9: undefined: isIncreasingSequence

    /tmp/tmp_dr7d8dv_test.go:29:9: undefined: isDecreasingSequence

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074940
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    return\
    \ monotonic_helper(l, 0, len(l)-1)\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp38uch14e_test.go:20:12: undefined: monotonic_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074941
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    sort.Ints(l)\n\n    for i := 1; i < len(l); i++ {\n     \
    \   if l[i-1] > l[i] {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjvyoholj_test.go:16:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074941
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    sort.Sort(sortedIntSlice(l))\n\
    \    prev := l[0]\n    for _, v := range l[1:] {\n        if v < prev {\n    \
    \        return false\n        }\n        prev = v\n    }\n    return true\n}\n\
    \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90ratwcj_test.go:20:5: undefined: sort

    /tmp/tmp90ratwcj_test.go:20:15: undefined: sortedIntSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    for\
    \ i := 0; i < len(l); i++ {\n        if l[i] < l[i-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpjk7k8o49_test.go:21\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpjk7k8o49_test.go:35\
    \ +0x739\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074942
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var m []int\n    var x1 int\n    var x2 int\n\n    for i\
    \ := range l {\n        x = l[i]\n        if m != nil {\n            if m[0] <\
    \ x {\n                return false\n            }\n        }\n\n        x2 =\
    \ x\n        x1 = x\n        m = append(m, 0)\n        m = append(m, x)\n    \
    \    m[x2] = x\n    }\n\n    return true\n}\n</code>\n<|/ a |>\n<| a |>\nThe main\
    \ difference between these two algorithms is that in the first one all elements\
    \ are visited once. In the second one all elements are visited twice. The third\
    \ algorithm is more similar to merge sort algorithm.\n<|/ a dscore=4 tags=sorting,algorithm,go\
    \ |>\n<| c |>\nThe first one is called a [stable sort](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability_and_guarantees).\
    \ The second one is [stable sort](https://en.wikipedia.org/wiki/Merge_sort#Stability_and_guarantees)\n\
    <|/ c |>\n<| c |>\nIt sounds like you are claiming that the first one is more\
    \ similar to merge sort. Can you explain why this is so?\n<|/ c |>\n<| c |>\n\
    Stability is important when sorting large data sets. For example, merge sort works\
    \ on small data sets while quicksort works on large data sets. A stable sort maintains\
    \ the relative order of elements that are already sorted.\n<|/ c |>\n<| c |>\n\
    Actually, [merge sort](https://en.m.wikipedia.org/wiki/Merge_sort#Stability_and_guarantees)\
    \ can be called stable, so it's not really a contradiction.\n<|/ c |>\n<| a dscore=4\
    \ tags=sorting,algorithm,go |>\nThe first one is the most efficient sort if you\
    \ don't want to change your order of the elements in the list. \nThe second one\
    \ is more efficient because it uses less memory if you're not changing the order\
    \ of the elements in the list. \nThe third is like the first one but uses more\
    \ memory in any case.\n<|/ a |>\n<| a tags=sorting,algorithm,go |>\nA very simple\
    \ explanation is that while sorting a list once the list is sorted (by your algorithm),\
    \ it's better to sort it twice. Once for the beginning of the list and then for\
    \ the end (by insertion sort).\nSo the algorithm is efficient if you'll insert\
    \ your data at the right position in the list (i.e. the most efficient would be\
    \ the insertion sort algorithm).\n<|/ a dscore=3 |>\n<| a |>\nThe second is more\
    \ efficient because you only have to sort the list once.\nThe first and third\
    \ algorithms are both linear time algorithms, so they both have linear time \n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi0iv_ian_test.go:37:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    length :=\
    \ len(l)\n    if length == 0 {\n        return true\n    }\n\n    last, currLast,\
    \ nextCurrLast := l[0], l[0], l[0]\n    nextCurrLast += curr := 0\n    for i :=\
    \ 1; i < length; i++ {\n        curr = currLast + l[i]\n        if curr < last{\n\
    \            return false\n        }\n        if curr > last {\n            return\
    \ true\n        }\n\n        if curr != last{\n            if curr < nextCurrLast{\n\
    \                return false\n            }\n            if curr > nextCurrLast\
    \ {\n                return true\n            }\n        }\n\n        last, currLast,\
    \ nextCurrLast = curr, curr, l[i]\n    }\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzsnn9lq7_test.go:25:26: expected '';'', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074941
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // TODO: Sort if necessary.\n    // TODO: Avoid O(n) sort\
    \ if possible.\n    var prev int\n    for _, e := range l {\n        if e <= prev\
    \ {\n            return false\n        }\n        prev = e\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpx_fdlvxx_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpx_fdlvxx_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpx_fdlvxx_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074942
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    i := 0\n    for i = 1; i < len(l); i++ {\n        if l[i-1]\
    \ > l[i] {\n            return false\n        }\n        if l[i-1] < l[i] {\n\
    \            return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpt3bfdx4n_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpt3bfdx4n_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpt3bfdx4n_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpt3bfdx4n_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpt3bfdx4n_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074942
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    current\
    \ := l[0]\n    for i := range l {\n        if l[i] < current {\n            return\
    \ false\n        }\n        if l[i] > current {\n            current = l[i]\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpjwtgfdw5_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpjwtgfdw5_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    last := 0\n\
    \    for i := 0; i < len(l); i++ {\n        if i > 0 {\n            if l[i-1]\
    \ <= l[i] {\n                return false\n            }\n        }\n        if\
    \ l[i] <= last {\n            return false\n        }\n        last = l[i]\n \
    \   }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp5alqlv_a_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp5alqlv_a_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp5alqlv_a_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp5alqlv_a_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp5alqlv_a_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp5alqlv_a_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    i := 0\n    max := l[0]\n    min := max\n    for _, e :=\
    \ range l {\n        if e < max {\n            min = e\n            i++\n    \
    \    }\n        if e > min {\n            i++\n        }\n        max = e\n  \
    \  }\n    return i == len(l)\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp8lc6j2l4_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp8lc6j2l4_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp8lc6j2l4_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp8lc6j2l4_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp8lc6j2l4_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp8lc6j2l4_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return monotonicHelper(l)\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9qs3q3_8_test.go:16:12: undefined: monotonicHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074942
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Sort list to ensure O(N log N) complexity for checking.\n\
    \    for i := 0; i < len(l); i++ {\n        j := i\n        for {\n          \
    \  if l[j] > l[j+1] {\n                break\n            }\n            j = j\
    \ + 1\n        }\n        if i != j {\n            tmp := l[i]\n            l[i]\
    \ = l[j]\n            l[j] = tmp\n        }\n    }\n    for i := 0; i < len(l);\
    \ i++ {\n        if l[i-1] > l[i] {\n            return false\n        }\n   \
    \ }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0001d2550?, 0x450700?, 0x8?})\n\
    \t/tmp/tmpy9dp3u08_test.go:20 +0xbf\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpy9dp3u08_test.go:46 +0x93\ntesting.tRunner(0xc000198ea0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    var prev,\
    \ cur int\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] < l[i+1] {\n \
    \           prev = l[i]\n            cur = l[i+1]\n            break\n       \
    \ }\n    }\n\n    return cur > prev\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpxivk78gg_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpxivk78gg_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpxivk78gg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpxivk78gg_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpxivk78gg_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return true\n    }\n\
    \    i := 0\n    j := n - 1\n    for k := 0; k < n; k++ {\n        if l[i] > l[j]\
    \ {\n            i = j\n        } else {\n            j = k\n        }\n    }\n\
    \    return l[i] <= l[j]\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp7o98fepr_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp7o98fepr_test.go:52:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    n := len(l)\n\
    \    if n == 1 {\n        return l[0] < l[0]\n    }\n    min := l[0]\n    max\
    \ := l[0]\n    for i := 1; i < n; i++ {\n        if l[i] < min {\n           \
    \ min = l[i]\n        }\n        if l[i] > max {\n            max = l[i]\n   \
    \     }\n    }\n    return min >= max\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmptcdxmi8q_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmptcdxmi8q_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmptcdxmi8q_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmptcdxmi8q_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmptcdxmi8q_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l)\
    \ == 1 {\n        return true\n    }\n\n    first := l[0]\n    last := l[0]\n\
    \    for _, v := range l[1:] {\n        if v < first {\n            return false\n\
    \        }\n        if v > last {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp36z19r19_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp36z19r19_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp36z19r19_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp36z19r19_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp36z19r19_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l)\
    \ == 1 {\n        return true\n    }\n    for i := 1; i < len(l); i++ {\n    \
    \    if l[i-1] < l[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpsod26tbz_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpsod26tbz_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpsod26tbz_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 || len(l)-1 < 2 {\n        return true\n \
    \   }\n    if l[0] >= l[1] {\n        return false\n    }\n    return monotonicTail(l,\
    \ 0, len(l)-1)\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwde9w_nv_test.go:22:12: undefined: monotonicTail

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    i := len(l)\n    switch {\n    case i == 0: return false\n\
    \    case i == 1:\n        return l[0] >= l[1]\n    case i == 2:\n        return\
    \ l[0] > l[1] && l[1] > l[2]\n    case i == 3:\n        return l[0] > l[1] &&\
    \ l[1] > l[2] && l[2] > l[3]\n    default:\n        return l[0] > l[1] && l[1]\
    \ > l[2] && l[2] > l[3] && l[3] > l[4]\n    }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    this does not answer the question (the question is how to find if a list has monotonic\
    \ increase/decrease sequence, not if an element exists in the monotonic sequence\
    \ )\n<|/ c |>\n<| a |>\nUsing a Set and some math, we can get this done.\n<code>\n\
    package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"time\"\n)\n\ntype Set\
    \ \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsnbbkzux_test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074942
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var i, j int\n    for ; i < len(l); i++ {\n        if l[i]\
    \ > l[j] {\n            return false\n        }\n        j = i\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpz05f_6b__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpz05f_6b__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpz05f_6b__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var a int\n    var b int\n    var c int\n    var d int\n\
    \    var e int\n    for i := 0; i < len(l); i++ {\n        a = l[i]\n        b\
    \ = i\n        c = i + 1\n        d = i + 1\n        e = i + 1\n        if a ==\
    \ b {\n            if a < c {\n                return false\n            }\n \
    \           if b < d {\n                return true\n            }\n         \
    \   if a < e {\n                return true\n            }\n        } else {\n\
    \            if a < c {\n                return false\n            }\n       \
    \     if b < d {\n                return false\n            }\n            if\
    \ a < e {\n                return true\n            }\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpybynww6z_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpybynww6z_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpybynww6z_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpybynww6z_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpybynww6z_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpybynww6z_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l); i++ {\n        if i > 0 && l[i-1]\
    \ <= l[i] {\n            return false\n        }\n        if i < len(l)-1 && l[i+1]\
    \ < l[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpj04nmkpb_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpj04nmkpb_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpj04nmkpb_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpj04nmkpb_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpj04nmkpb_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpj04nmkpb_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    var minVal\
    \ int\n    var maxVal int\n    for _, v := range l {\n        if v < minVal {\n\
    \            minVal = v\n        }\n        if v > maxVal {\n            maxVal\
    \ = v\n        }\n    }\n    if minVal == maxVal {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp_pa6pp43_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp_pa6pp43_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074943
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return l[0] < l[len(l)-1] && monotonicInc(l, len(l)-1)\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx26w99v3_test.go:16:34: undefined: monotonicInc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for _, v := range l {\n        if v < l[0] {\n          \
    \  return false\n        }\n        if v > l[len(l)-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpd_mqdrir_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpd_mqdrir_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmpd_mqdrir_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    max := 0\n    min := 0\n    for _, v := range l {\n     \
    \   if v < min {\n            min = v\n        }\n        if v > max {\n     \
    \       max = v\n        }\n    }\n    return min < max\n}\n</code>\n<|/ a tags=go\
    \ dscore=0 |>\n<| a |>\nThe below is my solution using Go's sort package.\n<code>\n\
    package main\n\nimport \"sort\"\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeou7pka8_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074943
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    if len(l)\
    \ == 0 {\n        return false\n    }\n    if l[0] > l[len(l)-1] {\n        return\
    \ false\n    }\n    for i := range l {\n        if l[i] < l[i-1] {\n         \
    \   return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmp7njwkq99_test.go:26\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmp7njwkq99_test.go:40\
    \ +0x7bf\ntesting.tRunner(0xc0001036c0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l)\
    \ == 1 {\n        return true\n    }\n    for _, v := range l[1:] {\n        if\
    \ l[0] > v {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpv4_e60vr_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpv4_e60vr_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpv4_e60vr_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpv4_e60vr_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l := make([]int, len(l))\n    for i, e := range l {\n   \
    \     if i > 0 && l[i-1] > e {\n            return false\n        }\n        if\
    \ i < len(l)-1 && l[i+1] < e {\n            return false\n        }\n        l[i]\
    \ = e\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuqdcv0e6_test.go:16:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    sort.Sort(IntSlice(l))\n    return sort.IsSorted(l)\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7cvbpg_1_test.go:16:5: undefined: sort

    /tmp/tmp7cvbpg_1_test.go:16:15: undefined: IntSlice

    /tmp/tmp7cvbpg_1_test.go:17:12: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    length := len(l)\n    if length == 0 {\n        return false\n\
    \    }\n    if length == 1 {\n        return l[0] > l[1]\n    }\n    current :=\
    \ l[0]\n    var previous int\n    for i, v := range l[1:] {\n        if i == 0\
    \ {\n            previous = v\n            continue\n        }\n        if v <\
    \ current {\n            return false\n        }\n        if v > current {\n \
    \           return true\n        }\n        current = v\n        if v < previous\
    \ {\n            return false\n        }\n        previous = v\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpi36dcs8a_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpi36dcs8a_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpi36dcs8a_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpi36dcs8a_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var first, last int\n    for i := 0; i < len(l); i++ {\n\
    \        if l[i] > l[i+1] {\n            return false\n        }\n        if l[i]\
    \ < l[i-1] {\n            return true\n        }\n    }\n    return true\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuf4rn51n_test.go:16:9: first declared but not used

    /tmp/tmpuf4rn51n_test.go:16:16: last declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var prev int\n    for _, v := range l {\n        if v > prev\
    \ {\n            return false\n        }\n        prev = v\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp8xpecz8x_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp8xpecz8x_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp8xpecz8x_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp8xpecz8x_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp8xpecz8x_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp8xpecz8x_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    i := 0\n\
    \    j := len(l) - 1\n    for {\n        if j-i < 1 {\n            break\n   \
    \     }\n        if l[i] > l[j] {\n            return false\n        }\n     \
    \   if l[j] < l[i] {\n            return true\n        }\n        i++\n      \
    \  j--\n    }\n    return true\n}\n</code>\nI hope this helps you. My code is\
    \ inspired by this question.\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI've solved\
    \ the problem with Kotlin with extension functions. I share the code with you,\
    \ hope this helps\n<code>\nclass MonotonicDecreasingOrIncreasingExtensions(\n\
    \    private val array: Array<Int>\n) {\n\n    fun getFirstNonNegative(): Int\
    \ {\n        return if (array.size > 1) {\n            array.firstOrNull { it\
    \ > 0 }\n        } else {\n            throw IllegalArgumentException(\"Input\
    \ array should be longer than 1\")\n        }\n    }\n\n    fun getFirstNonNegativeOrZero():\
    \ Int {\n        return if (array.size > 1) {\n            array.firstOrNull {\
    \ it > 0 } ?: 0\n        } else {\n            throw IllegalArgumentException(\"\
    Input array should be longer than 1\")\n        }\n    }\n\n    fun getLastNonNegative():\
    \ Int {\n        return if (array.size > 1) {\n            array.lastOrNull {\
    \ it > 0 }\n        } else {\n            throw IllegalArgumentException(\"Input\
    \ array should be longer than 1\")\n        }\n    }\n\n    fun getLastNonNegativeOrZero():\
    \ Int {\n        return if (array.size > 1) {\n            array.lastOrNull {\
    \ it > 0 } ?: 0\n        } else {\n            throw IllegalArgumentException(\"\
    Input array should be longer than 1\")\n        }\n    }\n\n    fun getFirstNonNonNegativeOrZero():\
    \ Int {\n        return if (array.size > 1) {\n            array.firstOrNull {\
    \ it > 0 || it == 0 }\n        } else {\n            throw IllegalArgumentException(\"\
    Input array should be longer than 1\")\n        }\n    }\n\n    fun getLastNonNonNegativeOrZero():\
    \ Int {\n        return if (array.size > 1) {\n            array.lastOrNull {\
    \ it > 0 || it == 0 }\n        } else {\n            throw IllegalArgumentException(\"\
    Input array should be longer than 1\")\n        }\n    }\n\n    fun getFirstNonNegativeOrZeroOrOne():\
    \ Int {\n        return if (array.size > 1) {\n            array.firstOrNull {\
    \ it > 0 || it == 0 } ?: 1\n        } else {\n            throw IllegalArgumentException(\"\
    Input array should be longer than \nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmvpoo25x_test.go:36:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    for i\
    \ := len(l) - 1; i > 1; i-- {\n        if l[i-1] < l[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpfm6nd3n2_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpfm6nd3n2_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpfm6nd3n2_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l := append([]int{0, 0}, l...)\n    for i := 1; i < len(l);\
    \ i++ {\n        if l[i-1] > l[i] {\n            return false\n        }\n   \
    \ }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7p5zzfn7_test.go:16:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if l[0]\
    \ < l[1] {\n        return false\n    }\n    if l[0] > l[1] {\n        return\
    \ monotonic(l[2:])\n    }\n    return monotonic(l[1:])\n}\n</code>\n<|/ a dscore=3\
    \ tags=go |>\n<| a |>\nSince no answer has mentioned about Go's sort package and\
    \ it's sorting mechanisms, I thought to give it a try. I've created my own sort\
    \ mechanism with Go sort package and it's working.\nHere is the code:\n<code>\n\
    package main\n\nimport \"fmt\"\nimport \"sort\"\n\ntype Person \nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfi5eenou_test.go:27:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if l[0]\
    \ < l[1] {\n        return false\n    }\n    return monotonic(l[1:])\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0001d25c8?, 0x725?, 0xc0001d24a0?})\n\
    \t/tmp/tmpieqy1gq9_test.go:19 +0x6e\ncommand-line-arguments_test.monotonic({0xc0001d25c0?,\
    \ 0x5648db?, 0x5648db?})\n\t/tmp/tmpieqy1gq9_test.go:22 +0x48\ncommand-line-arguments_test.monotonic({0xc0001d25b8?,\
    \ 0x5d3fb0?, 0x5e3ea0?})\n\t/tmp/tmpieqy1gq9_test.go:22 +0x48\ncommand-line-arguments_test.monotonic({0xc0001d25b0?,\
    \ 0x450700?, 0x8?})\n\t/tmp/tmpieqy1gq9_test.go:22 +0x48\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpieqy1gq9_test.go:35 +0x18f\ntesting.tRunner(0xc000199040, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    size := len(l)\n    left := make([]int, 0, size)\n    right\
    \ := make([]int, 0, size)\n    for i := 0; i < size; i++ {\n        left = append(left,\
    \ l[i])\n        right = append(right, l[i+1])\n    }\n\n    for i := 0; i < size;\
    \ i++ {\n        if left[i] > right[i] {\n            return true\n        }\n\
    \    }\n    return false\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpcmyonpti_test.go:21\n\
    command-line-arguments_test.TestMonotonic(0xc0001a01a0?)\n\t/tmp/tmpcmyonpti_test.go:39\
    \ +0x15a5\ntesting.tRunner(0xc0001a01a0, 0x529f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    prev\
    \ := l[0]\n    for _, e := range l[1:] {\n        if e < prev {\n            return\
    \ false\n        }\n        prev = e\n    }\n\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpbyzth2v9_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpbyzth2v9_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    first\
    \ := l[0]\n    for _, v := range l {\n        if v < first {\n            return\
    \ false\n        }\n        first = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmps17_cskc_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmps17_cskc_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074945
- exit_code: 0
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l[0] < l[len(l)-1] {\n        for i := 1; i < len(l)-1;\
    \ i++ {\n            if l[i] < l[i-1] {\n                return false\n      \
    \      }\n        }\n        return true\n    }\n    for i := 1; i < len(l)-1;\
    \ i++ {\n        if l[i] > l[i-1] {\n            return false\n        }\n   \
    \ }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var last, current int\n\n    for _, v := range l {\n    \
    \    if v == last+1 {\n            return true\n        }\n        current = last\n\
    \        last = v\n    }\n    return false\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4v_a7wps_test.go:16:15: current declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    k := l[0]\n    if k < l[1] { return false }\n    if k < l[2]\
    \ { return true }\n    if k < l[3] { return true }\n    if k < l[4] { return false\
    \ }\n    if k < l[5] { return false }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmp_hk64k2w_test.go:20\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmp_hk64k2w_test.go:35\
    \ +0x632\ntesting.tRunner(0xc000103380, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    max := l[0]\n    min := l[0]\n    for i := 0; i < len(l);\
    \ i++ {\n        if l[i] > max {\n            max = l[i]\n        }\n        if\
    \ l[i] < min {\n            min = l[i]\n        }\n    }\n    return min > max\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpgvu0wtk6_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpgvu0wtk6_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpgvu0wtk6_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpgvu0wtk6_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpgvu0wtk6_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpgvu0wtk6_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    var prev\
    \ int\n    for _, v := range l[1:] {\n        if prev < v {\n            return\
    \ false\n        }\n        prev = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmppa7ice9p_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmppa7ice9p_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmppa7ice9p_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmppa7ice9p_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmppa7ice9p_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmppa7ice9p_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n    last := l[0]\n\
    \    for _, val := range l[1:] {\n        if val > last {\n            return\
    \ false\n        }\n        last = val\n    }\n    return true\n}\n</code>\n<|/\
    \ a dscore=4 tags=go,arrays |>\n<| c |>\nThis should be the accepted answer. The\
    \ other answers rely on creating two new slices while this one is able to iterate\
    \ over the original slice and return the desired output.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer because it takes advantage of the fact that\
    \ slices are iterable, and does not create an additional array slice.\n<|/ c |>\n\
    <| a tags=go,arrays |>\nHere's my take on this:\n<code>\npackage main\n\nimport\
    \ (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4z406i6v_test.go:28:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074945
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    max :=\
    \ 0\n    min := 1\n    i := 0\n    for i < len(l) {\n        if l[i] <= min {\n\
    \            min = l[i]\n        }\n        if l[i] >= max {\n            max\
    \ = l[i]\n        }\n        i++\n    }\n    if max == 1 {\n        return true\n\
    \    }\n    if min == 0 {\n        return false\n    }\n    if max < min {\n \
    \       return false\n    }\n    switch {\n    case max < l[0]:\n        return\
    \ true\n    case max < l[len(l)-1]:\n        return false\n    case l[0] > l[len(l)-1]:\n\
    \        return true\n    default:\n        return false\n    }\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmppy2lytdl_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmppy2lytdl_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmppy2lytdl_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__6 (0.00s)\n        tmppy2lytdl_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmppy2lytdl_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 || n > 100 {\n        return false\n\
    \    }\n    return monotonic1(l)\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgex97_0h_test.go:20:12: undefined: monotonic1

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    head\
    \ := l[0]\n    tail := l[1:]\n    switch {\n    case head >= tail:\n        return\
    \ false\n    case head < tail[0]:\n        return true\n    }\n\n    return monotonic(tail)\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp39_px5pq_test.go:23:18: invalid operation: head >= tail (mismatched types
    int and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    t := l[0]\n\
    \    for _, e := range l[1:] {\n        if e < t {\n            return false\n\
    \        }\n        t = e\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp4gq6o1iu_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp4gq6o1iu_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    diff := make([]int, len(l))\n    for i, x := range l {\n\
    \        if i > 0 {\n            diff[i] = x - l[i-1]\n        }\n    }\n    return\
    \ len(diff) < 2 && len(diff) > 0 && diff[0] < 0\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp7oc2lkmu_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp7oc2lkmu_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp7oc2lkmu_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp7oc2lkmu_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp7oc2lkmu_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp7oc2lkmu_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    prev =\
    \ l[0]\n    for _, cur := range l[1:] {\n        if cur < prev {\n           \
    \ return false\n        }\n        prev = cur\n    }\n    return true\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpii8kb1k3_test.go:19:5: undefined: prev

    /tmp/tmpii8kb1k3_test.go:21:18: undefined: prev

    /tmp/tmpii8kb1k3_test.go:24:9: undefined: prev

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    sort.Sort(IntSlice(l))\n    return monotonic.In(l, l[len(l)-1])\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr4__kcp1_test.go:16:5: undefined: sort

    /tmp/tmpr4__kcp1_test.go:16:15: undefined: IntSlice

    /tmp/tmpr4__kcp1_test.go:17:22: monotonic.In undefined (type func(l []int) bool
    has no field or method In)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074946
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Sort and remove duplicate elements.\n    sort.Ints(l)\n\
    \    l = uniqueSort(l)\n    // If list is all zeros or all negatives, return false.\n\
    \    if len(l) == 0 || len(l) == 1 && l[0] < 0 {\n        return false\n    }\n\
    \    // If list is all positives, return true.\n    if len(l) == 1 && l[0] > 0\
    \ {\n        return true\n    }\n    // Otherwise, sort and remove duplicate elements.\
    \ Keep the list length constant while maintaining increasing order.\n    sort.Ints(l)\n\
    \    lLen := len(l)\n    l[0] = 0\n    for i := 1; i < lLen; i++ {\n        if\
    \ l[i-1] > l[i] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx4jqwmxb_test.go:17:5: undefined: sort

    /tmp/tmpx4jqwmxb_test.go:18:9: undefined: uniqueSort

    /tmp/tmpx4jqwmxb_test.go:28:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074946
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l); i++ {\n        if l[i] < l[i-1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpekhyvxjt_test.go:17\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpekhyvxjt_test.go:31\
    \ +0x739\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074947
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    last,\
    \ cur := l[0], l[0]\n    for _, item := range l[1:] {\n        if item <= last\
    \ {\n            return false\n        }\n        last = cur\n        cur = item\n\
    \    }\n\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp7t7mr9u9_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp7t7mr9u9_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmp7t7mr9u9_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074947
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    // Find\
    \ the first decreasing element.\n    i := 0\n    for i = 0; l[i] >= l[i+1]; i++\
    \ {\n    }\n\n    // Return whether there is a decreasing element.\n    return\
    \ i > 0 && l[i+1] > l[i]\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmp5dtenbcm_test.go:22\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmp5dtenbcm_test.go:39\
    \ +0x7e5\ntesting.tRunner(0xc0001031e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074947
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return monotonic_impl(l, 0)\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpglwuv4u5_test.go:16:12: undefined: monotonic_impl

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Sort and find first element.\n    if len(l) < 2 {\n  \
    \      return false\n    }\n    first := sort.IntSlice(l).Len()\n    if first\
    \ == 0 {\n        return false\n    }\n    var prev int\n    i := 0\n    j :=\
    \ first\n    for i < j {\n        k := sort.IntSlice(l[i:]).Len()\n        if\
    \ k == 0 {\n            return false\n        }\n        if prev < k {\n     \
    \       prev = 0\n        } else {\n            prev = k\n        }\n        i\
    \ += k\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6gt6ptta_test.go:20:14: undefined: sort

    /tmp/tmp6gt6ptta_test.go:28:14: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    var (\n\
    \        min  = math.MaxInt32\n        max = math.MinInt32\n    )\n    for _,\
    \ v := range l {\n        if v < min {\n            min = v\n        }\n     \
    \   if v > max {\n            max = v\n        }\n    }\n    if min > max {\n\
    \        return true\n    }\n    for i := 1; i < len(l); i++ {\n        if l[i-1]\
    \ > l[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29gfbrcb_test.go:20:16: undefined: math

    /tmp/tmp29gfbrcb_test.go:21:15: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l, tail := removeNonIncreasingElements(l)\n    if len(l)\
    \ == 0 {\n        return true\n    }\n    if tail == nil {\n        return monotonic(tail)\n\
    \    }\n\n    return l[0] < tail[0] || monotonic(tail)\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcypo8px7_test.go:16:16: undefined: removeNonIncreasingElements

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n\n    current\
    \ := l[0]\n\n    for _, v := range l[1:] {\n        if current > v {\n       \
    \     return false\n        }\n        current = v\n    }\n\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpjzr5gqf4_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpjzr5gqf4_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074948
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // The first list element.\n    prev := l[0]\n    ok := true\n\
    \n    // The last list element.\n    var last int\n    for i := 1; i < len(l);\
    \ i++ {\n        current := l[i]\n        if last > current {\n            ok\
    \ = false\n        }\n        last = current\n    }\n\n    // Return true if list\
    \ elements are monotonically increasing or decreasing.\n    return ok\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32m96d35_test.go:17:5: prev declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    return\
    \ monotonicHelper(l[0], l[len(l)-1])\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix4w7s4j_test.go:19:12: undefined: monotonicHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074947
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    for i :=\
    \ 1; i < len(l); i++ {\n        if l[i-1] < l[i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpmod_gbnl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpmod_gbnl_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpmod_gbnl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074948
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    // Sort\
    \ and check monotonicity.\n    sort.Sort(l)\n    for i := 1; i < len(l); i++ {\n\
    \        if l[i-1] > l[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmpcg11j_test.go:20:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074948
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    n := len(l)\n\
    \    min := 0\n    max := n-1\n    for i := 0; i < n; i++ {\n        if l[i] >\
    \ l[max] {\n            max = i\n        } else if l[i] < l[min] {\n         \
    \   min = i\n        }\n    }\n    if min < n && min < max {\n        for i :=\
    \ n; i > min; i-- {\n            if l[i] > l[min] {\n                return false\n\
    \            }\n        }\n        for i := min; i > 0; i-- {\n            if\
    \ l[i] < l[max] {\n                return false\n            }\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0001d2550?, 0x450700?, 0x8?})\n\
    \t/tmp/tmpr5gfvdxp_test.go:31 +0x115\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpr5gfvdxp_test.go:51 +0x93\ntesting.tRunner(0xc000199040, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074948
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Initialize to true\n    var ok bool = true\n\n    // Check\
    \ each element of the list \n    for i := range l {\n        if i == 0 || l[i-1]\
    \ > l[i] {\n            // Elements are monotonically increasing\n           \
    \ ok = false\n            break\n        }\n    }\n\n    return ok\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp8f9m389w_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp8f9m389w_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp8f9m389w_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp8f9m389w_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp8f9m389w_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp8f9m389w_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074948
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n%2 == 1 {\n        return false\n  \
    \  }\n\n    for i := 1; i < n; i++ {\n        if l[i-1] <= l[i] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpxiy0dfcu_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpxiy0dfcu_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpxiy0dfcu_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__6 (0.00s)\n        tmpxiy0dfcu_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpxiy0dfcu_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074948
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    // Set\
    \ current and previous elements.\n    cur, prev := l[0], l[0]\n    i := 1\n  \
    \  for i < len(l) {\n        current := l[i]\n        if current > prev {\n  \
    \          return false\n        }\n        if current < prev {\n            prev\
    \ = current\n        } else {\n            if i > len(l)-1 || current != l[i-1]\
    \ {\n                return false\n            }\n            i++\n        }\n\
    \        prev = current\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzjt3y1qs_test.go:21:5: cur declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074948
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    i :=\
    \ 0\n    prev := l[0]\n    for _, v := range l[1:] {\n        if v < prev {\n\
    \            return false\n        }\n        prev = v\n        i++\n    }\n \
    \   return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpqms54zxt_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpqms54zxt_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074949
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    var m\
    \ int = 0\n    var prev int = 0\n    for _, x := range l {\n        if x != prev\
    \ {\n            m = x\n            prev = x\n        }\n    }\n\n    return m\
    \ > prev\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpoyi7fwdk_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpoyi7fwdk_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpoyi7fwdk_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpoyi7fwdk_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpoyi7fwdk_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpoyi7fwdk_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074949
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    s := s[0]\n\
    \    for _, e := range l[1:] {\n        if e < s {\n            return false\n\
    \        }\n        s = e\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp79em8q77_test.go:19:10: undefined: s

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074948
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if len(l)-1\
    \ > len(l)-2 {\n        return false\n    }\n    if l[0] < l[len(l)-1] {\n   \
    \     return true\n    }\n    return false\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmple_ekr4j_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmple_ekr4j_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmple_ekr4j_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmple_ekr4j_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmple_ekr4j_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmple_ekr4j_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074949
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    return\
    \ monotonicSorted(l, 0, len(l)-1)\n}\n\nfunc TestMonotonic(t *testing.T) {\n \
    \ candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mfoka84_test.go:19:12: undefined: monotonicSorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074949
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n\n    prev\
    \ := l[0]\n    for _, cur := range l {\n        if prev >= cur {\n           \
    \ return false\n        }\n        prev = cur\n    }\n    return true\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp1ug4izae_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp1ug4izae_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp1ug4izae_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp1ug4izae_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp1ug4izae_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp1ug4izae_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074949
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return monotonicHelper(l, 0, len(l)-1)\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zeh6gvs_test.go:16:12: undefined: monotonicHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074949
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    s := l[0]\n    for i := 1; i < len(l); i++ {\n        if\
    \ s[i] > s[i-1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04rmthlz_test.go:18:13: invalid operation: cannot index s (variable of
    type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074949
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    first :=\
    \ l[0]\n    second := l[1]\n    for i := 2; i < len(l); i++ {\n        if l[i]\
    \ < first {\n            return false\n        }\n        if l[i] > second {\n\
    \            return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp_v_xcaeo_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp_v_xcaeo_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmp_v_xcaeo_test.go:52: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp_v_xcaeo_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var prev int\n    var cur int\n    var count int\n    for\
    \ _, v := range l {\n        if prev < v {\n            count++\n            cur\
    \ = v\n        } else {\n            count--\n            prev = v\n        }\n\
    \    }\n    return count == 0\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx_s_4ewe_test.go:17:9: cur declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return false\n    }\n\n    var\
    \ i int\n    var prev int\n    var cur int\n    var count int\n\n    for i = 0;\
    \ i < len(l); i++ {\n        prev = cur\n        cur = l[i]\n        count = 1\n\
    \        switch {\n        case cur < prev:\n            count++\n        case\
    \ cur > prev:\n            count--\n        }\n\n        if count == 0 {\n   \
    \         return false\n        }\n    }\n\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp5rqtmras_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp5rqtmras_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp5rqtmras_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp5rqtmras_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp5rqtmras_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp5rqtmras_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074950
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    m := make(map[int]\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6llfymk5_test.go:19:23: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074949
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    f := l[0]\n\
    \    for _, v := range l[1:] {\n        if f > v {\n            return false\n\
    \        }\n        f = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpu151p49g_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpu151p49g_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074950
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return false\n    }\n    var i,\
    \ j int\n    for i = 0; i < len(l); i++ {\n        if l[i] > l[j] {\n        \
    \    return false\n        }\n        if l[i] < l[j] {\n            j = i\n  \
    \      }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpwdp44e3q_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpwdp44e3q_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpwdp44e3q_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    var\
    \ last = -999999\n    var i int\n    for i, v := range l {\n        if v < 0 {\n\
    \            return false\n        }\n\n        if v > last {\n            last\
    \ = v\n        }\n    }\n\n    return len(l) == 0 || last == l[i-1]\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpczo2qlgr_test.go:22:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    last,\
    \ i := l[0], 1\n    for _, val := range l[1:] {\n        if val < last {\n   \
    \         return false\n        }\n        if val > last {\n            last,\
    \ i = val, i + 1\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpesyhzodm_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpesyhzodm_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    sort.Sort(IntSlice(l))\n\
    \    return monotonicHelper(l, 0, len(l), false)\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8bm9vtw_test.go:19:5: undefined: sort

    /tmp/tmpd8bm9vtw_test.go:19:15: undefined: IntSlice

    /tmp/tmpd8bm9vtw_test.go:20:12: undefined: monotonicHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    sort.Sort(IntSlice(l))\n    for i := 1; i < len(l); i++ {\n\
    \        if l[i-1] > l[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8b7qyq0o_test.go:16:5: undefined: sort

    /tmp/tmp8b7qyq0o_test.go:16:15: undefined: IntSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    if len(l)\
    \ == 1 {\n        return l[0] >= 0\n    }\n\n    // Sort increasingly until the\
    \ first decreasing is found.\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    for i := 0; i < len(l); i++ {\n        if l[i] <= 0 {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvq2n12ax_test.go:25:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return len(l) <= 1 || monotonicHelper(l, len(l)-1, 0)\n}\n\
    \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppsg61srz_test.go:16:27: undefined: monotonicHelper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074950
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l)\
    \ == 1 {\n        return l[0] > l[0]\n    }\n    for i := range l {\n        if\
    \ l[i-1] < l[i] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpkzptu9n3_test.go:23\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpkzptu9n3_test.go:37\
    \ +0x739\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Go has built-in max and min functions.\n    if l == nil\
    \ || len(l) == 0 {\n        return true\n    }\n\n    max := l[0]\n    min :=\
    \ l[0]\n    pos := 1\n    for _, e := range l {\n        if e < min {\n      \
    \      min = e\n        }\n        if e > max {\n            max = e\n       \
    \ }\n    }\n    if min >= max {\n        return false\n    }\n\n    if pos ==\
    \ len(l) {\n        return true\n    }\n    pos := 1\n    for _, e := range l\
    \ {\n        if e < l[pos-1] {\n            pos = pos\n        }\n    }\n\n  \
    \  return l[pos-1] <= l[pos]\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp50c8t4me_test.go:39:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    current\
    \ := l[0]\n    if len(l) > 1 {\n        for _, v := range l[1:] {\n          \
    \  if current > v {\n                return false\n            }\n           \
    \ current = v\n        }\n    }\n    return current > 0\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmppv4699_m_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmppv4699_m_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // If there are no numbers in l, then l is monotonically\
    \ increasing if all numbers are non-negative and non-zero.\n    if len(l) == 0\
    \ {\n        return true\n    }\n\n    // If all numbers are non-negative and\
    \ non-zero, then the list must be monotonically increasing.\n    if len(l) ==\
    \ 1 {\n        return true\n    }\n\n    // For all odd numbers in l, the list\
    \ is monotonically increasing if at least one of them is greater than the other.\n\
    \    // For all even numbers in l, the list is monotonically decreasing if at\
    \ least one of them is less than the other.\n    for _, i := range l {\n     \
    \   if i%2 == 1 {\n            if l[len(l)-2] > i {\n                return false\n\
    \            }\n        }\n        if i%2 == 0 {\n            if l[len(l)-1] <\
    \ i {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpfhz8hpga_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpfhz8hpga_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpfhz8hpga_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpfhz8hpga_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpfhz8hpga_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Initialize to the first element in the list.\n    prev\
    \ := l[0]\n    // Iterate from second element to the end.\n    for _, curr :=\
    \ range l[1:] {\n        if prev <= curr {\n            return false\n       \
    \ }\n        prev = curr\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpo2jr341v_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpo2jr341v_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpo2jr341v_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__6 (0.00s)\n        tmpo2jr341v_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpo2jr341v_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n\n    if len(l)\
    \ == 0 {\n        return false\n    }\n\n    // Assume monotonic if first and\
    \ last elements are equal\n    if l[0] != l[len(l)-1] {\n        return false\n\
    \    }\n\n    for i := 1; i < len(l); i++ {\n        if l[i] < l[i-1] {\n    \
    \        return false\n        }\n    }\n\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpjw9q8l02_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpjw9q8l02_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpjw9q8l02_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpjw9q8l02_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpjw9q8l02_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Start with the first element and check if its greater\
    \ than the\n    // last element.  We know that its not monotonic otherwise.\n\
    \    if len(l) < 2 {\n        return false\n    }\n    current := l[0]\n    last\
    \ := l[len(l)-1]\n    if current > last {\n        return false\n    }\n    if\
    \ len(l) < 2 {\n        return true\n    }\n\n    // Recursively check the rest\n\
    \    if len(l) < 4 {\n        return false\n    }\n    return monotonic(l[2:])\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpxnem511g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpxnem511g_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpxnem511g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpxnem511g_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpxnem511g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpxnem511g_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    l := l[:0]\n\
    \    for i := 0; i < len(l); i++ {\n        if l[i] < l[i-1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_qywupkk_test.go:19:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    prev\
    \ := l[0]\n    for _, cur := range l[1:] {\n        if cur >= prev {\n       \
    \     return false\n        }\n        prev = cur\n    }\n\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpr13pz8k7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpr13pz8k7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpr13pz8k7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__6 (0.00s)\n        tmpr13pz8k7_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpr13pz8k7_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074951
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if len(l)==1\
    \ {\n        return l[0] < l[0]\n    }\n    if l[0] > l[len(l)-1] {\n        return\
    \ false\n    }\n    return monotonic(l[1:len(l)-1])\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpop0ke6ta_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpop0ke6ta_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l); i++ {\n        j := i + 1\n     \
    \   if l[i] < l[j] {\n            return false\n        }\n        if l[i] > l[j]\
    \ {\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmp1lfs1thw_test.go:18\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmp1lfs1thw_test.go:42\
    \ +0x74a\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l); i++ {\n        if i > 0 && l[i] <=\
    \ l[i-1] {\n            return false\n        }\n        if i < len(l)-1 && l[i]\
    \ >= l[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpzb5fm484_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpzb5fm484_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpzb5fm484_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    prev := l[0]\n    for _, cur := range l {\n        if cur\
    \ <= prev {\n            return false\n        }\n        prev = cur\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpfv4gwhxj_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpfv4gwhxj_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpfv4gwhxj_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpfv4gwhxj_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpfv4gwhxj_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpfv4gwhxj_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    m := map[int]int{}\n    for _, v := range l {\n        m[v]\
    \ += 1\n    }\n    for _, v := range m {\n        if v == 0 {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp3ow9lrnq_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp3ow9lrnq_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    prev\
    \ := l[0]\n    for _, v := range l[1:] {\n        if v < prev {\n            return\
    \ false\n        }\n        prev = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpuwrlj7dj_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpuwrlj7dj_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if len(l)\
    \ == 1 {\n        return false\n    }\n\n    for i := 1; i < len(l); i++ {\n \
    \       if l[i-1] > l[i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmptzpoutz6_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmptzpoutz6_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n\n    if l[0]\
    \ != 1 {\n        return false\n    }\n\n    if len(l) == 1 {\n        return\
    \ true\n    }\n\n    switch {\n    case l[1] < l[0]:\n        return false\n \
    \   case l[1] > l[0]:\n        return true\n    case l[1] == l[0]:\n        return\
    \ true\n    default:\n        return false\n    }\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpj0mggu4e_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpj0mggu4e_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpj0mggu4e_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpj0mggu4e_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMonotonic/test_num__7\
    \ (0.00s)\n        tmpj0mggu4e_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // We have len(l) <= 1 here because len(l) > 0 can only occur\
    \ when l is empty.\n    if len(l) <= 1 {\n        return true\n    }\n    // Loop\
    \ through all elements except the first\n    for i := 1; i < len(l); i++ {\n \
    \       // If the current and next elements are the same\n        if l[i-1] ==\
    \ l[i] {\n            // If next element is less than current element\n      \
    \      if l[i-1] < l[i] {\n                // We have found two elements are monotonically\
    \ increasing or decreasing.\n                // We can return false here because\
    \ we will know this list is not monotonically\n                // increasing/decreasing\
    \ after we finish comparing elements 1 to i.\n                return false\n \
    \           }\n        } else {\n            // If the next element is greater\
    \ than the current element\n            if l[i-1] > l[i] {\n                //\
    \ We have found two elements are monotonically increasing or decreasing.\n   \
    \             // We can return false here because we will know this list is not\
    \ monotonically\n                // increasing/decreasing after we finish comparing\
    \ elements 1 to i.\n                return false\n            }\n        }\n \
    \   }\n\n    // If we've reached this point then we have found two elements are\
    \ monotonically increasing\n    // or decreasing.\n    return true\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpuys8uagm_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpuys8uagm_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    first,\
    \ prev := l[0], l[0]\n    for _, i := range l[1:] {\n        if i < prev {\n \
    \           return false\n        }\n        if i > prev {\n            prev =\
    \ i\n        }\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    I solved this in Haskell as follows:\n<code>\nimport Data.List\n\ninOrder :: Ord\
    \ a => [a] -> Bool\ninOrder [] = True\ninOrder [_] = True\ninOrder (x:xs) | (x\
    \ > head xs) && inOrder (tail xs) = False\n              | otherwise = (head xs)\
    \ <= x) && (inOrder (tail xs)\n\nmain = do\n    putStrLn (show (inOrder [1,3,5,7,9]))\n\
    </code>\n<|/ a tags=arrays,sorting,algorithm |>\n<| a dscore=0 |>\nSort a List\n\
    I needed this in Haskell and thought it might be useful to share my solution.\
    \ I am sorting a list of values using sortBy and passing in the function which\
    \ compares two values in a list. \n<code>\nimport Data.List\nimport Data.Ord\n\
    import Data.Foldable\n\nsortByComparable :: (a -> a -> Ordering) -> [a] -> [a]\n\
    sortByComparable cmp xs = sortBy cmp xs\n</code>\nYou can pass in\n<code>\nsortByComparable\
    \ (comparing length) \n</code>\nto get the same result as \n<code>\nsort (comparing\
    \ length)\n</code>\nBut I wanted a custom sorting function to sort in descending\
    \ order or ascending order, so I wrote this:\n<code>\nsortByComparable' :: (a\
    \ -> a -> Ordering) -> [a] -> [a]\nsortByComparable' cmp xs = sortBy cmp (reverse\
    \ xs)\n</code>\nAnd now I can do\n<code>\nsortByComparable' (comparing length)\
    \ [2,4,6,1,8,3,5,7] \n</code>\nand get a result like\n<code>\n[1,2,3,4,5,6,7,8]\n\
    </code>\n<|/ a tags=arrays,sorting,algorithm |>\n<| a tags=arrays,sorting,algorithm\
    \ |>\nHere is my solution in Javascript based on Sayaki's answer, which I believe\
    \ is the fastest way in practice:\n<code>\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp81q7yaw1_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n<=1 {\n        return true\n    }\n\
    \    switch l[0] {\n    case l[1]:\n        return true\n    case l[2]:\n    \
    \    return false\n    }\n    return monotonic(l[0:n-1])\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0000c4550?, 0x5648db?, 0x5648db?})\n\
    \t/tmp/tmpy6r_ve2j_test.go:23 +0x7e\ncommand-line-arguments_test.monotonic({0xc0000c4550?,\
    \ 0x5d3fb0?, 0x5e3ea0?})\n\t/tmp/tmpy6r_ve2j_test.go:26 +0x49\ncommand-line-arguments_test.monotonic({0xc0000c4550?,\
    \ 0x450700?, 0x8?})\n\t/tmp/tmpy6r_ve2j_test.go:26 +0x49\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpy6r_ve2j_test.go:36 +0x93\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l); i++ {\n        if l[i-1] > l[i] {\n\
    \            return false\n        }\n        if l[i-1] < l[i] {\n           \
    \ return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpgtot_0h9_test.go:17\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpgtot_0h9_test.go:34\
    \ +0x786\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    i := 0\n\
    \    start := l[0]\n    for _, val := range l {\n        if val < start {\n  \
    \          return false\n        }\n        if val > start {\n            i =\
    \ i + 1\n            start = val\n        }\n    }\n    return i == len(l)\n}\n\
    \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpf8ghudy2_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpf8ghudy2_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpf8ghudy2_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpf8ghudy2_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpf8ghudy2_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpf8ghudy2_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l := append([]int{}, l...)\n\n    var prev, cur int\n   \
    \ var isIncreasing bool\n    for i := range l {\n        cur = i\n        if cur\
    \ == prev {\n            isIncreasing = true\n        } else {\n            if\
    \ isIncreasing {\n                return false\n            }\n            isIncreasing\
    \ = false\n        }\n        prev = cur\n    }\n\n    return true\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmb3she0m_test.go:16:7: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var prev int = 0\n    var i int = 0\n    for ; i < len(l);\
    \ i++ {\n        if l[i] >= prev {\n            return false\n        }\n    \
    \    prev = l[i]\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpf4dpkxmm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpf4dpkxmm_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpf4dpkxmm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpf4dpkxmm_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpf4dpkxmm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpf4dpkxmm_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    l := append([]int{}, l...)\n    sort.Sort(sort.Reverse(sort.IntSlice(l)))\n\
    \    for _, e := range l {\n        if e != l[len(l)-1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThis is very elegant solution with O(n) complexity, works really good.\n\
    <|/ c |>\n<| c |>\nThis is by far the most elegant solution for this problem\n\
    <|/ c |>\n<| c |>\nThis should be accepted as the best solution.\n<|/ c |>\n<|\
    \ c |>\nThis is by far the best solution.\n<|/ c |>\n<| c |>\nIt works. But I\
    \ am not sure if this is O(n) or O(nlogn). From some references, the complexity\
    \ for this solution is O(nlogn). https://medium.com/analytics-vidhya/comparing-runtime-complexity-of-algorithms-for-sorting-9d2b706cb430\n\
    <|/ c |>\n<| a tags=sorting,go |>\nMy solution is O(n) time/space:\n<code>\npackage\
    \ main\n\nimport \"fmt\"\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptk25w7wy_test.go:25:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074952
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    m := make(map[int]bool)\n\n    for _, v := range l {\n  \
    \      m[v] = true\n    }\n\n    for i := len(l) - 1; i >= 0; i-- {\n        if\
    \ !m[i] {\n            return false\n        }\n    }\n\n    return true\n}\n\
    </code>\n<|/ a tags=sorting,go |>\n<| c |>\nWhile this doesn't answer my question,\
    \ I do appreciate the solution and would love to upvote for it.  Thanks!\n<|/\
    \ c |>\n<| a dscore=0 |>\nAnother approach using sort.Interface:\n<code>\npackage\
    \ main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcxc0opwe_test.go:30:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074952
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    m := map[int]int{}\n    for _, v := range l {\n        m[v]\
    \ = m[v] + 1\n    }\n    for key, value := range m {\n        if value > 1 {\n\
    \            return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgw1oh782_test.go:20:9: key declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    lastElem := l[0]\n    diff := 0\n    for _, element := range\
    \ l {\n        if element > lastElem {\n            if diff > 0 {\n          \
    \      return false\n            }\n            diff = 1\n        } else {\n \
    \           if diff < 0 {\n                return false\n            }\n     \
    \       diff = -1\n        }\n        lastElem = element\n    }\n    return true\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis one will work well for me :)\n<|/ c |>\n<|\
    \ c |>\nThis one worked for me, even though I had to tweak it a little to suit\
    \ my needs. I used the algorithm from here: https://stackoverflow.com/questions/4608587/how-to-determine-whether-a-sequence-of-numbers-is-monotonically-increasing/4608634#4608634\n\
    <|/ c |>\n<| a dscore=3 |>\nThe simplest solution is to first check for monotonicity\
    \ by sorting the numbers and then comparing the first two numbers:\n<code>\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfezz7ypj_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    n :=\
    \ len(l)\n    i := 0\n\n    for j := 0; j < n; j++ {\n        for k := j + 1;\
    \ k < n; k++ {\n            if l[j] < l[k] {\n                return false\n \
    \           }\n        }\n        i++\n    }\n\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpdta_x1fi_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpdta_x1fi_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpdta_x1fi_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    if len(l)\
    \ == 1 {\n        return true\n    }\n\n    switch l[len(l)-1] {\n    case l[0]:\n\
    \        return true\n    case l[1]:\n        return false\n    }\n\n    var last,\
    \ prev int\n    for _, v := range l {\n        if v > prev {\n            return\
    \ false\n        }\n\n        last = v\n        prev = v\n    }\n\n    return\
    \ last<prev\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpuxc1zvz__test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpuxc1zvz__test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpuxc1zvz__test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpuxc1zvz__test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpuxc1zvz__test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] < l[i+1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpl01w6_aq_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpl01w6_aq_test.go:44:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpl01w6_aq_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    var first,\
    \ rest []int\n    for _, i := range l {\n        if i > first[len(first)-1] {\n\
    \            first = append(first, i)\n        } else {\n            rest = append(rest,\
    \ i)\n        }\n    }\n    return monotonic(first) && monotonic(rest)\n}\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0000bf550, 0x4, 0x8?})\n\t\
    /tmp/tmpl4z_jjzd_test.go:21 +0x1d1\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpl4z_jjzd_test.go:37 +0x93\ntesting.tRunner(0xc0001036c0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // First check to see if any elements are the same\n    if\
    \ l[0] != l[len(l)-1] {\n        return false\n    }\n    i := 0\n    lastIncreased\
    \ := false\n    lastDecreased := false\n    for i < len(l)-1 {\n        if l[i]\
    \ > l[i+1] {\n            lastIncreased = true\n        }\n        if l[i] < l[i+1]\
    \ {\n            lastDecreased = true\n        }\n        i += 2\n    }\n    return\
    \ !(lastIncreased || lastDecreased)\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm,sorting\
    \ dscore=2 |>\nSince this isn't a specific programming question, and is more of\
    \ an algorithm question.\nYou might want to look into the Quick Sort Algorithm,\
    \ which can solve the problem in O(nlogn).\n<|/ a |>\n<| a tags=arrays,algorithm,sorting\
    \ dscore=2 |>\nOne way would be:\n<code>\ndef isSorted(array):\n  if len(array)\
    \ < 2: return False\n  for i in range(len(array) - 1):\n    if array[i] > array[i+1]:\n\
    \      return False\n  return True\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm,sorting\
    \ dscore=2 |>\nThe following code will check if an array is sorted or not, using\
    \ Quick sort algorithm:\n<code>\ndef isSorted(array):\n    if len(array) == 1:\n\
    \        return True\n\n    if len(array) < 2:\n        return False\n\n    pivot\
    \ = array[0]\n\n    left = []\n    right = []\n\n    for index, value in enumerate(array):\n\
    \        if value <= pivot:\n            left.append(value)\n        else:\n \
    \           right.append(value)\n\n    return isSorted(left) and isSorted(right)\n\
    </code>\n<|/ a |>\n<| a dscore=2 tags=arrays,algorithm,sorting |>\nThe first step\
    \ is to find out the last element in the array which is greater than the elements\
    \ in the two adjacent elements in the array. This is possible using binary search\
    \ but as there are only 4 elements in the array it would be a straight forward\
    \ binary search implementation. \nAfter this find out if any element in the array\
    \ is less than the pivot element. This can be done by binary search on all elements\
    \ above the pivot and checking if any element in the array is greater than the\
    \ pivot element in the corresponding array.\nIf any of the two elements are greater\
    \ than the pivot element then the array is sorted. Else not.\n<code>\nbool isSorted(int[]\
    \ a)\n{\n    int pivot = a[0];\n    int lo = 0;\n    int hi = a.Length-1;\n  \
    \  while (lo < hi)\n    {\n        int mid = (lo+hi)/2;\n        if(pivot > a[\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoes2mx6d_test.go:34:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074953
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return false\n    }\n\n    prev\
    \ := l[0]\n    next := l[1]\n    prevIsEven := true\n    nextIsEven := false\n\
    \    for _, val := range l[2:] {\n        if val-prev > 0 {\n            prevIsEven\
    \ = false\n        } else {\n            prevIsEven = true\n        }\n      \
    \  if val-next>0 {\n            nextIsEven = false\n        } else {\n       \
    \     nextIsEven = true\n        }\n        prev = val\n        next = val\n \
    \   }\n\n    return prevIsEven && !nextIsEven\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp50y5n8_2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp50y5n8_2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp50y5n8_2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp50y5n8_2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp50y5n8_2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp50y5n8_2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    switch\
    \ l[len(l)-1] - l[len(l)-2] {\n    case -2:\n        return false\n    case -1:\n\
    \        return true\n    default:\n        return monotonic(l[:len(l)-1])\n \
    \   }\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpwl1sdnq8_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpwl1sdnq8_test.go:49:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    if len(l)%2\
    \ != 0 {\n        fmt.Println(\"len not even\")\n        return false\n    }\n\
    \n    increasing := true\n    increasing = increasing && l[0] > l[1]\n    for\
    \ i := 1; i < len(l); i += 2 {\n        increasing = increasing && l[i] > l[i+1]\n\
    \    }\n\n    return increasing\n}\n</code>\n<|/ a dscore=0 tags=go |>\n<| c |>\n\
    This doesn't work for []int{1, 20, 4, 10}\n<|/ c |>\n<| c |>\nAh! Yes, you're\
    \ right. Not all lists are sorted.\n<|/ c |>\n<| a dscore=0 |>\nHere is an implementation\
    \ that is more efficient than sorting.\nIt uses binary search to determine whether\
    \ a particular number lies in the array. The complexity is O(log n), where n is\
    \ the length of the array.\n<code>\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprfjsie3p_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074953
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 || len(l) == 1 {\n        return true\n  \
    \  }\n    last, curr := l[0], 0\n    for i, e := range l[1:] {\n        if e <\
    \ last {\n            return false\n        }\n        last = e\n        curr\
    \ = i\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfhfdojz5_test.go:19:11: curr declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    l, tail\
    \ := l, l[1:]\n    if l[0] > l[1] {\n        return false\n    }\n\n    if len(l)\
    \ == 1 {\n        return true\n    }\n\n    for _, e := range tail {\n       \
    \ if e < l[0] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpl6az3qwl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpl6az3qwl_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpl6az3qwl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpl6az3qwl_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l[0] >= l[len(l)-1] {\n        return true\n    }\n  \
    \  var i int\n    var prev int\n    for i = len(l)-1; i >= 0; i-- {\n        if\
    \ l[i] < prev {\n            return false\n        }\n        prev = l[i]\n  \
    \  }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpb3sd22ml_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpb3sd22ml_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpb3sd22ml_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var a0, a1 int\n    var b0, b1 int\n\n    if len(l) < 2 {\n\
    \        return false\n    }\n\n    a0, b0 = l[0], l[1]\n    for i := 2; i < len(l);\
    \ i++ {\n        if l[i] > b0 {\n            b1 = l1\n            a1 = l[i]\n\
    \            b0 = l[i-1]\n        } else {\n            a1 = a0\n            b1\
    \ = b0\n        }\n        if a1 > b1 {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdloteh6k_test.go:26:18: undefined: l1

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return false\n    }\n\
    \n    var prev int\n    var curr int\n    delta := -1\n    for i := 0; i < n;\
    \ i++ {\n        if i > 0 {\n            if l[i-1] <= l[i] {\n               \
    \ return false\n            }\n        }\n        prev, curr = curr, l[i]\n\n\
    \        if delta == -1 {\n            delta = curr - prev\n        }\n      \
    \  if delta > 0 && curr < prev {\n            return false\n        }\n      \
    \  if delta < 0 && curr > prev {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmplagpe61f_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmplagpe61f_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmplagpe61f_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmplagpe61f_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmplagpe61f_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmplagpe61f_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n\n    if len(l)\
    \ < 4 {\n        return false\n    }\n\n    x := l[0]\n    y := l[1]\n    for\
    \ i := 2; i < len(l); i++ {\n        x = y\n        y = l[i]\n        if x < y\
    \ {\n            return true\n        }\n    }\n    return false\n}\n`),\n\tcommon:\
    \ common{\n\t\tinputDir:             \"input\",\n\t\toutputDir:            \"\
    output\",\n\t\tinputBelowOutput:      \"input\",\n\t\toutputBelowInput:      \"\
    output\",\n\t\toutputInsideInput:    \"input\",\n\t\texpectedResult:       \"\
    true\",\n\t\texpectedStderr:       \"\",\n\t\texpectedStdout:       \"true\\n\"\
    ,\n\t\texpectedExitCode:      0,\n\t\tshouldFail:           false,\n\t\tshouldPass:\
    \           true,\n\t\texpectedPreconditions: []string{},\n\t},\n}\n\nvar tests\
    \ = []test{\n\ttest{\n\t\tname:         \"no files in input\",\n\t\tshouldPass:\
    \  true,\n\t\tshouldFail:  false,\n\t\texpectedExitCode: 1,\n\t\texpectedStderr:\
    \   \"missing or empty '--input' flag\\n\",\n\t},\n\ttest{\n\t\tname:        \
    \ \"not enough arguments\",\n\t\tshouldPass:  false,\n\t\tshouldFail:  true,\n\
    \t\texpectedExitCode: 2,\n\t\texpectedStderr:   \"missing or empty '--output'\
    \ flag\\n\",\n\t},\n\ttest{\n\t\tname:         \"input files not under output\"\
    ,\n\t\tshouldPass:  false,\n\t\tshouldFail:  true,\n\t\texpectedExitCode: 2,\n\
    \t\texpectedStderr:   \"input files exist outside output directory\\n\",\n\t},\n\
    \ttest{\n\t\tname:         \"input files outside output dir\",\n\t\tshouldPass:\
    \  false,\n\t\tshouldFail:  true,\n\t\texpectedExitCode: 2,\n\t\texpectedStderr:\
    \   \"input files exist outside output directory\\n\",\n\t},\n\ttest{\n\t\tname:\
    \         \"output files outside output dir\",\n\t\tshouldPass:  false,\n\t\t\
    shouldFail:  true,\n\t\texpectedExitCode: 2,\n\t\texpectedStderr:   \"output files\
    \ exist outside output directory\\n\",\n\t},\n\ttest{\n\t\tname:         \"output\
    \ files inside output dir\",\n\t\tshouldPass:  false,\n\t\tshouldFail:  true,\n\
    \t\texpectedExitCode: 2,\n\t\texpectedStderr:   \"output files exist inside output\
    \ directory\\n\",\n\t},\n\ttest{\n\t\tname:         \"output files outside output\
    \ dir but inside input dir\",\n\t\tshouldPass:  false,\n\t\tshouldFail:  true,\n\
    \t\texpectedExit\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyeug1aqk_test.go:35:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074954
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Empty list has no order.\n    if len(l) == 0 {\n     \
    \   return true\n    }\n\n    // If list is sorted, it already is monotonically.\n\
    \    if len(l) == 1 && monotonicInorder(l) {\n        return true\n    }\n\n \
    \   prev := l[0]\n    switch {\n    case l[1] > prev:\n        return false\n\
    \    case l[1] < prev:\n        return true\n    }\n\n    for i := 2; i < len(l);\
    \ i++ {\n        prev := l[i-1]\n        cur := l[i]\n        switch {\n     \
    \   case cur > prev:\n            return false\n        case cur < prev:\n   \
    \         return true\n        }\n    }\n\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphhslkikx_test.go:22:23: undefined: monotonicInorder

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    min :=\
    \ l[0]\n    for _, max := range l[1:] {\n        if max < min {\n            return\
    \ false\n        }\n        min = max\n    }\n    return true\n}\n`\n\tbuf :=\
    \ new(bytes.Buffer)\n\tbuf.Write([]byte(text))\n\tbuf.Write([]byte(\"\\n\"))\n\
    \tfmt.Fprintf(buf, \"package test\\n\")\n\tfmt.Fprintf(buf, \"var monotonicTest\
    \ = []int{1, 2, 4, 20}\\n\")\n\tfmt.Fprintf(buf, \"var monotonicTest2 = []int{1,\
    \ 20, 4, 10}\\n\")\n\tfmt.Fprintf(buf, \"var monotonicTest3 = []int{4, 1, 0, -10}\\\
    n\")\n\tfmt.Fprintf(buf, \"var monotonicTest4 = []int{1, 2, 1}\\n\")\n\n\twant\
    \ := buf.Bytes()\n\tgot := make([]byte, len(want))\n\tn, err := io.Copy(bytes.NewBuffer(got),\
    \ buf)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif n != len(want) {\n\t\t\
    t.Errorf(\"copy: got %d bytes, want %d\", n, len(want))\n\t}\n\tif !bytes.Equal(got,\
    \ want) {\n\t\tt.Errorf(\"got\\n%s\\nwant\\n%s\", got, want)\n\t}\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbllcc9a7_test.go:28:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074954
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    var lptr int\n    var up bool\n    if len(l) == 0 {\n   \
    \     return false\n    }\n    up = true\n    for _, v := range l {\n        if\
    \ v < lptr {\n            up = false\n        } else if v > lptr {\n         \
    \   lptr = v\n        }\n    }\n    return up\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpba6y48ts_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpba6y48ts_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    return l[len(l)-1]\
    \ >= l[len(l)-2]\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpzmd8f8pm_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpzmd8f8pm_test.go:42:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmpzmd8f8pm_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmpzmd8f8pm_test.go:42:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil || len(l) <= 1 {\n        return true\n    }\n\
    \    i := 0\n    max := -1\n    for j := len(l) - 1; j >= 0; j-- {\n        if\
    \ l[j] > max {\n            max = l[j]\n        }\n        i++\n        if i ==\
    \ 2 {\n            break\n        }\n        if l[j] < max {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpnn3qgm5e_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmpnn3qgm5e_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmpnn3qgm5e_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    return monotonic1(l)\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxhajsjxk_test.go:16:12: undefined: monotonic1

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l)\
    \ == 1 {\n        return true\n    }\n    prev := l[0]\n    for _, val := range\
    \ l[1:] {\n        if val < prev {\n            return false\n        }\n    \
    \    prev = val\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp0yufib30_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp0yufib30_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074955
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    sort.Sort(IntSlice(l))\n    if len(l) <= 1 {\n        return\
    \ true\n    }\n    return l[0] == 0 || l[1] == l[0] || (l[1]+1 == l[0] && monotonic(l[2:]))\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3ljx8y41_test.go:16:5: undefined: sort

    /tmp/tmp3ljx8y41_test.go:16:15: undefined: IntSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return true\n    }\n\
    \    if n > 1 && l[n-1] <= l[n-2] {\n        return false\n    }\n    i := 0\n\
    \    for ; i < n-1; i++ {\n        if l[i] < l[i+1] {\n            return false\n\
    \        }\n    }\n    for ; i < n; i++ {\n        if l[i] > l[i+1] {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpm9_7_dzz_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpm9_7_dzz_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpm9_7_dzz_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpm9_7_dzz_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpm9_7_dzz_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpm9_7_dzz_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return true\n    }\n\
    \    prev, curr, prev1, curr1 := l[0], l[0], 0, 1\n    for i := 1; i < n; i++\
    \ {\n        curr += prev - curr\n        prev1 = curr\n        curr1 += prev1\
    \ - prev\n        if prev < curr {\n            return false\n        }\n    \
    \    prev = curr\n        curr1 = prev1\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp84_gmi66_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp84_gmi66_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    l := make([]int,\
    \ len(l))\n    copy(l, l)\n    sort.Sort(l)\n    return l[0] >= l[len(l)-1]\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdpjigtee_test.go:19:7: no new variables on left side of :=

    /tmp/tmpdpjigtee_test.go:21:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if l[0]\
    \ > l[len(l)-1] {\n        return true\n    }\n    i := 0\n    j := len(l) - 1\n\
    \    k := j - 1\n    for k < j {\n        if l[i] > l[j] {\n            return\
    \ true\n        }\n        if l[i] < l[k] {\n            return false\n      \
    \  }\n        if l[i] == l[j] {\n            i++\n            j--\n          \
    \  k = j - 1\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t *testing.T)\
    \ {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0000bf570?, 0x450700?, 0x8?})\n\
    \t/tmp/tmpcg3itoh5_test.go:29 +0xc9\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmpcg3itoh5_test.go:55 +0x35d\ntesting.tRunner(0xc0001036c0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 0 {\n        return false\n    }\n    min :=\
    \ l[0]\n    max := l[0]\n    for _, v := range l {\n        if min > v {\n   \
    \         min = v\n        }\n        if max < v {\n            max = v\n    \
    \    }\n    }\n    if min > max {\n        return false\n    }\n    for _, v :=\
    \ range l {\n        if min <= v && max >= v {\n            return false\n   \
    \     }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpzrwcvtkj_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpzrwcvtkj_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpzrwcvtkj_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpzrwcvtkj_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpzrwcvtkj_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpzrwcvtkj_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n\n    if len(l)\
    \ < 4 {\n        return false\n    }\n\n    max := l[0]\n    for i := 1; i < len(l);\
    \ i++ {\n        if max < l[i] {\n            return false\n        }\n      \
    \  max = l[i]\n    }\n    return true\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,sorting,go,time-complexity,mergesort\
    \ |>\nSince you are looking for sorting algorithms with time complexity lower\
    \ than O(n*log(n)), I recommend you to take a look at the merge sort algorithm.\
    \ It is one of the easiest sorting algorithms. It is very similar to the merge\
    \ sort algorithm, but uses a divide and conquer approach, which results in faster\
    \ time complexity. \nThe merge sort algorithm is also used in a variety of other\
    \ algorithms, such as quick sort, radix sort, and bucket sort. \n\nSince a merge\
    \ sort is implemented in O(nlog(n)), it will result in a faster time complexity.\
    \ \nSince the merge sort is implemented in O(n), it will result in faster computational\
    \ complexity. \nSince a merge sort is implemented in O(n), it will result in a\
    \ faster computational complexity. \nSince a merge sort is implemented in O(n),\
    \ it will result in a faster computational complexity.\n\nSince a merge sort is\
    \ implemented in O(nlog(n)), it will result in a faster time complexity. \nSince\
    \ a merge sort is implemented in O(nlog(n)), it will result in a faster computational\
    \ complexity. \nSince a merge sort is implemented in O(nlog(n)), it will result\
    \ in a faster computational complexity.\n\nSince a merge sort is implemented in\
    \ O(nlog(n)), it will result in a faster time complexity. \nSince a merge sort\
    \ is implemented in O(nlog(n)), it will result in a faster computational complexity.\
    \ \nSince a merge sort is implemented in O(nlog(n)), it will result in a faster\
    \ computational complexity.\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nThe easiest\
    \ way to sort a list of size n in O(nlogn) time complexity is to use Merge sort\
    \ algorithm. \nIn merge sort we divide the list into two parts recursively. \n\
    If the length of the first part of the list is 1 then we know that the first element\
    \ of the list will be at the very beginning of the sorted list and we can simply\
    \ compare it to the rest of the list. We do this until we reach the half of the\
    \ list. \nIf the length of the first part of the list is even then the second\
    \ element of the list will be at the very middle of the sorted list and we can\
    \ simply compare it to the first half of the list. \nIf the length of the first\
    \ part of the list is odd then the second element of the list will be in the middle\
    \ \nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd47z6mep_test.go:33:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if l[0]\
    \ > l[len(l)-1] {\n        return false\n    }\n    for _, i := range l[:len(l)-1]\
    \ {\n        if l[i+1] <= i {\n            return false\n        }\n    }\n  \
    \  return true\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npackage main\n\nimport\
    \ \"testing\"\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyfawx83__test.go:29:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    i := 0\n    max := 0\n    for _, e := range l {\n       \
    \ if e > max {\n            max = e\n        }\n        if e < max {\n       \
    \     i++\n        }\n    }\n    return i == len(l)\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp2snx4lv7_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp2snx4lv7_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp2snx4lv7_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp2snx4lv7_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp2snx4lv7_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmp2snx4lv7_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 3 {\n        return false\n    }\n\n    n :=\
    \ len(l)\n\n    // If the list is empty, all elements are monotonically increasing\n\
    \    if n == 0 {\n        return true\n    }\n\n    // If only 1 element, list\
    \ elements are monotonically increasing\n    if n == 1 {\n        return l[0]\
    \ > l[1]\n    }\n\n    // If 2 elements, list elements are monotonically increasing\
    \ if the\n    // previous element is greater than the next element.\n    prev\
    \ = l[0] > l[1]\n\n    for i := 2; i < n; i++ {\n        current = l[i] > l[i-1]\n\
    \n        // If current > prev, then the list is not monotonically increasing\n\
    \        if !current && prev {\n            return false\n        }\n\n      \
    \  prev = current\n    }\n\n    return true\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nThe \"no loops\" check is not needed, because if `a[1] > a[2]` then `a[2]\
    \ > a[3]`, because `a[2] > a[1]` which is trivially true because `a[1] > a[2]`\
    \ and so on and so forth.\n<|/ c |>\n<| c |>\n, you're right, thanks for pointing\
    \ it out. The loop can be easily removed. I've updated the answer to reflect that.\n\
    <|/ c |>\n<| a tags=sorting,algorithm,go dscore=5 |>\nTo extend Kevin's answer.\
    \ \n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6j566mx3_test.go:49:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074955
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n\n    min :=\
    \ l[0]\n    max := l[0]\n    counter := 0\n\n    for _, v := range l {\n     \
    \   if v > max {\n            max = v\n        } else if (v < min) && (min !=\
    \ 0) {\n            counter++\n        }\n\n        if v < min {\n           \
    \ counter++\n        }\n    }\n\n    return counter <= 1\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp7da192k9_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__3 (0.00s)\n        tmp7da192k9_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__4\
    \ (0.00s)\n        tmp7da192k9_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp7da192k9_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // The return value is a boolean that indicates whether\n\
    \    // each element in `l` is monotonic increasing or\n    // decreasing.\n \
    \   min := l[0]\n    max := l[0]\n    for _, v := range l {\n        if v < min\
    \ {\n            min = v\n        }\n        if v > max {\n            max = v\n\
    \        }\n    }\n    // Check that the list is monotonically increasing or decreasing.\n\
    \    // The monotonic property holds if `min <= max &&\n    //    (min == max\
    \ || (min != (min + max) / 2))`.\n    return min <= max && (min == max || (min\
    \ != (min + max) / 2))\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmp5jeugtpg_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__5 (0.00s)\n        tmp5jeugtpg_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n    if n < 2 {\n        return false\n    }\n\
    \    max := l[n-1]\n    for i := 0; i < n-1; i++ {\n        if l[i] > max {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp5r5ne0_z_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp5r5ne0_z_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmp5r5ne0_z_test.go:49: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    switch len(l) {\n    case 0:\n        return false\n    case\
    \ 1:\n        return l[0] >= l[1]\n    case 2:\n        return l[0] > l[1] ||\
    \ monotonic(l[1:2])\n    default:\n        // len(l) >= 3, so start recursing\
    \ on the tail.\n        return monotonic(l[1:len(l)-1])\n    }\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic({0xc0000c4560?, 0x5648db?, 0x5648db?})\n\
    \t/tmp/tmp1im4brun_test.go:20 +0x90\ncommand-line-arguments_test.monotonic({0xc0000c4558?,\
    \ 0x5d3fb0?, 0x5e3ea0?})\n\t/tmp/tmp1im4brun_test.go:22 +0x53\ncommand-line-arguments_test.monotonic({0xc0000c4550?,\
    \ 0x450700?, 0x8?})\n\t/tmp/tmp1im4brun_test.go:25 +0x6d\ncommand-line-arguments_test.TestMonotonic(0x0?)\n\
    \t/tmp/tmp1im4brun_test.go:36 +0x93\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Add 1 to all the elements of the list.\n    for _, v :=\
    \ range l {\n        v += 1\n    }\n\n    prev := 0\n    max := 0\n    min :=\
    \ -1\n\n    for _, v := range l {\n        if v < min {\n            min = v\n\
    \        }\n\n        if v > max {\n            max = v\n        }\n\n       \
    \ if prev == v {\n            return false\n        }\n\n        prev = v\n  \
    \  }\n\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__2\
    \ (0.00s)\n        tmpkqwzqftf_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpkqwzqftf_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmpkqwzqftf_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpkqwzqftf_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    var xs\
    \ []int\n    for _, x := range l {\n        xs = append(xs, x)\n    }\n    xs[0],\
    \ xs[len(xs)-1] = *xs[0], *xs[len(xs)-1]\n    i := 0\n    for j := 1; j < len(xs);\
    \ j++ {\n        if xs[i] < xs[j] {\n            return false\n        }\n   \
    \     i += j\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcwl_oxgk_test.go:23:29: invalid operation: cannot indirect xs[0] (variable
    of type int)

    /tmp/tmpcwl_oxgk_test.go:23:37: invalid operation: cannot indirect xs[len(xs)
    - 1] (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074956
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if len(l)\
    \ == 1 {\n        return false\n    }\n    if l[0] > l[1] {\n        return false\n\
    \    }\n    return monotonic(append(l[:1], l[1:], l[0]))\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmvxc3lq1_test.go:25:37: cannot use l[1:] (value of type []int) as type
    int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // Sort list first, so we don't mess up element order.\n\
    \    sortedIdx := 0\n    for i := range l {\n        j := i\n        for (j -\
    \ 1); j >= 0; j-- {\n            if l[j] < l[j-1] {\n                break\n \
    \           }\n        }\n        l[sortedIdx] = l[j]\n        sortedIdx++\n \
    \   }\n\n    // Check each element of the list to see if it has decreased.\n \
    \   // If we see a decreasing element then the first one we see must\n    // be\
    \ decreasing.\n    for i := range l {\n        prev := -1\n        for j := 0;\
    \ j < i; j++ {\n            if l[j] <= prev {\n                return false\n\
    \            }\n            prev = l[j]\n        }\n    }\n\n    return true\n\
    }\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3h5k2lja_test.go:20:13: (j - 1) (value of type int) is not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    length := len(l)\n    sort.Ints(l)\n    for i := 0; i < length;\
    \ i++ {\n        if l[i-1] > l[i] {\n            return true\n        }\n    }\n\
    \    return false\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzjz2vib5_test.go:17:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for _, v := range l {\n        if v < l[0] {\n          \
    \  return false\n        }\n        if v > l[len(l)-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n\
    \  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}),\
    \ expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected:\
    \ false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n\
    \     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9,\
    \ 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpd_mqdrir_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpd_mqdrir_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__5\
    \ (0.00s)\n        tmpd_mqdrir_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074944
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return true\n    }\n    if len(l)\
    \ == 1 {\n        return false\n    }\n    prev := l[0]\n    for _, e := range\
    \ l {\n        if e <= prev {\n            return false\n        }\n        prev\
    \ = e\n    }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate\
    \ := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpnpty_1v3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpnpty_1v3_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpnpty_1v3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpnpty_1v3_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpnpty_1v3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpnpty_1v3_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    n := len(l)\n\n    if n <= 1 {\n        return true\n   \
    \ }\n\n    if l[0] == 1 {\n        return false\n    }\n\n    if l[n - 1] == -1\
    \ {\n        return false\n    }\n\n    var prev, curr int\n\n    for i := 0;\
    \ i < n; i++ {\n        if prev < 0 {\n            prev = l[i]\n            continue\n\
    \        }\n\n        if l[i] < prev {\n            return false\n        }\n\n\
    \        if curr < 0 {\n            curr = l[i]\n            continue\n      \
    \  }\n\n        if l[i] > prev {\n            return false\n        }\n\n    \
    \    if curr < curr {\n            return false\n        }\n\n        prev = l[i]\n\
    \    }\n\n    return true\n}\n</code>\n<|/ a tags=algorithm,go |>\n<| a dscore=2\
    \ tags=algorithm,go |>\nMy take on this:\n<code>\npackage main\n\nimport (\n \
    \   \"fmt\"\n)\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpid1eqthj_test.go:60:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074956
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return true\n    }\n    if l[0] >\
    \ l[len(l)-1] {\n        return false\n    }\n    for i := 0; i < len(l); i++\
    \ {\n        if l[i] > l[i+1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpyh6hri2e_test.go:23\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpyh6hri2e_test.go:37\
    \ +0x7d2\ntesting.tRunner(0xc000103520, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // If length=0, return false.\n    if len(l) == 0 {\n   \
    \     return false\n    }\n    // Initialize first value to be true and compare\
    \ the first and second values.\n    firstValue := true\n    secondValue := l[0]\n\
    \    for _, element := range l {\n        if firstValue == true {\n          \
    \  firstValue = false\n            if secondValue <= element {\n             \
    \   return false\n            }\n        } else if firstValue == false {\n   \
    \         firstValue = true\n            if secondValue > element {\n        \
    \        return false\n            }\n        } else {\n            if secondValue\
    \ < element {\n                return false\n            }\n        }\n      \
    \  secondValue = element\n    }\n    return true\n}\n</code>\n<|/ a dscore=2 tags=sorting,go,algorithm,arrays\
    \ |>\n<| a tags=sorting,go,algorithm,arrays dscore=1 |>\nI came up with a different\
    \ approach to my problem without using any library, but with O(n) complexity.\n\
    <code>\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n\
    \     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual:\
    \ candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4,\
    \ 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}),\
    \ expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true\
    \ },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg89x8kvs_test.go:43:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074956
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n\n    n := len(l)\n\
    \    for i := 1; i < n; i++ {\n        j, k, l := 0, 0, i\n        for j < n {\n\
    \            if l[j] <= l[k] {\n                l = j\n            } else {\n\
    \                k = j\n            }\n            j++\n            k++\n    \
    \    }\n\n        if j < n {\n            return l[j] <= l[k]\n        } else\
    \ {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprcj2vbph_test.go:24:17: invalid operation: cannot index l (variable of
    type int)

    /tmp/tmprcj2vbph_test.go:34:21: invalid operation: cannot index l (variable of
    type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if l == nil {\n        return false\n    }\n\n    if len(l)\
    \ <= 1 {\n        return true\n    }\n\n    i := 0\n    j := len(l)-1\n\n    for\
    \ i < j {\n        if l[i] >= l[j] {\n            i++\n        }\n        if l[i]\
    \ < l[j] {\n            j--\n        }\n    }\n\n    return false\n}\n</code>\n\
    <|/ a tags=list,go,algorithm dscore=5 |>\n<| c |>\nThis code is awesome! Just\
    \ one thing, `if l[i] >= l[j] {` should be `if l[i] <= l[j] {`. Otherwise, you\
    \ would have two consecutive increasing elements `a` and `b` in `[]int{1, 2, 3,\
    \ 4, 5}`, but your code would return `false`.\n<|/ c |>\n<| c |>\nThis is not\
    \ the most efficient solution (O(n\xB2)). It is O(n) because it uses a nested\
    \ loop.\n<|/ c |>\n<| a dscore=5 |>\n<code>\npackage main\n\nimport \"fmt\"\n\n\
    func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47ne4sax_test.go:38:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074956
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    for i := range l {\n        l[i+1] = l[i]\n    }\n    return\
    \ monotonicSlow(l)\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfiezd61i_test.go:19:12: undefined: monotonicSlow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    last, max := l[0], 0\n    for _, v := range l {\n       \
    \ if v < max {\n            return false\n        }\n        max = v\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8iw6qzy3_test.go:16:5: last declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    prev :=\
    \ l[0]\n    for _, v := range l[1:] {\n        if v < prev {\n            return\
    \ false\n        }\n        prev = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpoa7a1_l0_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpoa7a1_l0_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    s := 0\n\
    \    t := 0\n    for _, v := range l {\n        if s > v {\n            s = v\n\
    \        }\n        if t < v {\n            t = v\n        }\n    }\n    if t\
    \ > s {\n        return false\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpbswterif_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpbswterif_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpbswterif_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpbswterif_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpbswterif_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__7 (0.00s)\n        tmpbswterif_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    left :=\
    \ l[0]\n    right := l[len(l)-1]\n    for i := 0; i < len(l); i++ {\n        if\
    \ left > l[i+1] || right < l[i] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\npanic: runtime error: index out of range\
    \ [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4]\
    \ with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.monotonic(...)\n\t/tmp/tmpbiidauok_test.go:22\n\
    command-line-arguments_test.TestMonotonic(0x0?)\n\t/tmp/tmpbiidauok_test.go:36\
    \ +0x7c6\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n\n    min\
    \ := l[0]\n    max := l[0]\n\n    for _, v := range l {\n        if min > v {\n\
    \            min = v\n        }\n\n        if max < v {\n            max = v\n\
    \        }\n    }\n\n    if min >= max {\n        return true\n    }\n\n    return\
    \ false\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpgtrvfjcd_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpgtrvfjcd_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpgtrvfjcd_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpgtrvfjcd_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpgtrvfjcd_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 2
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 1 {\n        return true\n    }\n    // The\
    \ first element is the smallest\n    sml := l[0]\n    r := []int{}\n    for _,\
    \ v := range l {\n        if v < smv {\n            r = append(r, smv)\n     \
    \       smv = v\n        } else {\n            smv = v\n        }\n    }\n   \
    \ // If the smallest is larger than the second, then we know that they're not\
    \ monotonic\n    if sml > smv {\n        return false\n    }\n    // If the smallest\
    \ is smaller than the second, then we know that they're not monotonic\n    return\
    \ true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzz64bym_test.go:23:16: undefined: smv

    /tmp/tmphzz64bym_test.go:24:27: undefined: smv

    /tmp/tmphzz64bym_test.go:25:13: undefined: smv

    /tmp/tmphzz64bym_test.go:27:13: undefined: smv

    /tmp/tmphzz64bym_test.go:31:14: undefined: smv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    // This algorithm returns true if a sequence is monotonically\
    \ increasing or decreasing.\n    // A list with decreasing elements is monotonically\
    \ increasing. A list with non-decreasing elements\n    // is monotonically decreasing.\
    \ A list with increasing elements is monotonically decreasing.\n    //\n    //\
    \ The algorithm takes the first element as the start point. It then continues\
    \ iterating through the\n    // list until it reaches a point where it stops decreasing.\
    \ This point is the current index where the\n    // current element will stop\
    \ decreasing.\n    //\n    // If at any point the value of the current element\
    \ decreases, then the algorithm will stop\n    // iterating through the list as\
    \ long as the value of the next element is greater than the current element.\n\
    \    // If the value of the next element does not decrease, then the algorithm\
    \ will stop iterating through the\n    // list.\n    //\n    // If the next element\
    \ does not increase the value of the current element, then the algorithm will\n\
    \    // stop iterating through the list as soon as it reaches the end of the list.\n\
    \    //\n    // If the next element does increase the value of the current element,\
    \ then the algorithm will continue\n    // iterating through the list starting\
    \ at the current index to see if there are any elements that do not\n    // increase\
    \ the value of the current element.\n    //\n    // As a result, if the list does\
    \ not increase monotonically, then the list itself is monotonically\n    // increasing.\n\
    \    //\n    // As an example: if the list has decreasing elements [1, 20, 4,\
    \ 10], the algorithm will go through\n    // the list until it reaches the index\
    \ where 20 is less than the value of the current element. At this\n    // point\
    \ 20 is the current index, at which we stop the decreasing iteration of the list.\
    \ So our list\n    // is monotonically increasing.\n\n    // Get the first element,\
    \ which is the start point\n    start := l[0]\n\n    // Iterate through the list\
    \ to see if there are any elements that are greater than the current element\n\
    \    for i := 0; i < len(l); i++ {\n        if l[i] > start {\n            return\
    \ false\n        }\n        start = l[i]\n    }\n\n    return true\n}\n\nfunc\
    \ TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual:\
    \ candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1,\
    \ 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}),\
    \ expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true\
    \ },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n\
    \     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     {\
    \ actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmpq69l1dye_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmpq69l1dye_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmpq69l1dye_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    last :=\
    \ l[0]\n    for _, v := range l[1:] {\n        if last > v {\n            return\
    \ false\n        }\n        last = v\n    }\n    return true\n}\n\nfunc TestMonotonic(t\
    \ *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1,\
    \ 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}),\
    \ expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected:\
    \ true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n  \
    \   { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual:\
    \ candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmpnxq0u5ql_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmpnxq0u5ql_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074957
- exit_code: 1
  program: "package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Return true is list elements are monotonically increasing or decreasing.\n\
    // >>> monotonic([]int{1, 2, 4, 20})\n// true\n// >>> monotonic([]int{1, 20, 4,\
    \ 10})\n// false\n// >>> monotonic([]int{4, 1, 0, -10})\n// true\nfunc monotonic(l\
    \ []int) bool {\n    if len(l) <= 0 {\n        return false\n    }\n    n := len(l)\n\
    \    i := 0\n    last := l[n-1]\n    for i < n {\n        if l[i] < last {\n \
    \           return false\n        }\n        last = l[i]\n        i += 1\n   \
    \ }\n    return true\n}\n\nfunc TestMonotonic(t *testing.T) {\n  candidate :=\
    \ monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected:\
    \ true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n \
    \    { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual:\
    \ candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4,\
    \ 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5,\
    \ 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}),\
    \ expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMonotonic (0.00s)\n    --- FAIL: TestMonotonic/test_num__0\
    \ (0.00s)\n        tmp74t20py3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__1 (0.00s)\n        tmp74t20py3_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__3\
    \ (0.00s)\n        tmp74t20py3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMonotonic/test_num__4 (0.00s)\n        tmp74t20py3_test.go:52:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMonotonic/test_num__6\
    \ (0.00s)\n        tmp74t20py3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074957
