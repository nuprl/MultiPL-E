language: go_test.go
name: HumanEval_20_find_closest_elements
results:
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // Sort by distance\n    sort.Float64s(numbers)\n\n    // Find first\
    \ two closest.\n    index := 0\n    if numbers[index] < numbers[index+1] {\n \
    \       index++\n    }\n\n    var closest float64\n    var closee1 float64\n \
    \   var closee2 float64\n    var dist1 float64\n    var dist2 float64\n    var\
    \ distanceSquared1 float64\n    var distanceSquared2 float64\n\n    for index\
    \ != len(numbers)-1 {\n        closee1 = numbers[index]\n        closee2 = numbers[index+1]\n\
    \n        // Compute the distance\n        dist1 = math.Pow(closee1-closee2, 2)\n\
    \        dist2 = math.Pow(numbers[index], 2)+math.Pow(numbers[index+1], 2)\n\n\
    \        // If the distance is less than the previous smallest\n        // then\
    \ that is the new smallest value.\n        if dist1 < distanceSquared1 {\n   \
    \         closest = closee1\n            distanceSquared1 = dist1\n        }\n\
    \n        // If the distance is greater than the next smallest\n        // then\
    \ that is the new smallest value.\n        if dist2 < distanceSquared2 {\n   \
    \         closest = closee2\n            distanceSquared2 = dist2\n        }\n\
    \n        index++\n    }\n\n    // Return them in order.\n    return []interface{}{closest,\
    \ closest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsldb3fb9_test.go:20:5: undefined: sort

    /tmp/tmpsldb3fb9_test.go:41:17: undefined: math

    /tmp/tmpsldb3fb9_test.go:42:17: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, smallest := numbers[0], numbers[0]\n\
    \    largest, largest = numbers[0], numbers[0]\n\n    for _, number := range numbers\
    \ {\n        if smallest-number > 0 {\n            smallest, largest = number,\
    \ number\n        }\n    }\n\n    return []interface{}{smallest, largest}\n}\n\
    \nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkis8lbqs_test.go:15:15: smallest repeated on left side of :=

    /tmp/tmpkis8lbqs_test.go:16:5: undefined: largest

    /tmp/tmpkis8lbqs_test.go:20:23: undefined: largest

    /tmp/tmpkis8lbqs_test.go:24:36: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) <= 1 {\n        return numbers\n\
    \    }\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, num\
    \ := range numbers[1:] {\n        if num < smallest {\n            smallest =\
    \ num\n        }\n        if num > largest {\n            largest = num\n    \
    \    }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz7yt8vz4_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    numbers1 := numbers[0:len(numbers)-1]\n    numbers2 := numbers[len(numbers)-1]\n\
    \    diff := abs(numbers1 - numbers2)\n    index := 1\n    closest := numbers1\n\
    \    for diff > 0 {\n        if numbers1[index] > numbers2[index] {\n        \
    \    diff -= 1\n        } else {\n            diff += 1 \n        }\n        if\
    \ diff == 0 {\n            return []interface{}{closest[index], numbers[index]}\n\
    \        }\n        index += 1\n    }\n    return []interface{}{closest[index],\
    \ numbers[index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnof4d6xy_test.go:20:13: undefined: abs

    /tmp/tmpnof4d6xy_test.go:20:17: invalid operation: numbers1 - numbers2 (mismatched
    types []float64 and float64)

    /tmp/tmpnof4d6xy_test.go:24:38: invalid operation: cannot index numbers2 (variable
    of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074843
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Get first two numbers in the list that are\
    \ closest\n    smallest := numbers[0]\n    second := numbers[1]\n    minimum :=\
    \ &numbers[0]\n    for _, number := range numbers[2:] {\n        if smallest >\
    \ number {\n            smallest = number\n        } else if smallest == number\
    \ {\n            // If the numbers are equal we check which number is smaller\n\
    \            if second < number {\n                second = number\n         \
    \   } else {\n                second = minimum\n                minimum = &number\n\
    \            }\n        } else {\n            // If the numbers are not equal\
    \ we check which one is closer\n            smallest := number\n            second\
    \ := number\n            minimum := &number\n        }\n    }\n    // Return the\
    \ numbers in order (smallest first, largest last)\n    return []interface{}{smallest,\
    \ minimum, second}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2d03kgin_test.go:27:26: cannot use minimum (variable of type *float64)
    as type float64 in assignment

    /tmp/tmp2d03kgin_test.go:32:13: smallest declared but not used

    /tmp/tmp2d03kgin_test.go:33:13: second declared but not used

    /tmp/tmp2d03kgin_test.go:34:13: minimum declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the minimum and maximum for the supplied\
    \ list of numbers.\n    numbers := make([]float64, len(numbers))\n    for i, v\
    \ := range numbers {\n        numbers[i] = v\n    }\n    min := numbers[0]\n \
    \   max := numbers[0]\n    for _, v := range numbers {\n        if min > v {\n\
    \            min = v\n        }\n        if max < v {\n            max = v\n \
    \       }\n    }\n    // Find the closest two numbers to each other.\n    result\
    \ := make([]interface{}, 0)\n    distance := float64(math.Abs(min - max))\n  \
    \  diff := max - min\n    for _, v := range numbers {\n        if v == max ||\
    \ v == min {\n            continue\n        }\n        if diff > float64(math.Abs(v\
    \ - min)) {\n            diff = float64(math.Abs(v - min))\n        }\n      \
    \  if diff < float64(math.Abs(v - max)) {\n            diff = float64(math.Abs(v\
    \ - max))\n        }\n        distance -= diff\n        if distance < float64(0)\
    \ {\n            distance = float64(0)\n        }\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnwwgc69_test.go:16:13: no new variables on left side of :=

    /tmp/tmpfnwwgc69_test.go:32:25: undefined: math

    /tmp/tmpfnwwgc69_test.go:38:27: undefined: math

    /tmp/tmpfnwwgc69_test.go:39:28: undefined: math

    /tmp/tmpfnwwgc69_test.go:41:27: undefined: math

    /tmp/tmpfnwwgc69_test.go:42:28: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    \n    if len(numbers) < 2 {\n        return\
    \ numbers\n    }\n\n    // Find smallest element\n    smallest := numbers[0]\n\
    \    smallest := numbers[0]\n    for _, num := range numbers {\n        if smallest\
    \ > num {\n            smallest = num\n        }\n    }\n\n    // Remove smallest\
    \ element from array\n    numbers := []float64{}\n    for _, num := range numbers\
    \ {\n        if num != smallest {\n            numbers = append(numbers, num)\n\
    \        }\n    }\n\n    // Find largest element\n    largest := numbers[0]\n\
    \    for _, num := range numbers {\n        if largest < num {\n            largest\
    \ = num\n        }\n    }\n\n    // Remove largest element from array\n    numbers\
    \ = nil\n    for _, num := range numbers {\n        if num != largest {\n    \
    \        numbers = append(numbers, num)\n        }\n    }\n\n    return numbers\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphnu5eqm3_test.go:17:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmphnu5eqm3_test.go:22:14: no new variables on left side of :=

    /tmp/tmphnu5eqm3_test.go:30:13: no new variables on left side of :=

    /tmp/tmphnu5eqm3_test.go:53:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    var result []interface{}\n    var smallestDiff = math.MaxFloat64\n\
    \    var smallestValue float64\n    for i := 0; i < len(numbers); i++ {\n    \
    \    var diff float64\n        if smallestValue == numbers[i] {\n            continue\n\
    \        }\n        diff = math.Abs(numbers[i] - smallestValue)\n        if diff\
    \ < smallestDiff {\n            smallestDiff = diff\n            smallestValue\
    \ = numbers[i]\n            result = append(result, smallestValue)\n        }\
    \ else {\n            diff = math.Abs(smallestValue - numbers[i])\n          \
    \  if diff < smallestDiff {\n                smallestDiff = diff\n           \
    \     smallestValue = numbers[i]\n                result = append(result, smallestValue)\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjalbo3b6_test.go:19:24: undefined: math

    /tmp/tmpjalbo3b6_test.go:26:16: undefined: math

    /tmp/tmpjalbo3b6_test.go:32:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var smallest []float64\n    var largest []float64\n\
    \    var second []float64\n    for _, num := range numbers {\n        if smallest\
    \ == nil {\n            smallest = append(smallest, num)\n            second=append(second,num)\n\
    \        }\n        if largest==nil{\n            largest = append(largest, num)\n\
    \        }\n        if num < smallest[0] {\n            second=append(second,\
    \ smallest[0])\n            smallest=append(smallest, num)\n        }\n      \
    \  if num > largest[1]{\n            second=append(second, largest[1])\n     \
    \       largest=append(largest, num)\n        }\n    }\n    if smallest == nil\
    \ {\n        second=append(second, largest[1])\n        largest=append(largest,\
    \ largest[1])\n    }\n    if smallest == nil {\n        smallest = append(smallest,\
    \ largest[0])\n        second=append(second, smallest[0])\n    }\n    if smallest\
    \ == nil {\n        return second\n    }\n    return second\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp09neiq6n_test.go:44:16: cannot use second (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmp09neiq6n_test.go:46:12: cannot use second (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Loop through the supplied list of numbers,\
    \ finding two numbers that have the smallest absolute difference.\n    // If they\
    \ have equal differences then return both.\n    var smallest_difference_ind int\n\
    \    var smallest float64\n    var second_smallest float64\n    for i := 0; i\
    \ < len(numbers); i++ {\n        if numbers[i] == numbers[0] {\n            continue\n\
    \        }\n        diff := float64(numbers[i] - numbers[0])\n        if diff\
    \ < 0 {\n            diff *= -1\n        }\n        if diff < smallest_difference\
    \ {\n            smallest_difference = diff\n            smallest_difference_ind\
    \ = i\n        }\n    }\n    // If no difference was found then return nil\n \
    \   if smallest_difference_ind == -1 {\n        return nil\n    }\n    // Return\
    \ an array with two values.\n    return []interface{}{numbers[smallest_difference_ind],\
    \ numbers[smallest_difference_ind + 1]}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp76c7oyh5_test.go:18:9: smallest declared but not used

    /tmp/tmp76c7oyh5_test.go:19:9: second_smallest declared but not used

    /tmp/tmp76c7oyh5_test.go:28:19: undefined: smallest_difference

    /tmp/tmp76c7oyh5_test.go:29:13: undefined: smallest_difference

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    diff := map[float64]float64{numbers[0]: math.Abs(numbers[0])}\n\
    \    for _, n := range numbers[1:] {\n        diff [n] = math.Abs(diff[n]) + math.Abs(n\
    \ - numbers[0])\n    }\n\n    min := numbers[0]\n    max := numbers[0]\n    for\
    \ _, v := range diff {\n        if min > v {\n            min = v\n        }\n\
    \        if max < v {\n            max = v\n        }\n    }\n\n    return []interface{}{min,\
    \ max}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgofiaft_test.go:19:45: undefined: math

    /tmp/tmprgofiaft_test.go:21:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    result := make([]interface{}, len(numbers))\n\
    \    for i, number1 := range numbers {\n        distance := find_closest_distance(numbers)\n\
    \        result[i] = numbers[distance]\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpia9_laa9_test.go:16:12: number1 declared but not used

    /tmp/tmpia9_laa9_test.go:17:21: undefined: find_closest_distance

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    distances := make([]float64, len(numbers))\n    for i, x := range\
    \ numbers {\n        distances[i] = math.Abs(x - numbers[0])\n    }\n\n    i :=\
    \ 0\n    for {\n        i := i\n        for ; i < len(numbers); i++ {\n      \
    \      if distances[i] < distances[i-1] {\n                break\n           \
    \ }\n        }\n\n        if i == len(numbers) {\n            break\n        }\n\
    \n        distances[i-1] = distances[i]\n    }\n\n    return numbers[i:]\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_f4035ss_test.go:21:24: undefined: math

    /tmp/tmp_f4035ss_test.go:40:19: cannot use numbers[i:] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    length := len(numbers)\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    if length == 0 {\n        return []interface{}{}\n\
    \    }\n    if length == 1 {\n        return numbers\n    }\n\n    for index :=\
    \ 1; index < length; index++ {\n        if numbers[index] < smallest {\n     \
    \       smallest = numbers[index]\n        }\n        if numbers[index] > largest\
    \ {\n            largest = numbers[index]\n        }\n    }\n\n    smallestIndex\
    \ := length\n    for index := 0; index < length; index++ {\n        if numbers[index]\
    \ == smallest {\n            smallestIndex = index\n            break\n      \
    \  }\n    }\n\n    largestIndex := 0\n    for index := 0; index < length; index++\
    \ {\n        if numbers[index] == largest {\n            largestIndex = index\n\
    \            break\n        }\n    }\n\n    return []interface{}{numbers[smallestIndex],\
    \ numbers[largestIndex]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdmlvne1_test.go:22:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n    \n    // Assume that the numbers are in order\n    smallestNumber\
    \ := numbers[0]\n    largestNumber := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number < smallestNumber {\n            smallestNumber = number\n\
    \        }\n        if number > largestNumber {\n            largestNumber = number\n\
    \        }\n    }\n    \n    return []interface{}{smallestNumber, largestNumber}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph95akb4l_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    \n    var a float64\n    var b float64\n    \n    first := numbers[0]\n\
    \    second := numbers[1]\n    \n    found := false\n    for i := range numbers\
    \ {\n        if found {\n            break\n        }\n        \n        a = numbers[i]\n\
    \        b = numbers[len(numbers)-1]\n        \n        if abs(a-b) < 0.000001\
    \ {\n            found = true\n        }\n        \n        if a < second {\n\
    \            second = a\n        } else {\n            second = b\n        }\n\
    \    }\n    \n    output := []interface{}{first, second}\n    \n    return output\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx5l2g13w_test.go:34:12: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    numbers := make([]float64, len(numbers))\n    copy(numbers, numbers)\n\
    \n    diff := numbers[len(numbers)-1] - numbers[0]\n    for i := len(numbers)\
    \ - 2; i > 0; i-- {\n        diff += numbers[i] - numbers[i-1]\n        numbers[i]\
    \ = numbers[i-1]\n        if diff < numbers[i] && numbers[i] < numbers[i+1] {\n\
    \            return append([]interface{}{numbers[i], numbers[i+1]}, numbers[0:i+2])\n\
    \        }\n    }\n    return numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7zu_6e39_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmp7zu_6e39_test.go:19:13: no new variables on left side of :=

    /tmp/tmp7zu_6e39_test.go:30:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074843
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallest, _ := findClosest(numbers, numbers[1])\n    largest, _ :=\
    \ findClosest(numbers, numbers[0])\n\n    return []interface{}{smallest, largest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphqt9df26_test.go:18:20: undefined: findClosest

    /tmp/tmphqt9df26_test.go:19:19: undefined: findClosest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest []interface{}\n    sorted_numbers\
    \ := make([]float64, len(numbers))\n    sorted_numbers = sort_numbers_ascending(numbers)\n\
    \n    // The closest is set to this number.\n    smallest := sorted_numbers[0]\n\
    \n    // Search from smallest to largest.\n    for i := 1; i < len(sorted_numbers);\
    \ i++ {\n        if math.Abs(sorted_numbers[i]-smallest) < math.Abs(sorted_numbers[i]-closest[0])\
    \ {\n            closest = sorted_numbers[i:]\n        }\n    }\n    return closest\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprbyja57a_test.go:17:22: undefined: sort_numbers_ascending

    /tmp/tmprbyja57a_test.go:24:12: undefined: math

    /tmp/tmprbyja57a_test.go:24:60: invalid operation: sorted_numbers[i] - closest[0]
    (mismatched types float64 and interface{})

    /tmp/tmprbyja57a_test.go:25:37: cannot use sorted_numbers[i:] (value of type []float64)
    as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range\
    \ numbers[1:] {\n        if number > max {\n            max = number\n       \
    \ } else if number < min {\n            min = number\n        }\n    }\n    return\
    \ []interface{}{min, max}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpp31qevdt_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpp31qevdt_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpp31qevdt_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpp31qevdt_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpp31qevdt_test.go:47: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074843
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    diff := math.Inf(1)\n    // initialize first\
    \ element to the first number in the list\n    firstNumber := numbers[0]\n   \
    \ secondNumber := numbers[0]\n    smallest := numbers[0]\n    larger := numbers[0]\n\
    \    // iterate over the rest of the list\n    for _, number := range numbers[1:]\
    \ {\n        // calculate difference between current number and the smallest element\
    \ in the list\n        diff := math.Abs(number - firstNumber)\n        if diff\
    \ < smallest {\n            smallest = diff\n        }\n        // calculate difference\
    \ between current number and the largest element in the list\n        diff = math.Abs(number\
    \ - secondNumber)\n        if diff > largest {\n            largest = diff\n \
    \       }\n        // update the smallest and largest numbers as necessary\n \
    \       if smallest < diff {\n            secondNumber = number\n        } else\
    \ if largest > diff {\n            firstNumber = number\n        } else {\n  \
    \          firstNumber = number\n            secondNumber = number\n        }\n\
    \    }\n    return []interface{}{firstNumber, secondNumber}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjay79axz_test.go:15:13: undefined: math

    /tmp/tmpjay79axz_test.go:20:5: larger declared but not used

    /tmp/tmpjay79axz_test.go:24:17: undefined: math

    /tmp/tmpjay79axz_test.go:29:16: undefined: math

    /tmp/tmpjay79axz_test.go:30:19: undefined: largest

    /tmp/tmpjay79axz_test.go:31:13: undefined: largest

    /tmp/tmpjay79axz_test.go:36:19: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n    i := 0\n\
    \    closestElements := make([]interface{}, 2)\n    for index < len(numbers) {\n\
    \        number := numbers[index]\n        // Stop if we've got the two numbers\
    \ we're looking for\n        if index == 0 {\n            return closestElements\n\
    \        }\n        if number == numbers[i] {\n            i += 1 // Same number\
    \ as previous\n            continue\n        }\n        if number < numbers[i]\
    \ {\n            closestElements[0] = number\n            closestElements[1] =\
    \ numbers[i]\n            i += 1 // New number found, can stop now\n        }\
    \ else if number > numbers[i] {\n            closestElements[0] = numbers[i]\n\
    \            closestElements[1] = number\n            i += 1 // New number found,\
    \ can stop now\n        }\n    }\n    return closestElements\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5s0931vt_test.go:18:5: undefined: sort

    /tmp/tmp5s0931vt_test.go:21:9: undefined: index

    /tmp/tmp5s0931vt_test.go:22:27: undefined: index

    /tmp/tmp5s0931vt_test.go:24:12: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074842
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closests []interface{}\n    var closest\
    \ float64\n    var smallest float64\n    for _, number := range numbers {\n  \
    \      smallest = number\n        closest = number\n        for _, otherNumber\
    \ := range numbers {\n            if number < otherNumber {\n                if\
    \ smallest > otherNumber {\n                    closest = otherNumber\n      \
    \          }\n                smallest = number\n            }\n        }\n  \
    \      closests = append(closests, closest)\n    }\n    return closests\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmphgnn09oe_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2) %!s(float64=3.9) %!s(float64=4) %!s(float64=5)\
    \ %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n\
    \        tmphgnn09oe_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=2) %!s(float64=5.9) %!s(float64=4) %!s(float64=5)]'\n\
    \    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmphgnn09oe_test.go:51:\
    \ expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2)\
    \ %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL:\
    \ TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmphgnn09oe_test.go:51:\
    \ expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)\
    \ %!s(float64=3) %!s(float64=4) %!s(float64=5) %!s(float64=2)]'\n    --- FAIL:\
    \ TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmphgnn09oe_test.go:51:\
    \ expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)\
    \ %!s(float64=3.1) %!s(float64=4.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074843
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    biggest := numbers[0]\n    for i, value\
    \ := range numbers {\n        if value < smallest {\n            smallest = value\n\
    \        }\n        if value > biggest {\n            biggest = value\n      \
    \  }\n    }\n    numbers = make([]float64, 0, len(numbers))\n    for i, value\
    \ := range numbers {\n        if i < len(numbers) {\n            numbers = append(numbers,\
    \ value)\n        }\n    }\n    numbers.Sort()\n    smallest := numbers[0]\n \
    \   biggest := numbers[0]\n    for i, value := range numbers {\n        if value\
    \ < smallest {\n            smallest = value\n        }\n        if value > biggest\
    \ {\n            biggest = value\n        }\n    }\n    return []interface{}{smallest,\
    \ biggest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_2tyjerv_test.go:20:9: i declared but not used

    /tmp/tmp_2tyjerv_test.go:34:13: numbers.Sort undefined (type []float64 has no
    field or method Sort)

    /tmp/tmp_2tyjerv_test.go:35:14: no new variables on left side of :=

    /tmp/tmp_2tyjerv_test.go:36:13: no new variables on left side of :=

    /tmp/tmp_2tyjerv_test.go:37:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallestNum := numbers[0]\n    largestNum := numbers[len(numbers)-1]\n\
    \    index := 0\n    found := false\n    for index < len(numbers)-1 {\n      \
    \  if numbers[index] >= largestNum {\n            found = true\n            break\n\
    \        }\n        if numbers[index] < smallestNum {\n            found = true\n\
    \            break\n        }\n        if numbers[index] == smallestNum {\n  \
    \          largestNum = numbers[index]\n        }\n        if numbers[index] ==\
    \ largestNum {\n            smallestNum = numbers[index]\n        }\n        index++\n\
    \    }\n    result := make([]interface{}, 2)\n    result[0] = smallestNum\n  \
    \  result[1] = largestNum\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyvlmpsr6_test.go:21:5: found declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers := numbers[:0]\n    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n    smallest := numbers[0]\n    biggest\
    \ := numbers[0]\n    for _, number := range numbers[1:] {\n        if number <\
    \ smallest {\n            smallest = number\n        }\n        if number > biggest\
    \ {\n            biggest = number\n        }\n        numbers = append(numbers,\
    \ number)\n    }\n    return numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqoexm5zr_test.go:15:13: no new variables on left side of :=

    /tmp/tmpqoexm5zr_test.go:17:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpqoexm5zr_test.go:30:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the two closest numbers and return them\
    \ in order (smaller number, larger number).\n    if len(numbers) < 2 {\n     \
    \   return nil\n    }\n\n    // Find the smallest and largest numbers in the list.\n\
    \    smallest, _ := numbers[0], numbers[0]\n    largest, _ := numbers[0], numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n        }\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n    }\n\n    // Build the resulting\
    \ list.\n    result := make([]interface{}, 2)\n    result[0] = smallest\n    result[1]\
    \ = largest\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpu504x53l_test.go:56: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpu504x53l_test.go:56: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpu504x53l_test.go:56: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpu504x53l_test.go:56: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpu504x53l_test.go:56: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074846
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    numbers := make([]float64, len(numbers))\n    for i, number := range\
    \ numbers {\n        numbers[i] = number\n    }\n\n    sort.Float64s(numbers)\n\
    \n    i := 0\n    j = 1\n    if numbers[i-1] < numbers[j] {\n        i = i - 1\n\
    \    }\n\n    if numbers[i-1] > numbers[j] {\n        j = j + 1\n    }\n\n   \
    \ return []interface{}{numbers[i], numbers[j]}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvhyrtovv_test.go:19:13: no new variables on left side of :=

    /tmp/tmpvhyrtovv_test.go:24:5: undefined: sort

    /tmp/tmpvhyrtovv_test.go:27:5: undefined: j

    /tmp/tmpvhyrtovv_test.go:28:31: undefined: j

    /tmp/tmpvhyrtovv_test.go:32:31: undefined: j

    /tmp/tmpvhyrtovv_test.go:33:13: undefined: j

    /tmp/tmpvhyrtovv_test.go:36:46: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    diff := numbers[len(numbers)-1] - numbers[0]\n    sort.Float64s(numbers)\n\
    \n    if len(numbers) > 2 {\n        return numbers[:2]\n    }\n\n    return []interface{}{numbers[0],\
    \ numbers[0] + diff}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfijhuo9h_test.go:20:5: undefined: sort

    /tmp/tmpfijhuo9h_test.go:23:23: cannot use numbers[:2] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallestNumberIndex := sort.Search(len(numbers),\
    \ func(i int) bool { return numbers[i] < numbers[i+1] })\n    closestNumberIndex\
    \ := smallestNumberIndex\n    if smallestNumberIndex == len(numbers)-1 {\n   \
    \     closestNumberIndex--\n    }\n    return append(numbers[smallestNumberIndex:closestNumberIndex+1:],\
    \ numbers[:smallestNumberIndex])\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpysroayl5_test.go:20:67: 3rd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074844
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) <= 2 {\n        return nil\n\
    \    }\n    var closest1, closest2 float64\n    var closest1Index, closest2Index\
    \ int\n    for i := 0; i < len(numbers); i++ {\n        closest1Index = i\n  \
    \      closest1 = numbers[i]\n        if i == 0 {\n            continue\n    \
    \    }\n        for j := 1; j < i; j++ {\n            closest2Index = j\n    \
    \        closest2 = numbers[j]\n            if closest1 < closest2 {\n       \
    \         var temp float64\n                if closest1 < closest2 {\n       \
    \             temp = closest1\n                    closest1 = closest2\n     \
    \               closest2 = temp\n                }\n                if closest1\
    \ < numbers[j] {\n                    closest1 = numbers[j]\n                }\n\
    \                if closest2 < numbers[j] {\n                    closest2 = numbers[j]\n\
    \                }\n                if closest1 < closest2 {\n               \
    \     closest1, closest2 = closest2, closest1\n                }\n           \
    \     if closest2 < closest1 {\n                    closest2, closest1 = closest1,\
    \ closest2\n                }\n                if closest1 == closest2 {\n   \
    \                 continue\n                }\n            }\n            break\n\
    \        }\n    }\n    return []interface{}{closest1, closest2}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxt2bhm6p_test.go:19:9: closest1Index declared but not used

    /tmp/tmpxt2bhm6p_test.go:19:24: closest2Index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil {\n        return nil\n  \
    \  }\n    numbers := make([]interface{}, len(numbers))\n    if len(numbers) <\
    \ 2 {\n        return numbers\n    }\n    numbers := append(numbers, numbers[0])\n\
    \    result := make([]interface{}, len(numbers))\n    for i := 1; i < len(numbers);\
    \ i++ {\n        result[0] = numbers[0]\n        result[1] = numbers[i]\n    \
    \    result := findClosest(&numbers, &result)\n        if result == nil {\n  \
    \          return nil\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplfi_vvob_test.go:18:13: no new variables on left side of :=

    /tmp/tmplfi_vvob_test.go:18:16: cannot use make([]interface{}, len(numbers)) (value
    of type []interface{}) as type []float64 in assignment

    /tmp/tmplfi_vvob_test.go:20:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmplfi_vvob_test.go:22:13: no new variables on left side of :=

    /tmp/tmplfi_vvob_test.go:27:19: undefined: findClosest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    min := numbers[0]\n    max := numbers[len(numbers)-1]\n\n    //\
    \ For each number in the array ...\n    for _, n := range numbers {\n        //\
    \ ... calculate its square ...\n        squared := n * n\n\n        // ... and\
    \ find the closest number ...\n        delta := squared - min\n\n        if delta\
    \ < 0 {\n            delta = -delta\n        }\n        if delta < 1 {\n     \
    \       continue\n        }\n        if delta > 0 {\n            delta = 1\n \
    \       }\n\n        // ... that is greater than the given max ...\n        if\
    \ delta > max {\n            return nil\n        }\n\n        // ... and less\
    \ than the given min ...\n        if delta < min {\n            min = n\n    \
    \    }\n    }\n\n    return []interface{}{min, max}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpfqu_goqi_test.go:71: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpfqu_goqi_test.go:71: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpfqu_goqi_test.go:71: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpfqu_goqi_test.go:71: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpfqu_goqi_test.go:71: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=5.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074846
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) <= 1 {\n        return numbers\n\
    \    }\n    var low = numbers[0]\n    var high = numbers[0]\n    for _, number\
    \ := range numbers[1:] {\n        if number < low {\n            low = number\n\
    \        } else if number > high {\n            high = number\n        }\n   \
    \ }\n    return []interface{}{low, high}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgr8tdn0j_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest []float64\n    var first float64\n\
    \    var second float64\n    close := 0.0\n\n    for _, num := range numbers {\n\
    \        delta = abs(num - first)\n        if delta < close {\n            close\
    \ = delta\n            closest = []float64{first, second}\n        }\n       \
    \ delta = abs(num - second)\n        if delta < close {\n            close = delta\n\
    \            closest = []float64{second, first}\n        }\n        first = num\n\
    \    }\n    return closest\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkeemlod6_test.go:21:9: undefined: delta

    /tmp/tmpkeemlod6_test.go:21:17: undefined: abs

    /tmp/tmpkeemlod6_test.go:22:12: undefined: delta

    /tmp/tmpkeemlod6_test.go:23:21: undefined: delta

    /tmp/tmpkeemlod6_test.go:26:9: undefined: delta

    /tmp/tmpkeemlod6_test.go:26:17: undefined: abs

    /tmp/tmpkeemlod6_test.go:27:12: undefined: delta

    /tmp/tmpkeemlod6_test.go:28:21: undefined: delta

    /tmp/tmpkeemlod6_test.go:33:12: cannot use closest (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    smallest := numbers[0]\n    biggest := numbers[len(numbers)-1]\n\
    \n    diff := biggest - smallest\n    i := 0\n    for len(numbers) > 0 {\n   \
    \     smallest2 := numbers[i]\n        biggest2 := numbers[len(numbers)-1]\n\n\
    \        diff2 := biggest2 - smallest2\n        if diff2 == diff {\n         \
    \   if diff < 0 {\n                return nil\n            }\n            return\
    \ []interface{}{smallest2, biggest2}\n        }\n\n        if diff > diff2 {\n\
    \            i, diff = i, diff2\n        } else {\n            i, diff = 0, len(numbers)\n\
    \        }\n    }\n\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprg0n6zns_test.go:39:26: cannot use len(numbers) (value of type int) as
    type float64 in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // If there are only two numbers, there's nothing\
    \ to do.\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n\
    \    smallestNum := numbers[0]\n    smallestNumIndex := 0\n    biggestNum := numbers[0]\n\
    \    biggestNumIndex := 0\n\n    for i := 1; i < len(numbers); i++ {\n       \
    \ // if either of these is less than our smallest number, replace it\n       \
    \ if numbers[i] < smallestNum {\n            smallestNum = numbers[i]\n      \
    \      smallestNumIndex = i\n        }\n        // otherwise check if it is larger\
    \ than our biggest number\n        if numbers[i] > biggestNum {\n            biggestNum\
    \ = numbers[i]\n            biggestNumIndex = i\n        }\n    }\n\n    result\
    \ := []interface{}{}\n\n    // If the smallest number is the largest number then\
    \ we're done!\n    if smallestNum == biggestNum {\n        result = []interface{}{smallestNum,\
    \ smallestNum}\n        return result\n    }\n\n    // Find the two biggest numbers\
    \ that are less than or equal to our smallest number\n    biggestNumsLessThanOrEqualToSmallestNumber\
    \ := []float64{}\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ >= smallestNum {\n            if numbers[i] > biggestNum {\n               \
    \ biggestNum = numbers[i]\n                biggestNumIndex = i\n            }\n\
    \        } else if numbers[i] <= smallestNum {\n            if numbers[i] < biggestNum\
    \ {\n                biggestNum = numbers[i]\n                biggestNumIndex\
    \ = i\n            }\n        }\n    }\n\n    // If there isn't any big numbers\
    \ that are less than or equal to the smallest number, return the biggest\n   \
    \ // number and the smallest number in order (smallest, largest)\n    if len(biggestNumsLessThanOrEqualToSmallestNumber)\
    \ == 0 {\n        result = []interface{}{biggestNum, biggestNum}\n        return\
    \ result\n    }\n\n    // We want to find the closest biggest number to the smaller\
    \ one (as close as possible)\n    closestBiggerThanTheBiggerNumber = biggestNum\n\
    \    closestLowerThanTheSmallerNumber = smallestNum\n\n    for i := 0; i < len(biggestNumsLessThanOrEqualToSmallestNumber);\
    \ i++ {\n        if biggestNumsLessThanOrEqualToSmallestNumber[i] < closestBiggerThanTheBiggerNumber\
    \ {\n            closestBiggerThanTheBiggerNumber = biggestNumsLessThanOrEqualToSmallestNumber[i]\n\
    \        } else if biggestNumsLessThanOrEqualToSmallestNumber[i] \nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9q907n9s_test.go:77:6: expected ''('', found TestFind_Closest_Elements

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074844
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallest_diff := math.Abs(numbers[0] - numbers[1])\n    smallest_index\
    \ := 0\n    second_index := 1\n    for second_index < len(numbers) {\n       \
    \ diff := math.Abs(numbers[second_index] - numbers[smallest_index])\n        if\
    \ diff < smallest_diff {\n            smallest_diff = diff\n            smallest_index\
    \ = second_index\n        } else {\n            second_index++\n        }\n  \
    \  }\n    return []interface{}{numbers[smallest_index], numbers[second_index]}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvahrx2mj_test.go:18:22: undefined: math

    /tmp/tmpvahrx2mj_test.go:22:17: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    closest1, closest2 := numbers[0], numbers[0]\n\
    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < closest1 {\n\
    \            closest1 = numbers[i]\n        }\n        if numbers[i] > closest2\
    \ {\n            closest2 = numbers[i]\n        }\n    }\n\n    return []interface{}{closest2,\
    \ closest1}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpbqoluo0__test.go:46: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpbqoluo0__test.go:46: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=5.9) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpbqoluo0__test.go:46: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpbqoluo0__test.go:46: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=5) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpbqoluo0__test.go:46: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=5.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074846
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    sorted := make([]interface{}, 0, len(numbers))\n\n    for i, number\
    \ := range numbers {\n        sorted = append(sorted, number)\n        if i ==\
    \ 0 {\n            continue\n        }\n        delta := numbers[i] - numbers[i\
    \ - 1]\n        if delta < 0 {\n            delta = -delta\n        }\n      \
    \  if delta > 0 {\n            sorted = append(sorted, numbers[i])\n         \
    \   sorted = append(sorted, numbers[i-1])\n            sorted = append(sorted,\
    \ sorted[0], sorted[-1])\n            break\n        }\n    }\n\n    return sorted\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplsaf4a4f_test.go:33:55: invalid argument: index -1 (constant of type int)
    must not be negative

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    numbers := make([]interface{}, 0, len(numbers))\n    first := numbers[0]\n\
    \    last := numbers[len(numbers)-1]\n    numbers = append(numbers, first)\n \
    \   for i := 1; i < len(numbers); i++ {\n        if numbers[i-1] <= last {\n \
    \           numbers = append(numbers, numbers[i])\n        }\n    }\n    return\
    \ numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_t4qzkmu_test.go:18:13: no new variables on left side of :=

    /tmp/tmp_t4qzkmu_test.go:18:16: cannot use make([]interface{}, 0, len(numbers))
    (value of type []interface{}) as type []float64 in assignment

    /tmp/tmp_t4qzkmu_test.go:27:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil || len(numbers) < 2 {\n  \
    \      return nil\n    }\n    smallestValue := numbers[0]\n    largestValue :=\
    \ numbers[0]\n    smallestIndex := 0\n    largestIndex := 0\n\n    for index :=\
    \ 1; index < len(numbers); index++ {\n        value := numbers[index]\n      \
    \  if value < smallestValue {\n            smallestValue = value\n           \
    \ smallestIndex = index\n        }\n\n        if value > largestValue {\n    \
    \        largestValue = value\n            largestIndex = index\n        }\n \
    \   }\n    return append([]interface{}{smallestValue, largestValue}, numbers[smallestIndex:largestIndex+1])\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpk7lkm9la_test.go:55: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5) [%!s(float64=1) %!s(float64=2) %!s(float64=3.9)\
    \ %!s(float64=4) %!s(float64=5)]]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpk7lkm9la_test.go:55: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9) [%!s(float64=1) %!s(float64=2) %!s(float64=5.9)]]'\n\
    \    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpk7lkm9la_test.go:55:\
    \ expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=5)\
    \ [%!s(float64=1) %!s(float64=2) %!s(float64=3) %!s(float64=4) %!s(float64=5)]]'\n\
    \    --- FAIL: TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpk7lkm9la_test.go:55:\
    \ expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=5)\
    \ [%!s(float64=1) %!s(float64=2) %!s(float64=3) %!s(float64=4) %!s(float64=5)]]'\n\
    \    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpk7lkm9la_test.go:55:\
    \ expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=5.1)\
    \ [%!s(float64=1.1) %!s(float64=2.2) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=5.1)]]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074846
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // If the array is of length 1, then there is nothing to be returned.\n\
    \    if len(numbers) == 1 {\n        return []interface{}{}\n    }\n\n    // If\
    \ the array contains only two element, then there is nothing to be returned.\n\
    \    if len(numbers) == 2 {\n        return numbers\n    }\n\n    // If the array\
    \ contains one element that is larger than the other, swap them.\n    if numbers[0]\
    \ > numbers[1] {\n        t := numbers[0]\n        numbers[0] = numbers[1]\n \
    \       numbers[1] = t\n    }\n\n    // Find smallest and largest numbers in the\
    \ array.\n    smallest := numbers[0]\n    largest := numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n           \
    \ smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        }\n    }\n\n    // If smallest and largest\
    \ are equal, there's nothing to be returned.\n    if smallest == largest {\n \
    \       return []interface{}{}\n    }\n\n    // If smallest is equal to largest,\
    \ swap them and find closest of largest.\n    if smallest == largest {\n     \
    \   if numbers[1] > numbers[0] {\n            t := numbers[1]\n            numbers[1]\
    \ = numbers[0]\n            numbers[0] = t\n        }\n\n        return numbers\n\
    \    }\n\n    // Find first and last number that don't fit the criteria for being\
    \ in order.\n    i, j := 0, 0\n    for i < len(numbers) && numbers[i] >= smallest\
    \ {\n        i++\n    }\n    j = len(numbers)\n    for j < i && numbers[j] <=\
    \ smallest {\n        j++\n    }\n\n    // If smallest is between first and last\
    \ number in array, then swap first and last and find closest of smallest.\n  \
    \  if j < i {\n        t := numbers[j]\n        numbers[j] = numbers[i]\n    \
    \    numbers[i] = t\n    }\n\n    return find_closest_elements(numbers[i:j])\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwwm3w_qd_test.go:26:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpwwm3w_qd_test.go:61:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    closest1 := numbers[0]\n    closest2 := numbers[0]\n\
    \n    for _, number := range numbers[1:] {\n        if math.Abs(number - closest1)\
    \ > math.Abs(number - closest2) {\n            closest2 = closest1\n         \
    \   closest1 = number\n        } else {\n            closest2 = number\n     \
    \   }\n    }\n\n    return []interface{}{closest1, closest2}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfok5wvrc_test.go:19:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074845
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    sort.Float64s(numbers)\n\n    prev := numbers[0]\n    result :=\
    \ []interface{}{}\n\n    for _, number := range numbers[1:] {\n        if number\
    \ < prev {\n            result = append(result, number)\n            prev = number\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpchewpks5_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074846
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    closest := make([]interface{}, 0, 2)\n    if\
    \ len(numbers) < 2 {\n        return closest\n    }\n    if numbers[0] < numbers[1]\
    \ {\n        closest = append(closest, numbers[0])\n        return closest\n \
    \   }\n    closest = append(closest, numbers[1])\n    return closest\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpj3cbbk61_test.go:44: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpj3cbbk61_test.go:44: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpj3cbbk61_test.go:44: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpj3cbbk61_test.go:44: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpj3cbbk61_test.go:44: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074847
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    n := len(numbers)\n    if n < 2 {\n        return\
    \ []interface{}{}\n    }\n    smallest := numbers[0]\n    largestNumber := numbers[n-1]\n\
    \    smallestNumber := numbers[1]\n\n    if smallest < smallestNumber {\n    \
    \    smallestNumber = smallest\n    }\n    if largest < largestNumber {\n    \
    \    largestNumber = largest\n    }\n\n    return []interface{}{smallestNumber,\
    \ largestNumber}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp38i_wd6t_test.go:26:8: undefined: largest

    /tmp/tmp38i_wd6t_test.go:27:25: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074847
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var smallest, largest float64\n\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        if smallest == -1 {\n            smallest\
    \ = numbers[i]\n            largest = numbers[i]\n        } else if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        } else if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n    }\n\n    result\
    \ := []interface{}{}\n\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ == smallest {\n            result = append(result, smallest)\n        }\n  \
    \      if numbers[i] == largest {\n            result = append(result, largest)\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpwxhdggp2_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpwxhdggp2_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpwxhdggp2_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpwxhdggp2_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpwxhdggp2_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074847
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    distances := make([]float64, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        distances[i] = math.Abs(numbers[i]\
    \ - numbers[(i+1)%len(numbers)])\n    }\n    sort.Float64s(distances)\n    selectedIndices\
    \ := make([]int, len(numbers))\n    selectedIndices[0] = 0\n    selectedIndices[1]\
    \ = 1\n    for i := 2; i < len(numbers); i++ {\n        if distances[i-1] > distances[i]\
    \ {\n            selectedIndices[i] = selectedIndices[i-1]\n            selectedIndices[i-1]\
    \ = i\n        } else {\n            selectedIndices[i] = selectedIndices[i-1]\n\
    \        }\n    }\n    return selectedIndices[0 : len(numbers)-1]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpry3paqd8_test.go:17:24: undefined: math

    /tmp/tmpry3paqd8_test.go:19:5: undefined: sort

    /tmp/tmpry3paqd8_test.go:31:27: cannot use selectedIndices[0:len(numbers) - 1]
    (value of type []int) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074847
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    var min float64\n    var min float64\n    var diff float64\n    for\
    \ i, _ := range numbers {\n        if i != 0 {\n            diff := numbers[i]\
    \ - numbers[i-1]\n            if diff < min {\n                min = diff\n  \
    \              min = numbers[i]\n            }\n        }\n    }\n\n    var min2\
    \ float64\n    var min2 float64\n    for i, _ := range numbers {\n        if i\
    \ != 0 {\n            diff2 := numbers[i] - numbers[i-1]\n            if diff2\
    \ < min2 {\n                min2 = diff2\n                min2 = numbers[i]\n\
    \            }\n        }\n    }\n\n    return []interface{}{min2, min}\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqu7n5w3i_test.go:19:9:\
    \ min redeclared in this block\n\t/tmp/tmpqu7n5w3i_test.go:18:9: other declaration\
    \ of min\n/tmp/tmpqu7n5w3i_test.go:20:9: diff declared but not used\n/tmp/tmpqu7n5w3i_test.go:32:9:\
    \ min2 redeclared in this block\n\t/tmp/tmpqu7n5w3i_test.go:31:9: other declaration\
    \ of min2\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074847
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil {\n        return nil\n  \
    \  }\n    sortedNumbers := numbers.Sorted()\n    if sortedNumbers.Len() < 2 {\n\
    \        return nil\n    }\n    numberOne := sortedNumbers.Get(0)\n    numberTwo\
    \ := sortedNumbers.Get(1)\n    if numberOne == numberTwo {\n        return []interface{}{numberOne,\
    \ numberTwo}\n    }\n    closestNumberOne := closestNumber(numbers, numberOne)\n\
    \    closestNumberTwo := closestNumber(numbers, numberTwo)\n    if closestNumberOne\
    \ == closestNumberTwo {\n        return []interface{}{closestNumberOne, closestNumberTwo}\n\
    \    }\n    return []interface{}{closestNumberOne, closestNumberTwo}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_5bwe4h_test.go:18:30: numbers.Sorted undefined (type []float64 has no
    field or method Sorted)

    /tmp/tmp3_5bwe4h_test.go:27:25: undefined: closestNumber

    /tmp/tmp3_5bwe4h_test.go:28:25: undefined: closestNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    largest, smallest := numbers[0], numbers[0]\n\
    \    smallest += 1.0\n    largest += 1.0\n    for i, value := range numbers {\n\
    \        if value < smallest {\n            smallest = value\n        } else if\
    \ value > largest {\n            largest = value\n        }\n    }\n\n    output\
    \ := make([]interface{}, 0, len(numbers)-1)\n    for i, value := range numbers\
    \ {\n        if value == smallest {\n            output = []interface{}{smallest,\
    \ largest}\n            fmt.Printf(\"%d %f\\n\", i, largest)\n            break\n\
    \        } else if value == largest {\n            output = []interface{}{smallest,\
    \ largest}\n            fmt.Printf(\"%d %f\\n\", i, largest)\n            break\n\
    \        }\n\n    }\n    return output\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_dsmt3n_test.go:18:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Float64Slice(numbers))\n\n  \
    \  smallest := numbers[0]\n    largest := numbers[0]\n\n    for _, number := range\
    \ numbers[1:] {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    sort.Sort(sort.Float64Slice(numbers))\n\n    return append([]interface{}{smallest,\
    \ largest}, numbers...)\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp27v9a353_test.go:15:5: undefined: sort

    /tmp/tmp27v9a353_test.go:28:5: undefined: sort

    /tmp/tmp27v9a353_test.go:30:53: cannot use numbers (variable of type []float64)
    as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    // Calculate the midpoint\n    half := len(numbers) / 2\n    midpoint\
    \ := numbers[half]\n\n    // Calculate the closest points\n    closestIndexes\
    \ := make([]int, len(numbers))\n    closestValues := make([]float64, len(numbers))\n\
    \    for i, number := range numbers {\n        distance := math.Abs((number -\
    \ midpoint))\n        closestValues[i] = number\n        closestIndexes[i] = i\n\
    \    }\n\n    // Sort the values by their distance from the midpoint\n    sort.Sort(sort.Reverse(sort.Float64Slice(closestValues)))\n\
    \n    // Return the sorted values\n    return closestIndexes\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdqceiub_test.go:26:21: undefined: math

    /tmp/tmpvdqceiub_test.go:32:5: undefined: sort

    /tmp/tmpvdqceiub_test.go:35:12: cannot use closestIndexes (variable of type []int)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    // Sort the two values in order of magnitude.\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \n    // We want the next value to be the smallest of the two numbers.\n    smallest\
    \ := numbers[0]\n    smallest := numbers[1]\n    smallest := numbers[2]\n\n  \
    \  // Find the index of the smallest number in our two arrays.\n    for i := 0;\
    \ i < len(numbers); i++ {\n        if smallest > numbers[i] {\n            smallest\
    \ = numbers[i]\n            smallestIndex = i\n        }\n    }\n\n    // Now\
    \ that we have the index of the smallest two numbers,\n    // we can get all the\
    \ other numbers by using that index.\n    numbers := numbers[smallestIndex:]\n\
    \    numbers := append(numbers, numbers...)\n\n    return numbers\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctpce5g6_test.go:20:5: undefined: sort

    /tmp/tmpctpce5g6_test.go:24:14: no new variables on left side of :=

    /tmp/tmpctpce5g6_test.go:25:14: no new variables on left side of :=

    /tmp/tmpctpce5g6_test.go:31:13: undefined: smallestIndex

    /tmp/tmpctpce5g6_test.go:37:13: no new variables on left side of :=

    /tmp/tmpctpce5g6_test.go:37:24: undefined: smallestIndex

    /tmp/tmpctpce5g6_test.go:38:13: no new variables on left side of :=

    /tmp/tmpctpce5g6_test.go:40:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallest, smallest := numbers[0], numbers[0]\n    largest, largest\
    \ := numbers[0], numbers[0]\n    for _, number := range numbers[1:] {\n      \
    \  if number > largest {\n            largest = number\n        }\n        if\
    \ number < smallest {\n            smallest = number\n        }\n        if largest\
    \ <= smallest {\n            largest += 1.\n            smallest -= 1.\n     \
    \   }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr3hckv7d_test.go:18:15: smallest repeated on left side of :=

    /tmp/tmpr3hckv7d_test.go:19:14: largest repeated on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n\n    smallest := smallest\n    smallest := numbers[0]\n    for\
    \ _, number := range numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n    }\n\n    smallest := smallest\n    smallest := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest {\n      \
    \      smallest = number\n        }\n    }\n\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps94t6niu_test.go:30:14: no new variables on left side of :=

    /tmp/tmps94t6niu_test.go:31:14: no new variables on left side of :=

    /tmp/tmps94t6niu_test.go:38:14: no new variables on left side of :=

    /tmp/tmps94t6niu_test.go:39:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    numbers := numbers[:len(numbers)-1]\n    diff := numbers[1] - numbers[0]\n\
    \    diff *= diff\n    diff += numbers[1]\n\n    numbers := numbers[1:]\n    diff\
    \ := numbers[1] - numbers[0]\n    diff *= diff\n    diff += numbers[1]\n\n   \
    \ numbers := numbers[:len(numbers)-1]\n    diff := numbers[1] - numbers[0]\n \
    \   diff *= diff\n    diff += numbers[1]\n\n    numbers := numbers[1:]\n\n   \
    \ var selected []float64\n    var selected []float64\n    var selected []float64\n\
    \n    for _, number := range numbers {\n        if number < numbers[0] {\n   \
    \         selected = append(selected, numbers[0])\n        }\n        if number\
    \ > numbers[len(numbers)-1] {\n            selected = append(selected, numbers[len(numbers)-1])\n\
    \        }\n\n        if number == numbers[0] {\n            selected = append(selected,\
    \ numbers[0])\n        }\n        if number == numbers[len(numbers)-1] {\n   \
    \         selected = append(selected, numbers[len(numbers)-1])\n        }\n  \
    \  }\n\n    return selected\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ffqljge_test.go:19:13:\
    \ no new variables on left side of :=\n/tmp/tmp_ffqljge_test.go:24:13: no new\
    \ variables on left side of :=\n/tmp/tmp_ffqljge_test.go:25:10: no new variables\
    \ on left side of :=\n/tmp/tmp_ffqljge_test.go:29:13: no new variables on left\
    \ side of :=\n/tmp/tmp_ffqljge_test.go:30:10: no new variables on left side of\
    \ :=\n/tmp/tmp_ffqljge_test.go:34:13: no new variables on left side of :=\n/tmp/tmp_ffqljge_test.go:37:9:\
    \ selected redeclared in this block\n\t/tmp/tmp_ffqljge_test.go:36:9: other declaration\
    \ of selected\n/tmp/tmp_ffqljge_test.go:38:9: selected redeclared in this block\n\
    \t/tmp/tmp_ffqljge_test.go:36:9: other declaration of selected\n/tmp/tmp_ffqljge_test.go:56:12:\
    \ cannot use selected (variable of type []float64) as type []interface{} in return\
    \ statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var numberSet = []float64{}\n    var numbers\
    \ []interface{}\n    for _, number := range numbers {\n        numberSet = append(numberSet,\
    \ number)\n    }\n    numbers := numberSet\n\n    // sort the numbers (smallest\
    \ first)\n    sort.Float64s(numbers)\n\n    // find the smallest and largest numbers\
    \ in the numbers array\n    var smallest, largest, current float64\n    for i,\
    \ number := range numbers {\n        if smallest > number {\n            smallest\
    \ = number\n        }\n        if largest < number {\n            largest = number\n\
    \        }\n        current = numbers[i]\n        if i == 0 {\n            current\
    \ = number\n        }\n    }\n\n    // loop through numbers again\n    var closest1,\
    \ closest2 float64\n    var closestIndex1, closestIndex2 int\n    for i, number\
    \ := range numbers {\n        if number == largest {\n            closest1 = number\n\
    \            closestIndex1 = i\n        }\n        if number == smallest {\n \
    \           closest2 = number\n            closestIndex2 = i\n        }\n    }\n\
    \n    // return the numbers in the order they are found\n    // if the two numbers\
    \ being returned are closer than the first returned number, choose the second\
    \ number\n    if closest1 < closest2 {\n        return numbers[closestIndex2:closestIndex1+1]\n\
    \    } else {\n        return numbers[closestIndex1:closestIndex2+1]\n    }\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoj68iirh_test.go:16:9:\
    \ numbers redeclared in this block\n\t/tmp/tmpoj68iirh_test.go:14:28: other declaration\
    \ of numbers\n/tmp/tmpoj68iirh_test.go:20:13: no new variables on left side of\
    \ :=\n/tmp/tmpoj68iirh_test.go:23:5: undefined: sort\n/tmp/tmpoj68iirh_test.go:26:28:\
    \ current declared but not used\n/tmp/tmpoj68iirh_test.go:57:23: cannot use numbers[closestIndex2:closestIndex1\
    \ + 1] (value of type []float64) as type []interface{} in return statement\n/tmp/tmpoj68iirh_test.go:59:23:\
    \ cannot use numbers[closestIndex1:closestIndex2 + 1] (value of type []float64)\
    \ as type []interface{} in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    len      := len(numbers)\n    numberSet := make(map[float64]bool)\n\
    \    smallest  := numbers[0]\n    largest   := numbers[0]\n\n    for i := 1; i\
    \ < len; i++ {\n        number := numbers[i]\n        if !numberSet[number] {\n\
    \            numberSet[number] = true\n            if number < smallest {\n  \
    \              smallest = number\n            }\n            if number > largest\
    \ {\n                largest = number\n            }\n        }\n    }\n    return\
    \ []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpl4qqbccg_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpl4qqbccg_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpl4qqbccg_test.go:52: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpl4qqbccg_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpl4qqbccg_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074848
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var result []interface{}\n    if numbers ==\
    \ nil {\n        return nil\n    }\n    min := numbers[0]\n    max := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < min {\n           \
    \ min = number\n        } else if number > max {\n            max = number\n \
    \       }\n    }\n    if min == max {\n        return nil\n    }\n    result =\
    \ make([]interface{}, 1)\n    result[0] = min\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpr4jzrsc7_test.go:53: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpr4jzrsc7_test.go:53: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpr4jzrsc7_test.go:53: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpr4jzrsc7_test.go:53: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpr4jzrsc7_test.go:53: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    distance := make([]float64, len(numbers)+1)\n\
    \    distance[0] = math.Inf(1)\n\n    for i := 0; i < len(numbers); i++ {\n  \
    \      distance[i+1] = math.Sqrt(float64(numbers[i])*(numbers[i])+float64(distance[i])*(distance[i]))\n\
    \    }\n\n    index := make([]int, len(numbers)+1)\n\n    for i := range index\
    \ {\n        index[i] = i\n    }\n    for i := range distance {\n        if distance[i]\
    \ < distance[0] {\n            distance[0] = distance[i]\n            index[0]\
    \ = index[i]\n        }\n    }\n    for i := range distance[1:] {\n        if\
    \ distance[i] < distance[index[0]] {\n            index[0] = i\n        }\n  \
    \  }\n    return index\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx_694ktv_test.go:16:19: undefined: math

    /tmp/tmpx_694ktv_test.go:19:25: undefined: math

    /tmp/tmpx_694ktv_test.go:38:12: cannot use index (variable of type []int) as type
    []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n    closestIndex :=\
    \ 0\n    closestDistance := numbers[0]\n    for _, v := range numbers[1:] {\n\
    \        if v == closestDistance {\n            continue\n        }\n        distance\
    \ := float64(v)\n        if distance < closestDistance {\n            closestDistance\
    \ = distance\n            closestIndex = closestDistance - 1\n        }\n    }\n\
    \    return numbers[closestIndex:]\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1_3822af_test.go:15:5: undefined: sort

    /tmp/tmp1_3822af_test.go:25:28: cannot use closestDistance - 1 (value of type
    float64) as type int in assignment

    /tmp/tmp1_3822af_test.go:28:19: cannot use numbers[closestIndex:] (value of type
    []float64) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, largest := numbers[0], numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        val := numbers[i]\n        if\
    \ val < smallest {\n            smallest = val\n        }\n        if val > largest\
    \ {\n            largest = val\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp8col4ebj_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp8col4ebj_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp8col4ebj_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp8col4ebj_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp8col4ebj_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074849
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Sort by smallest number, so numbers[0] is\
    \ the smallest.\n    // Sort by largest number, so numbers[-1] is the largest.\n\
    \    sort.Float64s(numbers)\n    var i int\n    var smallest float64\n    var\
    \ largest float64\n    for _, value := range numbers {\n        if i == 0 {\n\
    \            smallest = value\n            largest = value\n        } else {\n\
    \            if value < smallest {\n                smallest = value\n       \
    \     } else if value > largest {\n                largest = value\n         \
    \   }\n        }\n        i++\n    }\n    if largest < smallest {\n        return\
    \ nil\n    }\n    numbers := make([]interface{}, 2)\n    numbers[0] = smallest\n\
    \    numbers[1] = largest\n    return numbers\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxmncenjg_test.go:17:5: undefined: sort

    /tmp/tmpxmncenjg_test.go:37:13: no new variables on left side of :=

    /tmp/tmpxmncenjg_test.go:37:16: cannot use make([]interface{}, 2) (value of type
    []interface{}) as type []float64 in assignment

    /tmp/tmpxmncenjg_test.go:40:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    min := numbers[0]\n    max := numbers[0]\n    for _, number := range\
    \ numbers[1:] {\n        if number > max {\n            max = number\n       \
    \ } else if number < min {\n            min = number\n        }\n    }\n    return\
    \ []interface{}{min, max}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpio_7dyl1_test.go:48: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpio_7dyl1_test.go:48: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpio_7dyl1_test.go:48: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpio_7dyl1_test.go:48: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpio_7dyl1_test.go:48: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074849
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    if len(numbers) == 2 {\n        return numbers\n    }\n\n    bigger_number\
    \ := numbers[0]\n    smaller_number := numbers[1]\n    next_bigger_number := numbers[2]\n\
    \n    smallest_diff := float64(Inf)\n    biggest_diff := -float64(Inf)\n\n   \
    \ for i := 3; i < len(numbers); i++ {\n        diff_to_next_bigger := bigger_number\
    \ - next_bigger_number\n        diff_to_smaller := next_bigger_number - smaller_number\n\
    \n        if diff_to_next_bigger < smallest_diff {\n            smallest_diff\
    \ = diff_to_next_bigger\n        }\n\n        if diff_to_next_bigger > biggest_diff\
    \ {\n            biggest_diff = diff_to_next_bigger\n        }\n\n        if diff_to_smaller\
    \ < smallest_diff {\n            smallest_diff = diff_to_smaller\n        }\n\n\
    \        if diff_to_smaller > biggest_diff {\n            biggest_diff = diff_to_smaller\n\
    \        }\n\n        bigger_number = next_bigger_number\n        smaller_number\
    \ = next_bigger_number\n\n        next_bigger_number = numbers[i]\n    }\n\n \
    \   result := []interface{}{smaller_number, bigger_number}\n    return result\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdqj73a9_test.go:20:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpvdqj73a9_test.go:27:30: undefined: Inf

    /tmp/tmpvdqj73a9_test.go:28:30: undefined: Inf

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    numbers := numbers\n    sort.Sort(sort.Reverse(numbers))\n    numbers\
    \ := numbers[1:]\n    closest := numbers[0]\n    second := numbers[1]\n    if\
    \ second < closest {\n        return nil\n    }\n    return []interface{}{second,\
    \ closest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_o75nm0_test.go:18:13: no new variables on left side of :=

    /tmp/tmpz_o75nm0_test.go:19:5: undefined: sort

    /tmp/tmpz_o75nm0_test.go:20:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074848
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Go through each element in the array and\
    \ compare it to each other\n    result := make([]interface{}, 0, 2)\n    for i\
    \ := 0; i < len(numbers); i++ {\n        // See if we can find a better match\n\
    \        other := numbers[i]\n        jmin := i\n        for j := i; j < len(numbers);\
    \ j++ {\n            if numbers[j] < other {\n                jmin = j\n     \
    \       }\n        }\n        if jmin != i {\n            // We have a better\
    \ match\n            result2 = append(result2, numbers[jmin])\n            result2\
    \ = append(result2, numbers[i])\n        }\n    }\n    return result2\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkw5zl9dl_test.go:16:5: result declared but not used

    /tmp/tmpkw5zl9dl_test.go:28:30: undefined: result2

    /tmp/tmpkw5zl9dl_test.go:29:30: undefined: result2

    /tmp/tmpkw5zl9dl_test.go:32:12: undefined: result2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074849
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    n := len(numbers)\n    if n < 2 {\n        return\
    \ nil\n    }\n\n    arr := make([]interface{}, 2)\n    arr[0] = numbers[0]\n \
    \   arr[1] = numbers[len(numbers)-1]\n    pivot := arr[0]\n\n    for i := 1; i\
    \ < n; i++ {\n        if arr[0] < arr[1] {\n            if numbers[i] == pivot\
    \ {\n                return nil\n            } else {\n                arr[0]\
    \ = numbers[i]\n                arr[1] = numbers[len(numbers)-1]\n           \
    \ }\n        } else {\n            if numbers[i] != pivot {\n                if\
    \ numbers[i-1] == pivot {\n                    return nil\n                } else\
    \ {\n                    arr[0] = numbers[i]\n                    arr[1] = numbers[i-1]\n\
    \                }\n            }\n        }\n    }\n    return arr\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1erxma3k_test.go:26:12: invalid operation: arr[0] < arr[1] (operator <
    not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074850
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest []interface{}\n\n    if len(numbers)\
    \ <= 1 {\n        return nil\n    }\n\n    minimum := numbers[0]\n    index :=\
    \ 0\n    max := numbers[0]\n\n    for index, value := range numbers {\n      \
    \  if value < minimum {\n            minimum = value\n            closest = make([]interface{},\
    \ 2)\n        }\n\n        if value > max {\n            max = value\n       \
    \ }\n\n        if index == len(numbers)-1 {\n            closest[0] = minimum\n\
    \            closest[1] = max\n            return closest\n        }\n    }\n\n\
    \    closest[0] = minimum\n    closest[1] = max\n    return closest\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpypyhaamm_test.go:22:5: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074850
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, largest := numbers[0], numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp65x7hroy_test.go:44: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp65x7hroy_test.go:44: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp65x7hroy_test.go:44: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp65x7hroy_test.go:44: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp65x7hroy_test.go:44: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    // Initialize to last number (which will be first in sorted list)\n\
    \    min := numbers[len(numbers)-1]\n\n    max := numbers[0]\n    min := numbers[0]\n\
    \n    diff := numbers[1] - numbers[0]\n\n    // Initialize min as first number\
    \ in list and max as last number in list\n    for i := 2; i < len(numbers); i++\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \        if numbers[i] < min {\n            min = numbers[i]\n        }\n    }\n\
    \    diff -= min - max\n\n    // Initialize diff2 as diff squared for diff squared\n\
    \    diff2 := diff * diff\n\n    closestElements := []interface{}{max, min}\n\
    \    for i := 2; i < len(numbers); i++ {\n        diff := numbers[i] - numbers[i-1]\n\
    \        diff2 -= diff * diff\n        if diff > 0 && diff2 < diff {\n       \
    \     closestElements = append(closestElements, numbers[i-1])\n            closestElements\
    \ = append(closestElements, numbers[i])\n        }\n    }\n    return closestElements\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzjodbnig_test.go:22:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    length := len(numbers)\n    sort.Float64s(numbers)\n\
    \    var smallest, second float64\n    for i := 0; i < length/2; i++ {\n     \
    \   if smallest > numbers[i] {\n            smallest = numbers[i]\n        }\n\
    \        if second > numbers[i] {\n            second = numbers[i]\n        }\n\
    \    }\n    return []interface{}{smallest, second}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwo6ue6d_test.go:16:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var results []interface{}\n    var minIndex\
    \ int\n    var maxIndex int\n    for index, number := range numbers {\n      \
    \  if number < numbers[minIndex] {\n            minIndex = index\n        } else\
    \ if number > numbers[maxIndex] {\n            maxIndex = index\n        }\n \
    \   }\n    results = append(results, numbers[minIndex], numbers[maxIndex])\n \
    \   return\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7q1ic3ve_test.go:26:5:\
    \ not enough return values\n\thave ()\n\twant ([]interface{})\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n    for _, number := range numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgel56o5z_test.go:16:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, largest := numbers[0], numbers[0]\n\
    \    for _, n := range numbers {\n        if n > largest {\n            largest\
    \ = n\n        }\n        if n < smallest {\n            smallest = n\n      \
    \  }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmptdryvkwn_test.go:44: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmptdryvkwn_test.go:44: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmptdryvkwn_test.go:44: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmptdryvkwn_test.go:44: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmptdryvkwn_test.go:44: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest float64\n    var second float64\n\
    \    var distance float64\n\n    if len(numbers) < 2 {\n        return nil\n \
    \   }\n\n    // Find the first number that is closest\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if numbers[i] == closest {\n            continue\n        }\n\
    \        distance = math.Abs(numbers[i] - closest)\n        if distance < second\
    \ {\n            second       = distance\n            closest      = numbers[i]\n\
    \        }\n    }\n\n    // Now return the second\n    distance = math.Abs(closest\
    \ - second)\n    if distance < numbers[1] {\n        return nil\n    }\n\n   \
    \ return []interface{}{closest, second}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpahtl28k6_test.go:28:20: undefined: math

    /tmp/tmpahtl28k6_test.go:36:16: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest []interface{}\n    closest := numbers[0]\n\
    \    for _, number := range numbers[1:] {\n        if closest.Float64() > number.Float64()\
    \ {\n            closest = number\n        }\n    }\n    return closest\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj3zhgs6y_test.go:16:13: no new variables on left side of :=

    /tmp/tmpj3zhgs6y_test.go:16:16: cannot use numbers[0] (variable of type float64)
    as type []interface{} in assignment

    /tmp/tmpj3zhgs6y_test.go:18:20: closest.Float64 undefined (type []interface{}
    has no field or method Float64)

    /tmp/tmpj3zhgs6y_test.go:18:39: number.Float64 undefined (type float64 has no
    field or method Float64)

    /tmp/tmpj3zhgs6y_test.go:19:23: cannot use number (variable of type float64) as
    type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Sort numbers by their absolute value (to\
    \ find the smaller number).\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \n    // Find smaller number - it is the closest to the first number in the list\n\
    \    // and will always be the first item in the returned list.\n    smallestNumber\
    \ := numbers[0]\n\n    // Find bigger number - the largest number in the list\n\
    \    // and it will be the last item in the returned list.\n    biggestNumber\
    \ := numbers[len(numbers)-1]\n\n    // If there aren't at least 2 numbers in the\
    \ list - nothing to return\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // Get the two numbers that are closest to each other and return\
    \ the list in\n    // order of smallest to biggest value.\n    var smallerNumber\
    \ float64\n    var largerNumber float64\n    for _, number := range numbers {\n\
    \        if number > biggestNumber {\n            smallerNumber = number\n   \
    \         largerNumber = biggestNumber\n            biggestNumber = number\n \
    \       } else {\n            if number < smallestNumber {\n                smallerNumber\
    \ = number\n                largerNumber = smallestNumber\n                smallestNumber\
    \ = number\n            } else {\n                if math.Abs(number - smallerNumber)\
    \ < math.Abs(number - largerNumber) {\n                    smallerNumber = number\n\
    \                } else {\n                    largerNumber = number\n       \
    \         }\n            }\n        }\n    }\n\n    return []interface{}{smallerNumber,\
    \ largerNumber}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkuu1_rh2_test.go:16:5: undefined: sort

    /tmp/tmpkuu1_rh2_test.go:46:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sorted_numbers := make([]float64, 0)\n    for\
    \ _, number := range numbers {\n        sorted_numbers = append(sorted_numbers,\
    \ number)\n    }\n    sort.Float64s(sorted_numbers)\n\n    var closest []interface{}\n\
    \    for _, number := range sorted_numbers {\n        nearest := number\n    \
    \    closest = append(closest, number)\n        closest2 := number\n        for\
    \ _, number2 := range sorted_numbers {\n            if number2 < nearest {\n \
    \               closest = append(closest, number2)\n                closest2 =\
    \ number2\n            }\n        }\n    }\n    return closest\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnf0xmmac_test.go:19:5: undefined: sort

    /tmp/tmpnf0xmmac_test.go:25:9: closest2 declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var result []interface{}\n    var min float64\n\
    \    var max float64\n\n    if len(numbers) < 2 {\n        return nil\n    }\n\
    \n    min = numbers[0]\n    max = numbers[0]\n\n    for _, number := range numbers\
    \ {\n        if number > max {\n            max = number\n        } else if number\
    \ < min {\n            min = number\n        }\n    }\n\n    if min != max {\n\
    \        result = append(result, min)\n        result = append(result, max)\n\
    \    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpof_ey523_test.go:59: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpof_ey523_test.go:59: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpof_ey523_test.go:59: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpof_ey523_test.go:59: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpof_ey523_test.go:59: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    closestDistance := map[float64]float64{numbers[0]:\
    \ 1.0}\n    for _, number := range numbers[1:] {\n        distance := 0.0\n  \
    \      for _, smallerNumber := range numbers[:len(numbers)-1] {\n            distance\
    \ += math.Abs(smallerNumber - number)\n        }\n        closestDistance[number]\
    \ = distance\n    }\n\n    // find the first element that has distance < closestDistance\n\
    \    var closestElement float64\n    for number, distance := range closestDistance\
    \ {\n        if closestDistance == 0.0 {\n            closestElement = number\n\
    \        } else {\n            if distance < closestDistance {\n             \
    \   closestElement = number\n            }\n        }\n    }\n    return []interface{}{closestElement,\
    \ closestElement}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyhme5stw_test.go:19:25: undefined: math

    /tmp/tmpyhme5stw_test.go:27:31: cannot convert 0.0 (untyped float constant 0)
    to map[float64]float64

    /tmp/tmpyhme5stw_test.go:30:27: invalid operation: distance < closestDistance
    (mismatched types float64 and map[float64]float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var result []interface{}\n    var min float64\n\
    \    var max float64\n    for _, num := range numbers {\n        if num > max\
    \ {\n            max = num\n        }\n        if num < min {\n            min\
    \ = num\n        }\n    }\n    if len(numbers) < 2 {\n        return nil\n   \
    \ }\n    for _, num := range numbers {\n        if num > max {\n            max\
    \ = num\n        }\n        if num < min {\n            min = num\n        }\n\
    \    }\n    if max - min < 0 {\n        return nil\n    }\n    if min > max {\n\
    \        min = max\n    }\n    if min == max {\n        result = []interface{}{min,\
    \ max}\n    } else {\n        result = []interface{}{min, max}\n        i := 0\n\
    \        for _, num := range numbers {\n            if num > min {\n         \
    \       num := num\n                result[i] = num\n                i++\n   \
    \         }\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index\
    \ out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out\
    \ of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_closest_elements({0xc0000f5e10, 0x6,\
    \ 0x5e3ea0?})\n\t/tmp/tmp02squdag_test.go:51 +0x2f2\ncommand-line-arguments_test.TestFind_Closest_Elements(0x0?)\n\
    \t/tmp/tmp02squdag_test.go:66 +0xd2\ntesting.tRunner(0xc0001924e0, 0x528fc8)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    sort.Float64s(numbers)\n    idx := sort.Search(len(numbers)-1, func(i\
    \ int) bool {\n        return numbers[i] > numbers[i+1]\n    })\n    return []interface{}{numbers[idx],\
    \ numbers[idx+1]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpich7nb04_test.go:18:5: undefined: sort

    /tmp/tmpich7nb04_test.go:19:12: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    if len(numbers) < 2 {\n        return nil\n    }\n    result := []interface{}{}\n\
    \    min := numbers[0]\n    max := numbers[0]\n    for _, number := range numbers\
    \ {\n        if number > max {\n            max = number\n        } else if number\
    \ < min {\n            min = number\n        }\n    }\n    result += []interface{}{min,\
    \ max}\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr4oew5h__test.go:15:5: undefined: sort

    /tmp/tmpr4oew5h__test.go:29:5: invalid operation: operator + not defined on result
    (variable of type []interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallestIndex := 0\n    closestIndex := 0\n\
    \    smallestDistance := math.MaxFloat64\n    for i := 1; i < len(numbers); i++\
    \ {\n        distanceSquaredForCurrent := math.Pow(numbers[i-1]-numbers[i], 2)\n\
    \        if smallestDistance > distanceSquaredForCurrent {\n            smallestDistance\
    \ = distanceSquaredForCurrent\n            smallestIndex = i\n        }\n    }\n\
    \n    closestNumber = numbers[smallestIndex]\n    for i := 0; i < smallestIndex;\
    \ i++ {\n        distanceSquaredForCurrent = math.Pow(numbers[i]-closestNumber,\
    \ 2)\n        if distanceSquaredForCurrent < smallestDistance {\n            closestNumber\
    \ = numbers[i]\n            closestIndex = i\n        }\n    }\n    return []interface{}{closestNumber,\
    \ numbers[closestIndex]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnrr90e0__test.go:17:25: undefined: math

    /tmp/tmpnrr90e0__test.go:19:38: undefined: math

    /tmp/tmpnrr90e0__test.go:26:5: undefined: closestNumber

    /tmp/tmpnrr90e0__test.go:28:9: undefined: distanceSquaredForCurrent

    /tmp/tmpnrr90e0__test.go:28:37: undefined: math

    /tmp/tmpnrr90e0__test.go:28:57: undefined: closestNumber

    /tmp/tmpnrr90e0__test.go:29:12: undefined: distanceSquaredForCurrent

    /tmp/tmpnrr90e0__test.go:30:13: undefined: closestNumber

    /tmp/tmpnrr90e0__test.go:34:26: undefined: closestNumber

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, number\
    \ := range numbers[1:] {\n        if number > largest {\n            largest =\
    \ number\n        } else if number < smallest {\n            smallest = number\n\
    \        }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp4h16dmv0_test.go:47: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp4h16dmv0_test.go:47: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp4h16dmv0_test.go:47: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp4h16dmv0_test.go:47: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp4h16dmv0_test.go:47: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074851
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    result := make([]interface{}, 0)\n    if len(numbers)\
    \ < 2 {\n        return result\n    }\n\n    number0 := numbers[0]\n    number1\
    \ := numbers[1]\n    diff := number1 - number0\n    switch diff {\n    case 0:\n\
    \        result = append(result, number0)\n        result = append(result, number1)\n\
    \        return result\n    case 1:\n        result = append(result, number1)\n\
    \        result = append(result, number0)\n        return result\n    default:\n\
    \        midIndex := (len(numbers) >> 1) + 1\n        middleValue := numbers[midIndex]\n\
    \        diffMid := middleValue - number0\n        switch diffMid {\n        case\
    \ 0:\n            result = append(result, number0)\n            result = append(result,\
    \ middleValue)\n            result = append(result, number1)\n            return\
    \ result\n        case 1:\n            result = append(result, middleValue)\n\
    \            result = append(result, number0)\n            result = append(result,\
    \ number1)\n            return result\n        default:\n            lowMidIndex\
    \ := midIndex - 1\n            lowerMiddleValue := numbers[lowMidIndex]\n    \
    \        diffLowMid := lowerMiddleValue - number0\n            switch diffLowMid\
    \ {\n            case 0:\n                result = append(result, number0)\n \
    \               result = append(result, lowerMiddleValue)\n                result\
    \ = append(result, number1)\n                return result\n            case 1:\n\
    \                result = append(result, lowerMiddleValue)\n                result\
    \ = append(result, number0)\n                result = append(result, number1)\n\
    \                return result\n            default:\n                highMidIndex\
    \ := lowMidIndex - 1\n                higherMiddleValue := numbers[highMidIndex]\n\
    \                diffHighMid := higherMiddleValue - number0\n                switch\
    \ diffHighMid {\n                case 0:\n                    result = append(result,\
    \ number0)\n                    result = append(result, higherMiddleValue)\n \
    \                   result = append(result, number1)\n                    return\
    \ result\n                case 1:\n                    result = append(result,\
    \ higherMiddleValue)\n                    result = append(result, number0)\n \
    \                   result = append(result, number1)\n                    return\
    \ result\n                default:\n                    midValue := (number0 +\
    \ number1) / 2\n                    diffMid := midValue - number0\n          \
    \          switch diffMid {\n                    case 0:\n                   \
    \     result = append(result, number0)\n                        result = append(result,\
    \ midValue)\n                        result = append(result, number1)\n      \
    \                  return result\n                    case 1:\n              \
    \          result = append(result, midValue)\n                        result =\
    \ append(result, number0)\n                        result = append(result, number1)\n\
    \                        return result\n                    default:\n       \
    \                 result = append(result, number0)\n                        result\
    \ = append(result, number1)\n                        result = append(result, midValue)\n\
    \                        return result\n                }\n            }\n   \
    \     }\n    }\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd7nuemh2_test.go:102:6: expected ''('', found TestFind_Closest_Elements

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074850
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    sort.Float64s(numbers)\n    bigger := numbers[0]\n    smaller :=\
    \ numbers[1]\n    result := []interface{}{}\n    for i := 2; i < len(numbers);\
    \ i++ {\n        current := numbers[i]\n        if current < bigger {\n      \
    \      bigger = current\n            result = append(result, smaller)\n      \
    \  }\n        if current > smaller && bigger != current {\n            bigger\
    \ = current\n            smaller = current\n            result = append(result,\
    \ smaller)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7wv726p_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Float64Slice(numbers))\n\n  \
    \  if len(numbers) <= 1 {\n        return []interface{}{}\n    }\n\n    var smallest1,\
    \ largest1, smallest2, largest2 float64\n    if numbers[0] < numbers[1] {\n  \
    \      smallest1 = numbers[0]\n        smallest2 = numbers[1]\n        largest1\
    \ = numbers[1]\n        largest2 = numbers[0]\n    } else {\n        smallest1\
    \ = numbers[1]\n        smallest2 = numbers[0]\n        largest1 = numbers[0]\n\
    \        largest2 = numbers[1]\n    }\n\n    i := 1\n    for i < len(numbers)\
    \ {\n        if numbers[i] < smallest1 {\n            smallest1 = numbers[i]\n\
    \        } else if numbers[i] > largest1 {\n            largest1 = numbers[i]\n\
    \        } else if numbers[i] < smallest2 {\n            smallest2 = numbers[i]\n\
    \        } else if numbers[i] > largest2 {\n            largest2 = numbers[i]\n\
    \        }\n        i++\n    }\n\n    if smallest1 == largest1 {\n        return\
    \ []interface{}{smallest1, smallest2}\n    }\n\n    if smallest2 == largest2 {\n\
    \        return []interface{}{smallest2, smallest1}\n    }\n\n    return []interface{}{smallest1,\
    \ smallest2}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5nkz6a6o_test.go:15:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074851
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    sortedNumbers := numbers.sort()\n    // Find closest numbers\n   \
    \ var min1, max1, min2, max2 float64\n    for i := range numbers {\n        if\
    \ min1 == 0.0 {\n            min1 = numbers[i]\n            min2 = numbers[i]\n\
    \            max2 = numbers[i]\n            continue\n        }\n        if max1\
    \ == 0.0 {\n            max1 = numbers[i]\n            max2 = numbers[i]\n   \
    \         continue\n        }\n        if numbers[i] < min1 {\n            min1\
    \ = numbers[i]\n            min2 = numbers[i]\n            max2 = numbers[i]\n\
    \            continue\n        }\n        if numbers[i] > max1 {\n           \
    \ max1 = numbers[i]\n            max2 = numbers[i]\n            continue\n   \
    \     }\n    }\n    if min1 == max1 {\n        // Return only a single one\n \
    \       return append([]interface{}{min1}, numbers...)\n    }\n    if max1 ==\
    \ min1 {\n        // Return only a single one\n        return append([]interface{}{max1},\
    \ numbers...)\n    }\n    // Return both numbers\n    return []interface{}{min1,\
    \ min2}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpufesb2_4_test.go:18:30: numbers.sort undefined (type []float64 has no
    field or method sort)

    /tmp/tmpufesb2_4_test.go:20:27: max2 declared but not used

    /tmp/tmpufesb2_4_test.go:47:44: cannot use numbers (variable of type []float64)
    as type []interface{} in argument to append

    /tmp/tmpufesb2_4_test.go:51:44: cannot use numbers (variable of type []float64)
    as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074852
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smaller, larger := numbers[0], numbers[0]\n\
    \    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > larger {\n            larger\
    \ = numbers[i]\n        } else if numbers[i] < smaller {\n            smaller\
    \ = numbers[i]\n        }\n    }\n    return []interface{}{smaller, larger}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp80v_61vm_test.go:46: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp80v_61vm_test.go:46: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp80v_61vm_test.go:46: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp80v_61vm_test.go:46: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp80v_61vm_test.go:46: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    sort.Slice(numbers, func(i, j int) bool {\n        return numbers[i]\
    \ < numbers[j]\n    })\n    diff := numbers[1] - numbers[0]\n\n    for i := 1;\
    \ i < len(numbers); i++ {\n        diff -= numbers[i] - numbers[i - 1]\n    }\n\
    \    return append([]interface{}{numbers[0], numbers[len(numbers)-1]}, numbers[:len(numbers)-1]...)\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprpinydsf_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmprpinydsf_test.go:19:5: undefined: sort

    /tmp/tmprpinydsf_test.go:27:78: cannot use numbers[:len(numbers) - 1] (value of
    type []float64) as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallestNumber := numbers[0]\n    smallestPosition := 0\n    secondSmallestNumber\
    \ := numbers[0]\n    secondSmallestPosition := 0\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] < smallestNumber {\n            smallestNumber\
    \ = numbers[i]\n            smallestPosition = i\n        } else {\n         \
    \   if smallestPosition == 0 {\n                secondSmallestNumber = numbers[i]\n\
    \                secondSmallestPosition = i\n            }\n            if abs(numbers[i]-secondSmallestNumber)\
    \ < abs(numbers[i]-smallestNumber) {\n                secondSmallestNumber = numbers[i]\n\
    \                secondSmallestPosition = i\n            }\n        }\n    }\n\
    \    return []interface{}{\n        smallestNumber,\n        secondSmallestNumber,\n\
    \    }\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpetv5xvy0_test.go:21:5: secondSmallestPosition declared but not used

    /tmp/tmpetv5xvy0_test.go:31:16: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    // Find the smallest value and the next largest value\n    smallest\
    \ := numbers[0]\n    largest := numbers[0]\n    for _, n := range numbers[1:]\
    \ {\n        if n < smallest {\n            smallest = n\n        }\n        if\
    \ n > largest {\n            largest = n\n        }\n    }\n\n    smallest :=\
    \ smallest\n    largest := largest\n    indices := make([]int, 0)\n\n    for i\
    \ := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n        \
    \    smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n   \
    \         largest = numbers[i]\n        }\n        if smallest == largest {\n\
    \            continue\n        }\n\n        // If the numbers are far apart then\
    \ skip them\n        if abs(smallest - largest) > 1e-5 {\n            continue\n\
    \        }\n\n        indices := append(indices, i)\n        if smallest < numbers[i]\
    \ {\n            smallest = numbers[i]\n        }\n        if largest > numbers[i]\
    \ {\n            largest = numbers[i]\n        }\n    }\n\n    return append(indices,\
    \ largest)\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpekgdmfbj_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpekgdmfbj_test.go:31:14: no new variables on left side of :=

    /tmp/tmpekgdmfbj_test.go:32:13: no new variables on left side of :=

    /tmp/tmpekgdmfbj_test.go:47:12: undefined: abs

    /tmp/tmpekgdmfbj_test.go:51:9: indices declared but not used

    /tmp/tmpekgdmfbj_test.go:60:12: cannot use append(indices, largest) (value of
    type []int) as type []interface{} in return statement

    /tmp/tmpekgdmfbj_test.go:60:28: cannot use largest (variable of type float64)
    as type int in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Create a map of min and max for each number\
    \ in numbers\n    var mins map[float64]float64\n    var maxes map[float64]float64\n\
    \    var result []interface{}\n    for _, number := range numbers {\n        if\
    \ !(mins == nil || number < mins[number]) {\n            mins[number] = number\n\
    \        }\n        if !(maxes == nil || number > maxes[number]) {\n         \
    \   maxes[number] = number\n        }\n    }\n    sort.Float64s(numbers)\n   \
    \ // Append the min to the end of the result\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    result = append(result, mins[numbers[len(numbers)-1]])\n    // Append the\
    \ max to the end of the result\n    result = append(result, maxes[numbers[len(numbers)-1]])\n\
    \    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2gz519o5_test.go:27:5: undefined: sort

    /tmp/tmp2gz519o5_test.go:29:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n\n    // Initialize\
    \ smallest and largest in each pass.\n    var smallest interface{} = numbers[0]\n\
    \    var largest interface{} = numbers[0]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if smallest > numbers[i] {\n            smallest = numbers[i]\n \
    \       }\n        if largest < numbers[i] {\n            largest = numbers[i]\n\
    \        }\n    }\n\n    // Initialize current as smallest.\n    current := smallest\n\
    \n    // Initialize distances from current to largest.\n    distances := make([]float64,\
    \ len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        distances[i]\
    \ = float64(numbers[i]-current)\n    }\n\n    // Set smallest/largest to current\
    \ to prevent a second pass through this loop (current is the same as smallest\
    \ or\n    // largest).\n    smallest = current\n    largest = current\n\n    //\
    \ Set distance to smallest + largest to ensure that we never return anything before\
    \ we return anything after.\n    distances[0] = float64(largest - smallest)\n\n\
    \    // Loop until we find a value that is smaller than smallest (the current\
    \ value).\n    for i := 1; i < len(numbers); i++ {\n        // Return values not\
    \ smaller than current value.\n        if distances[i] < 0 {\n            continue\n\
    \        }\n        if distances[i] < distances[i-1] {\n            // Set smallest\
    \ and largest to current to prevent another pass through this loop (current is\
    \ the same as smallest or\n            // largest).\n            smallest = current\n\
    \            largest = current\n\n            // Set distance to smallest + largest\
    \ to ensure that we never return anything before we return anything after.\n \
    \           distances[i] = float64(largest - smallest)\n        }\n        if\
    \ current == numbers[i] {\n            return numbers[:i]\n        }\n    }\n\n\
    \    // Return no values.\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjtbm_3r7_test.go:15:5: undefined: sort

    /tmp/tmpjtbm_3r7_test.go:21:12: invalid operation: smallest > numbers[i] (operator
    > not defined on interface)

    /tmp/tmpjtbm_3r7_test.go:24:12: invalid operation: largest < numbers[i] (operator
    < not defined on interface)

    /tmp/tmpjtbm_3r7_test.go:35:32: invalid operation: numbers[i] - current (mismatched
    types float64 and interface{})

    /tmp/tmpjtbm_3r7_test.go:44:28: invalid operation: operator - not defined on largest
    (variable of type interface{})

    /tmp/tmpjtbm_3r7_test.go:59:36: invalid operation: operator - not defined on largest
    (variable of type interface{})

    /tmp/tmpjtbm_3r7_test.go:62:27: cannot use numbers[:i] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    second := numbers[1]\n    count := 0\n\
    \    for _, value := range numbers[2:] {\n        count += value\n        if count\
    \ > second {\n            second = count\n        }\n    }\n    if smallest <\
    \ second {\n        smallest = second\n    }\n    result := []interface{}{smallest,\
    \ second}\n    if second != numbers[len(numbers)-1] {\n        result = append(result,\
    \ second)\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbbwkjpim_test.go:22:9: invalid operation: count += value (mismatched types
    int and float64)

    /tmp/tmpbbwkjpim_test.go:23:20: invalid operation: count > second (mismatched
    types int and float64)

    /tmp/tmpbbwkjpim_test.go:24:22: cannot use count (variable of type int) as type
    float64 in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    result := make([]interface{}, 0)\n    smallest\
    \ := math.MaxFloat64\n    largest := -math.MaxFloat64\n    for _, number := range\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       } else if number > largest {\n            largest = number\n        }\n\
    \    }\n    result <- smallest\n    result <- largest\n    return result\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6258fjrf_test.go:16:17: undefined: math

    /tmp/tmp6258fjrf_test.go:17:17: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    i := 0\n    j := len(numbers) - 1\n    var closest float64\n    var closestIndex\
    \ int\n    for ; i < j; i++ {\n        if numbers[i] >= numbers[j] {\n       \
    \     closestIndex = i\n            closest = numbers[i]\n        } else {\n \
    \           closestIndex = j\n            closest = numbers[j]\n        }\n  \
    \  }\n    return []interface{}{numbers[closestIndex], numbers[closestIndex]}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkjh2tlc3_test.go:15:5: undefined: sort

    /tmp/tmpkjh2tlc3_test.go:18:9: closest declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    index := 0\n    closestIndex := 0\n    closestDistance\
    \ := float64(math.Inf(1))\n    for index < len(numbers)-1 {\n        if numbers[index]\
    \ > numbers[index+1] {\n            closestIndex = index\n            closestDistance\
    \ = numbers[index]\n        } else {\n            closestIndex = index + 1\n \
    \           closestDistance = numbers[index+1]\n        }\n\n        if closestDistance\
    \ < numbers[index+1] {\n            closestIndex = index + 1\n        }\n\n  \
    \      if closestDistance < numbers[index] {\n            closestIndex = index\n\
    \        }\n\n        index++\n    }\n\n    return []interface{}{numbers[closestIndex],\
    \ numbers[closestIndex+1]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph363t17y_test.go:17:32: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers := make([]float64, len(numbers))\n \
    \   for i, number := range numbers {\n        numbers[i] = number\n    }\n   \
    \ smallest := numbers[0]\n    biggest := numbers[len(numbers)-1]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i]-smallest > biggest-numbers[i]\
    \ {\n            biggest = numbers[i]\n        } else {\n            smallest\
    \ = numbers[i]\n        }\n    }\n    return []interface{}{smallest, biggest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzqt52r0f_test.go:15:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    index := len(numbers) - 1\n    closests := make([]interface{},\
    \ 2)\n    for i := 0; i < len(numbers); i++ {\n        if i >= index {\n     \
    \       closests[i] = numbers[index]\n            index = i\n            continue\n\
    \        }\n        val := numbers[index]\n        diff := val - numbers[i]\n\
    \        if diff < 0 {\n            closests[i] = val\n            index = i\n\
    \        } else {\n            closests[i] = numbers[i]\n            index = index\
    \ - 1\n        }\n    }\n    return closests\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index\
    \ out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out\
    \ of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_closest_elements({0xc0000f5e10, 0x6,\
    \ 0x5e3ea0?})\n\t/tmp/tmpx4auuba__test.go:29 +0x1da\ncommand-line-arguments_test.TestFind_Closest_Elements(0x0?)\n\
    \t/tmp/tmpx4auuba__test.go:43 +0xd2\ntesting.tRunner(0xc0001a0340, 0x528fc8)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074854
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        panic(\"find_closest_elements:\
    \ not enough numbers to find 2 closest to each other.\")\n    }\n\n    // Store\
    \ the two numbers closest to each other.\n    n := len(numbers)\n    closest :=\
    \ make([]interface{}, 2*n)\n\n    // Get two closest numbers to each other.\n\
    \    for i := 0; i < n; i++ {\n        closest [2*i] = numbers[i]\n        closest\
    \ [2*i+1] = numbers[(i+1)%n]\n    }\n\n    return closest\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpqok1htdr_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=3.9) %!s(float64=3.9)\
    \ %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=5) %!s(float64=2.2)\
    \ %!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpqok1htdr_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=2) %!s(float64=2) %!s(float64=5.9) %!s(float64=5.9)\
    \ %!s(float64=4) %!s(float64=4) %!s(float64=5) %!s(float64=5) %!s(float64=1)]'\n\
    \    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpqok1htdr_test.go:49:\
    \ expected '[%!s(float64=2) %!s(float64=2.2)]', got '[%!s(float64=1) %!s(float64=2)\
    \ %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5)\
    \ %!s(float64=5) %!s(float64=2.2) %!s(float64=2.2) %!s(float64=1)]'\n    --- FAIL:\
    \ TestFind_Closest_Elements/test_num__3 (0.00s)\n        tmpqok1htdr_test.go:49:\
    \ expected '[%!s(float64=2) %!s(float64=2)]', got '[%!s(float64=1) %!s(float64=2)\
    \ %!s(float64=2) %!s(float64=3) %!s(float64=3) %!s(float64=4) %!s(float64=4) %!s(float64=5)\
    \ %!s(float64=5) %!s(float64=2) %!s(float64=2) %!s(float64=1)]'\n    --- FAIL:\
    \ TestFind_Closest_Elements/test_num__4 (0.00s)\n        tmpqok1htdr_test.go:49:\
    \ expected '[%!s(float64=2.2) %!s(float64=3.1)]', got '[%!s(float64=1.1) %!s(float64=2.2)\
    \ %!s(float64=2.2) %!s(float64=3.1) %!s(float64=3.1) %!s(float64=4.1) %!s(float64=4.1)\
    \ %!s(float64=5.1) %!s(float64=5.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) <= 1 {\n        return numbers\n\
    \    }\n    min := numbers[0]\n    max := numbers[0]\n    for _, num := range\
    \ numbers {\n        if num < min {\n            min = num\n        } else if\
    \ num > max {\n            max = num\n        }\n    }\n    return []interface{}{min,\
    \ max}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk5fg_p49_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the smallest and largest numbers in\
    \ the given list\n    smallestNum := numbers[0]\n    largestNum := numbers[0]\n\
    \    for _, num := range numbers {\n        if smallestNum == 0 {\n          \
    \  smallestNum = num\n        } else {\n            if num < smallestNum {\n \
    \               smallestNum = num\n            }\n        }\n        if largestNum\
    \ == 0 {\n            largestNum = num\n        } else {\n            if num >\
    \ largestNum {\n                largestNum = num\n            }\n        }\n \
    \   }\n\n    // Find the two numbers that are closest to each other and return\
    \ them in order\n    var smallestNum2 interface{}\n    var largestNum2 interface{}\n\
    \    var smallestNum2Ind int\n    var largestNum2Ind int\n    for i := 1; i <\
    \ len(numbers); i++ {\n        if numbers[smallestNum2Ind] < numbers[smallestNum]\
    \ {\n            smallestNum2 = numbers[smallestNum2Ind]\n            smallestNum2Ind\
    \ = i\n        }\n        if numbers[largestNum2Ind] > numbers[largestNum] {\n\
    \            largestNum2 = numbers[largestNum2Ind]\n            largestNum2Ind\
    \ = i\n        }\n    }\n    return []interface{}{smallestNum2, largestNum2}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt9lg4bxs_test.go:41:47: invalid argument: index smallestNum (variable
    of type float64) must be integer

    /tmp/tmpt9lg4bxs_test.go:45:46: invalid argument: index largestNum (variable of
    type float64) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074853
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil {\n        return nil\n  \
    \  }\n\n    sort.Float64s(numbers)\n\n    // Use a two element slice to save the\
    \ two elements we want to return\n    result := []interface{}{}\n    smallest\
    \ := numbers[0]\n    second := numbers[0]\n    i := 0\n    for i := 1; i < len(numbers);\
    \ i++ {\n        third := numbers[i]\n        if third < smallest {\n        \
    \    smallest = third\n            second = i\n        } else if third > smallest\
    \ {\n            if numbers[second] == smallest {\n                result[0] =\
    \ smallest // replace the first one\n                result[1] = third // replace\
    \ the second one\n                break\n            }\n\n            result[0]\
    \ = numbers[second]\n            result[1] = smallest // replace the second one\
    \ with the smallest one\n            break\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoob0i6hj_test.go:19:5: undefined: sort

    /tmp/tmpoob0i6hj_test.go:25:5: i declared but not used

    /tmp/tmpoob0i6hj_test.go:30:22: cannot use i (variable of type int) as type float64
    in assignment

    /tmp/tmpoob0i6hj_test.go:32:24: invalid argument: index second (variable of type
    float64) must be integer

    /tmp/tmpoob0i6hj_test.go:38:33: invalid argument: index second (variable of type
    float64) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    var result []interface{}\n\n    // Scan the first two numbers and\
    \ see what number is closer to them.\n    result := append(result, numbers[1])\n\
    \    diff := numbers[1] - numbers[0]\n    if diff > 0 {\n        diff *= -1\n\
    \    }\n    diff *= diff\n    if diff < math.MaxFloat64 {\n        result = append(result,\
    \ numbers[0])\n        diff += numbers[0]\n    } else {\n        diff /= 2\n \
    \   }\n\n    // Scan the second two numbers and see what number is closer to them.\n\
    \    result := append(result, numbers[2])\n    diff := numbers[2] - numbers[1]\n\
    \    if diff > 0 {\n        diff *= -1\n    }\n    diff *= diff\n    if diff <\
    \ math.MaxFloat64 {\n        result = append(result, numbers[1])\n        diff\
    \ += numbers[1]\n    } else {\n        diff /= 2\n    }\n\n    return result\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl9dpoiw9_test.go:22:12: no new variables on left side of :=

    /tmp/tmpl9dpoiw9_test.go:28:15: undefined: math

    /tmp/tmpl9dpoiw9_test.go:36:12: no new variables on left side of :=

    /tmp/tmpl9dpoiw9_test.go:37:10: no new variables on left side of :=

    /tmp/tmpl9dpoiw9_test.go:42:15: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    numbers := numbers[:len(numbers)-1]\n    if len(numbers) < 2 {\n \
    \       return nil\n    }\n    sort.Float64s(numbers)\n    numbers := numbers[:len(numbers)-1]\n\
    \    return numbers[:2]\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qo_yzmm_test.go:18:13: no new variables on left side of :=

    /tmp/tmp4qo_yzmm_test.go:22:5: undefined: sort

    /tmp/tmp4qo_yzmm_test.go:23:13: no new variables on left side of :=

    /tmp/tmp4qo_yzmm_test.go:24:19: cannot use numbers[:2] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(ByFloat64(numbers))\n\n    // Find\
    \ two closest numbers to the numbers we are given.\n    var twoClosestNumbers\
    \ []float64\n    var closestNumber float64\n    var closestDistance float64\n\
    \    for i := 0; i < len(numbers); i++ {\n        twoClosestNumbers = append(twoClosestNumbers,\
    \ numbers[i])\n        closestNumber = numbers[i]\n        closestDistance = i\n\
    \    }\n\n    // If there are more than two numbers, return all of them.\n   \
    \ if len(twoClosestNumbers) > 2 {\n        return twoClosestNumbers\n    }\n\n\
    \    // If we are given one number, return it twice.\n    if len(twoClosestNumbers)\
    \ == 1 {\n        return twoClosestNumbers\n    }\n\n    // For two closest numbers,\
    \ find the smallest distance.\n    for i := 0; i < len(twoClosestNumbers)-1; i++\
    \ {\n        if closestDistance > i {\n            closestNumber = twoClosestNumbers[i]\n\
    \            closestDistance = i\n        } else {\n            if closestDistance\
    \ == i {\n                if twoClosestNumbers[i+1] - closestNumber < closestDistance\
    \ - i {\n                    closestNumber = twoClosestNumbers[i]\n          \
    \          closestDistance = i\n                }\n            } else {\n    \
    \            if twoClosestNumbers[i+1] - closestNumber > closestDistance - i {\n\
    \                    closestNumber = twoClosestNumbers[i]\n                  \
    \  closestDistance = i\n                }\n            }\n        }\n    }\n\n\
    \    return []interface{}{closestNumber, closestNumber}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyc_d3flh_test.go:15:5: undefined: sort

    /tmp/tmpyc_d3flh_test.go:15:15: undefined: ByFloat64

    /tmp/tmpyc_d3flh_test.go:24:27: cannot use i (variable of type int) as type float64
    in assignment

    /tmp/tmpyc_d3flh_test.go:29:16: cannot use twoClosestNumbers (variable of type
    []float64) as type []interface{} in return statement

    /tmp/tmpyc_d3flh_test.go:34:16: cannot use twoClosestNumbers (variable of type
    []float64) as type []interface{} in return statement

    /tmp/tmpyc_d3flh_test.go:39:30: invalid operation: closestDistance > i (mismatched
    types float64 and int)

    /tmp/tmpyc_d3flh_test.go:41:31: cannot use i (variable of type int) as type float64
    in assignment

    /tmp/tmpyc_d3flh_test.go:43:35: invalid operation: closestDistance == i (mismatched
    types float64 and int)

    /tmp/tmpyc_d3flh_test.go:44:61: invalid operation: closestDistance - i (mismatched
    types float64 and int)

    /tmp/tmpyc_d3flh_test.go:46:39: cannot use i (variable of type int) as type float64
    in assignment

    /tmp/tmpyc_d3flh_test.go:46:39: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    var smallerNum float64 = numbers[0]\n    var largerNum float64 =\
    \ numbers[0]\n    for _, num := range numbers[1:] {\n        if num < smallerNum\
    \ {\n            smallerNum = num\n        } else {\n            largerNum = num\n\
    \        }\n    }\n\n    return []interface{}{smallerNum, largerNum}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp1k_y6ems_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp1k_y6ems_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp1k_y6ems_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp1k_y6ems_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp1k_y6ems_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil {\n        return []interface{}{}\n\
    \    }\n    first := numbers[0]\n    second := numbers[1]\n    third := numbers[2]\n\
    \    fourth := numbers[3]\n    fifth := numbers[4]\n\n    if abs(first) > abs(second)\
    \ {\n        if abs(first) > abs(third) {\n            if abs(first) > abs(fourth)\
    \ {\n                if abs(first) > abs(fifth) {\n                    if abs(first)\
    \ < abs(second) {\n                        if abs(third) < abs(fourth) {\n   \
    \                         if abs(third) < abs(fifth) {\n                     \
    \           return []interface{}{second, third}\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return []interface{}{second, fourth}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprptlo7xp_test.go:24:8: undefined: abs

    /tmp/tmprptlo7xp_test.go:25:12: undefined: abs

    /tmp/tmprptlo7xp_test.go:26:16: undefined: abs

    /tmp/tmprptlo7xp_test.go:27:20: undefined: abs

    /tmp/tmprptlo7xp_test.go:28:24: undefined: abs

    /tmp/tmprptlo7xp_test.go:29:28: undefined: abs

    /tmp/tmprptlo7xp_test.go:30:32: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    n := len(numbers)\n    if n == 0 {\n       \
    \ return []interface{}{}\n    }\n    biggest := numbers[0]\n    smallest := numbers[0]\n\
    \    for i := 1; i < n; i++ {\n        if numbers[i] < smallest {\n          \
    \  smallest = numbers[i]\n        } else if numbers[i] > biggest {\n         \
    \   biggest = numbers[i]\n        }\n    }\n\n    first := make([]interface{},\
    \ 0)\n    second := make([]interface{}, 0)\n\n    if smallest == biggest {\n \
    \       return first\n    }\n\n    if smallest < biggest {\n        first = append(first,\
    \ smallest)\n        second = append(second, biggest)\n    } else {\n        first\
    \ = append(first, biggest)\n        second = append(second, smallest)\n    }\n\
    \    return first\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpex8557fk_test.go:63: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpex8557fk_test.go:63: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpex8557fk_test.go:63: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpex8557fk_test.go:63: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpex8557fk_test.go:63: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074855
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    numbers := numbers[:len(numbers)-1]\n    numbers := append(numbers,\
    \ numbers[0])\n    for i := len(numbers) - 1; i > 1; i-- {\n        if numbers[i]\
    \ < numbers[i-1] {\n            numbers := numbers[:i]\n            break\n  \
    \      }\n    }\n    return numbers[1:]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw6b52npv_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpw6b52npv_test.go:19:13: no new variables on left side of :=

    /tmp/tmpw6b52npv_test.go:20:13: no new variables on left side of :=

    /tmp/tmpw6b52npv_test.go:23:13: numbers declared but not used

    /tmp/tmpw6b52npv_test.go:27:19: cannot use numbers[1:] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074854
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Get all numbers\n    var numbers []float64\n\
    \    for _, n := range numbers {\n        numbers = append(numbers, n)\n    }\n\
    \    if len(numbers) < 2 {\n        return nil\n    }\n    // Get min and max\n\
    \    min := numbers[0]\n    max := numbers[0]\n    for _, n := range numbers {\n\
    \        if n < min {\n            min = n\n        }\n        if n > max {\n\
    \            max = n\n        }\n    }\n    // Select only 2 numbers in the given\
    \ range\n    min += 0.0001\n    max += 0.0001\n    found := false\n    for i :=\
    \ 0; i < len(numbers); i++ {\n        diff := numbers[i] - min\n        if diff\
    \ < 0 {\n            diff = diff * -1\n        }\n        diff *= diff\n     \
    \   if diff < max {\n            if diff > min {\n                return []interface{}{numbers[i],\
    \ numbers[(i+1)%len(numbers)]}\n            } else {\n                return []interface{}{numbers[i],\
    \ numbers[(i-1)%len(numbers)]}\n            }\n        } else if diff > max {\n\
    \            diff = max - diff\n            if diff > min {\n                return\
    \ []interface{}{numbers[i], numbers[(i-1)%len(numbers)]}\n            } else {\n\
    \                return []interface{}{numbers[i], numbers[(i+1)%len(numbers)]}\n\
    \            }\n        }\n    }\n    // No numbers found with given range\n \
    \   return nil\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe02a6yor_test.go:16:9:\
    \ numbers redeclared in this block\n\t/tmp/tmpe02a6yor_test.go:14:28: other declaration\
    \ of numbers\n/tmp/tmpe02a6yor_test.go:37:5: found declared but not used\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074855
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find two numbers from the given numbers list\
    \ that are the closest to each other.\n    // The numbers are chosen with the\
    \ smaller numbers first and larger numbers second.\n    // This guarantees a solution\
    \ that has one element from each of the two lists.\n    var closestToEach []float64\n\
    \    var closestToEachIndex int\n    for i := 1; i < len(numbers); i++ {\n   \
    \     diff := numbers[i] - numbers[i-1]\n        if diff < 0 {\n            //\
    \ If the difference between the numbers we are looking at is negative, we need\
    \ to\n            // move to the next number.\n            closestToEachIndex++\n\
    \        } else {\n            // Otherwise, we can keep moving forward...\n \
    \           closestToEachIndex = 0\n            closestToEach = append(closestToEach,\
    \ numbers[i-1])\n        }\n        if closestToEachIndex == 2 {\n           \
    \ // At this point, we have found the two closest numbers. We need to return them\n\
    \            // in order because they are in different lists.\n            return\
    \ closestToEach\n        }\n    }\n    return nil\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpecldb0d7_test.go:34:20: cannot use closestToEach (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074855
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, num := range numbers[1:] {\n        if num < smallest {\n        \
    \    smallest = num\n        } else if num > largest {\n            largest =\
    \ num\n        }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpnl8ogoly_test.go:44: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpnl8ogoly_test.go:44: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpnl8ogoly_test.go:44: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpnl8ogoly_test.go:44: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpnl8ogoly_test.go:44: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074856
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    biggest := numbers[0]\n    smallest := numbers[0]\n    index :=\
    \ 0\n    for index < len(numbers)-1 {\n        if numbers[index] > biggest {\n\
    \            biggest = numbers[index]\n        }\n\n        if numbers[index]\
    \ < smallest {\n            smallest = numbers[index]\n        }\n\n        index++\n\
    \    }\n\n    return []interface{}{smallest, biggest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpptlbkuyb_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpptlbkuyb_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpptlbkuyb_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpptlbkuyb_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpptlbkuyb_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=4.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    arr := make([]interface{}, 2, 2)\n    arr[0] = numbers[0]\n    arr[1]\
    \ = numbers[0]\n    var index int = 0\n    for _, number := range numbers {\n\
    \        if arr[0] > number {\n            arr[0] = number\n            index\
    \ = index + 1\n        }\n        if arr[1] < number {\n            arr[1] = number\n\
    \        }\n    }\n    return arr[:index]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ccfukjv_test.go:23:12: invalid operation: arr[0] > number (operator >
    not defined on interface)

    /tmp/tmp7ccfukjv_test.go:27:12: invalid operation: arr[1] < number (operator <
    not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    sort.Float64s(numbers)\n\n    index := 1\n    difference := numbers[index]\
    \ - numbers[index-1]\n    for index != len(numbers) {\n        difference = numbers[index]\
    \ - numbers[index-1]\n        if difference > 0 {\n            index += 1\n  \
    \      } else {\n            index -= 1\n        }\n    }\n\n    return []interface{}{numbers[index-1],\
    \ numbers[index]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf7at2wn3_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var numbers_sorted = make([]interface{}, len(numbers))\n\
    \    for i := range numbers {\n        numbers_sorted[i] = numbers[i]\n    }\n\
    \    sort.Sort(sort.Reverse(sort.Float64Slice(numbers_sorted)))\n\n    i := 0\n\
    \    var smallest_number float64\n    for j := range numbers_sorted {\n      \
    \  if numbers_sorted[j] < smallest_number {\n            smallest_number = numbers_sorted[j]\n\
    \        }\n        if j == 0 {\n            numbers_sorted[0] = smallest_number\n\
    \            continue\n        }\n        if numbers_sorted[j] == numbers_sorted[0]\
    \ {\n            numbers_sorted[0] = smallest_number\n            numbers_sorted[1]\
    \ = numbers_sorted[j-1]\n            numbers_sorted[j] = numbers_sorted[j-1]\n\
    \            continue\n        }\n        if numbers_sorted[j-1] < numbers_sorted[j]\
    \ {\n            numbers_sorted[0] = smallest_number\n            numbers_sorted[1]\
    \ = numbers_sorted[j-1]\n            numbers_sorted[j] = numbers_sorted[j-1]\n\
    \            numbers_sorted[j-1] = numbers_sorted[j]\n        }\n        i++\n\
    \    }\n    return numbers_sorted\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc7idmxry_test.go:19:5:\
    \ undefined: sort\n/tmp/tmpc7idmxry_test.go:24:12: invalid operation: numbers_sorted[j]\
    \ < smallest_number (operator < not defined on interface)\n/tmp/tmpc7idmxry_test.go:25:31:\
    \ cannot use numbers_sorted[j] (variable of type interface{}) as type float64\
    \ in assignment:\n\tneed type assertion\n/tmp/tmpc7idmxry_test.go:37:12: invalid\
    \ operation: numbers_sorted[j - 1] < numbers_sorted[j] (operator < not defined\
    \ on interface)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers := make([]float64, len(numbers))\n \
    \   for i, n := range numbers {\n        if n < numbers[0] {\n            numbers[i]\
    \ = n\n            numbers[0] = n\n        }\n    }\n    indices := make([]int,\
    \ len(numbers))\n    for i, n := range numbers {\n        numbers[i] -= numbers[0]\n\
    \        indices[i] = i\n    }\n    numbers.Sort()\n    return numbers[indices[0]:indices[1]]\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiygqw5jw_test.go:15:13: no new variables on left side of :=

    /tmp/tmpiygqw5jw_test.go:23:12: n declared but not used

    /tmp/tmpiygqw5jw_test.go:27:13: numbers.Sort undefined (type []float64 has no
    field or method Sort)

    /tmp/tmpiygqw5jw_test.go:28:19: cannot use numbers[indices[0]:indices[1]] (value
    of type []float64) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    lenNumber := len(numbers)\n    if lenNumber\
    \ < 2 {\n        return nil\n    }\n    number1, number2 := numbers[0], numbers[0]\n\
    \    i := 1\n    for i < lenNumber {\n        number1 = numbers[i]\n        number2\
    \ = numbers[i-1]\n        if number2 > number1 {\n            break\n        }\n\
    \        i += 2\n    }\n    result := []interface{}{number1, number2}\n    return\
    \ append(result, numbers[lenNumber-1])\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp8rxqqwhn_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=2.2) %!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp8rxqqwhn_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=4) %!s(float64=5.9) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp8rxqqwhn_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=2.2) %!s(float64=5) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp8rxqqwhn_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=2) %!s(float64=5) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp8rxqqwhn_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=4.1) %!s(float64=3.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074857
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Create a list of two empty lists - one where\
    \ we store our results\n    // and one where we keep track of our current best\
    \ result.\n    smallest := []interface{}{}\n    largest = []interface{}{}\n  \
    \  smallest := append(smallest, numbers[0])\n    largest := append(largest, numbers[0])\n\
    \    smallest[0] = numbers[0]\n\n    // Iterate through the entire list of numbers\
    \ and see if they're\n    // close to eachother. If they are put them into the\
    \ smallest and\n    // largest lists.\n    for _, number := range numbers[1:]\
    \ {\n        // The numbers themselves are always going to be the same, so we\n\
    \        // can safely compare them using ==. Since we are comparing\n       \
    \ // against another number, and we know they are the same type, we\n        //\
    \ can safely compare them using ==.\n        if number == smallest[0] {\n    \
    \        smallest = []interface{}{number}\n        } else {\n            // If\
    \ the new number we're working with is less than the one\n            // currently\
    \ in the smallest list, then we push it into the\n            // smallest list,\
    \ and update the current number we're working with.\n            if number < smallest[0]\
    \ {\n                smallest = append(smallest, number)\n                smallest[0]\
    \ = number\n            }\n        }\n\n        // If the new number we're working\
    \ with is larger than the one\n        // currently in the largest list, then\
    \ we push it into the largest\n        // list, and update the current number\
    \ we're working with.\n        if number > largest[0] {\n            largest =\
    \ append(largest, number)\n            largest[0] = number\n        }\n    }\n\
    \    return append(smallest, largest)\n}\n</code>\n<|/ a |>\n<| c |>\nHi, the\
    \ code is not working when the list has negative numbers. Can you please suggest\
    \ a modification to handle negative numbers?\n<|/ c |>\n<| c |>\nThank you so\
    \ much for the solution. It works great.\n<|/ c |>\n<| c |>\nHi, the code is not\
    \ working when the list has negative numbers. Can you please suggest a modification\
    \ to handle negative numbers?\n<|/ c |>\n<| c |>\nThank you for following up and\
    \ sharing your code. The code works perfectly. Just want to know if the code can\
    \ be optimized further?\n<|/ c |>\n<| c |>\nThe code is actually pretty straightforward\
    \ to read and follow. How can it be optimized further? It's basically the logic\
    \ of what it does.\n<|/ c |>\n<| a tags=algorithm,list,python,arrays,sorting |>\n\
    A python solution based on the answer:\n<code>\ndef sort2(x,y):\n    if \nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplnq56p12_test.go:53:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074855
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest, _ := math.Abs(numbers[0])\n    largest := numbers[0]\n \
    \   for _, number := range numbers {\n        if number > largest {\n        \
    \    largest = number\n        }\n        if number < smallest {\n           \
    \ smallest = number\n        }\n    }\n    return []interface{}{smallest, largest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyv1hmjm9_test.go:18:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n    closestToBothIndexes\
    \ := make([]int, len(numbers))\n    closestToBothIndexes[0] = 1\n    closestToBothIndexes[1]\
    \ = 1\n    for i := 2; i < len(numbers); i++ {\n        distance := 0\n      \
    \  numberToCompare := numbers[closestToBothIndexes[i-2]]\n        for j := i -\
    \ 1; j >= 0; j-- {\n            distance += math.Abs(numbers[j] - numberToCompare)\n\
    \            numberToCompare = numbers[j]\n        }\n        if distance < numbers[closestToBothIndexes[i]]\
    \ {\n            closestToBothIndexes[i] = closestToBothIndexes[i-2]\n       \
    \     closestToBothIndexes[i-2] = i\n        }\n    }\n    return numbers[closestToBothIndexes[len(numbers)-1]\
    \ : closestToBothIndexes[0] : closestToBothIndexes]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb4tuo2a_test.go:15:5: undefined: sort

    /tmp/tmphb4tuo2a_test.go:23:25: undefined: math

    /tmp/tmphb4tuo2a_test.go:26:23: invalid operation: distance < numbers[closestToBothIndexes[i]]
    (mismatched types int and float64)

    /tmp/tmphb4tuo2a_test.go:31:19: cannot use numbers[closestToBothIndexes[len(numbers)
    - 1]:closestToBothIndexes[0]:closestToBothIndexes] (value of type []float64) as
    type []interface{} in return statement

    /tmp/tmphb4tuo2a_test.go:31:85: invalid argument: index closestToBothIndexes (variable
    of type []int) must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074856
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    arr := make([]float64, 2)\n    arr[0] = numbers[0]\n    arr[1] = numbers[1]\n\
    \n    for i := 2; i < len(numbers); i++ {\n        if arr[0] - numbers[i-1] <\
    \ arr[0] - numbers[i] {\n            arr[0] = numbers[i-1]\n        } else {\n\
    \            arr[1] = numbers[i]\n        }\n    }\n    return []interface{}{arr[0],\
    \ arr[1]}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpbcs6j_ik_test.go:49: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=5) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpbcs6j_ik_test.go:49: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=5.9) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpbcs6j_ik_test.go:49: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=5) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpbcs6j_ik_test.go:49: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=5) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpbcs6j_ik_test.go:49: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    second := numbers[1]\n    return append([]interface{}{smallest,\
    \ second}, numbers[2:]...)\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp69a73vrq_test.go:20:59: cannot use numbers[2:] (value of type []float64)
    as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sorted_numbers := sort.Float64s(numbers)\n \
    \   smallest_number := sorted_numbers[0]\n    largest_number := sorted_numbers[len(sorted_numbers)-1]\n\
    \n    i := 0\n    result := make([]interface{}, 2)\n    for ; i < len(sorted_numbers);\
    \ i++ {\n        if sorted_numbers[i] == largest_number {\n            break\n\
    \        }\n        if sorted_numbers[i] == smallest_number {\n            if\
    \ i == 0 {\n                result[0] = smallest_number\n            } else {\n\
    \                result[1] = smallest_number\n            }\n            break\n\
    \        }\n        if sorted_numbers[i-1] <= smallest_number && sorted_numbers[i]\
    \ > smallest_number {\n            result[0] = smallest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] > smallest_number && sorted_numbers[i]\
    \ <= smallest_number {\n            result[1] = smallest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] <= largest_number && sorted_numbers[i]\
    \ > largest_number {\n            result[0] = largest_number\n            break\n\
    \        }\n        if sorted_numbers[i-1] > largest_number && sorted_numbers[i]\
    \ <= largest_number {\n            result[1] = largest_number\n            break\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3eqpn4l6_test.go:15:23: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    arr := make([]interface{}, len(numbers))\n\n\
    \    if len(numbers) < 2 {\n        return arr\n    }\n\n    arr[0] = math.Abs(numbers[0])\n\
    \    arr[1] = math.Abs(numbers[1])\n\n    for i := 2; i < len(numbers); i++ {\n\
    \        diff := math.Abs(numbers[i] - numbers[i-1])\n\n        if diff > arr[0]\
    \ {\n            arr[0] = diff\n            arr[1] = numbers[i-1]\n        } else\
    \ if diff < arr[0] {\n            arr[1] = diff\n            arr[0] = numbers[i-1]\n\
    \        }\n    }\n\n    return arr\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpct1tt2t6_test.go:21:14: undefined: math

    /tmp/tmpct1tt2t6_test.go:22:14: undefined: math

    /tmp/tmpct1tt2t6_test.go:25:17: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if lengthOfSlice(numbers) < 2 {\n        return\
    \ nil\n    }\n\n    smallestNum := numbers[0]\n    largestNum := numbers[0]\n\n\
    \    for _, number := range numbers {\n        if number < smallestNum {\n   \
    \         smallestNum = number\n        }\n\n        if number > largestNum {\n\
    \            largestNum = number\n        }\n    }\n\n    var result []interface{}\n\
    \n    if smallestNum == largestNum {\n        result = append(result, smallestNum)\n\
    \        return append(result, largestNum)\n    }\n\n    smallestIndex := -1\n\
    \    largestIndex := -1\n\n    for i := 1; i < lengthOfSlice(numbers); i++ {\n\
    \        if smallestNum > numbers[i] && largestNum < numbers[i] {\n          \
    \  if smallestIndex == -1 {\n                smallestIndex = i\n            }\
    \ else {\n                largestIndex = i\n            }\n        }\n    }\n\n\
    \    if smallestIndex == -1 {\n        result = append(result, smallestNum)\n\
    \    } else {\n        result = append(result, numbers[smallestIndex])\n    }\n\
    \n    if largestIndex == -1 {\n        result = append(result, largestNum)\n \
    \   } else {\n        result = append(result, numbers[largestIndex])\n    }\n\n\
    \    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0rgezkcw_test.go:15:8: undefined: lengthOfSlice

    /tmp/tmp0rgezkcw_test.go:42:21: undefined: lengthOfSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    var result []interface{}\n    var diff float64\n    var smaller, bigger\
    \ float64\n\n    for _, n := range numbers {\n        smaller, bigger = n, n\n\
    \    }\n\n    for _, n := range numbers[1:] {\n        diff := bigger - smaller\n\
    \        if diff < 0 {\n            smaller, bigger = n, n\n        } else {\n\
    \            bigger, smaller = n, n\n        }\n    }\n\n    result = append(result,\
    \ smaller)\n    result = append(result, bigger)\n    return result\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpij84ikvy_test.go:19:9: diff declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // If there are no numbers, return empty slice\n\
    \    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n    var smallest,\
    \ largest float64\n    for _, number := range numbers {\n        if smallest >\
    \ number {\n            smallest = number\n        }\n        if largest < number\
    \ {\n            largest = number\n        }\n    }\n\n    // If we are just looking\
    \ for the largest element, no need to bother with anything.\n    if smallest ==\
    \ largest {\n        return []interface{}{smallest}\n    }\n\n    // The first\
    \ and last elements are always the smallest and largest.\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp6wqrvqw5_test.go:56: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=0) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp6wqrvqw5_test.go:56: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=0) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp6wqrvqw5_test.go:56: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=0) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp6wqrvqw5_test.go:56: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=0) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp6wqrvqw5_test.go:56: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=0) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if numbers == nil || len(numbers) < 2 {\n  \
    \      return numbers\n    }\n    first := numbers[0]\n    second := numbers[1]\n\
    \    for i := 1; i < len(numbers); i++ {\n        thisNext := numbers[i]\n   \
    \     delta := thisNext - second\n        if delta > second {\n            delta\
    \ = second\n        } else if (delta < second) && (delta > first) {\n        \
    \    delta = second\n        }\n        second = thisNext\n        first = delta\n\
    \    }\n    return []interface{}{first, second}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozl1xonj_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    x := numbers[0]\n    y := numbers[1]\n\n    distance := x - y\n\n\
    \    if distance == 0.0 {\n        return nil\n    }\n\n    numbers := make([]interface{},\
    \ 2)\n    i := 0\n    for _, number := range numbers {\n        if number != y\
    \ {\n            numbers[i] = number\n            i++\n        }\n    }\n\n  \
    \  numbers[i] = y\n\n    return numbers\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3912cgc3_test.go:28:13: no new variables on left side of :=

    /tmp/tmp3912cgc3_test.go:28:16: cannot use make([]interface{}, 2) (value of type
    []interface{}) as type []float64 in assignment

    /tmp/tmp3912cgc3_test.go:39:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Slice(numbers, func(i, j int) bool {\n\
    \        return numbers[i] < numbers[j]\n    })\n\n    // Two smallest numbers\
    \ found so far.\n    smallest := numbers[0]\n    smallest += numbers[1]\n\n  \
    \  // Smallest number larger than smallest number to find closest to.\n    largest\
    \ = numbers[0]\n    for _, number := range numbers[1:] {\n        if number >\
    \ smallest {\n            largest = number\n        }\n    }\n    if largest-smallest\
    \ > 1 {\n        return nil\n    }\n    return []interface{}{smallest, largest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiti2z8i4_test.go:15:5: undefined: sort

    /tmp/tmpiti2z8i4_test.go:24:5: undefined: largest

    /tmp/tmpiti2z8i4_test.go:27:13: undefined: largest

    /tmp/tmpiti2z8i4_test.go:30:8: undefined: largest

    /tmp/tmpiti2z8i4_test.go:33:36: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Get the first two numbers\n    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    first_number := numbers[0]\n    second_number\
    \ := numbers[1]\n\n    // Now determine which of two numbers is closer to the\
    \ other\n    if first_number > second_number {\n        // The first number is\
    \ closer\n        index := 0\n    } else {\n        // The second number is closer\n\
    \        index = 1\n    }\n\n    // Find the smaller of the two\n    smallest\
    \ := first_number\n    second_smallest := second_number\n    if index == 0 {\n\
    \        second_smallest = numbers[1]\n    } else {\n        smallest = numbers[0]\n\
    \    }\n\n    // Now select from the remaining array and return in order\n   \
    \ result := make([]interface{}, 0, 2)\n    result <- smallest\n    result <- second_smallest\n\
    \    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgntpq01p_test.go:25:9: index declared but not used

    /tmp/tmpgntpq01p_test.go:28:9: undefined: index

    /tmp/tmpgntpq01p_test.go:34:8: undefined: index

    /tmp/tmpgntpq01p_test.go:42:5: invalid operation: cannot send to non-channel result
    (variable of type []interface{})

    /tmp/tmpgntpq01p_test.go:43:5: invalid operation: cannot send to non-channel result
    (variable of type []interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074857
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    numbers := make([]float64, 0, len(numbers))\n    for _, number :=\
    \ range numbers {\n        numbers = append(numbers, number)\n    }\n\n    var\
    \ min1, max1 float64\n    var min2, max2 float64\n    for _, number := range numbers\
    \ {\n        if min1 == 0 {\n            min1 = number\n        } else {\n   \
    \         min1 = min(min1, number)\n        }\n\n        if max1 == 0 {\n    \
    \        max1 = number\n        } else {\n            max1 = max(max1, number)\n\
    \        }\n    }\n\n    for _, number := range numbers {\n        if min2 ==\
    \ 0 {\n            min2 = number\n        } else {\n            min2 = min(min2,\
    \ number)\n        }\n\n        if max2 == 0 {\n            max2 = number\n  \
    \      } else {\n            max2 = max(max2, number)\n        }\n    }\n\n  \
    \  var closest []interface{}\n\n    if min1 <= max2 {\n        closest = []interface{}{min1,\
    \ min2}\n    } else {\n        closest = []interface{}{max2, max1}\n    }\n\n\
    \    return closest\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3t2vduwf_test.go:19:13: no new variables on left side of :=

    /tmp/tmp3t2vduwf_test.go:30:20: undefined: min

    /tmp/tmp3t2vduwf_test.go:36:20: undefined: max

    /tmp/tmp3t2vduwf_test.go:44:20: undefined: min

    /tmp/tmp3t2vduwf_test.go:50:20: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074858
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, largest := numbers[0], numbers[0]\n\
    \    i := 1\n    for number := range numbers {\n        if number < smallest {\n\
    \            smallest = number\n        } else if number > largest {\n       \
    \     largest = number\n        }\n        i++\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzxbhu86s_test.go:18:21: invalid operation: number < smallest (mismatched
    types int and float64)

    /tmp/tmpzxbhu86s_test.go:19:24: cannot use number (variable of type int) as type
    float64 in assignment

    /tmp/tmpzxbhu86s_test.go:20:28: invalid operation: number > largest (mismatched
    types int and float64)

    /tmp/tmpzxbhu86s_test.go:21:23: cannot use number (variable of type int) as type
    float64 in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074858
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    var ret []interface{}\n    var i int\n    var index int\n    for i\
    \ = 0; i < len(numbers); i++ {\n        index = i\n        for j = i + 1; j <\
    \ len(numbers); j++ {\n            if math.Abs(numbers[i]-numbers[j]) < math.Abs(numbers[i]-numbers[index])\
    \ {\n                index = j\n            }\n        }\n        ret = append(ret,\
    \ numbers[index])\n    }\n    return ret\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp25sd9zcs_test.go:23:13: undefined: j

    /tmp/tmp25sd9zcs_test.go:24:16: undefined: math

    /tmp/tmp25sd9zcs_test.go:24:44: undefined: j

    /tmp/tmp25sd9zcs_test.go:24:50: undefined: math

    /tmp/tmp25sd9zcs_test.go:25:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074858
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    var min1, max1, min2, max2 float64\n    for i, _ := range numbers\
    \ {\n        if min1 == 0 {\n            min1, max1 = numbers[i], numbers[i]\n\
    \        } else {\n            if min1 > numbers[i] {\n                min1 =\
    \ numbers[i]\n            }\n            if max1 < numbers[i] {\n            \
    \    max1 = numbers[i]\n            }\n        }\n    }\n    min2, max2 = numbers[0],\
    \ numbers[0]\n    for i, _ := range numbers {\n        if min2 == 0 {\n      \
    \      min2, max2 = numbers[i], numbers[i]\n        } else {\n            if min2\
    \ > numbers[i] {\n                min2 = numbers[i]\n            }\n         \
    \   if max2 < numbers[i] {\n                max2 = numbers[i]\n            }\n\
    \        }\n    }\n    result := []interface{}{}\n    if min1 < min2 {\n     \
    \   result = append(result, min1)\n        result = append(result, max2)\n   \
    \ }\n    if max1 > max2 {\n        result = append(result, max1)\n        result\
    \ = append(result, min2)\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpasdlaq6c_test.go:73: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n    \
    \    tmpasdlaq6c_test.go:73: expected '[%!s(float64=5) %!s(float64=5.9)]', got\
    \ '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpasdlaq6c_test.go:73:\
    \ expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpasdlaq6c_test.go:73: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n    \
    \    tmpasdlaq6c_test.go:73: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    min := math.MaxFloat64\n    min := math.MaxFloat64\n\
    \    nearest := numbers[0]\n    i := 0\n    for _, number := range numbers {\n\
    \        if math.Abs(number-nearest) < min {\n            min = math.Abs(number-nearest)\n\
    \            nearest = number\n        }\n        i++\n        if i%2 == 0 {\n\
    \            ret = append(ret, nearest)\n        }\n    }\n    return ret\n}\n\
    \nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf036nqim_test.go:15:12: undefined: math

    /tmp/tmpf036nqim_test.go:16:9: no new variables on left side of :=

    /tmp/tmpf036nqim_test.go:16:12: undefined: math

    /tmp/tmpf036nqim_test.go:20:12: undefined: math

    /tmp/tmpf036nqim_test.go:21:19: undefined: math

    /tmp/tmpf036nqim_test.go:26:26: undefined: ret

    /tmp/tmpf036nqim_test.go:29:12: undefined: ret

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    diff := math.Abs(numbers[1] - numbers[0])\n\n\
    \    for i := 2; i < len(numbers); i++ {\n        diff += math.Abs(numbers[i]\
    \ - numbers[i-1])\n    }\n    if diff <= math.MaxFloat64 {\n        return nil\n\
    \    }\n    closestIndex := 0\n    closestNumber := numbers[0]\n\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        diff := math.Abs(closestNumber - numbers[i])\n\
    \        if diff < diff {\n            closestIndex = i\n            closestNumber\
    \ = numbers[i]\n        }\n    }\n\n    sortedNumbers := make([]float64, 0, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        sortedNumbers = append(sortedNumbers,\
    \ numbers[i])\n    }\n    sortedNumbers = append(sortedNumbers, closestNumber)\n\
    \    return sortedNumbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n\
    \  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5o3ut2hz_test.go:15:13: undefined: math

    /tmp/tmp5o3ut2hz_test.go:18:17: undefined: math

    /tmp/tmp5o3ut2hz_test.go:20:16: undefined: math

    /tmp/tmp5o3ut2hz_test.go:23:5: closestIndex declared but not used

    /tmp/tmp5o3ut2hz_test.go:27:17: undefined: math

    /tmp/tmp5o3ut2hz_test.go:39:12: cannot use sortedNumbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    second := numbers[1]\n\
    \    index := 0\n    smallestIndex := -1\n    secondIndex := -1\n    for index\
    \ < len(numbers) {\n        if numbers[index] < smallest {\n            smallest\
    \ = numbers[index]\n            smallestIndex = index\n        }\n        if numbers[index]\
    \ > second {\n            second = numbers[index]\n            secondIndex = index\n\
    \        }\n        index++\n    }\n    return []interface{}{smallest, second}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb88yrtfk_test.go:18:5: smallestIndex declared but not used

    /tmp/tmpb88yrtfk_test.go:19:5: secondIndex declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n    smallest := numbers[0]\n\
    \    largest := numbers[0]\n\n    // find smallest and largest numbers in list\n\
    \    for _, number := range numbers[1:] {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n\n    var selected []interface{}\n\
    \    \n    smallest := smallest * 1000\n    largest := largest * 1000\n\n    if\
    \ smallest == largest {\n        selected = append(selected, smallest)\n     \
    \   return selected\n    }\n\n    // if smallest is bigger than largest, swap\
    \ them\n    if smallest > largest {\n        smallest := largest\n        largest\
    \ := smallest\n    }\n\n    // find middle of smallest and largest numbers\n \
    \   middle := (smallest + largest) / 2.0\n\n    // find elements in middle\n \
    \   for index, number := range numbers {\n        if number >= middle {\n    \
    \        selected = append(selected, number)\n        }\n    }\n\n    // find\
    \ closest element to middle number\n    for index, number := range numbers {\n\
    \        if number < middle {\n            continue\n        }\n\n        // if\
    \ number is greater than middle and is smaller than smallest or largest then add\
    \ this number to the selected array\n        if number > middle && number < smallest\
    \ || number > middle && number > largest {\n            selected = append(selected,\
    \ number)\n        }\n    }\n\n    // if selected array is empty, return nil\n\
    \    if len(selected) == 0 {\n        return nil\n    }\n    return selected\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5f4p7k9a_test.go:15:5: undefined: sort

    /tmp/tmp5f4p7k9a_test.go:31:14: no new variables on left side of :=

    /tmp/tmp5f4p7k9a_test.go:32:13: no new variables on left side of :=

    /tmp/tmp5f4p7k9a_test.go:42:9: largest declared but not used

    /tmp/tmp5f4p7k9a_test.go:49:9: index declared but not used

    /tmp/tmp5f4p7k9a_test.go:56:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest_number := numbers[0]\n    largest_number\
    \ := numbers[0]\n\n    if len(numbers) == 1 {\n        return numbers\n    }\n\
    \n    for _, number := range numbers[1:] {\n        if number < smallest_number\
    \ {\n            smallest_number = number\n        }\n        if number > largest_number\
    \ {\n            largest_number = number\n        }\n    }\n\n    return append([]interface{}{smallest_number},\
    \ find_closest_elements(numbers[:len(numbers)-1]), largest_number)\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx3fb4dj9_test.go:19:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n    smallestNumber :=\
    \ numbers[0]\n    largestNumber := numbers[len(numbers)-1]\n    closestToSmallest\
    \ := numbers[0]\n    closestToLargest := numbers[len(numbers)-1]\n    for _, number\
    \ := range numbers {\n        if smallestNumber > number {\n            smallestNumber\
    \ = number\n            closestToSmallest = number\n        }\n        if largestNumber\
    \ < number {\n            largestNumber = number\n            closestToLargest\
    \ = number\n        }\n    }\n    return []interface{}{smallestNumber, largestNumber}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwbhnhtux_test.go:15:5: undefined: sort

    /tmp/tmpwbhnhtux_test.go:18:5: closestToSmallest declared but not used

    /tmp/tmpwbhnhtux_test.go:19:5: closestToLargest declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var smallest int = 0\n    var largest int =\
    \ 0\n    var temp1 float64\n    var temp2 float64\n\n    for _, num := range numbers\
    \ {\n        if smallest > num {\n            smallest = num\n        }\n    \
    \    if largest < num {\n            largest = num\n        }\n    }\n\n    if\
    \ smallest > largest {\n        temp1 = smallest\n        temp2 = largest\n  \
    \      smallest = largest\n        largest = temp1\n    }\n\n    var returnArray\
    \ []interface{}\n    returnArray = append(returnArray, smallest)\n    returnArray\
    \ = append(returnArray, largest)\n    return returnArray\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdb25n4lg_test.go:21:23: invalid operation: smallest > num (mismatched
    types int and float64)

    /tmp/tmpdb25n4lg_test.go:22:24: cannot use num (variable of type float64) as type
    int in assignment

    /tmp/tmpdb25n4lg_test.go:24:22: invalid operation: largest < num (mismatched types
    int and float64)

    /tmp/tmpdb25n4lg_test.go:25:23: cannot use num (variable of type float64) as type
    int in assignment

    /tmp/tmpdb25n4lg_test.go:30:17: cannot use smallest (variable of type int) as
    type float64 in assignment

    /tmp/tmpdb25n4lg_test.go:31:17: cannot use largest (variable of type int) as type
    float64 in assignment

    /tmp/tmpdb25n4lg_test.go:33:19: cannot use temp1 (variable of type float64) as
    type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the smallest number and the largest\
    \ number in the supplied list\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest {\n      \
    \      smallest = number\n        }\n        if number > largest {\n         \
    \   largest = number\n        }\n    }\n\n    // If the list is smaller than two\
    \ numbers return an empty list\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    // Sort the numbers and get the two numbers that are closest\n \
    \   sort.Float64s(numbers)\n    closest1, closest2 := math.Abs(numbers[0] - smallest),\
    \ math.Abs(largest - numbers[0])\n\n    for i := 0; i < len(numbers); i++ {\n\
    \        if math.Abs(numbers[i] - smallest) < closest1 {\n            closest1\
    \ = math.Abs(numbers[i] - smallest)\n            closest2 = numbers[i]\n     \
    \   } else if math.Abs(numbers[i] - largest) < closest2 {\n            closest2\
    \ = math.Abs(numbers[i] - largest)\n            closest1 = numbers[i]\n      \
    \  }\n    }\n\n    // Return the two closest numbers to the supplied numbers\n\
    \    return []interface{}{closest1, closest2}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptnl_4ohz_test.go:33:5: undefined: sort

    /tmp/tmptnl_4ohz_test.go:34:27: undefined: math

    /tmp/tmptnl_4ohz_test.go:37:12: undefined: math

    /tmp/tmptnl_4ohz_test.go:38:24: undefined: math

    /tmp/tmptnl_4ohz_test.go:40:19: undefined: math

    /tmp/tmptnl_4ohz_test.go:41:24: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    closestMin := numbers[0]\n    closestMax :=\
    \ numbers[0]\n    currentMin := numbers[0]\n    currentMax := numbers[0]\n\n \
    \   // If the length is less than two then return no values\n    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    // Loop through the numbers\n    for\
    \ _, number := range numbers {\n        // If the current number is greater than\
    \ the previous min number\n        if number > currentMax {\n            // Set\
    \ the new number\n            currentMax = number\n        }\n\n        // If\
    \ the current number is less than the previous max number\n        if number <\
    \ currentMin {\n            // Set the new number\n            currentMin = number\n\
    \        }\n\n        // If the current number is the same as the previous min\
    \ or max\n        if number == currentMin || number == currentMax {\n        \
    \    continue\n        }\n\n        // If the current number is closer to the\
    \ current min\n        if number < closestMin {\n            // Set the new closest\
    \ min number\n            closestMin = number\n        }\n\n        // If the\
    \ current number is closer to the current max\n        if number > closestMax\
    \ {\n            // Set the new closest max number\n            closestMax = number\n\
    \        }\n    }\n\n    // Return the two closest numbers\n    return []interface{}{closestMin,\
    \ closestMax}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp29eoap3d_test.go:78: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp29eoap3d_test.go:78: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp29eoap3d_test.go:78: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp29eoap3d_test.go:78: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp29eoap3d_test.go:78: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var smallest, larger float64\n    var closest\
    \ []float64\n    var i int\n\n    // check that the list contains at least two\
    \ values\n    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\n\
    \    smallest = numbers[0]\n    larger = numbers[1]\n\n    for i = 2; i < len(numbers);\
    \ i++ {\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \        } else if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \        } else {\n            continue\n        }\n\n        if numbers[i] <\
    \ smallest {\n            closest = append(closest, smallest)\n        } else\
    \ {\n            closest = append(closest, largest)\n        }\n\n        if numbers[i]\
    \ > largest {\n            closest = append(closest, largest)\n        } else\
    \ {\n            closest = append(closest, smallest)\n        }\n    }\n\n   \
    \ return closest\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,go\
    \ |>\nThis is an older question, but I've found an answer that seems to be much\
    \ more efficient:\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw879asq3_test.go:51:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    numbersInOrder, numbersInOrder := append([]interface{}{}, smallest),\
    \ append([]interface{}{}, largest)\n    for i := 0; i < len(numbersInOrder)-1;\
    \ i++ {\n        if numbersInOrder[i] > numbersInOrder[i+1] {\n            numbersInOrder,\
    \ numbersInOrder = append([]interface{}{}, smallest), append([]interface{}{},\
    \ largest)\n            break\n        }\n    }\n    return numbersInOrder\n}\n\
    \nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz8qzymqt_test.go:28:21: numbersInOrder repeated on left side of :=

    /tmp/tmpz8qzymqt_test.go:30:12: invalid operation: numbersInOrder[i] > numbersInOrder[i
    + 1] (operator > not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n\n    var result []interface{}\n\
    \    smallest, largest := numbers[0], numbers[0]\n    for _, number := range numbers[1:]\
    \ {\n        if number < smallest {\n            smallest = number\n        }\n\
    \n        if number > largest {\n            largest = number\n        }\n   \
    \ }\n\n    if smallest != largest {\n        result = append(result, smallest,\
    \ largest)\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2c5xikd1_test.go:15:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) <= 1 {\n        return nil\n\
    \    }\n    smallest1 := numbers[0]\n    smallest2 := numbers[0]\n    secondSmallest\
    \ := numbers[1]\n\n    for _, num := range numbers[1:] {\n        if num < smallest1\
    \ {\n            secondSmallest = smallest2\n            smallest1 = num\n   \
    \     }\n\n        if smallest1 < num {\n            secondSmallest = num\n  \
    \          smallest2 = num\n        }\n    }\n\n    return []interface{}{smallest1,\
    \ secondSmallest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp4hslhzug_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp4hslhzug_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp4hslhzug_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp4hslhzug_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp4hslhzug_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    n := numbers[0]\n    numbers = numbers[1:]\n    numbers = append(numbers,\
    \ n)\n\n    closest1 := -1\n    closest2 := -1\n\n    for _, number := range numbers\
    \ {\n        if closest1 != -1 {\n            if number < numbers[closest1] {\n\
    \                closest1 = -1\n            } else {\n                closest\
    \ = number\n            }\n        }\n\n        if closest2 != -1 {\n        \
    \    if number > numbers[closest2] {\n                closest2 = -1\n        \
    \    } else {\n                closest = number\n            }\n        }\n  \
    \  }\n    return []interface{}{closest1, closest2}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_4fo4gb_test.go:30:17: undefined: closest

    /tmp/tmpv_4fo4gb_test.go:38:17: undefined: closest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    largest1 := numbers[0]\n\
    \    largest2 := numbers[0]\n    if len(numbers) < 2 {\n        fmt.Println(\"\
    len(numbers) must be greater than 1\")\n        return nil\n    }\n    if len(numbers)\
    \ == 2 {\n        return numbers\n    }\n\n    // Find the smallest number\n \
    \   for i := 1; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n        }\n    }\n    // Find the largest\
    \ number\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > largest1\
    \ {\n            largest1 = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            largest2 = numbers[i]\n        }\n    }\n    // Return the smallest\
    \ number followed by the largest number\n    return []interface{}{smallest, largest2}\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThank you for the response. I would like to find\
    \ a way to modify this algorithm to find 2 numbers (not one number) that are closest\
    \ to each other. For example if the input is [3.0,1.2,3.6,3.5,3.2] then the output\
    \ should be [1,3]. I would like to use a binary search algorithm to find the smallest\
    \ and largest number. Can you help me with this? Thank you.\n<|/ c |>\n<| c |>\n\
    I updated the post to include a new algorithm.  I ran a quick test and it is working\
    \ properly.\n<|/ c |>\n<| c |>\nI ran the test with your input and it is giving\
    \ me an incorrect output. I think it is returning a list of 2 numbers that are\
    \ the closest to the input but the output should only have one number in the list.\
    \ Can you please take a look? Thanks.\n<|/ c |>\n<| c |>\nThe output should be\
    \ a single number not a list of 2 numbers.  If you look at my example, I showed\
    \ that the output is a list of 2 numbers.\n<|/ c |>\n<| c |>\nOh yes sorry I see\
    \ now. Thank you very much. This is exactly what I was looking for.\n<|/ c |>\n\
    <| a |>\nHere's my solution. It may not be very efficient, but it is simple and\
    \ short.\nIt works by sorting the list by the absolute value of the difference\
    \ between the input and the current item, then finding the first pair with a difference\
    \ of 0. If none are found, it returns the input.\n<code>\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb4ge2cyh_test.go:44:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        fmt.Printf(\"\
    find_closest_elements requires at least 2 numbers.\\n\")\n        return []interface{}{}\n\
    \    }\n\n    smallest := numbers[0]\n    largest := numbers[0]\n    i := 1\n\
    \    for number := range numbers {\n        if number < smallest {\n         \
    \   smallest = number\n        } else if number > largest {\n            largest\
    \ = number\n        }\n        i++\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2tac0i0z_test.go:24:21: invalid operation: number < smallest (mismatched
    types int and float64)

    /tmp/tmp2tac0i0z_test.go:25:24: cannot use number (variable of type int) as type
    float64 in assignment

    /tmp/tmp2tac0i0z_test.go:26:28: invalid operation: number > largest (mismatched
    types int and float64)

    /tmp/tmp2tac0i0z_test.go:27:23: cannot use number (variable of type int) as type
    float64 in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074859
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \n    closest := make([]interface{}, 2)\n    for i := 0; i < len(numbers); i +=\
    \ 2 {\n        closest[i] = numbers[i]\n        closest[i+1] = numbers[i+1]\n\
    \    }\n    return closest\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl76w7lrz_test.go:15:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers = numbers[:1]\n    nearest := make([]interface{},\
    \ 2)\n    smallestDiffInd := len(numbers) - 1\n    smallestDiffVal := numbers[smallestDiffInd]\n\
    \    largestDiffInd := len(numbers) - 1\n    largestDiffVal := numbers[largestDiffInd]\n\
    \n    smallestDiffVal -= numbers[smallestDiffInd-1]\n    largestDiffVal -= numbers[largestDiffInd-1]\n\
    \n    if smallestDiffVal > largestDiffVal {\n        // smallest is greater than\
    \ largest, so find the smallest two and swap them\n        smallest := numbers[smallestDiffInd-1]\n\
    \        largest = numbers[smallestDiffInd]\n\n        for smallestDiffInd > 0\
    \ {\n            smallestDiffInd--\n            smallestDiffVal -= numbers[smallestDiffInd]\n\
    \        }\n\n        numbers[smallestDiffInd-1] = smallest\n        numbers[smallestDiffInd]\
    \ = largest\n\n    } else {\n        // largest is greater than smallest, so find\
    \ the largest two and swap them\n        smallest := numbers[smallestDiffInd]\n\
    \        largest = numbers[largestDiffInd]\n\n        for largestDiffInd > 0 {\n\
    \            largestDiffInd--\n            largestDiffVal -= numbers[largestDiffInd]\n\
    \        }\n\n        numbers[largestDiffInd-1] = smallest\n        numbers[largestDiffInd]\
    \ = largest\n    }\n\n    // Now we have smallest < largest, so find which two\
    \ of them are closest to eachother\n    for i := 0; i < len(numbers); i++ {\n\
    \        if numbers[i] < smallest {\n            nearest = append(nearest, numbers[i])\n\
    \        } else if numbers[i] > smallest {\n            nearest = append(nearest,\
    \ smallest)\n        } else {\n            if numbers[i] > largest {\n       \
    \         nearest = append(nearest, largest)\n            } else {\n         \
    \       nearest = append(nearest, numbers[i])\n            }\n        }\n    }\n\
    \n    return nearest\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph17c_kir_test.go:28:9: undefined: largest

    /tmp/tmph17c_kir_test.go:36:36: undefined: largest

    /tmp/tmph17c_kir_test.go:41:9: undefined: largest

    /tmp/tmph17c_kir_test.go:49:35: undefined: largest

    /tmp/tmph17c_kir_test.go:54:25: undefined: smallest

    /tmp/tmph17c_kir_test.go:56:32: undefined: smallest

    /tmp/tmph17c_kir_test.go:57:39: undefined: smallest

    /tmp/tmph17c_kir_test.go:59:29: undefined: largest

    /tmp/tmph17c_kir_test.go:60:43: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    found := make([]interface{}, len(numbers))\n\
    \    for i := 0; i < len(numbers); i++ {\n        found[i] = numbers[i]\n    \
    \    if i > 0 {\n            delta := numbers[i] - found[i-1]\n            if\
    \ delta < 0 {\n                delta *= -1\n            }\n            if delta\
    \ < float64(len(numbers)-2)/2 {\n                found[i-1] = numbers[i+1]\n \
    \               if i < len(numbers)-1 {\n                    found[i+1] = numbers[i]\n\
    \                }\n            }\n        }\n    }\n    return found\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ifzg6z8_test.go:19:22: invalid operation: numbers[i] - found[i - 1] (mismatched
    types float64 and interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers := numbers\n    numbers, err := Sort.Float64s(numbers)\n\
    \    if err != nil {\n        panic(err)\n    }\n    n := len(numbers)\n    if\
    \ n < 2 {\n        return []interface{}{}\n    }\n\n    x := numbers[0]\n    y\
    \ := numbers[n-1]\n    if n == 1 {\n        return []interface{}{x}\n    }\n\n\
    \    d := math.Abs(x-y)\n    i := 0\n    if d < numbers[1]-numbers[0] {\n    \
    \    d = numbers[1] - numbers[0]\n        i = n-1\n    } else {\n        d = numbers[0]\
    \ - numbers[n-1]\n        i = 0\n    }\n    numbers := numbers[i:]\n    return\
    \ numbers\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxzz_r7xv_test.go:15:13: no new variables on left side of :=

    /tmp/tmpxzz_r7xv_test.go:16:21: undefined: Sort

    /tmp/tmpxzz_r7xv_test.go:31:10: undefined: math

    /tmp/tmpxzz_r7xv_test.go:40:13: no new variables on left side of :=

    /tmp/tmpxzz_r7xv_test.go:41:12: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the smallest number.\n    smallest :=\
    \ numbers[0]\n\n    // Find the largest number.\n    largest := numbers[0]\n\n\
    \    for _, number := range numbers[1:] {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n\n    numberList := make([]interface{},\
    \ 2, 2) // We are looking for two numbers that are closer than \"largest_number\"\
    \ away.\n    numberList[0] = smallest\n    numberList[1] = largest\n\n    return\
    \ numberList\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp6r_xjv0k_test.go:54: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp6r_xjv0k_test.go:54: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp6r_xjv0k_test.go:54: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp6r_xjv0k_test.go:54: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp6r_xjv0k_test.go:54: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest, largest := numbers[0], numbers[0]\n\
    \    for _, number := range numbers {\n        if math.Abs(number-smallest) <\
    \ math.Abs(number-largest) {\n            smallest = number\n        } else {\n\
    \            largest = number\n        }\n    }\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuvnd2u3f_test.go:17:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    diff := math.Abs(numbers[1] - numbers[0])\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if diff == math.Abs(numbers[i] - numbers[0]) {\n            continue\n\
    \        }\n        diff += math.Abs(numbers[i] - numbers[0])\n        if diff\
    \ < math.Abs(numbers[i] - numbers[1]) {\n            return nil\n        }\n \
    \   }\n    return []interface{}{numbers[0], numbers[1]}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppscjfef2_test.go:18:13: undefined: math

    /tmp/tmppscjfef2_test.go:20:20: undefined: math

    /tmp/tmppscjfef2_test.go:23:17: undefined: math

    /tmp/tmppscjfef2_test.go:24:19: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    var result []interface{}\n    var smallest, largest float64\n  \
    \  var count int\n    for _, num := range numbers {\n        if smallest+1 < num\
    \ {\n            smallest = num\n        }\n        if largest >= num {\n    \
    \        largest = num\n        }\n        count = 0\n        for _, v := range\
    \ result {\n            if smallest+1 < v {\n                smallest = v\n  \
    \          }\n            if largest >= v {\n                largest = v\n   \
    \         }\n            if v == num {\n                count++\n            }\n\
    \        }\n\n        if count <= 1 {\n            result = append(result, num)\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdp8zjiuq_test.go:31:29:\
    \ invalid operation: smallest + 1 < v (operator < not defined on interface)\n\
    /tmp/tmpdp8zjiuq_test.go:32:28: cannot use v (variable of type interface{}) as\
    \ type float64 in assignment:\n\tneed type assertion\n/tmp/tmpdp8zjiuq_test.go:34:27:\
    \ invalid operation: largest >= v (operator >= not defined on interface)\n/tmp/tmpdp8zjiuq_test.go:35:27:\
    \ cannot use v (variable of type interface{}) as type float64 in assignment:\n\
    \tneed type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallest, largest := numbers[0], numbers[len(numbers)-1]\n    first\
    \ := secondIndex := 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i]\
    \ != smallest {\n            secondIndex = i\n        }\n        if numbers[i]\
    \ != largest {\n            if abs(numbers[i] - smallest) < abs(numbers[secondIndex]\
    \ - largest) {\n                secondIndex = i\n            }\n        }\n  \
    \  }\n\n    // swap them\n    smallest ^= numbers[secondIndex]\n    numbers[secondIndex]\
    \ ^= numbers[0]\n    numbers[0] ^= numbers[secondIndex]\n    numbers[secondIndex]\
    \ ^= numbers[0]\n\n    // now rearrange them\n    i := secondIndex\n    for secondIndex\
    \ > 0 && numbers[i] == smallest {\n        numbers[i] = numbers[secondIndex--]\n\
    \    }\n    for secondIndex > 0 && numbers[i] == largest {\n        numbers[i]\
    \ = numbers[secondIndex--]\n    }\n\n    return numbers[i:]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwvxnlgmd_test.go:19:26: expected '';'', found '':=''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074860
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \n    for i, value := range numbers[1:] {\n        if value < smallest {\n   \
    \         smallest = value\n        }\n        if value > largest {\n        \
    \    largest = value\n        }\n    }\n\n    result := make([]interface{}, 1)\n\
    \    result[0] = smallest\n    result[1] = largest\n\n    return result\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0lzcyqe1_test.go:18:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    // Sort the numbers and find the two smallest numbers\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    return []interface{}{numbers[len(numbers)/2-1], numbers[len(numbers)/2]}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8997a0bz_test.go:20:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Loop through each element (number in our\
    \ case)\n    for _, element := range numbers {\n        // If this element matches\
    \ the smallest number in the array, then we return this element.\n        // Otherwise\
    \ we continue looping through each element until we find a smaller one.\n    \
    \    if element < numbers[0] {\n            return []interface{}{element}\n  \
    \      } else {\n            for _, otherElement := range numbers {\n        \
    \        // If this number and the current element are the same or smaller, then\
    \ we've found our first match.\n                if element < otherElement || otherElement\
    \ == element {\n                    return []interface{}{element, otherElement}\n\
    \                }\n            }\n        }\n    }\n    return []interface{}{}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp2g1znmtp_test.go:50: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp2g1znmtp_test.go:50: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp2g1znmtp_test.go:50: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp2g1znmtp_test.go:50: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp2g1znmtp_test.go:50: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    // The two nearest numbers will be the two smallest numbers in the\
    \ list\n    sortedNumbers := sortNumbers(numbers)\n    smallestNear := sortedNumbers[0]\n\
    \    largestNear := sortedNumbers[1]\n\n    // Now find the two numbers that are\
    \ the closest to the two in sequence\n    closestNumbers := []float64{}\n    for\
    \ _, number := range numbers {\n        if number < smallestNear {\n         \
    \   closestNumbers = append(closestNumbers, number)\n        } else if number\
    \ > largestNear {\n            closestNumbers = append(closestNumbers, number)\n\
    \        } else {\n            if number == smallestNear {\n                closestNumbers\
    \ = append(closestNumbers, smallestNear)\n            }\n            if number\
    \ == largestNear {\n                closestNumbers = append(closestNumbers, largestNear)\n\
    \            }\n        }\n    }\n\n    return closestNumbers\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6tspl2__test.go:20:22: undefined: sortNumbers

    /tmp/tmpf6tspl2__test.go:41:12: cannot use closestNumbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // The \"i\" variable is for iteration through\
    \ each of the values in the list\n    var i int\n    // The smallest number we\
    \ will return\n    var smallest float64\n    // The second smallest number we\
    \ will return\n    var second float64\n    // The index to the first of the two\
    \ smallest numbers that will be returned\n    var smallestIndex int\n    // The\
    \ index to the first of the two smallest numbers that will be returned\n    var\
    \ secondIndex int\n\n    // Loop through the numbers\n    for i = 0; numbers[i]\
    \ != 0; i++ {\n        // If the current number is smaller than our smallest number\
    \ so far\n        if (numbers[i] < smallest) {\n            // Remember the current\
    \ index for the smallest number\n            smallestIndex = i\n            //\
    \ Set our smallest number to this number\n            smallest = numbers[i]\n\
    \        }\n\n        // If the current number is smaller than our second smallest\
    \ number so far\n        if (numbers[i] < second) {\n            // Remember the\
    \ current index for the second smallest number\n            secondIndex = i\n\
    \            // Set our second smallest number to this number\n            second\
    \ = numbers[i]\n        }\n    }\n\n    // Return the result from that index\n\
    \    return []interface{}{numbers[smallestIndex], numbers[secondIndex]}\n}\n\n\
    func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\npanic: runtime error: index\
    \ out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out\
    \ of range [6] with length 6\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_closest_elements(...)\n\t/tmp/tmpgb_y_j_0_test.go:27\n\
    command-line-arguments_test.TestFind_Closest_Elements(0x0?)\n\t/tmp/tmpgb_y_j_0_test.go:56\
    \ +0xd76\ntesting.tRunner(0xc000103520, 0x528fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    sorted := sort.Float64Slice(numbers)\n    sort.Sort(sort.Reverse(sorted))\n\
    \n    var smallestDifference float64\n    smallestDifference := sorted[1] - sorted[0]\n\
    \n    // Go through all numbers again and compare with the smallest difference.\n\
    \    // If smallest difference is larger than the one we already found we update\
    \ that one.\n    for _, num := range sorted {\n        if num == smallestDifference\
    \ {\n            continue\n        }\n\n        var foundNumber float64\n    \
    \    foundNumber := numbers[1]\n        if smallestDifference > foundNumber {\n\
    \            foundNumber = num\n            smallestDifference = foundNumber -\
    \ numbers[0]\n        }\n\n        return []interface{}{foundNumber, smallestDifference}\n\
    \    }\n\n    // If the smallest difference is smaller than the smallestDifference\
    \ from last time we return empty\n    // list because no two numbers are the closest\
    \ to eachother.\n    return []interface{}{}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6db0vxp7_test.go:18:15: undefined: sort

    /tmp/tmp6db0vxp7_test.go:19:5: undefined: sort

    /tmp/tmp6db0vxp7_test.go:22:24: no new variables on left side of :=

    /tmp/tmp6db0vxp7_test.go:32:21: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Float64Slice(numbers))\n    var\
    \ closest []interface{}\n    i := 0\n    // Go through list until we find the\
    \ first element that is less than the second element\n    for i < len(numbers)-1\
    \ {\n        if numbers[i] < numbers[i+1] {\n            closest = append(closest,\
    \ numbers[i])\n            break\n        } else {\n            i++\n        }\n\
    \    }\n    closest = append(closest, numbers[len(numbers)-1])\n    return closest\n\
    }\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_54rfww4_test.go:15:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers = sort_numbers(numbers)\n\n    index\
    \ := 0\n    closest_index := index\n    closest_number := numbers[index]\n\n \
    \   // If there is only one number in the list it can be returned immediately.\n\
    \    if len(numbers) == 1 {\n        return []interface{}{closest_number}\n  \
    \  }\n\n    for index != len(numbers)-1 {\n        index += 1\n        number\
    \ := numbers[index]\n\n        if math.Abs(number-closest_number) < math.Abs(number-closest_index)\
    \ {\n            closest_index = number\n            closest_number = number\n\
    \        }\n    }\n\n    // Now find the two closest numbers.\n    numbers = numbers[0\
    \ : closest_index+2]\n    return sort_numbers(numbers)\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbbe5wzpa_test.go:15:15: undefined: sort_numbers

    /tmp/tmpbbe5wzpa_test.go:30:12: undefined: math

    /tmp/tmpbbe5wzpa_test.go:30:55: invalid operation: number - closest_index (mismatched
    types float64 and int)

    /tmp/tmpbbe5wzpa_test.go:31:29: cannot use number (variable of type float64) as
    type int in assignment

    /tmp/tmpbbe5wzpa_test.go:38:12: undefined: sort_numbers

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // For this method to work you must sort your\
    \ input list of numbers!\n    sort.Float64s(numbers)\n    result := make([]interface{},\
    \ 0)\n\n    var smallestDiff, secondSmallestDiff float64\n    for _, num := range\
    \ numbers {\n        if smallestDiff*secondSmallestDiff > secondSmallestDiff*smallestDiff\
    \ {\n            smallestDiff = secondSmallestDiff\n            secondSmallestDiff\
    \ = smallestDiff\n            secondSmallestDiff = num\n            continue\n\
    \        }\n\n        if smallestDiff*secondSmallestDiff < secondSmallestDiff*num\
    \ {\n            secondSmallestDiff = num\n        }\n    }\n\n    if smallestDiff\
    \ < secondSmallestDiff {\n        result = append(result, smallestDiff)\n    \
    \    result = append(result, secondSmallestDiff)\n    } else {\n        result\
    \ = append(result, secondSmallestDiff)\n        result = append(result, smallestDiff)\n\
    \    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcuva2g27_test.go:16:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    sorted_numbers := sort.Float64Slice(numbers)\n    min_diff := math.MaxFloat64\n\
    \    min := sorted_numbers[0]\n    max := sorted_numbers[len(sorted_numbers)-1]\n\
    \n    for i, v := range sorted_numbers {\n        diff := math.Abs(max-v)\n  \
    \      if min_diff > diff {\n            min_diff = diff\n            min = v\n\
    \        }\n        diff := math.Abs(min-v)\n        if min_diff > diff {\n  \
    \          min_diff = diff\n            max = v\n        }\n    }\n\n    if min_diff\
    \ > math.MaxFloat64-math.MaxFloat64 {\n        return nil\n    }\n\n    return\
    \ []interface{}{min, max}\n}\n</code>\n<|/ a dscore=2 tags=go,floating-point |>\n\
    <| c |>\nWhy not `float64(numbers[i] - numbers[j])`? And `min_diff > diff {` is\
    \ not idiomatic in Go as `>` has higher precedence than `<`. It should be `min_diff\
    \ > (diff { ... })`\n<|/ c |>\n<| c |>\nGood point, thanks. I just copy/pasted\
    \ from the original source but I'll update the answer to fix the precedence\n\
    <|/ c |>\n<| c |>\nI suggest you read up on [precedence](https://golang.org/ref/spec#Comparison_operators)\
    \ and [operator precedence](https://golang.org/ref/spec#Operator_precedence),\
    \ so that you understand why your implementation does not work.\n<|/ c |>\n<|\
    \ a tags=go,floating-point |>\nAs far as I know, there is no straight way to do\
    \ this. But you can use some sort of heuristic to estimate how far apart two floats\
    \ are from each other. \nThe function below will give you the closest float to\
    \ another float in either direction, assuming the second float is greater than\
    \ the first. \n<code>\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1a8ycvz5_test.go:42:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074861
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return numbers\n\
    \    }\n\n    min := numbers[0]\n    max := numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] < min {\n            min = numbers[i]\n       \
    \ }\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \    }\n\n    result := []interface{}{}\n    for i, number := range numbers {\n\
    \        if number < min {\n            result = append(result, min)\n       \
    \ }\n        if number > max {\n            result = append(result, max)\n   \
    \     }\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprfd7vrap_test.go:16:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmprfd7vrap_test.go:31:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    biggest := numbers[0]\n\
    \    for _, num := range numbers[1:] {\n        if num < smallest {\n        \
    \    smallest = num\n        } else if num > biggest {\n            biggest =\
    \ num\n        }\n    }\n    return []interface{}{smallest, biggest}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmp203hb28s_test.go:44: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmp203hb28s_test.go:44: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmp203hb28s_test.go:44: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmp203hb28s_test.go:44: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmp203hb28s_test.go:44: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sorted_numbers := sortNumbers(numbers)\n   \
    \ smallest_difference := sorted_numbers[1] - sorted_numbers[0]\n    largest_difference\
    \ := sorted_numbers[len(sorted_numbers)-1] - sorted_numbers[len(sorted_numbers)-2]\n\
    \n    smallest := sorted_numbers[0]\n    largest := sorted_numbers[len(sorted_numbers)-1]\n\
    \n    if smallest_difference < 0 {\n        return nil\n    }\n\n    if smallest_difference\
    \ == 0 {\n        return []interface{}{smallest, smallest}\n    }\n\n    if largest_difference\
    \ == 0 {\n        return []interface{}{largest, largest}\n    }\n\n    found :=\
    \ false\n    diff := smallest_difference * 2\n\n    for i := 0; i < len(sorted_numbers);\
    \ i++ {\n        if sorted_numbers[i]-diff < smallest_difference {\n         \
    \   smallest = sorted_numbers[i]\n            diff = sorted_numbers[i]-smallest\n\
    \            found = true\n        }\n        if sorted_numbers[i]-diff == smallest_difference\
    \ {\n            if sorted_numbers[i]-diff == largest {\n                found\
    \ = true\n            }\n            largest = sorted_numbers[i]\n           \
    \ diff = sorted_numbers[i]-largest\n        }\n    }\n\n    if !found {\n    \
    \    return nil\n    }\n\n    return []interface{}{smallest, largest}\n}\n\nfunc\
    \ TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdy4wjyg1_test.go:15:23: undefined: sortNumbers

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    largestNumber := numbers[0]\n    smallest := numbers[0]\n    for _,\
    \ number := range numbers[1:] {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return []interface{}{smallest, largest}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpha99wyed_test.go:18:5: largestNumber declared but not used

    /tmp/tmpha99wyed_test.go:23:28: undefined: largest

    /tmp/tmpha99wyed_test.go:24:13: undefined: largest

    /tmp/tmpha99wyed_test.go:27:36: undefined: largest

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    diff := numbers[0] - numbers[1]\n    diff /= float64(len(numbers)-1)\n\
    \    if len(numbers) == 1 {\n        return nil\n    }\n    numbers := make([]interface{},\
    \ 2)\n    if diff < 0 {\n        numbers[0] = numbers[1]\n        numbers[1] =\
    \ numbers[0]\n    }\n    if diff > 0 {\n        numbers[0] = numbers[1]\n    \
    \    numbers[1] = numbers[0]\n    }\n    switch diff {\n    case -0.0:\n     \
    \   numbers[0] = numbers[1]\n        numbers[1] = numbers[0]\n        return numbers\n\
    \    case 1.0:\n        return nil\n    default:\n        diff /= float64(2) -\
    \ 1.0\n        if diff < 0 {\n            numbers[0] = numbers[1]\n          \
    \  numbers[1] = numbers[0]\n            numbers[0] = numbers[0] - diff\n     \
    \       numbers[1] = numbers[1] + diff\n        }\n        numbers[0] = numbers[1]\n\
    \        numbers[1] = numbers[0]\n        return numbers\n    }\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp1c4s8l9_test.go:23:13: no new variables on left side of :=

    /tmp/tmpp1c4s8l9_test.go:23:16: cannot use make([]interface{}, 2) (value of type
    []interface{}) as type []float64 in assignment

    /tmp/tmpp1c4s8l9_test.go:36:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmpp1c4s8l9_test.go:49:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    sort.Slice(numbers, func(i, j int) bool {\n        return numbers[i]\
    \ < numbers[j]\n    })\n\n    if len(numbers) == 2 {\n        return numbers\n\
    \    }\n\n    idx := 0\n    diff := numbers[idx] - numbers[idx+1]\n    smallest,\
    \ largest := numbers[idx], numbers[idx+1]\n\n    for idx < len(numbers)-1 {\n\
    \        diff2 := numbers[idx] - numbers[idx+1]\n        if diff == diff2 {\n\
    \            smallest = numbers[idx]\n            largest = numbers[idx+1]\n \
    \       }\n        diff = diff2\n    }\n\n    return []interface{}{smallest, largest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp38k65wki_test.go:19:5: undefined: sort

    /tmp/tmp38k65wki_test.go:24:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers = append(numbers, numbers[0])\n    index\
    \ := len(numbers) - 1\n    for i := 0; i < index; i++ {\n        if numbers[i]\
    \ > numbers[index] {\n            numbers = append(numbers, numbers[i])\n    \
    \        index = i\n        }\n    }\n    return numbers[1:]\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpodlww9dq_test.go:23:19: cannot use numbers[1:] (value of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    // Find the smallest element and subtract it\
    \ from the rest to find closest element\n    smallest := numbers[0]\n    i :=\
    \ 1\n    for ; i < len(numbers); i++ {\n        if numbers[i] < smallest {\n \
    \           smallest = numbers[i]\n        }\n    }\n\n    // Now select the correct\
    \ numbers\n    j := 1\n    closeNumbers := []interface{}{}\n    for ; j < len(numbers);\
    \ j++ {\n        if numbers[j] == smallest {\n            closeNumbers = append(closeNumbers,\
    \ numbers[j])\n        }\n    }\n    return closeNumbers\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpquncwl4i_test.go:52: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1 (0.00s)\n    \
    \    tmpquncwl4i_test.go:52: expected '[%!s(float64=5) %!s(float64=5.9)]', got\
    \ '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2 (0.00s)\n        tmpquncwl4i_test.go:52:\
    \ expected '[%!s(float64=2) %!s(float64=2.2)]', got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpquncwl4i_test.go:52: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4 (0.00s)\n    \
    \    tmpquncwl4i_test.go:52: expected '[%!s(float64=2.2) %!s(float64=3.1)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    sorted_numbers := make([]float64, len(numbers))\n    sorted_numbers\
    \ = append(sorted_numbers, numbers[0])\n    sorted_numbers = append(sorted_numbers,\
    \ numbers[1])\n\n    smallest_number := sorted_numbers[0]\n    biggest_number\
    \ := sorted_numbers[1]\n\n    for i := 2; i < len(numbers); i++ {\n        previous_value\
    \ := sorted_numbers[i-1]\n        this_value := sorted_numbers[i]\n\n        if\
    \ this_value < smallest_number {\n            smallest_number = previous_value\n\
    \        }\n\n        if this_value > biggest_number {\n            biggest_number\
    \ = this_value\n        }\n    }\n\n    result := make([]interface{}, 2)\n   \
    \ result[0] = biggest_number\n    result[1] = smallest_number\n\n    return result\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpgoccm7np_test.go:63: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpgoccm7np_test.go:63: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpgoccm7np_test.go:63: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpgoccm7np_test.go:63: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpgoccm7np_test.go:63: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=0) %!s(float64=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var smallest, largest float64\n    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n\n    smallest := numbers[0]\n    largest\
    \ := numbers[0]\n\n    for _, number := range numbers[1:] {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n\n    return []interface{}{smallest,\
    \ largest}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpykhdp_2c_test.go:20:14: no new variables on left side of :=

    /tmp/tmpykhdp_2c_test.go:21:13: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    var smallest float64 = numbers[0]\n    var second float64 = numbers[1]\n\
    \n    for _, number := range numbers[2:] {\n        if float64(number) < smallest\
    \ {\n            second = smallest\n            smallest = number\n        } else\
    \ {\n            second = number\n        }\n    }\n\n    return []interface{}{smallest,\
    \ second}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate :=\
    \ find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpqvosfkv2_test.go:51: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpqvosfkv2_test.go:51: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpqvosfkv2_test.go:51: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=2.2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpqvosfkv2_test.go:51: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=2)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpqvosfkv2_test.go:51: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    i := 0\n    j := len(numbers) - 1\n    selected := make([]interface{}, 2)\n\
    \n    // Loop over all numbers and see if they are close to each other.\n    for\
    \ ; i <= j; i++ {\n        if i > j {\n            break\n        }\n        diff\
    \ := numbers[i] - numbers[j]\n        diff *= diff\n        if diff < numbers[i]\
    \ {\n            selected[0] = numbers[i]\n            selected[1] = numbers[j]\n\
    \        } else {\n            selected[0] = numbers[j]\n            selected[1]\
    \ = numbers[i]\n        }\n\n        // Move to the next element to be tested.\n\
    \        i++\n        j--\n    }\n    return selected\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfe3pxc99_test.go:15:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    numbers := numbers[:2]\n\n    if len(numbers)\
    \ < 2 {\n        return numbers\n    }\n\n    var closest1, closest2 float64\n\
    \    closest1 = numbers[0]\n    closest2 = numbers[1]\n\n    for _, number :=\
    \ range numbers[2:] {\n        if math.Abs(closest1-number) < math.Abs(closest2-number)\
    \ {\n            closest2 = number\n        } else {\n            closest1 = number\n\
    \        }\n    }\n\n    return []interface{}{closest1, closest2}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp44c00__s_test.go:15:13: no new variables on left side of :=

    /tmp/tmp44c00__s_test.go:18:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    /tmp/tmp44c00__s_test.go:26:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n\n    for i := 0; i < len(numbers); i++ {\n        for j := i; j < len(numbers);\
    \ j++ {\n            val := numbers[i]\n            minVal := numbers[j]\n\n \
    \           // If number[i] < number[j] then we're not going to find anything\n\
    \            // to compare it to, so return the empty slice\n            if val\
    \ < minVal {\n                return []interface{}{}\n            }\n\n      \
    \      // If we found something then return it\n            if val == minVal {\n\
    \                return []interface{}{val, minVal}\n            }\n        }\n\
    \    }\n\n    return []interface{}{}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T)\
    \ {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpo2a35dcr_test.go:57: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpo2a35dcr_test.go:57: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpo2a35dcr_test.go:57: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpo2a35dcr_test.go:57: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=1)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpo2a35dcr_test.go:57: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=1.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var result []interface{}\n    var min float64\n\
    \    var max float64\n\n    result := make([]interface{}, len(numbers))\n\n  \
    \  for i := 0; i < len(numbers); i++ {\n        min = numbers[i]\n        max\
    \ = numbers[i]\n\n        for j := i + 1; j < len(numbers); j++ {\n          \
    \  if numbers[j] < min {\n                min = numbers[j]\n            }\n  \
    \          if numbers[j] > max {\n                max = numbers[j]\n         \
    \   }\n        }\n        if min < max {\n            result[i] = min\n      \
    \      result[i+1] = max\n        }\n    }\n\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwin44djs_test.go:19:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    smallest := numbers[0]\n    largest := numbers[0]\n    for _, number\
    \ := range numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    result := make([]interface{}, 0)\n    for _, number := range\
    \ numbers {\n        if number < smallest {\n            slice = append(slice,\
    \ smallest)\n        }\n        if number > largest {\n            slice = append(slice,\
    \ largest)\n        }\n    }\n    return result\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgbpcmn3_test.go:31:28: undefined: slice

    /tmp/tmpcgbpcmn3_test.go:34:28: undefined: slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n\
    \    smallestDifference := numbers[1] - numbers[0]\n    result := []interface{}{}\n\
    \    for _, number := range numbers {\n        diff, ok := (number - numbers[0])\n\
    \        if ok {\n            smallestDifference = diff if diff < smallestDifference\
    \ else smallestDifference\n        }\n        result = append(result, number)\n\
    \        if smallestDifference > 0 {\n            break\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6kmpvqtq_test.go:21:39: expected '';'', found ''if''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074862
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    var closest, next []float64\n    min := numbers[0]\n\
    \    max := numbers[0]\n\n    for _, n := range numbers {\n        if n == min\
    \ {\n            continue\n        }\n        if n > max {\n            max =\
    \ n\n            closest = append([]float64{min}, max)\n            next = append(next,\
    \ max)\n            continue\n        }\n        if min > n {\n            min\
    \ = n\n            closest = append([]float64{min}, max)\n            next = append(next,\
    \ min)\n            continue\n        }\n        closest = append(closest, min)\n\
    \        next = append(next, min)\n    }\n    return next\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptj45u510_test.go:38:12: cannot use next (variable of type []float64) as
    type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 1
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    smallest := numbers[0]\n    largest := numbers[0]\n\
    \    for _, number := range numbers {\n        if number < smallest {\n      \
    \      smallest = number\n        }\n        if number > largest {\n         \
    \   largest = number\n        }\n    }\n    return []interface{}{smallest, largest}\n\
    }\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Closest_Elements (0.00s)\n    --- FAIL: TestFind_Closest_Elements/test_num__0\
    \ (0.00s)\n        tmpuv44vqv5_test.go:45: expected '[%!s(float64=3.9) %!s(float64=4)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__1\
    \ (0.00s)\n        tmpuv44vqv5_test.go:45: expected '[%!s(float64=5) %!s(float64=5.9)]',\
    \ got '[%!s(float64=1) %!s(float64=5.9)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__2\
    \ (0.00s)\n        tmpuv44vqv5_test.go:45: expected '[%!s(float64=2) %!s(float64=2.2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__3\
    \ (0.00s)\n        tmpuv44vqv5_test.go:45: expected '[%!s(float64=2) %!s(float64=2)]',\
    \ got '[%!s(float64=1) %!s(float64=5)]'\n    --- FAIL: TestFind_Closest_Elements/test_num__4\
    \ (0.00s)\n        tmpuv44vqv5_test.go:45: expected '[%!s(float64=2.2) %!s(float64=3.1)]',\
    \ got '[%!s(float64=1.1) %!s(float64=5.1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074622
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    result := []interface{}{}\n    minimum := math.Inf(1)\n    maximum\
    \ := math.Inf(-1)\n\n    for _, number := range numbers {\n        current :=\
    \ number\n        delta := math.Abs(number - minimum)\n        if delta < math.Abs(current\
    \ - maximum) {\n            minimum = number\n        }\n        delta = math.Abs(number\
    \ - maximum)\n        if delta < math.Abs(current - minimum) {\n            maximum\
    \ = number\n        }\n\n        result = append(result, number)\n    }\n\n  \
    \  return result\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate\
    \ := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0,\
    \ 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}),\
    \ expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgrjbh5t_test.go:20:16: undefined: math

    /tmp/tmprgrjbh5t_test.go:21:16: undefined: math

    /tmp/tmprgrjbh5t_test.go:25:18: undefined: math

    /tmp/tmprgrjbh5t_test.go:26:20: undefined: math

    /tmp/tmprgrjbh5t_test.go:29:17: undefined: math

    /tmp/tmprgrjbh5t_test.go:30:20: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n\n    sort.Sort(sort.Reverse(sort.Float64Slice(numbers)))\n    min :=\
    \ numbers[0]\n    max := numbers[0]\n    for _, number := range numbers[1:] {\n\
    \        if number < min {\n            min = number\n        } else if number\
    \ > max {\n            max = number\n        }\n    }\n    return []interface{}{min,\
    \ max}\n}\n\nfunc TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
    \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
    \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
    \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp40f4dz2o_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n\
    \    }\n    if numbers[0] == numbers[1] {\n        return numbers\n    }\n   \
    \ min := numbers[0]\n    max := numbers[0]\n    for _, n := range numbers[1:]\
    \ {\n        if n > max {\n            max = n\n        } else if n < min {\n\
    \            min = n\n        }\n    }\n    result := []interface{}{min, max}\n\
    \    return append(result, numbers[len(numbers)-1])\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuqawbd8a_test.go:19:16: cannot use numbers (variable of type []float64)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
- exit_code: 2
  program: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n// other and return them in order\
    \ (smaller number, larger number).\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
    \ []float64) []interface{} {\n    sort.Float64s(numbers)\n    idx := 0\n    diff\
    \ := numbers[0]-numbers[1]\n    closest := numbers[0]\n    closestNext := numbers[1]\n\
    \    if diff < 0 {\n        idx = 1\n        diff = diff * -1\n        closest\
    \ = numbers[idx]\n        closestNext = numbers[idx+1]\n    }\n    for idx < len(numbers)-1\
    \ {\n        diff += numbers[idx+1]-numbers[idx]\n        if diff < 0 {\n    \
    \        closestNext.Set(numbers[idx])\n            closest.Set(numbers[idx])\n\
    \            idx = idx+1\n            diff = -diff\n        } else {\n       \
    \     closest.Set(numbers[idx])\n            closestNext.Set(numbers[idx+1])\n\
    \        }\n    }\n    return []interface{}{closest, closestNext}\n}\n\nfunc TestFind_Closest_Elements(t\
    \ *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9,\
    \ 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected:\
    \ []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual:\
    \ candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2,\
    \ 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2xmgofn7_test.go:15:5: undefined: sort

    /tmp/tmp2xmgofn7_test.go:29:25: closestNext.Set undefined (type float64 has no
    field or method Set)

    /tmp/tmp2xmgofn7_test.go:30:21: closest.Set undefined (type float64 has no field
    or method Set)

    /tmp/tmp2xmgofn7_test.go:34:21: closest.Set undefined (type float64 has no field
    or method Set)

    /tmp/tmp2xmgofn7_test.go:35:25: closestNext.Set undefined (type float64 has no
    field or method Set)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074863
