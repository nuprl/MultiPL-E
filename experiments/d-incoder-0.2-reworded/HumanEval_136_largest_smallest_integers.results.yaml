language: d
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcv66ozzl.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpcv66ozzl.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcv66ozzl.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv66ozzl.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpezbcne5_.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpezbcne5_.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpezbcne5_.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpezbcne5_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = 0, b = 1;\n    for (long i : lst)\n    {\n        if\
    \ (i < 0)\n        {\n            a = i;\n        }\n        else\n        {\n\
    \            b = i;\n        }\n    }\n    return Tuple!(Nullable!(long), Nullable!(long));\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8yb4ph2a.d(22): Error: semicolon expected, not `:`\n/tmp/tmp8yb4ph2a.d(22):
    Error: expression expected, not `:`\n/tmp/tmp8yb4ph2a.d(22): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8yb4ph2a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n\
    \        {\n            foundNegative = true;\n        }\n        if (i > 0)\n\
    \        {\n            foundPositive = true;\n        }\n        if (foundNegative\
    \ && foundPositive)\n        {\n            break;\n        }\n        if (foundNegative)\n\
    \        {\n            largest = i;\n        }\n        if (foundPositive)\n\
    \        {\n            smallest = i;\n        }\n    }\n    if (foundNegative\
    \ && foundPositive)\n    {\n        result.a = Nullable!(largest);\n        result.b\
    \ = Nullable!(smallest);\n    }\n    else\n    {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2lc92eq_.d(26): Error: semicolon expected, not `:`\n/tmp/tmp2lc92eq_.d(26):
    Error: expression expected, not `:`\n/tmp/tmp2lc92eq_.d(26): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp2lc92eq_.d(61): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lc92eq_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst)\n\
    \    {\n        if (x < 0)\n        {\n            if (a < 0)\n              \
    \  a = x;\n        }\n        else\n        {\n            if (b < 0)\n      \
    \          b = x;\n        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpogto2ctj.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpogto2ctj.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpogto2ctj.d(36): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogto2ctj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    bool positive = false;\n    long largest = Long.min;\n    long\
    \ smallest = Long.max;\n    foreach(long x, lst) {\n        if (x < 0) {\n   \
    \         negative = true;\n        } else if (x > 0) {\n            positive\
    \ = true;\n        }\n        if (negative && positive && x > largest) {\n   \
    \         largest = x;\n        } else if (negative && positive && x < smallest)\
    \ {\n            smallest = x;\n        }\n    }\n    if (negative && positive)\
    \ {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.0\
    \ = largest;\n        result.1 = smallest;\n    } else {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = null;\n        result.1 = null;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqwuup5sn.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpqwuup5sn.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpqwuup5sn.d(38): Error: found `if`
    when expecting `)`\n/tmp/tmpqwuup5sn.d(38): Error: found `&&` when expecting `)`\n/tmp/tmpqwuup5sn.d(38):
    Error: missing `{ ... }` for function literal\n/tmp/tmpqwuup5sn.d(38): Error:
    found `positive` when expecting `;` following statement\n/tmp/tmpqwuup5sn.d(38):
    Error: found `)` instead of statement\n/tmp/tmpqwuup5sn.d(40): Error: found `0.00000`
    when expecting `;` following statement\n/tmp/tmpqwuup5sn.d(40): Error: found `=`
    instead of statement\n/tmp/tmpqwuup5sn.d(41): Error: found `0.1` when expecting
    `;` following statement\n/tmp/tmpqwuup5sn.d(41): Error: found `=` instead of statement\n/tmp/tmpqwuup5sn.d(42):
    Error: declaration expected, not `else`\n/tmp/tmpqwuup5sn.d(44): Error: no identifier
    for declarator `result`\n/tmp/tmpqwuup5sn.d(44): Error: declaration expected,
    not `0.00000`\n/tmp/tmpqwuup5sn.d(45): Error: no identifier for declarator `result`\n/tmp/tmpqwuup5sn.d(45):
    Error: declaration expected, not `0.1`\n/tmp/tmpqwuup5sn.d(46): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwuup5sn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            foundNegative = true;\n\
    \        }\n        else if (x > 0)\n        {\n            foundPositive = true;\n\
    \        }\n        else\n        {\n            result.a = x;\n            result.b\
    \ = x;\n        }\n    }\n    \n    if (foundNegative && foundPositive)\n    {\n\
    \        return result;\n    }\n    \n    return Tuple!(Nullable!(long), Nullable!(long));\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzf6b_99x.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpzf6b_99x.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpzf6b_99x.d(43): Error: found `if`
    when expecting `)`\n/tmp/tmpzf6b_99x.d(43): Error: found `&&` when expecting `)`\n/tmp/tmpzf6b_99x.d(43):
    Error: missing `{ ... }` for function literal\n/tmp/tmpzf6b_99x.d(43): Error:
    found `foundPositive` when expecting `;` following statement\n/tmp/tmpzf6b_99x.d(43):
    Error: found `)` instead of statement\n/tmp/tmpzf6b_99x.d(48): Error: declaration
    expected, not `return`\n/tmp/tmpzf6b_99x.d(49): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzf6b_99x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \           result.b = null;\n        }\n        else\n        {\n           \
    \ result.a = null;\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdpsbk9j6.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpdpsbk9j6.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdpsbk9j6.d(37): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpsbk9j6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            negative = true;\n     \
    \   } else if (i > largest) {\n            largest = i;\n        } else if (i\
    \ < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result = Tuple!(Nullable!(long), Nullable!(long)) (largest,\
    \ smallest);\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, null);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf0c1g_eg.d(25): Error: semicolon expected, not `:`\n/tmp/tmpf0c1g_eg.d(25):
    Error: expression expected, not `:`\n/tmp/tmpf0c1g_eg.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpf0c1g_eg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool found\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst) {\n \
    \       if (i < 0) {\n            found = true;\n            max = i;\n      \
    \  } else {\n            min = i;\n        }\n    }\n    if (found) {\n      \
    \  result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n\
    \        result.b = min;\n    } else {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.a = Nullable!(long);\n        result.b = Nullable!(long);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp_m7vp3a.d(25): Error: semicolon expected, not `:`\n/tmp/tmpp_m7vp3a.d(25):
    Error: expression expected, not `:`\n/tmp/tmpp_m7vp3a.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpp_m7vp3a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        foreach(j : lst, \n            \n            if(i\
    \ == j)\n            {\n                if(i == 0)\n                {\n      \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \      }\n                else\n                {\n                    result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n                }\n           \
    \ }\n            else\n            {\n                if(i.signum() < j.signum())\n\
    \                {\n                    result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \                }\n                else\n                {\n                \
    \    result = Tuple!(Nullable!(long), Nullable!(long));\n                }\n \
    \           }\n        )\n    );\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppz57pdhg.d(23): Error: no identifier for declarator `i`\n/tmp/tmppz57pdhg.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmppz57pdhg.d(25): Error: expression
    expected, not `foreach`\n/tmp/tmppz57pdhg.d(25): Error: found `:` when expecting
    `,`\n/tmp/tmppz57pdhg.d(27): Error: expression expected, not `if`\n/tmp/tmppz57pdhg.d(28):
    Error: found `{` when expecting `,`\n/tmp/tmppz57pdhg.d(29): Error: expression
    expected, not `if`\n/tmp/tmppz57pdhg.d(30): Error: found `{` when expecting `,`\n/tmp/tmppz57pdhg.d(31):
    Error: found `;` when expecting `,`\n/tmp/tmppz57pdhg.d(32): Error: expression
    expected, not `}`\n/tmp/tmppz57pdhg.d(33): Error: found `else` when expecting
    `,`\n/tmp/tmppz57pdhg.d(37): Error: found `}` when expecting `,`\n/tmp/tmppz57pdhg.d(38):
    Error: expression expected, not `else`\n/tmp/tmppz57pdhg.d(39): Error: found `{`
    when expecting `,`\n/tmp/tmppz57pdhg.d(40): Error: expression expected, not `if`\n/tmp/tmppz57pdhg.d(41):
    Error: found `{` when expecting `,`\n/tmp/tmppz57pdhg.d(42): Error: found `;`
    when expecting `,`\n/tmp/tmppz57pdhg.d(43): Error: expression expected, not `}`\n/tmp/tmppz57pdhg.d(44):
    Error: found `else` when expecting `,`\n/tmp/tmppz57pdhg.d(48): Error: found `}`
    when expecting `,`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppz57pdhg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    bool negative = true;\n    long max = 0;\n    long min = 0;\n \
    \   foreach(long i, lst)\n    {\n        if (i < 0)\n        {\n            negative\
    \ = false;\n        }\n        if (i > 0)\n        {\n            positive = false;\n\
    \        }\n        if (i == 0)\n        {\n            max = i;\n           \
    \ min = i;\n        }\n        else\n        {\n            if (max < i)\n   \
    \         {\n                max = i;\n            }\n            if (min > i)\n\
    \            {\n                min = i;\n            }\n        }\n    }\n  \
    \  if (positive && negative)\n    {\n        result.a = Nullable!(long);\n   \
    \     result.b = Nullable!(long);\n    }\n    else if (positive)\n    {\n    \
    \    result.a = Nullable!(long);\n        result.b = max;\n    }\n    else if\
    \ (negative)\n    {\n        result.a = min;\n        result.b = Nullable!(long);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(long);\n        result.b\
    \ = Nullable!(long);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq0zjcw8c.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpq0zjcw8c.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpq0zjcw8c.d(53): Error: found `if`
    when expecting `)`\n/tmp/tmpq0zjcw8c.d(53): Error: found `&&` when expecting `)`\n/tmp/tmpq0zjcw8c.d(53):
    Error: missing `{ ... }` for function literal\n/tmp/tmpq0zjcw8c.d(53): Error:
    found `negative` when expecting `;` following statement\n/tmp/tmpq0zjcw8c.d(53):
    Error: found `)` instead of statement\n/tmp/tmpq0zjcw8c.d(58): Error: declaration
    expected, not `else`\n/tmp/tmpq0zjcw8c.d(61): Error: no identifier for declarator
    `result.b`\n/tmp/tmpq0zjcw8c.d(61): Error: declaration expected, not `=`\n/tmp/tmpq0zjcw8c.d(62):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0zjcw8c.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n       \
    \     foundNegative = true;\n            largestNegative = i;\n        }\n   \
    \     else if (i > 0)\n        {\n            foundPositive = true;\n        \
    \    largestPositive = i;\n        }\n        else\n        {\n            smallestPositive\
    \ = i;\n            smallestNegative = i;\n        }\n    }\n    if (foundNegative)\n\
    \    {\n        result.a = Nullable!(largestNegative);\n        result.b = Nullable!(smallestPositive);\n\
    \    }\n    else if (foundPositive)\n    {\n        result.a = Nullable!(largestPositive);\n\
    \        result.b = Nullable!(smallestNegative);\n    }\n    else\n    {\n   \
    \     result.a = Nullable!(null);\n        result.b = Nullable!(null);\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmputlo94yn.d(28): Error: semicolon expected, not `:`\n/tmp/tmputlo94yn.d(28):
    Error: expression expected, not `:`\n/tmp/tmputlo94yn.d(28): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmputlo94yn.d(63): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputlo94yn.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    \n    for (long i : lst) {\n \
    \       if (i < 0) {\n            has_negative = true;\n        }\n        if\
    \ (i > 0) {\n            has_positive = true;\n        }\n    }\n    \n    if\
    \ (has_negative && has_positive) {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \        result.a = null;\n        result.b = null;\n    } else if (has_negative)\
    \ {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = null;\n        result.b = Long.min;\n    } else if (has_positive) {\n    \
    \    result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = Long.max;\n\
    \        result.b = null;\n    } else {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.a = null;\n        result.b = null;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpes7alavr.d(25): Error: semicolon expected, not `:`\n/tmp/tmpes7alavr.d(25):
    Error: expression expected, not `:`\n/tmp/tmpes7alavr.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpes7alavr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers(i))\n\
    \    {\n        if(t.a != null)\n        {\n            if(t.b != null)\n    \
    \        {\n                result = t;\n                break;\n            }\n\
    \            else\n            {\n                result = null;\n           \
    \     break;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp68_8w_s0.d(23): Error: no identifier for declarator `i`\n/tmp/tmp68_8w_s0.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp68_8w_s0.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmp68_8w_s0.d(24): Error: found `=` instead of statement\n/tmp/tmp68_8w_s0.d(33):
    Error: declaration expected, not `else`\n/tmp/tmp68_8w_s0.d(36): Error: declaration
    expected, not `break`\n/tmp/tmp68_8w_s0.d(37): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp68_8w_s0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst)\n    {\n        if (i < 0L)\n        {\n            result.a = Nullable!(long);\n\
    \            result.b = i;\n        }\n        else if (i > 0L)\n        {\n \
    \           result.a = i;\n            result.b = Nullable!(long);\n        }\n\
    \        else\n        {\n            result.a = Nullable!(long);\n          \
    \  result.b = Nullable!(long);\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphzuue2yf.d(23): Error: no identifier for declarator `i`\n/tmp/tmphzuue2yf.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphzuue2yf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        return result;\n    }\n    \n    long max;\n\
    \    long min;\n    \n    foreach (long i in lst)\n    {\n        if (i < 0)\n\
    \        {\n            max = i;\n        }\n        else\n        {\n       \
    \     min = i;\n        }\n    }\n    \n    if (max == min)\n    {\n        return\
    \ result;\n    }\n    \n    result.0 = max;\n    result.1 = min;\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmfruwj4w.d(31): Error: found `in` when expecting `;`\n/tmp/tmpmfruwj4w.d(48):
    Error: found `0.00000` when expecting `;` following statement\n/tmp/tmpmfruwj4w.d(48):
    Error: found `=` instead of statement\n/tmp/tmpmfruwj4w.d(49): Error: found `0.1`
    when expecting `;` following statement\n/tmp/tmpmfruwj4w.d(49): Error: found `=`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfruwj4w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    foreach(long i in lst)\n    {\n        if (i\
    \ < 0)\n        {\n            foundNegative = true;\n        }\n        if (i\
    \ > 0)\n        {\n            foundPositive = true;\n        }\n        if (foundNegative\
    \ && foundPositive)\n        {\n            break;\n        }\n        if (foundNegative)\n\
    \        {\n            largest = i;\n        }\n        if (foundPositive)\n\
    \        {\n            smallest = i;\n        }\n    }\n    if (foundNegative\
    \ && foundPositive)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \        result.a = largest;\n        result.b = smallest;\n    }\n    else\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = Nullable!(long);\n        result.b = Nullable!(long);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbnbb37wt.d(26): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbnbb37wt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    for (long i : lst)\n    {\n  \
    \      if (i < 0)\n        {\n            has_negative = true;\n        }\n  \
    \      else if (i > 0)\n        {\n            has_positive = true;\n        }\n\
    \    }\n    if (has_negative && has_positive)\n    {\n        Tuple!(Nullable!(long),\
    \ Nullable!(long)) tuple = Tuple!(Nullable!(long), Nullable!(long));\n       \
    \ tuple.a = null;\n        tuple.b = null;\n        return tuple;\n    }\n   \
    \ else if (has_negative)\n    {\n        Tuple!(Nullable!(long), Nullable!(long))\
    \ tuple = Tuple!(Nullable!(long), Nullable!(long));\n        tuple.a = null;\n\
    \        tuple.b = lst[0];\n        return tuple;\n    }\n    else if (has_positive)\n\
    \    {\n        Tuple!(Nullable!(long), Nullable!(long)) tuple = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        tuple.a = lst[0];\n        tuple.b = null;\n    \
    \    return tuple;\n    }\n    else\n    {\n        Tuple!(Nullable!(long), Nullable!(long))\
    \ tuple = Tuple!(Nullable!(long), Nullable!(long));\n        tuple.a = null;\n\
    \        tuple.b = null;\n        return tuple;\n    }\n}\n/*\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8ry8t20t.d(24): Error: semicolon expected, not `:`\n/tmp/tmp8ry8t20t.d(24):
    Error: expression expected, not `:`\n/tmp/tmp8ry8t20t.d(24): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp8ry8t20t.d(64): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ry8t20t.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst) {\n\
    \        if (x < 0) {\n            a = x;\n        } else {\n            b = x;\n\
    \        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjjwdkgd4.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpjjwdkgd4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpjjwdkgd4.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjwdkgd4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    while (i < lst.len) {\n        var x = lst[i];\n        if\
    \ (x < 0) {\n            if (largest == Nullable!(long)) {\n                largest\
    \ = Nullable!(long);\n            }\n            largest.val = x;\n        } else\
    \ {\n            if (smallest == Nullable!(long)) {\n                smallest\
    \ = Nullable!(long);\n            }\n            smallest.val = x;\n        }\n\
    \        i += 1;\n    }\n    return (largest, smallest);\n}\nunittest\n{\n   \
    \ alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppur7i4hx.d(21): Error: undefined identifier `var`\n/tmp/tmppur7i4hx.d(21):
    Error: type `inout(long)` has no value\n/tmp/tmppur7i4hx.d(22): Error: undefined
    identifier `var`\n/tmp/tmppur7i4hx.d(22): Error: type `inout(long)` has no value\n/tmp/tmppur7i4hx.d(23):
    Error: undefined identifier `var`\n/tmp/tmppur7i4hx.d(24): Error: no property
    `len` for type `long[]`\n/tmp/tmppur7i4hx.d(25): Error: undefined identifier `var`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppur7i4hx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, el) in zip(lst, lst.tail) {\n        if (el < 0L) {\n            result.a\
    \ = el;\n            result.b = null; // no negative integers\n            break;\n\
    \        }\n    }\n    \n    if (result.a == null) {\n        result.a = null;\
    \ // no negative integers\n        result.b = null; // no positive integers\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdttcmqcj.d(23): Error: no identifier for declarator `el`\n/tmp/tmpdttcmqcj.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdttcmqcj.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdttcmqcj.d(23): Error: found `zip` when expecting
    `)`\n/tmp/tmpdttcmqcj.d(31): Error: found `if` when expecting `;` following statement\n/tmp/tmpdttcmqcj.d(31):
    Error: found `==` when expecting `)`\n/tmp/tmpdttcmqcj.d(31): Error: missing `{
    ... }` for function literal\n/tmp/tmpdttcmqcj.d(31): Error: found `null` when
    expecting `;` following statement\n/tmp/tmpdttcmqcj.d(31): Error: found `)` instead
    of statement\n/tmp/tmpdttcmqcj.d(36): Error: declaration expected, not `return`\n/tmp/tmpdttcmqcj.d(37):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdttcmqcj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else if\
    \ (x > 0) {\n            result.b = x;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmperk3wda6.d(23): Error: no identifier for declarator `lst`\n/tmp/tmperk3wda6.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmperk3wda6.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperk3wda6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long max = 0;\n    long min =\
    \ 0;\n    foreach(long i in lst)\n    {\n        if (i < 0)\n        {\n     \
    \       foundNegative = true;\n        }\n        if (i > 0)\n        {\n    \
    \        foundPositive = true;\n        }\n        if (foundNegative && foundPositive)\n\
    \        {\n            break;\n        }\n        if (foundNegative)\n      \
    \  {\n            max = i;\n        }\n        if (foundPositive)\n        {\n\
    \            min = i;\n        }\n    }\n    if (foundNegative && foundPositive)\n\
    \    {\n        result.a = max;\n        result.b = min;\n    }\n    else\n  \
    \  {\n        result.a = null;\n        result.b = null;\n    }\n    return result;\n\
    }\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n  \
    \      auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk1brqrto.d(26): Error: found `in` when expecting `;`\n/tmp/tmpk1brqrto.d(61):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk1brqrto.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ isNegative = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n\
    \    \n    for (long i : lst) {\n        if (i < 0) {\n            isNegative\
    \ = true;\n        }\n        if (i > largest) {\n            largest = i;\n \
    \       }\n        if (i < smallest) {\n            smallest = i;\n        }\n\
    \    }\n    \n    if (isNegative) {\n        result.first = null;\n        result.second\
    \ = smallest;\n    } else {\n        result.first = largest;\n        result.second\
    \ = smallest;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdpm5j2mp.d(27): Error: semicolon expected, not `:`\n/tmp/tmpdpm5j2mp.d(27):
    Error: expression expected, not `:`\n/tmp/tmpdpm5j2mp.d(27): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdpm5j2mp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool is_negative\
    \ = false;\n    long max_negative = Long.min;\n    long min_positive = Long.max;\n\
    \    foreach (long i in lst) {\n        if (is_negative) {\n            if (i\
    \ < 0) {\n                is_negative = false;\n                min_positive =\
    \ i;\n            } else {\n                if (i > max_negative) {\n        \
    \            max_negative = i;\n                }\n            }\n        } else\
    \ {\n            if (i > 0) {\n                is_negative = true;\n         \
    \       max_negative = i;\n            } else {\n                if (i < min_positive)\
    \ {\n                    min_positive = i;\n                }\n            }\n\
    \        }\n    }\n    if (is_negative) {\n        result.a = max_negative;\n\
    \        result.b = min_positive;\n    } else {\n        result.a = min_positive;\n\
    \        result.b = max_negative;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp667iisdl.d(25): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp667iisdl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, el) in zip(lst, lst[1..])\n    {\n        if (el < 0)\n        {\n     \
    \       result.a = el;\n            result.b = i;\n            break;\n      \
    \  }\n    }\n    \n    if (result.a == null)\n    {\n        result.a = null;\n\
    \        result.b = null;\n    }\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplvhvny9_.d(23): Error: no identifier for declarator `el`\n/tmp/tmplvhvny9_.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplvhvny9_.d(23): Error: expression
    expected, not `in`\n/tmp/tmplvhvny9_.d(23): Error: found `zip` when expecting
    `)`\n/tmp/tmplvhvny9_.d(23): Error: expression expected, not `]`\n/tmp/tmplvhvny9_.d(23):
    Error: found `)` when expecting `]`\n/tmp/tmplvhvny9_.d(24): Error: found `{`
    when expecting `)`\n/tmp/tmplvhvny9_.d(25): Error: missing `{ ... }` for function
    literal\n/tmp/tmplvhvny9_.d(25): Error: found `if` when expecting `;` following
    statement\n/tmp/tmplvhvny9_.d(25): Error: found `<` when expecting `)`\n/tmp/tmplvhvny9_.d(25):
    Error: missing `{ ... }` for function literal\n/tmp/tmplvhvny9_.d(25): Error:
    found `0` when expecting `;` following statement\n/tmp/tmplvhvny9_.d(25): Error:
    found `)` instead of statement\n/tmp/tmplvhvny9_.d(31): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvhvny9_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst) {\n\
    \        if (x < 0) {\n            a = x;\n        } else {\n            b = x;\n\
    \        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjjwdkgd4.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpjjwdkgd4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpjjwdkgd4.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjwdkgd4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst)\n    {\n        if (i < 0)\n        {\n            result.a = i;\n  \
    \      }\n        else if (i > 0)\n        {\n            result.b = i;\n    \
    \    }\n        else\n        {\n            result.a = null;\n            result.b\
    \ = null;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxldxmgd6.d(23): Error: no identifier for declarator `i`\n/tmp/tmpxldxmgd6.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxldxmgd6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool neg\
    \ = false;\n    long max = 0;\n    long min = 0;\n    foreach(long x in lst)\n\
    \    {\n        if (x < 0)\n        {\n            neg = true;\n        }\n  \
    \      if (x > max)\n        {\n            max = x;\n        }\n        if (x\
    \ < min)\n        {\n            min = x;\n        }\n    }\n    if (neg)\n  \
    \  {\n        result.a = Nullable!(long);\n        result.b = Nullable!(long);\n\
    \    }\n    else\n    {\n        result.a = max;\n        result.b = min;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0m1ehcii.d(25): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m1ehcii.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long max;\n    long min;\n    foreach(long x, lst) {\n       \
    \ if (x < 0) {\n            max = x;\n        } else {\n            min = x;\n\
    \        }\n    }\n    return Tuple!(Nullable!(long), Nullable!(long)) (max, min);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpioay0pbc.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpioay0pbc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpioay0pbc.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpioay0pbc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ negative = false;\n    long max = 0;\n    long min = 0;\n    \n    for (long\
    \ i : lst)\n    {\n        if (i < 0)\n        {\n            negative = true;\n\
    \        }\n        \n        if (i > max)\n        {\n            max = i;\n\
    \        }\n        \n        if (i < min)\n        {\n            min = i;\n\
    \        }\n    }\n    \n    if (negative && max > min)\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n     \
    \   result.b = min;\n    }\n    else if (!negative && max < min)\n    {\n    \
    \    result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n\
    \        result.b = min;\n    }\n    else if (!negative && max == min)\n    {\n\
    \        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max == 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = max;\n    }\n    else if (!negative && max != 0)\n\
    \    {\n        result = Tuple!(Nullable!(long\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe_1fr671.d(27): Error: semicolon expected, not `:`\n/tmp/tmpe_1fr671.d(27):
    Error: expression expected, not `:`\n/tmp/tmpe_1fr671.d(27): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpe_1fr671.d(114): Error:
    found `unittest` when expecting `.` following long\n/tmp/tmpe_1fr671.d(115): Error:
    found `{` when expecting identifier following `long`.\n/tmp/tmpe_1fr671.d(116):
    Error: found `alias` when expecting `)` following template argument list\n/tmp/tmpe_1fr671.d(116):
    Error: found `candidate` when expecting `)` following template argument list\n/tmp/tmpe_1fr671.d(185):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_1fr671.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n\
    \        {\n            foundNegative = true;\n        }\n        else if (i >\
    \ 0)\n        {\n            foundPositive = true;\n        }\n        else\n\
    \        {\n            if (foundNegative && foundPositive)\n            {\n \
    \               result = Tuple!(Nullable!(long), Nullable!(long));\n         \
    \   }\n            else if (foundNegative)\n            {\n                result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n            }\n            else\
    \ if (foundPositive)\n            {\n                result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n            }\n            else\n            {\n        \
    \        result = Tuple!(Nullable!(long), Nullable!(long));\n            }\n \
    \           break;\n        }\n        if (largest < i)\n        {\n         \
    \   largest = i;\n        }\n        if (smallest > i)\n        {\n          \
    \  smallest = i;\n        }\n    }\n    if (foundNegative && foundPositive)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n  \
    \  else if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    else if (foundPositive)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu3wnx0lh.d(26): Error: semicolon expected, not `:`\n/tmp/tmpu3wnx0lh.d(26):
    Error: expression expected, not `:`\n/tmp/tmpu3wnx0lh.d(26): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpu3wnx0lh.d(83): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu3wnx0lh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else if\
    \ (x > 0) {\n            result.b = x;\n        } else {\n            result.a\
    \ = null;\n            result.b = null;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa22_t3t7.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpa22_t3t7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpa22_t3t7.d(34): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa22_t3t7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            negative = true;\n     \
    \   }\n        if (i > largest) {\n            largest = i;\n        }\n     \
    \   if (i < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result = Tuple!(Nullable!(long), Nullable!(long)) (largest,\
    \ smallest);\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, null);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk3rlhumg.d(25): Error: semicolon expected, not `:`\n/tmp/tmpk3rlhumg.d(25):
    Error: expression expected, not `:`\n/tmp/tmpk3rlhumg.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpk3rlhumg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n               else if (i > 0L) result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n               else result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa4e3rllk.d(23): Error: no identifier for declarator `i`\n/tmp/tmpa4e3rllk.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpa4e3rllk.d(28): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa4e3rllk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long smallest = lst.min();\n\
    \    long largest = lst.max();\n    \n    if (smallest < 0)\n    {\n        result.a\
    \ = null;\n        result.b = smallest;\n    }\n    else if (largest > 0)\n  \
    \  {\n        result.a = largest;\n        result.b = null;\n    }\n    else\n\
    \    {\n        result.a = null;\n        result.b = null;\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp91fj4fhl.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmp91fj4fhl.d(26):
    Error: no property `min` for type `long[]`\n/tmp/tmp91fj4fhl.d(27): Error: no
    property `max` for type `long[]`\n/tmp/tmp91fj4fhl.d(31): Error: no property `a`
    for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp91fj4fhl.d(32): Error:
    no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp91fj4fhl.d(36):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp91fj4fhl.d(37):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp91fj4fhl.d(41):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp91fj4fhl.d(42):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91fj4fhl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if (i < 0) \n               result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (null, i); \n           else\n               result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (i, null));\n    \n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_k1hndlx.d(23): Error: no identifier for declarator `i`\n/tmp/tmp_k1hndlx.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp_k1hndlx.d(24): Error: expression
    expected, not `if`\n/tmp/tmp_k1hndlx.d(25): Error: found `result` when expecting
    `)`\n/tmp/tmp_k1hndlx.d(25): Error: found `=` instead of statement\n/tmp/tmp_k1hndlx.d(26):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_k1hndlx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            negative = true;\n     \
    \   } else if (i > largest) {\n            largest = i;\n        } else if (i\
    \ < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ && smallest == Long.min) {\n        result.first = null;\n    } else {\n   \
    \     result.first = largest;\n    }\n    if (negative && largest == Long.max)\
    \ {\n        result.second = null;\n    } else {\n        result.second = smallest;\n\
    \    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphi842ojh.d(25): Error: semicolon expected, not `:`\n/tmp/tmphi842ojh.d(25):
    Error: expression expected, not `:`\n/tmp/tmphi842ojh.d(25): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmphi842ojh.d(46): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphi842ojh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            positive = false;\n    \
    \    }\n        if (i > largest) {\n            largest = i;\n        }\n    \
    \    if (i < smallest) {\n            smallest = i;\n        }\n    }\n    if\
    \ (positive && smallest == Long.max) {\n        result.a = Nullable!(null);\n\
    \        result.b = Nullable!(null);\n    } else {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvk246uaz.d(25): Error: semicolon expected, not `:`\n/tmp/tmpvk246uaz.d(25):
    Error: expression expected, not `:`\n/tmp/tmpvk246uaz.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvk246uaz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        return result;\n    }\n    \n    long largest\
    \ = lst.max();\n    long smallest = lst.min();\n    \n    if (largest < 0)\n \
    \   {\n        result.a = null;\n        result.b = smallest;\n    }\n    else\n\
    \    {\n        result.a = largest;\n        result.b = smallest;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvvxytx5c.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmpvvxytx5c.d(28):
    Error: no property `max` for type `long[]`\n/tmp/tmpvvxytx5c.d(29): Error: no
    property `min` for type `long[]`\n/tmp/tmpvvxytx5c.d(33): Error: no property `a`
    for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpvvxytx5c.d(34): Error:
    no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpvvxytx5c.d(38):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpvvxytx5c.d(39):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvvxytx5c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n                   result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n               else if (i > 0L)\n\
    \                   result = Tuple!(Nullable!(long), Nullable!(long));\n     \
    \          else\n                   result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgnscqgz7.d(23): Error: no identifier for declarator `i`\n/tmp/tmpgnscqgz7.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpgnscqgz7.d(31): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnscqgz7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    long max_negative = Long.min;\n\
    \    long min_positive = Long.max;\n    foreach(long x, lst) {\n        if (x\
    \ < 0) {\n            has_negative = true;\n            max_negative = x;\n  \
    \      } else if (x > 0) {\n            has_positive = true;\n            min_positive\
    \ = x;\n        }\n    }\n    if (has_negative && has_positive) {\n        result.first\
    \ = null;\n        result.second = min_positive;\n    } else if (has_negative)\
    \ {\n        result.first = null;\n        result.second = max_negative;\n   \
    \ } else if (has_positive) {\n        result.first = max_positive;\n        result.second\
    \ = null;\n    } else {\n        result.first = null;\n        result.second =\
    \ null;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1ti4u02a.d(26): Error: no identifier for declarator `lst`\n/tmp/tmp1ti4u02a.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmp1ti4u02a.d(35): Error: found `if`
    when expecting `)`\n/tmp/tmp1ti4u02a.d(35): Error: found `&&` when expecting `)`\n/tmp/tmp1ti4u02a.d(35):
    Error: missing `{ ... }` for function literal\n/tmp/tmp1ti4u02a.d(35): Error:
    found `has_positive` when expecting `;` following statement\n/tmp/tmp1ti4u02a.d(35):
    Error: found `)` instead of statement\n/tmp/tmp1ti4u02a.d(38): Error: declaration
    expected, not `else`\n/tmp/tmp1ti4u02a.d(40): Error: no identifier for declarator
    `result.second`\n/tmp/tmp1ti4u02a.d(40): Error: declaration expected, not `=`\n/tmp/tmp1ti4u02a.d(41):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ti4u02a.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.Length;\n   \
    \ while (i < n) {\n        if (lst[i] < smallest) {\n            smallest = Nullable!(long);\n\
    \        }\n        if (lst[i] > largest) {\n            largest = Nullable!(long);\n\
    \        }\n        if (lst[i] < 0) {\n            smallest = Nullable!(long);\n\
    \        }\n        if (lst[i] > 0) {\n            largest = Nullable!(long);\n\
    \        }\n        i += 1;\n    }\n    return Tuple!(largest, smallest);\n}\n\
    /*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
    \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw6s8gf0z.d(44): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpw6s8gf0z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0L) {\n            result.a = e;\n        }\
    \ else {\n            result.b = e;\n        }\n    }\n    \n    if (result.a\
    \ == null) {\n        result.a = result.b;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp00u_8b1b.d(23): Error: no identifier for declarator `e`\n/tmp/tmp00u_8b1b.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp00u_8b1b.d(23): Error: expression
    expected, not `in`\n/tmp/tmp00u_8b1b.d(23): Error: found `lst` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp00u_8b1b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchvp_66m.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpchvp_66m.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpchvp_66m.d(31): Error: found `if`
    when expecting `)`\n/tmp/tmpchvp_66m.d(31): Error: found `==` when expecting `)`\n/tmp/tmpchvp_66m.d(31):
    Error: missing `{ ... }` for function literal\n/tmp/tmpchvp_66m.d(31): Error:
    found `null` when expecting `;` following statement\n/tmp/tmpchvp_66m.d(31): Error:
    found `)` instead of statement\n/tmp/tmpchvp_66m.d(35): Error: declaration expected,
    not `return`\n/tmp/tmpchvp_66m.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchvp_66m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    \n    for (long\
    \ i : lst)\n    {\n        if (i < 0)\n        {\n            foundNegative =\
    \ true;\n        }\n        else if (i > 0)\n        {\n            foundPositive\
    \ = true;\n        }\n    }\n    \n    if (foundNegative && foundPositive)\n \
    \   {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n   \
    \ else if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    else if (foundPositive)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp79dnj4rh.d(26): Error: semicolon expected, not `:`\n/tmp/tmp79dnj4rh.d(26):
    Error: expression expected, not `:`\n/tmp/tmp79dnj4rh.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp79dnj4rh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n\
    \        {\n            foundNegative = true;\n        }\n        else if (i >\
    \ 0)\n        {\n            foundPositive = true;\n        }\n        else\n\
    \        {\n            if (foundNegative && foundPositive)\n            {\n \
    \               result = Tuple!(Nullable!(long), Nullable!(long));\n         \
    \       break;\n            }\n            else if (foundNegative)\n         \
    \   {\n                result = Tuple!(Nullable!(long), Nullable!(long));\n  \
    \              break;\n            }\n            else if (foundPositive)\n  \
    \          {\n                result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \                break;\n            }\n        }\n        if (largest < i)\n\
    \        {\n            largest = i;\n        }\n        if (smallest > i)\n \
    \       {\n            smallest = i;\n        }\n    }\n    if (foundNegative\
    \ && foundPositive)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    else if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else if (foundPositive)\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n    }\n    return result;\n}\n\
    /*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
    \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbwas5ftb.d(26): Error: semicolon expected, not `:`\n/tmp/tmpbwas5ftb.d(26):
    Error: expression expected, not `:`\n/tmp/tmpbwas5ftb.d(26): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpbwas5ftb.d(77): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbwas5ftb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = Long.MinValue;\n\
    \    long largestPositive = Long.MaxValue;\n    long smallestNegative = Long.MaxValue;\n\
    \    long smallestPositive = Long.MinValue;\n    foreach(long i, lst)\n    {\n\
    \        if (i < 0)\n        {\n            foundNegative = true;\n          \
    \  largestNegative = i;\n        }\n        else if (i > 0)\n        {\n     \
    \       foundPositive = true;\n            largestPositive = i;\n        }\n \
    \       else\n        {\n            smallestNegative = i;\n            smallestPositive\
    \ = i;\n        }\n    }\n    if (foundNegative)\n    {\n        result.a = Nullable!(largestNegative);\n\
    \        result.b = Nullable!(smallestPositive);\n    }\n    else if (foundPositive)\n\
    \    {\n        result.a = Nullable!(largestPositive);\n        result.b = Nullable!(smallestNegative);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(null);\n        result.b\
    \ = Nullable!(null);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb686rpg0.d(28): Error: no identifier for declarator `lst`\n/tmp/tmpb686rpg0.d(28):
    Error: found `)` when expecting `;`\n/tmp/tmpb686rpg0.d(46): Error: found `if`
    when expecting `)`\n/tmp/tmpb686rpg0.d(51): Error: found `else` when expecting
    `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb686rpg0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n               {\n     \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \     }\n               else\n               {\n                   result = Tuple!(i,\
    \ i);\n               }\n           });\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjm6dqisd.d(23): Error: no identifier for declarator `i`\n/tmp/tmpjm6dqisd.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpjm6dqisd.d(33): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjm6dqisd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0L) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n\
    \                    if(i>0L) Tuple!(Nullable!(long), Nullable!(long)) (null,\
    \ i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                       \
    \ if(i<0L) Tuple!(Nullable!(long), Nullable!(long)) (null, i) else Tuple!(Nullable!(long),\
    \ Nullable!(long)) (\n                            if(i>0L) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n\
    \                                if(i<0L) Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                \
    \                    if(i>0L) Tuple!(Nullable!(long), Nullable!(long)) (null,\
    \ i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                       \
    \                 if(i<0L) Tuple!(Nullable!(long), Nullable!(long)) (null, i)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (\n                          \
    \                  if(i>0L) Tuple!(Nullable!(long), Nullable!(long)) (null, i)\
    \ else Tuple!(Nullable!(long), Nullable!(long)) (\n                          \
    \                      if(i<0L) Tuple!(Nullable!(long), Nullable!(long)) (null,\
    \ i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                       \
    \                             if(i>0L) Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                \
    \                                        if(i<0L) Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n                \
    \                                            if(i>0L) Tuple!(Nullable!(long),\
    \ Nullable!(long)) (null, i) else Tuple!(Nullable!(long), Nullable!(long)) (\n\
    \                                                                if(i<0L) Tuple!(Nullable\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgsd0kr_3.d(23): Error: no identifier for declarator `i`\n/tmp/tmpgsd0kr_3.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpgsd0kr_3.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmpgsd0kr_3.d(24): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgsd0kr_3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n            if(i<0L || i>=long.max) \n                => result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(Nullable!(0L), Nullable!(i))\n            else\n          \
    \      => result = Tuple!(Nullable!(long), Nullable!(long))(Nullable!(i), Nullable!(long.max))\n\
    \    );\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmhf1fxjk.d(23): Error: no identifier for declarator `i`\n/tmp/tmpmhf1fxjk.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpmhf1fxjk.d(24): Error: expression
    expected, not `if`\n/tmp/tmpmhf1fxjk.d(25): Error: found `=>` when expecting `)`\n/tmp/tmpmhf1fxjk.d(26):
    Error: found `else` when expecting `;` following statement\n/tmp/tmpmhf1fxjk.d(27):
    Error: found `=>` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmhf1fxjk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool neg\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst)\n   \
    \ {\n        if (i < 0)\n        {\n            neg = true;\n        }\n     \
    \   if (i > 0)\n        {\n            if (neg)\n            {\n             \
    \   if (max < 0)\n                {\n                    max = i;\n          \
    \      }\n                else\n                {\n                    min = i;\n\
    \                }\n            }\n            else\n            {\n         \
    \       if (max < 0)\n                {\n                    max = i;\n      \
    \          }\n                else\n                {\n                    min\
    \ = i;\n                }\n            }\n        }\n    }\n    if (neg)\n   \
    \ {\n        result.a = Nullable!(long);\n        result.b = Nullable!(long);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(long);\n        result.b\
    \ = Nullable!(long);\n        if (max < min)\n        {\n            result.a\
    \ = Nullable!(long);\n            result.b = Nullable!(long);\n        }\n   \
    \     else\n        {\n            result.a = max;\n            result.b = min;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxphs4w5w.d(25): Error: semicolon expected, not `:`\n/tmp/tmpxphs4w5w.d(25):
    Error: expression expected, not `:`\n/tmp/tmpxphs4w5w.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxphs4w5w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n           else result = Tuple!(Nullable!(long), Nullable!(long))) \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbpkgbyse.d(23): Error: no identifier for declarator `i`\n/tmp/tmpbpkgbyse.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpbpkgbyse.d(24): Error: expression
    expected, not `if`\n/tmp/tmpbpkgbyse.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmpbpkgbyse.d(24): Error: found `=` instead of statement\n/tmp/tmpbpkgbyse.d(25):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpkgbyse.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.MinValue;\n    long smallest = Long.MaxValue;\n\
    \    for (long i : lst) {\n        if (i < 0) {\n            positive = false;\n\
    \        }\n        if (i > largest) {\n            largest = i;\n        }\n\
    \        if (i < smallest) {\n            smallest = i;\n        }\n    }\n  \
    \  if (positive && smallest > largest) {\n        smallest = largest;\n    }\n\
    \    if (positive && smallest < largest) {\n        largest = smallest;\n    }\n\
    \    result.a = largest;\n    result.b = smallest;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpveqezg_w.d(25): Error: semicolon expected, not `:`\n/tmp/tmpveqezg_w.d(25):
    Error: expression expected, not `:`\n/tmp/tmpveqezg_w.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpveqezg_w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        foreach(j : lst, \n            \n            if(i\
    \ == j)\n            {\n                result := (Nullable!(long), Nullable!(long));\n\
    \                break;\n            }\n            \n            if(i.value <\
    \ j)\n            {\n                result := (Nullable!(long), Nullable!(long));\n\
    \                break;\n            }\n            \n            if(i.value >\
    \ j)\n            {\n                result := (Nullable!(long), Nullable!(long));\n\
    \                break;\n            }\n            \n            if(i.value ==\
    \ j)\n            {\n                result := (Nullable!(long), Nullable!(long));\n\
    \                break;\n            }\n            \n        )\n    );\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeswugrva.d(23): Error: no identifier for declarator `i`\n/tmp/tmpeswugrva.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpeswugrva.d(25): Error: expression
    expected, not `foreach`\n/tmp/tmpeswugrva.d(25): Error: found `:` when expecting
    `,`\n/tmp/tmpeswugrva.d(27): Error: expression expected, not `if`\n/tmp/tmpeswugrva.d(28):
    Error: found `{` when expecting `,`\n/tmp/tmpeswugrva.d(29): Error: found `:`
    when expecting `,`\n/tmp/tmpeswugrva.d(29): Error: expression expected, not `=`\n/tmp/tmpeswugrva.d(29):
    Error: found `;` when expecting `,`\n/tmp/tmpeswugrva.d(30): Error: expression
    expected, not `break`\n/tmp/tmpeswugrva.d(30): Error: found `;` when expecting
    `,`\n/tmp/tmpeswugrva.d(31): Error: expression expected, not `}`\n/tmp/tmpeswugrva.d(33):
    Error: found `if` when expecting `,`\n/tmp/tmpeswugrva.d(33): Error: found `<`
    when expecting `)`\n/tmp/tmpeswugrva.d(33): Error: missing `{ ... }` for function
    literal\n/tmp/tmpeswugrva.d(33): Error: found `j` when expecting `,`\n/tmp/tmpeswugrva.d(34):
    Error: found `{` when expecting `)`\n/tmp/tmpeswugrva.d(35): Error: found `=`
    instead of statement\n/tmp/tmpeswugrva.d(39): Error: declaration expected, not
    `if`\n/tmp/tmpeswugrva.d(42): Error: declaration expected, not `break`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeswugrva.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst) {\n\
    \        if (x < 0) {\n            a = x;\n        } else {\n            b = x;\n\
    \        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjjwdkgd4.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpjjwdkgd4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpjjwdkgd4.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjwdkgd4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n               {\n     \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \     }\n               else\n               {\n                   result = Tuple!(i,\
    \ Nullable!(long));\n               }\n           });\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4lbnaqs6.d(23): Error: no identifier for declarator `i`\n/tmp/tmp4lbnaqs6.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp4lbnaqs6.d(33): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4lbnaqs6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i : lst) {\n        if (i < 0) {\n            result.a = i;\n        } else\
    \ {\n            result.b = i;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0cr2p46y.d(23): Error: no identifier for declarator `i`\n/tmp/tmp0cr2p46y.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp0cr2p46y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (long x in lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    if (result.a == null)\n    {\n        result.a = result.b\
    \ == null ? null : result.b;\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprmmn24lc.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmmn24lc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst) {\n\
    \        if (x < 0) {\n            if (a is null) a = x;\n            else b =\
    \ x;\n        }\n        else if (x > 0) {\n            if (b is null) b = x;\n\
    \            else a = x;\n        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3b9ym37h.d(23): Error: no identifier for declarator `lst`\n/tmp/tmp3b9ym37h.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3b9ym37h.d(33): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3b9ym37h.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        foreach(j : lst, \n            \n            if(i<j)\
    \ \n            {\n                if(i>result.a) \n                {\n      \
    \              result.a = i;\n                    result.b = j;\n            \
    \    }\n            }\n            \n            if(i==j) \n            {\n  \
    \              if(i>result.a) \n                {\n                    result.a\
    \ = i;\n                }\n                \n                if(i<result.b) \n\
    \                {\n                    result.b = i;\n                }\n   \
    \         }\n            \n            if(i>j) \n            {\n             \
    \   if(i>result.a) \n                {\n                    result.a = i;\n  \
    \              }\n                \n                if(i<result.b) \n        \
    \        {\n                    result.b = j;\n                }\n           \
    \ }\n            \n        )\n    );\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbwfki8cm.d(23): Error: no identifier for declarator `i`\n/tmp/tmpbwfki8cm.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpbwfki8cm.d(25): Error: expression
    expected, not `foreach`\n/tmp/tmpbwfki8cm.d(25): Error: found `:` when expecting
    `,`\n/tmp/tmpbwfki8cm.d(27): Error: expression expected, not `if`\n/tmp/tmpbwfki8cm.d(28):
    Error: found `{` when expecting `,`\n/tmp/tmpbwfki8cm.d(29): Error: expression
    expected, not `if`\n/tmp/tmpbwfki8cm.d(30): Error: found `{` when expecting `,`\n/tmp/tmpbwfki8cm.d(31):
    Error: found `;` when expecting `,`\n/tmp/tmpbwfki8cm.d(32): Error: found `;`
    when expecting `,`\n/tmp/tmpbwfki8cm.d(33): Error: expression expected, not `}`\n/tmp/tmpbwfki8cm.d(34):
    Error: found `}` when expecting `,`\n/tmp/tmpbwfki8cm.d(36): Error: expression
    expected, not `if`\n/tmp/tmpbwfki8cm.d(37): Error: found `{` when expecting `,`\n/tmp/tmpbwfki8cm.d(38):
    Error: expression expected, not `if`\n/tmp/tmpbwfki8cm.d(39): Error: found `{`
    when expecting `,`\n/tmp/tmpbwfki8cm.d(40): Error: found `;` when expecting `,`\n/tmp/tmpbwfki8cm.d(41):
    Error: expression expected, not `}`\n/tmp/tmpbwfki8cm.d(43): Error: found `if`
    when expecting `,`\n/tmp/tmpbwfki8cm.d(43): Error: found `<` when expecting `)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbwfki8cm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool neg\
    \ = false;\n    long max = 0;\n    long min = 0;\n    foreach(long i in lst)\n\
    \    {\n        if (i < 0)\n        {\n            neg = true;\n            max\
    \ = i;\n        }\n        else\n        {\n            if (i > max)\n       \
    \     {\n                max = i;\n            }\n        }\n    }\n    foreach(long\
    \ i in lst)\n    {\n        if (i < 0)\n        {\n            if (neg)\n    \
    \        {\n                result.a = Nullable!(long);\n                result.b\
    \ = Nullable!(long);\n                return result;\n            }\n        \
    \    else\n            {\n                result.a = Nullable!(long);\n      \
    \          result.b = i;\n                return result;\n            }\n    \
    \    }\n        else\n        {\n            if (i > max)\n            {\n   \
    \             result.a = i;\n                result.b = Nullable!(long);\n   \
    \             return result;\n            }\n        }\n    }\n    result.a =\
    \ Nullable!(long);\n    result.b = Nullable!(long);\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp9h5bquz.d(25): Error: found `in` when expecting `;`\n/tmp/tmpp9h5bquz.d(40):
    Error: found `in` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpp9h5bquz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    long largestPositive\
    \ = 0;\n    long largestNegative = 0;\n    \n    for (long i : lst) {\n      \
    \  if (i < 0) {\n            foundNegative = true;\n            largestNegative\
    \ = i;\n        } else {\n            foundPositive = true;\n            largestPositive\
    \ = i;\n        }\n    }\n    \n    if (foundNegative) {\n        result.a = Nullable!(long);\n\
    \        result.b = Nullable!(long);\n    } else {\n        result.a = Nullable!(long);\n\
    \        result.b = Nullable!(long);\n    }\n    \n    if (foundPositive) {\n\
    \        if (largestPositive > largestNegative) {\n            result.a = largestPositive;\n\
    \            result.b = largestNegative;\n        } else {\n            result.a\
    \ = largestNegative;\n            result.b = largestPositive;\n        }\n   \
    \ }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptw0oqjfx.d(28): Error: semicolon expected, not `:`\n/tmp/tmptw0oqjfx.d(28):
    Error: expression expected, not `:`\n/tmp/tmptw0oqjfx.d(28): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmptw0oqjfx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n                   result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n               else if (i > 0L)\n\
    \                   result = Tuple!(Nullable!(long), Nullable!(long));\n     \
    \          else\n                   result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgnscqgz7.d(23): Error: no identifier for declarator `i`\n/tmp/tmpgnscqgz7.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpgnscqgz7.d(31): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnscqgz7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ isNegative = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n\
    \    \n    for (long i : lst) {\n        if (i < 0) {\n            isNegative\
    \ = true;\n        } else if (i > largest) {\n            largest = i;\n     \
    \   } else if (i < smallest) {\n            smallest = i;\n        }\n    }\n\
    \    \n    if (isNegative) {\n        result.a = Nullable!(null);\n        result.b\
    \ = Nullable!(smallest);\n    } else {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(null);\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1cl6ri06.d(27): Error: semicolon expected, not `:`\n/tmp/tmp1cl6ri06.d(27):
    Error: expression expected, not `:`\n/tmp/tmp1cl6ri06.d(27): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1cl6ri06.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    long max_negative = Long.min;\n\
    \    long min_positive = Long.max;\n    foreach(long x, lst) {\n        if (x\
    \ < 0) {\n            has_negative = true;\n            max_negative = x;\n  \
    \      } else if (x > 0) {\n            has_positive = true;\n            min_positive\
    \ = x;\n        }\n    }\n    if (has_negative) {\n        result.a = max_negative;\n\
    \    } else {\n        result.a = null;\n    }\n    if (has_positive) {\n    \
    \    result.b = min_positive;\n    } else {\n        result.b = null;\n    }\n\
    \    return result;\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg4w8ayjd.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpg4w8ayjd.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpg4w8ayjd.d(35): Error: found `if`
    when expecting `)`\n/tmp/tmpg4w8ayjd.d(37): Error: found `else` when expecting
    `;` following statement\n/tmp/tmpg4w8ayjd.d(47): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg4w8ayjd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            smallest = Long.max;\n        \
    \    positive = false;\n        } else if (x > largest) {\n            largest\
    \ = x;\n        }\n    }\n    if (positive && smallest == Long.max) {\n      \
    \  result.a = null;\n        result.b = null;\n    } else {\n        result.a\
    \ = largest;\n        result.b = smallest;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx5xrfx3o.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpx5xrfx3o.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpx5xrfx3o.d(33): Error: found `if`
    when expecting `)`\n/tmp/tmpx5xrfx3o.d(33): Error: found `&&` when expecting `)`\n/tmp/tmpx5xrfx3o.d(33):
    Error: missing `{ ... }` for function literal\n/tmp/tmpx5xrfx3o.d(33): Error:
    found `smallest` when expecting `;` following statement\n/tmp/tmpx5xrfx3o.d(33):
    Error: found `==` instead of statement\n/tmp/tmpx5xrfx3o.d(36): Error: declaration
    expected, not `else`\n/tmp/tmpx5xrfx3o.d(38): Error: no identifier for declarator
    `result.b`\n/tmp/tmpx5xrfx3o.d(38): Error: declaration expected, not `=`\n/tmp/tmpx5xrfx3o.d(39):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx5xrfx3o.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n           else result = Tuple!(Nullable!(long), Nullable!(long))); \n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp02xo7voj.d(23): Error: no identifier for declarator `i`\n/tmp/tmp02xo7voj.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp02xo7voj.d(24): Error: expression
    expected, not `if`\n/tmp/tmp02xo7voj.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmp02xo7voj.d(24): Error: found `=` instead of statement\n/tmp/tmp02xo7voj.d(25):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02xo7voj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        return result;\n    }\n    \n    long max;\n\
    \    long min;\n    \n    foreach (long i in lst)\n    {\n        if (i < 0)\n\
    \        {\n            max = i;\n        }\n        else\n        {\n       \
    \     min = i;\n        }\n    }\n    \n    if (max == min)\n    {\n        return\
    \ result;\n    }\n    \n    result.0 = max;\n    result.1 = min;\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmfruwj4w.d(31): Error: found `in` when expecting `;`\n/tmp/tmpmfruwj4w.d(48):
    Error: found `0.00000` when expecting `;` following statement\n/tmp/tmpmfruwj4w.d(48):
    Error: found `=` instead of statement\n/tmp/tmpmfruwj4w.d(49): Error: found `0.1`
    when expecting `;` following statement\n/tmp/tmpmfruwj4w.d(49): Error: found `=`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfruwj4w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach (long i in lst)\
    \ {\n        if (i < 0) {\n            a = i;\n        } else if (i > 0){\n  \
    \          b = i;\n        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzbrd4l7.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzbrd4l7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    long largest_negative = Long.min;\n\
    \    long largest_positive = Long.max;\n    foreach(long x, lst) {\n        if\
    \ (x < 0) {\n            has_negative = true;\n            largest_negative =\
    \ x;\n        } else if (x > 0) {\n            has_positive = true;\n        \
    \    largest_positive = x;\n        } else {\n            has_negative = false;\n\
    \            has_positive = false;\n        }\n    }\n    if (has_negative) {\n\
    \        result.a = Nullable!(largest_negative);\n    } else {\n        result.a\
    \ = Nullable!(largest_positive);\n    }\n    if (has_positive) {\n        result.b\
    \ = Nullable!(largest_positive);\n    } else {\n        result.b = Nullable!(largest_negative);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq4b3njgn.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpq4b3njgn.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpq4b3njgn.d(38): Error: found `if`
    when expecting `)`\n/tmp/tmpq4b3njgn.d(40): Error: found `else` when expecting
    `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4b3njgn.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.MinValue;\n    long smallest = Long.MaxValue;\n\
    \    foreach(long x, lst)\n    {\n        if (x < 0)\n        {\n            positive\
    \ = false;\n        }\n        if (x > largest)\n        {\n            largest\
    \ = x;\n        }\n        if (x < smallest)\n        {\n            smallest\
    \ = x;\n        }\n    }\n    if (positive == true)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(largest, smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long))(null, null);\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprcl5n9uw.d(25): Error: no identifier for declarator `lst`\n/tmp/tmprcl5n9uw.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmprcl5n9uw.d(40): Error: found `if`
    when expecting `)`\n/tmp/tmprcl5n9uw.d(40): Error: found `==` when expecting `)`\n/tmp/tmprcl5n9uw.d(40):
    Error: missing `{ ... }` for function literal\n/tmp/tmprcl5n9uw.d(40): Error:
    found `true` when expecting `;` following statement\n/tmp/tmprcl5n9uw.d(40): Error:
    found `)` instead of statement\n/tmp/tmprcl5n9uw.d(44): Error: declaration expected,
    not `else`\n/tmp/tmprcl5n9uw.d(47): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprcl5n9uw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = Long.MinValue;\n\
    \    long largestPositive = Long.MaxValue;\n    long smallestNegative = Long.MaxValue;\n\
    \    long smallestPositive = Long.MinValue;\n    for (long i : lst)\n    {\n \
    \       if (i < 0)\n        {\n            foundNegative = true;\n           \
    \ largestNegative = i;\n        }\n        else if (i > 0)\n        {\n      \
    \      foundPositive = true;\n            largestPositive = i;\n        }\n  \
    \      else\n        {\n            foundNegative = false;\n            foundPositive\
    \ = false;\n        }\n    }\n    if (foundNegative)\n    {\n        result.a\
    \ = Nullable!(largestNegative);\n    }\n    else if (foundPositive)\n    {\n \
    \       result.a = Nullable!(largestPositive);\n    }\n    else\n    {\n     \
    \   result.a = Nullable!(smallestNegative);\n        result.b = Nullable!(smallestPositive);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9osi31jk.d(28): Error: semicolon expected, not `:`\n/tmp/tmp9osi31jk.d(28):
    Error: expression expected, not `:`\n/tmp/tmp9osi31jk.d(28): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp9osi31jk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst) {\n        if (i < 0) {\n            largest = i;\n    \
    \    } else {\n            smallest = i;\n        }\n    }\n    return Tuple!(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn7pe_twj.d(23): Error: no identifier for declarator `i`\n/tmp/tmpn7pe_twj.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpn7pe_twj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tuple = \n       \
    \     Tuple!(Nullable!(long), Nullable!(long)) \n                largest_smallest_integers(\n\
    \                    Array!long(\n                        Array!long(\n      \
    \                      Array!long(\n                                Array!long(\n\
    \                                    Array!long(\n                           \
    \             Array!long(\n                                            Array!long(\n\
    \                                                Array!long(\n               \
    \                                     Array!long(\n                          \
    \                              Array!long(\n                                 \
    \                           Array!long(\n                                    \
    \                            Array!long(\n                                   \
    \                                 Array!long(\n                              \
    \                                          Array!long(\n                     \
    \                                                       Array!long(\n        \
    \                                                                        Array!long(\n\
    \                                                                            \
    \        Array!long(\n                                                       \
    \                                 Array!long(\n                              \
    \                                                              Array!long(\n \
    \                                                                            \
    \                   Array!long(\n                                            \
    \                                                        Array!long(\n       \
    \                                                                            \
    \                     Array!long(\n                                          \
    \                                                                  Array!long(\n\
    \                                                                            \
    \                                    Array!long(\n                           \
    \                                                                            \
    \             Array!long(\n                                                  \
    \                                                                      Array!long(\n\
    \                                                                            \
    \                                                Array!long(\n               \
    \                                                                            \
    \                                     Array!long(\n                          \
    \                                                                            \
    \                              Array!long(\n                                 \
    \                                                                            \
    \                           Array!long(\n                                    \
    \                                                                            \
    \                            Array!long(\n                                   \
    \                                                                            \
    \                                 Array!long(\n                              \
    \                                                                            \
    \                                          Array!long(\n                     \
    \                                                                            \
    \                                                       Array!long(\n        \
    \                                                                            \
    \                                                                        Array!long(\n\
    \                                                                            \
    \                                                                            \
    \        Array!long(\n                                                       \
    \                                                                            \
    \                                 Array!long(\n                              \
    \                                                                            \
    \                                                              Array!long(\n \
    \                                                                            \
    \                                                                            \
    \                   Array!long(\n                                            \
    \                                                                            \
    \                                                        Array!long(\n       \
    \                                                                            \
    \                                                                            \
    \                     Array!long(\n                                          \
    \                                                                            \
    \                                                                  Array!long(\n\
    \                                                                            \
    \                                                                            \
    \                                    Array!long(\n                           \
    \                                                                            \
    \                                                                            \
    \             Array!long(\n                                                  \
    \                                                                            \
    \                                                                      Array!long(\n\
    \                                                                            \
    \                                                                            \
    \                                                Array!long(\n               \
    \                                                                            \
    \                                                                            \
    \                                     Array!long(\n                          \
    \                                                                            \
    \                                                                            \
    \                              Array!long(\n                                 \
    \                                                                            \
    \                                                                            \
    \                           Array!long(\n                                    \
    \                                                                            \
    \                                                                            \
    \                            Array!long(\n                                   \
    \                                                                            \
    \                                                                            \
    \                                 Array!long(\n                              \
    \                                                                            \
    \                                                                            \
    \                                          Array!long(\n                     \
    \                                                                            \
    \                                                                            \
    \                                                       Array!long(\n        \
    \                                                                            \
    \                                                                            \
    \                                                                        Array!long(\n\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \        Array!long(\n                                                       \
    \                                                                            \
    \                                                                            \
    \                                 Array!long(\n                              \
    \                                                                            \
    \                                                                            \
    \                                                              Array!long(\n \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                   Array!long(\n                                            \
    \                                                                            \
    \                                                                            \
    \                                                        Array!long(\n\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp78zgvkx_.d(23): Error: no identifier for declarator `i`\n/tmp/tmp78zgvkx_.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp78zgvkx_.d(24): Error: found `tuple`
    when expecting `)`\n/tmp/tmp78zgvkx_.d(24): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp78zgvkx_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ i, lst)\n    {\n        if (i < 0)\n        {\n            negative = true;\n\
    \        }\n        if (i > 0)\n        {\n            if (largest < i)\n    \
    \        {\n                largest = i;\n            }\n            if (smallest\
    \ > i)\n            {\n                smallest = i;\n            }\n        }\n\
    \    }\n    if (negative == false)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (largest, smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long)) (null, null);\n    }\n    return\
    \ result;\n}\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb5t_4o69.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpb5t_4o69.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpb5t_4o69.d(43): Error: found `if`
    when expecting `)`\n/tmp/tmpb5t_4o69.d(43): Error: found `==` when expecting `)`\n/tmp/tmpb5t_4o69.d(43):
    Error: missing `{ ... }` for function literal\n/tmp/tmpb5t_4o69.d(43): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpb5t_4o69.d(43):
    Error: found `)` instead of statement\n/tmp/tmpb5t_4o69.d(47): Error: declaration
    expected, not `else`\n/tmp/tmpb5t_4o69.d(50): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5t_4o69.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) tmp = \n         \
    \   Tuple!(Nullable!(long), Nullable!(long)) (\n                std.math.max(std.math.min(i,\
    \ 0L), 0L),\n                std.math.min(std.math.max(i, 0L), 0L)\n         \
    \   )\n    )\n    \n    result = Tuple!(Nullable!(long), Nullable!(long)) (\n\
    \        std.math.max(std.math.min(result, 0L), 0L),\n        std.math.min(std.math.max(result,\
    \ 0L), 0L)\n    );\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3lk3mmpe.d(23): Error: no identifier for declarator `i`\n/tmp/tmp3lk3mmpe.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp3lk3mmpe.d(24): Error: found `tmp`
    when expecting `)`\n/tmp/tmp3lk3mmpe.d(24): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3lk3mmpe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (long x in lst)\n    {\n        if (x < 0)\n        {\n            result.a\
    \ = x;\n        }\n        else\n        {\n            result.b = x;\n      \
    \  }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprg6ol1t1.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg6ol1t1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ negative = false;\n    long max = 0;\n    long min = 0;\n    \n    for (long\
    \ i : lst)\n    {\n        if (i < 0)\n        {\n            negative = true;\n\
    \        }\n        \n        if (i > max)\n        {\n            max = i;\n\
    \        }\n        \n        if (i < min)\n        {\n            min = i;\n\
    \        }\n    }\n    \n    if (negative == false)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(max, min);\n    }\n    else\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(null, null);\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpymayfyza.d(27): Error: semicolon expected, not `:`\n/tmp/tmpymayfyza.d(27):
    Error: expression expected, not `:`\n/tmp/tmpymayfyza.d(27): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpymayfyza.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n               {\n     \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \         break;\n               }\n               else\n               {\n  \
    \                 result = Tuple!(Nullable!(long), Nullable!(long));\n       \
    \            break;\n               }\n           });\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmxt91yy9.d(23): Error: no identifier for declarator `i`\n/tmp/tmpmxt91yy9.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpmxt91yy9.d(35): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmxt91yy9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst)\n    {\n        if (i < 0)\n        {\n            negative =\
    \ true;\n        }\n        if (i > 0)\n        {\n            if (largest < i)\n\
    \            {\n                largest = i;\n            }\n            if (smallest\
    \ > i)\n            {\n                smallest = i;\n            }\n        }\n\
    \    }\n    if (negative == false)\n    {\n        result.first = null;\n    \
    \    result.second = largest;\n    }\n    else\n    {\n        result.first =\
    \ null;\n        result.second = smallest;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmrrv763p.d(25): Error: semicolon expected, not `:`\n/tmp/tmpmrrv763p.d(25):
    Error: expression expected, not `:`\n/tmp/tmpmrrv763p.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmrrv763p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            result.a = x;\n \
    \           result.b = Nullable!(long);\n        }\n        else\n        {\n\
    \            result.a = Nullable!(long);\n            result.b = x;\n        }\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvqa31_18.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpvqa31_18.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpvqa31_18.d(37): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqa31_18.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool found\
    \ = false;\n    long largest = -100000000000L;\n    long smallest = 100000000000L;\n\
    \    for (long i : lst) {\n        if (i < 0) {\n            smallest = i;\n \
    \           found = true;\n        } else if (i > largest) {\n            largest\
    \ = i;\n        }\n    }\n    if (found) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.a = largest;\n        result.b = smallest;\n\
    \    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n  \
    \      result.a = Nullable!(long);\n        result.b = Nullable!(long);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfxvevav9.d(25): Error: semicolon expected, not `:`\n/tmp/tmpfxvevav9.d(25):
    Error: expression expected, not `:`\n/tmp/tmpfxvevav9.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfxvevav9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        return result;\n    }\n    \n    long largest\
    \ = std.math.max(lst);\n    long smallest = std.math.min(lst);\n    \n    if (largest\
    \ < 0)\n    {\n        result.a = null;\n        result.b = smallest;\n    }\n\
    \    else\n    {\n        result.a = largest;\n        result.b = smallest;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4il1wcn8.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmp4il1wcn8.d(28):
    Error: undefined identifier `max` in module `std.math`, did you mean function
    `fmax`?\n/tmp/tmp4il1wcn8.d(29): Error: undefined identifier `min` in module `std.math`,
    did you mean function `sin`?\n/tmp/tmp4il1wcn8.d(33): Error: no property `a` for
    type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp4il1wcn8.d(34): Error: no
    property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp4il1wcn8.d(38):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmp4il1wcn8.d(39):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4il1wcn8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst) {\n        if (i < 0) {\n\
    \            foundNegative = true;\n        } else if (i >= 0) {\n           \
    \ foundPositive = true;\n        }\n        if (foundNegative && foundPositive)\
    \ {\n            break;\n        }\n        if (foundNegative) {\n           \
    \ largest = i;\n        } else if (foundPositive) {\n            smallest = i;\n\
    \        }\n    }\n    if (foundNegative && foundPositive) {\n        result.first\
    \ = null;\n        result.second = smallest;\n    } else {\n        result.first\
    \ = null;\n        result.second = largest;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxrozz_o1.d(26): Error: semicolon expected, not `:`\n/tmp/tmpxrozz_o1.d(26):
    Error: expression expected, not `:`\n/tmp/tmpxrozz_o1.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxrozz_o1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    \n    for (long\
    \ i : lst)\n    {\n        if (i < 0)\n        {\n            foundNegative =\
    \ true;\n        }\n        else if (i > 0)\n        {\n            foundPositive\
    \ = true;\n        }\n    }\n    \n    if (foundNegative && foundPositive)\n \
    \   {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n   \
    \ else if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    else if (foundPositive)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp79dnj4rh.d(26): Error: semicolon expected, not `:`\n/tmp/tmp79dnj4rh.d(26):
    Error: expression expected, not `:`\n/tmp/tmp79dnj4rh.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp79dnj4rh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (long i in lst) {\n        if (i < 0) {\n            result.a = i;\n       \
    \ } else {\n            result.b = i;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqmqiyila.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmqiyila.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n            if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n            if(i>0) result = Tuple!(Nullable!(long), Nullable!(long)); \n\
    \            );\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplzzo8ay3.d(23): Error: no identifier for declarator `i`\n/tmp/tmplzzo8ay3.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmplzzo8ay3.d(24): Error: expression
    expected, not `if`\n/tmp/tmplzzo8ay3.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmplzzo8ay3.d(24): Error: found `=` instead of statement\n/tmp/tmplzzo8ay3.d(26):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmplzzo8ay3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        function(int i) {\n            if (i < 0) {\n             \
    \   result.a = i;\n            } else {\n                result.b = i;\n     \
    \       }\n        });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplf4n75qy.d(23): Error: no identifier for declarator `i`\n/tmp/tmplf4n75qy.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmplf4n75qy.d(30): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplf4n75qy.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           else if(i>0) result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           else result = Tuple!(Nullable!(long), Nullable!(long)));\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgbq6weia.d(23): Error: no identifier for declarator `i`\n/tmp/tmpgbq6weia.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpgbq6weia.d(24): Error: expression
    expected, not `if`\n/tmp/tmpgbq6weia.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmpgbq6weia.d(24): Error: found `=` instead of statement\n/tmp/tmpgbq6weia.d(25):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpgbq6weia.d(26):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgbq6weia.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool neg\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst) {\n \
    \       if (i < 0) {\n            neg = true;\n            i = -i;\n        }\n\
    \        if (i > max) {\n            max = i;\n        }\n        if (i < min)\
    \ {\n            min = i;\n        }\n    }\n    if (neg) {\n        result.first\
    \ = null;\n        result.second = min;\n    } else {\n        result.first =\
    \ max;\n        result.second = min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6mjptgyp.d(25): Error: semicolon expected, not `:`\n/tmp/tmp6mjptgyp.d(25):
    Error: expression expected, not `:`\n/tmp/tmp6mjptgyp.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp6mjptgyp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.MinValue;\n    long smallest = Long.MaxValue;\n\
    \    foreach (long i in lst) {\n        if (i < 0) {\n            negative = true;\n\
    \        }\n        if (largest < i) {\n            largest = i;\n        }\n\
    \        if (smallest > i) {\n            smallest = i;\n        }\n    }\n  \
    \  if (negative && smallest == Long.MinValue) {\n        smallest = null;\n  \
    \  }\n    if (negative && largest == Long.MaxValue) {\n        largest = null;\n\
    \    }\n    result = Tuple!(Nullable!(long), Nullable!(long));\n    result.0 =\
    \ largest;\n    result.1 = smallest;\n    return result;\n}\n/*\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyd6y7d9u.d(25): Error: found `in` when expecting `;`\n/tmp/tmpyd6y7d9u.d(43):
    Error: found `0.00000` when expecting `;` following statement\n/tmp/tmpyd6y7d9u.d(43):
    Error: found `=` instead of statement\n/tmp/tmpyd6y7d9u.d(44): Error: found `0.1`
    when expecting `;` following statement\n/tmp/tmpyd6y7d9u.d(44): Error: found `=`
    instead of statement\n/tmp/tmpyd6y7d9u.d(47): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyd6y7d9u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0L) Nullable!(0L)\
    \ else Nullable!(i),\n                if(i>0L) Nullable!(i) else Nullable!(Long.maxValue))\n\
    \        {\n            result = t;\n        }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_a0831p.d(23): Error: no identifier for declarator `i`\n/tmp/tmp3_a0831p.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp3_a0831p.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmp3_a0831p.d(24): Error: found `=` instead of statement\n/tmp/tmp3_a0831p.d(32):
    Error: declaration expected, not `return`\n/tmp/tmp3_a0831p.d(33): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_a0831p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.Length;\n   \
    \ while(i < n && j < n) {\n        if(lst[i] < lst[j]) {\n            largest\
    \ = Nullable!(long);\n            smallest = Nullable!(long);\n            k =\
    \ i;\n            while(i < n && lst[i] < lst[k]) {\n                i++;\n  \
    \          }\n            while(j < n && lst[j] < lst[k]) {\n                j++;\n\
    \            }\n            if(i < n) {\n                largest = Nullable!(long);\n\
    \                smallest = Nullable!(long);\n                while(i < n && lst[i]\
    \ < lst[k]) {\n                    i++;\n                }\n                while(j\
    \ < n && lst[j] < lst[k]) {\n                    j++;\n                }\n   \
    \         }\n        }\n        else if(lst[i] > lst[j]) {\n            largest\
    \ = Nullable!(long);\n            smallest = Nullable!(long);\n            k =\
    \ i;\n            while(i < n && lst[i] > lst[k]) {\n                i++;\n  \
    \          }\n            while(j < n && lst[j] > lst[k]) {\n                j++;\n\
    \            }\n            if(i < n) {\n                largest = Nullable!(long);\n\
    \                smallest = Nullable!(long);\n                while(i < n && lst[i]\
    \ > lst[k]) {\n                    i++;\n                }\n                while(j\
    \ < n && lst[j] > lst[k]) {\n                    j++;\n                }\n   \
    \         }\n        }\n        else {\n            i++;\n            j++;\n \
    \       }\n    }\n    if(i < n) {\n        largest = Nullable!(long);\n      \
    \  smallest = Nullable!(long);\n        while(i < n && lst[i] < lst[k]) {\n  \
    \          i++;\n        }\n        while(j < n && lst[j] < lst[k]) {\n      \
    \      j++;\n        }\n    }\n    if(j < n) {\n        largest = Nullable!(long);\n\
    \        smallest = Nullable!(long);\n        while(i < n && lst[i] > lst[k])\
    \ {\n            i++;\n        }\n        while(j < n && lst[j] > lst[k]) {\n\
    \            j++;\n        }\n    }\n    return Tuple!(largest, smallest);\n}\n\
    /*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
    \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps1ey9ql8.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps1ey9ql8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst) {\n \
    \       if (i < 0) {\n            negative = true;\n        }\n        if (max\
    \ < i) {\n            max = i;\n        }\n        if (min > i) {\n          \
    \  min = i;\n        }\n    }\n    if (negative && min > 0) {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n     \
    \   result.b = min;\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \        result.a = max;\n        result.b = min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnvudm9ap.d(25): Error: semicolon expected, not `:`\n/tmp/tmpnvudm9ap.d(25):
    Error: expression expected, not `:`\n/tmp/tmpnvudm9ap.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnvudm9ap.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool found\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst) {\n \
    \       if (i < 0) {\n            found = true;\n            max = i;\n      \
    \  } else if (i > max) {\n            max = i;\n        }\n    }\n    for (long\
    \ i : lst) {\n        if (i >= 0) {\n            found = true;\n            min\
    \ = i;\n        } else if (i < min) {\n            min = i;\n        }\n    }\n\
    \    if (found) {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \        result.a = max;\n        result.b = min;\n    } else {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = Nullable!(long);\n\
    \        result.b = Nullable!(long);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4v06kqw3.d(25): Error: semicolon expected, not `:`\n/tmp/tmp4v06kqw3.d(25):
    Error: expression expected, not `:`\n/tmp/tmp4v06kqw3.d(25): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp4v06kqw3.d(33): Error: semicolon
    expected, not `:`\n/tmp/tmp4v06kqw3.d(33): Error: expression expected, not `:`\n/tmp/tmp4v06kqw3.d(33):
    Error: found `lst` when expecting `;` following `for` condition\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4v06kqw3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    foreach(long x, lst) {\n        if (x < 0) {\n\
    \            foundNegative = true;\n            largest = x;\n        } else if\
    \ (x > 0) {\n            foundPositive = true;\n            smallest = x;\n  \
    \      }\n    }\n    if (foundNegative && foundPositive) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = Nullable!(largest);\n        result.1\
    \ = Nullable!(smallest);\n    } else {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = Nullable!(null);\n        result.1 = Nullable!(null);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprc6bznm1.d(26): Error: no identifier for declarator `lst`\n/tmp/tmprc6bznm1.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmprc6bznm1.d(35): Error: found `if`
    when expecting `)`\n/tmp/tmprc6bznm1.d(35): Error: found `&&` when expecting `)`\n/tmp/tmprc6bznm1.d(35):
    Error: missing `{ ... }` for function literal\n/tmp/tmprc6bznm1.d(35): Error:
    found `foundPositive` when expecting `;` following statement\n/tmp/tmprc6bznm1.d(35):
    Error: found `)` instead of statement\n/tmp/tmprc6bznm1.d(37): Error: found `0.00000`
    when expecting `;` following statement\n/tmp/tmprc6bznm1.d(37): Error: found `=`
    instead of statement\n/tmp/tmprc6bznm1.d(38): Error: found `0.1` when expecting
    `;` following statement\n/tmp/tmprc6bznm1.d(38): Error: found `=` instead of statement\n/tmp/tmprc6bznm1.d(39):
    Error: declaration expected, not `else`\n/tmp/tmprc6bznm1.d(41): Error: no identifier
    for declarator `result`\n/tmp/tmprc6bznm1.d(41): Error: declaration expected,
    not `0.00000`\n/tmp/tmprc6bznm1.d(42): Error: no identifier for declarator `result`\n/tmp/tmprc6bznm1.d(42):
    Error: declaration expected, not `0.1`\n/tmp/tmprc6bznm1.d(43): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprc6bznm1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (long i in lst)\n    {\n        if (i < 0)\n        {\n            result.a\
    \ = i;\n        }\n        else\n        {\n            result.b = i;\n      \
    \  }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvlp7iyfn.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvlp7iyfn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool found\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            smallest = i;\n        \
    \    found = true;\n        } else if (i > largest) {\n            largest = i;\n\
    \        }\n    }\n    if (found) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = largest;\n        result.1 = smallest;\n\
    \    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n  \
    \      result.0 = Nullable!(long);\n        result.1 = Nullable!(long);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1pkzoa2g.d(25): Error: semicolon expected, not `:`\n/tmp/tmp1pkzoa2g.d(25):
    Error: expression expected, not `:`\n/tmp/tmp1pkzoa2g.d(25): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp1pkzoa2g.d(35): Error: found
    `0.00000` when expecting `;` following statement\n/tmp/tmp1pkzoa2g.d(35): Error:
    found `=` instead of statement\n/tmp/tmp1pkzoa2g.d(36): Error: found `0.1` when
    expecting `;` following statement\n/tmp/tmp1pkzoa2g.d(36): Error: found `=` instead
    of statement\n/tmp/tmp1pkzoa2g.d(39): Error: found `0.00000` when expecting `;`
    following statement\n/tmp/tmp1pkzoa2g.d(39): Error: found `=` instead of statement\n/tmp/tmp1pkzoa2g.d(40):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmp1pkzoa2g.d(40):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp1pkzoa2g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, el) in lst {\n        if (el < 0L) {\n            result.a = el;\n     \
    \       result.b = null; // no positive integers\n        } else {\n         \
    \   result.a = null; // no negative integers\n            result.b = el;\n   \
    \     }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpofxlaepi.d(23): Error: no identifier for declarator `el`\n/tmp/tmpofxlaepi.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpofxlaepi.d(23): Error: expression
    expected, not `in`\n/tmp/tmpofxlaepi.d(23): Error: found `lst` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpofxlaepi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(x\
    \ :: lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5tih0bgg.d(23): Error: no identifier for declarator `x`\n/tmp/tmp5tih0bgg.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp5tih0bgg.d(23): Error: expression
    expected, not `:`\n/tmp/tmp5tih0bgg.d(23): Error: found `lst` when expecting `)`\n/tmp/tmp5tih0bgg.d(23):
    Error: found `)` instead of statement\n/tmp/tmp5tih0bgg.d(26): Error: declaration
    expected, not `else`\n/tmp/tmp5tih0bgg.d(28): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5tih0bgg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = -100L;\n    long smallest = 100L;\n    for (long\
    \ i : lst) {\n        if (i < 0) {\n            negative = true;\n           \
    \ i = -i;\n        }\n        if (i > largest) {\n            largest = i;\n \
    \       }\n        if (i < smallest) {\n            smallest = i;\n        }\n\
    \    }\n    if (negative == false) {\n        result.a = largest;\n        result.b\
    \ = smallest;\n    } else {\n        result.a = null;\n        result.b = null;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp52gzij60.d(25): Error: semicolon expected, not `:`\n/tmp/tmp52gzij60.d(25):
    Error: expression expected, not `:`\n/tmp/tmp52gzij60.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp52gzij60.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = -100L;\n    long smallest = 100L;\n    foreach(long\
    \ i, lst) {\n        if (i < 0) {\n            negative = true;\n        }\n \
    \       if (i > largest) {\n            largest = i;\n        }\n        if (i\
    \ < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result.first = null;\n        result.second = smallest;\n\
    \    } else {\n        result.first = null;\n        result.second = largest;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpat8_m1db.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpat8_m1db.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpat8_m1db.d(36): Error: found `if`
    when expecting `)`\n/tmp/tmpat8_m1db.d(36): Error: found `==` when expecting `)`\n/tmp/tmpat8_m1db.d(36):
    Error: missing `{ ... }` for function literal\n/tmp/tmpat8_m1db.d(36): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpat8_m1db.d(36):
    Error: found `)` instead of statement\n/tmp/tmpat8_m1db.d(39): Error: declaration
    expected, not `else`\n/tmp/tmpat8_m1db.d(41): Error: no identifier for declarator
    `result.second`\n/tmp/tmpat8_m1db.d(41): Error: declaration expected, not `=`\n/tmp/tmpat8_m1db.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpat8_m1db.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n                   result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n               else if (i > 0L)\n\
    \                   result = Tuple!(Nullable!(long), Nullable!(long));\n     \
    \          else\n                   result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \           });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgnscqgz7.d(23): Error: no identifier for declarator `i`\n/tmp/tmpgnscqgz7.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpgnscqgz7.d(31): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnscqgz7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach (long i in lst)\
    \ {\n        if (i < 0) {\n            a = i;\n        } else if (i > 0){\n  \
    \          b = i;\n        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzbrd4l7.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzbrd4l7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers(i))\n\
    \    {\n        result = t if t.a > result.a else result;\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpla5hg1w_.d(23): Error: no identifier for declarator `i`\n/tmp/tmpla5hg1w_.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpla5hg1w_.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmpla5hg1w_.d(24): Error: found `=` instead of statement\n/tmp/tmpla5hg1w_.d(29):
    Error: declaration expected, not `return`\n/tmp/tmpla5hg1w_.d(30): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla5hg1w_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n            if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n            if(i>0) result = Tuple!(Nullable!(long), Nullable!(long)); \n\
    \            );\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplzzo8ay3.d(23): Error: no identifier for declarator `i`\n/tmp/tmplzzo8ay3.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmplzzo8ay3.d(24): Error: expression
    expected, not `if`\n/tmp/tmplzzo8ay3.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmplzzo8ay3.d(24): Error: found `=` instead of statement\n/tmp/tmplzzo8ay3.d(26):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmplzzo8ay3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = 0;\n \
    \   long largestPositive = 0;\n    long smallestNegative = 0;\n    long smallestPositive\
    \ = 0;\n    foreach(long x in lst)\n    {\n        if (x < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = x;\n        }\n\
    \        else\n        {\n            foundPositive = true;\n            largestPositive\
    \ = x;\n        }\n    }\n    if (foundNegative && foundPositive)\n    {\n   \
    \     result.a = largestNegative;\n        result.b = largestPositive;\n    }\n\
    \    else if (foundNegative)\n    {\n        result.a = largestNegative;\n   \
    \     result.b = Nullable!(long);\n    }\n    else if (foundPositive)\n    {\n\
    \        result.a = largestPositive;\n        result.b = Nullable!(long);\n  \
    \  }\n    else\n    {\n        result.a = Nullable!(long);\n        result.b =\
    \ Nullable!(long);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8d3zryvv.d(28): Error: found `in` when expecting `;`\n/tmp/tmp8d3zryvv.d(63):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8d3zryvv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    foreach(long x, lst)\n\
    \    {\n        if (x < 0)\n        {\n            a = x;\n        }\n       \
    \ else if (x > 0)\n        {\n            b = x;\n        }\n    }\n    return\
    \ Tuple!(a, b);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0hxgxymq.d(23): Error: no identifier for declarator `lst`\n/tmp/tmp0hxgxymq.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp0hxgxymq.d(34): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hxgxymq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, x) in lst {\n        if (x < 0) {\n            result.a = x;\n        }\
    \ else if (x > 0) {\n            result.b = x;\n        } else {\n           \
    \ result.a = x;\n            result.b = x;\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvrpf1ce1.d(23): Error: no identifier for declarator `x`\n/tmp/tmpvrpf1ce1.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpvrpf1ce1.d(23): Error: expression
    expected, not `in`\n/tmp/tmpvrpf1ce1.d(23): Error: found `lst` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrpf1ce1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            positive = false;\n    \
    \    }\n        if (i > largest) {\n            largest = i;\n        }\n    \
    \    if (i < smallest) {\n            smallest = i;\n        }\n    }\n    if\
    \ (positive && largest == Long.min) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else if (positive && smallest == Long.max) {\n\
    \        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n    else if\
    \ (positive) {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n \
    \   }\n    else {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf5jpql03.d(25): Error: semicolon expected, not `:`\n/tmp/tmpf5jpql03.d(25):
    Error: expression expected, not `:`\n/tmp/tmpf5jpql03.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpf5jpql03.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool is_negative\
    \ = false;\n    bool is_positive = false;\n    long largest = Long.min;\n    long\
    \ smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n  \
    \      {\n            is_negative = true;\n        }\n        if (i > 0)\n   \
    \     {\n            is_positive = true;\n        }\n        if (is_negative &&\
    \ is_positive)\n        {\n            largest = i;\n            smallest = i;\n\
    \        }\n        else if (is_negative)\n        {\n            largest = i;\n\
    \        }\n        else if (is_positive)\n        {\n            smallest = i;\n\
    \        }\n    }\n    if (largest == Long.min)\n    {\n        result.a = null;\n\
    \        result.b = null;\n    }\n    else if (smallest == Long.max)\n    {\n\
    \        result.a = null;\n        result.b = null;\n    }\n    else\n    {\n\
    \        result.a = largest;\n        result.b = smallest;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpna55ttbu.d(26): Error: semicolon expected, not `:`\n/tmp/tmpna55ttbu.d(26):
    Error: expression expected, not `:`\n/tmp/tmpna55ttbu.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpna55ttbu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool neg\
    \ = false;\n    long max = 0;\n    long min = 0;\n    foreach(long i in lst)\n\
    \    {\n        if (i < 0)\n        {\n            neg = true;\n        }\n  \
    \      if (i > 0)\n        {\n            if (neg)\n            {\n          \
    \      if (max < 0)\n                {\n                    max = i;\n       \
    \         }\n                else\n                {\n                    if (min\
    \ > 0)\n                    {\n                        min = i;\n            \
    \        }\n                    else\n                    {\n                \
    \        result = Tuple!(Nullable!(long), Nullable!(long));\n                \
    \        break;\n                    }\n                }\n            }\n   \
    \         else\n            {\n                if (max > 0)\n                {\n\
    \                    max = i;\n                }\n                else\n     \
    \           {\n                    if (min < 0)\n                    {\n     \
    \                   min = i;\n                    }\n                    else\n\
    \                    {\n                        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n                        break;\n                    }\n \
    \               }\n            }\n        }\n    }\n    if (neg)\n    {\n    \
    \    result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n    else\n   \
    \ {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3obzy8r5.d(25): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3obzy8r5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long max = 0;\n    long min = 0;\n    foreach(long x, lst) {\n\
    \        if (x < 0) {\n            max = x;\n        } else {\n            min\
    \ = x;\n        }\n    }\n    return Tuple!(Nullable!(long), Nullable!(long));\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps6ncshoo.d(23): Error: no identifier for declarator `lst`\n/tmp/tmps6ncshoo.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmps6ncshoo.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6ncshoo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = 0;\n \
    \   long largestPositive = 0;\n    long smallestNegative = 0;\n    long smallestPositive\
    \ = 0;\n    foreach(long x in lst)\n    {\n        if (x < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = x;\n        }\n\
    \        else\n        {\n            foundPositive = true;\n            largestPositive\
    \ = x;\n        }\n    }\n    if (foundNegative && foundPositive)\n    {\n   \
    \     result.a = largestNegative;\n        result.b = largestPositive;\n    }\n\
    \    else if (foundNegative)\n    {\n        result.a = largestNegative;\n   \
    \     result.b = Nullable!(long);\n    }\n    else if (foundPositive)\n    {\n\
    \        result.a = largestPositive;\n        result.b = Nullable!(long);\n  \
    \  }\n    else\n    {\n        result.a = Nullable!(long);\n        result.b =\
    \ Nullable!(long);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8d3zryvv.d(28): Error: found `in` when expecting `;`\n/tmp/tmp8d3zryvv.d(63):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8d3zryvv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst) {\n        if (i < 0) {\n            result.a = i;\n        } else {\n\
    \            result.b = i;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1t1xmnrd.d(23): Error: no identifier for declarator `i`\n/tmp/tmp1t1xmnrd.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp1t1xmnrd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            negative = true;\n        } else\
    \ if (x == 0) {\n            smallest = 0;\n        } else if (x > largest) {\n\
    \            largest = x;\n        }\n    }\n    if (negative == false) {\n  \
    \      result.first = null;\n        result.second = largest;\n    } else {\n\
    \        result.first = null;\n        result.second = smallest;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzzy62q0q.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpzzy62q0q.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpzzy62q0q.d(34): Error: found `if`
    when expecting `)`\n/tmp/tmpzzy62q0q.d(34): Error: found `==` when expecting `)`\n/tmp/tmpzzy62q0q.d(34):
    Error: missing `{ ... }` for function literal\n/tmp/tmpzzy62q0q.d(34): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpzzy62q0q.d(34):
    Error: found `)` instead of statement\n/tmp/tmpzzy62q0q.d(37): Error: declaration
    expected, not `else`\n/tmp/tmpzzy62q0q.d(39): Error: no identifier for declarator
    `result.second`\n/tmp/tmpzzy62q0q.d(39): Error: declaration expected, not `=`\n/tmp/tmpzzy62q0q.d(40):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzy62q0q.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = 0;\n \
    \   long largestPositive = 0;\n    long smallestNegative = 0;\n    long smallestPositive\
    \ = 0;\n    foreach(long x in lst)\n    {\n        if (x < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = x;\n        }\n\
    \        else if (x > 0)\n        {\n            foundPositive = true;\n     \
    \       largestPositive = x;\n        }\n        else\n        {\n           \
    \ smallestNegative = x;\n            smallestPositive = x;\n        }\n    }\n\
    \    if (foundNegative)\n    {\n        result.a = Nullable!(largestNegative);\n\
    \    }\n    if (foundPositive)\n    {\n        result.b = Nullable!(largestPositive);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(smallestNegative);\n   \
    \     result.b = Nullable!(smallestPositive);\n    }\n    return result;\n}\n\
    /*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n     \
    \   auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt0b09eiw.d(28): Error: found `in` when expecting `;`\n/tmp/tmpt0b09eiw.d(61):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt0b09eiw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(x\
    \ :: lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq2kobfj_.d(23): Error: no identifier for declarator `x`\n/tmp/tmpq2kobfj_.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpq2kobfj_.d(23): Error: expression
    expected, not `:`\n/tmp/tmpq2kobfj_.d(23): Error: found `lst` when expecting `)`\n/tmp/tmpq2kobfj_.d(23):
    Error: found `)` instead of statement\n/tmp/tmpq2kobfj_.d(26): Error: declaration
    expected, not `else`\n/tmp/tmpq2kobfj_.d(28): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2kobfj_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    bool positive = false;\n    long largest = Long.MinValue;\n  \
    \  long smallest = Long.MaxValue;\n    foreach(long i, lst) {\n        if (i <\
    \ 0) {\n            negative = true;\n        } else if (i > 0){\n           \
    \ positive = true;\n        }\n        if (negative && positive && largest < i)\
    \ {\n            largest = i;\n        } else if (negative && positive && smallest\
    \ > i) {\n            smallest = i;\n        }\n    }\n    if (negative && positive\
    \ && largest < smallest) {\n        result.a = null;\n        result.b = smallest;\n\
    \    } else if (negative && positive && smallest > largest) {\n        result.a\
    \ = null;\n        result.b = largest;\n    } else {\n        result.a = largest;\n\
    \        result.b = smallest;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf36ox0go.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpf36ox0go.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpf36ox0go.d(38): Error: found `if`
    when expecting `)`\n/tmp/tmpf36ox0go.d(38): Error: found `&&` when expecting `)`\n/tmp/tmpf36ox0go.d(38):
    Error: missing `{ ... }` for function literal\n/tmp/tmpf36ox0go.d(38): Error:
    found `positive` when expecting `;` following statement\n/tmp/tmpf36ox0go.d(38):
    Error: found `&&` instead of statement\n/tmp/tmpf36ox0go.d(41): Error: declaration
    expected, not `else`\n/tmp/tmpf36ox0go.d(43): Error: no identifier for declarator
    `result.b`\n/tmp/tmpf36ox0go.d(43): Error: declaration expected, not `=`\n/tmp/tmpf36ox0go.d(44):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf36ox0go.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n    \n    function(long x)\n    {\n        if (x < 0)\n        {\n\
    \            result.a = x;\n            result.b = null;\n        }\n        else\n\
    \        {\n            result.a = null;\n            result.b = x;\n        }\n\
    \    });\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwlqdrfc7.d(23): Error: no identifier for declarator `i`\n/tmp/tmpwlqdrfc7.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpwlqdrfc7.d(37): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwlqdrfc7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            negative = true;\n        }\n \
    \       if (x > largest) {\n            largest = x;\n        }\n        if (x\
    \ < smallest) {\n            smallest = x;\n        }\n    }\n    if (negative\
    \ == false) {\n        result = Tuple!(Nullable!(long), Nullable!(long))(largest,\
    \ smallest);\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long))(Nullable!(long),\
    \ Nullable!(long));\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsrhu_ect.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpsrhu_ect.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpsrhu_ect.d(36): Error: found `if`
    when expecting `)`\n/tmp/tmpsrhu_ect.d(36): Error: found `==` when expecting `)`\n/tmp/tmpsrhu_ect.d(36):
    Error: missing `{ ... }` for function literal\n/tmp/tmpsrhu_ect.d(36): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpsrhu_ect.d(36):
    Error: found `)` instead of statement\n/tmp/tmpsrhu_ect.d(38): Error: declaration
    expected, not `else`\n/tmp/tmpsrhu_ect.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsrhu_ect.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if (i < 0L) \n               result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long));\n           else if (i\
    \ > 0L)\n               result = Tuple!(Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long));\n           else\n               result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long));\n           );\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaapef6on.d(23): Error: no identifier for declarator `i`\n/tmp/tmpaapef6on.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpaapef6on.d(24): Error: expression
    expected, not `if`\n/tmp/tmpaapef6on.d(25): Error: found `result` when expecting
    `)`\n/tmp/tmpaapef6on.d(25): Error: found `=` instead of statement\n/tmp/tmpaapef6on.d(26):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpaapef6on.d(28):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpaapef6on.d(30):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpaapef6on.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaldv6p90.d(23): Error: no identifier for declarator `i`\n/tmp/tmpaldv6p90.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpaldv6p90.d(267): Error: expression
    expected, not `unittest`\n/tmp/tmpaldv6p90.d(268): Error: found `{` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaldv6p90.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    foreach(long i in lst)\n    {\n        if (i < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = i;\n        }\n\
    \        else\n        {\n            foundPositive = true;\n            largestPositive\
    \ = i;\n        }\n    }\n    if (foundNegative && foundPositive)\n    {\n   \
    \     if (largestPositive > largestNegative)\n        {\n            result.a\
    \ = largestPositive;\n            result.b = smallestPositive;\n        }\n  \
    \      else\n        {\n            result.a = largestNegative;\n            result.b\
    \ = smallestNegative;\n        }\n    }\n    else if (foundNegative)\n    {\n\
    \        result.a = largestNegative;\n        result.b = smallestNegative;\n \
    \   }\n    else if (foundPositive)\n    {\n        result.a = largestPositive;\n\
    \        result.b = smallestPositive;\n    }\n    else\n    {\n        result.a\
    \ = null;\n        result.b = null;\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe2ixld8y.d(28): Error: found `in` when expecting `;`\n/tmp/tmpe2ixld8y.d(71):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe2ixld8y.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            negative = true;\n            smallest\
    \ = Long.max;\n        } else {\n            smallest = Long.min;\n        }\n\
    \        if (largest < x) {\n            largest = x;\n        }\n        if (smallest\
    \ > x) {\n            smallest = x;\n        }\n    }\n    if (negative == false)\
    \ {\n        result.a = Nullable!(largest);\n        result.b = Nullable!(smallest);\n\
    \    } else {\n        result.a = Nullable!(null);\n        result.b = Nullable!(null);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqmnlpjqa.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpqmnlpjqa.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpqmnlpjqa.d(39): Error: found `if`
    when expecting `)`\n/tmp/tmpqmnlpjqa.d(39): Error: found `==` when expecting `)`\n/tmp/tmpqmnlpjqa.d(39):
    Error: missing `{ ... }` for function literal\n/tmp/tmpqmnlpjqa.d(39): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpqmnlpjqa.d(39):
    Error: found `)` instead of statement\n/tmp/tmpqmnlpjqa.d(42): Error: declaration
    expected, not `else`\n/tmp/tmpqmnlpjqa.d(44): Error: no identifier for declarator
    `result.b`\n/tmp/tmpqmnlpjqa.d(44): Error: declaration expected, not `=`\n/tmp/tmpqmnlpjqa.d(45):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmnlpjqa.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            negative = true;\n     \
    \   }\n        if (i > largest) {\n            largest = i;\n        }\n     \
    \   if (i < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result.a = largest;\n        result.b = smallest;\n   \
    \ } else {\n        result.a = null;\n        result.b = null;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvo4ex15r.d(25): Error: semicolon expected, not `:`\n/tmp/tmpvo4ex15r.d(25):
    Error: expression expected, not `:`\n/tmp/tmpvo4ex15r.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvo4ex15r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst) {\n        if (i < 0) {\n            negative = true;\n     \
    \   } else if (i > largest) {\n            largest = i;\n        } else if (i\
    \ < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result = Tuple!(Nullable!(long), Nullable!(long)) (largest,\
    \ smallest);\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (null, null);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf0c1g_eg.d(25): Error: semicolon expected, not `:`\n/tmp/tmpf0c1g_eg.d(25):
    Error: expression expected, not `:`\n/tmp/tmpf0c1g_eg.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpf0c1g_eg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    for (long i : lst)\n \
    \   {\n        if (i < 0)\n        {\n            a = i;\n        }\n        else\
    \ if (i > 0)\n        {\n            b = i;\n        }\n    }\n    return Tuple!(a,\
    \ b);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n\
    \        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbxrz4l4s.d(23): Error: semicolon expected, not `:`\n/tmp/tmpbxrz4l4s.d(23):
    Error: expression expected, not `:`\n/tmp/tmpbxrz4l4s.d(23): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbxrz4l4s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool is_negative\
    \ = false;\n    bool is_positive = false;\n    long max_negative = Long.min;\n\
    \    long min_positive = Long.max;\n    foreach(long x, lst) {\n        if (x\
    \ < 0) {\n            is_negative = true;\n            if (x > max_negative) {\n\
    \                max_negative = x;\n            }\n        } else if (x > 0) {\n\
    \            is_positive = true;\n            if (x < min_positive) {\n      \
    \          min_positive = x;\n            }\n        } else {\n            is_negative\
    \ = false;\n            is_positive = false;\n        }\n    }\n    if (is_negative)\
    \ {\n        result.a = max_negative;\n    } else {\n        result.a = min_positive;\n\
    \    }\n    if (is_positive) {\n        result.b = min_positive;\n    } else {\n\
    \        result.b = max_negative;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph_wvkrlg.d(26): Error: no identifier for declarator `lst`\n/tmp/tmph_wvkrlg.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmph_wvkrlg.d(42): Error: found `if`
    when expecting `)`\n/tmp/tmph_wvkrlg.d(44): Error: found `else` when expecting
    `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_wvkrlg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n            if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n            if(i>0) result = Tuple!(Nullable!(long), Nullable!(long)); \n\
    \            );\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplzzo8ay3.d(23): Error: no identifier for declarator `i`\n/tmp/tmplzzo8ay3.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmplzzo8ay3.d(24): Error: expression
    expected, not `if`\n/tmp/tmplzzo8ay3.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmplzzo8ay3.d(24): Error: found `=` instead of statement\n/tmp/tmplzzo8ay3.d(26):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmplzzo8ay3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long max;\n    long min;\n    foreach(long x, lst) {\n       \
    \ if (x < 0) {\n            max = x;\n        } else {\n            min = x;\n\
    \        }\n    }\n    return Tuple!(Nullable!(long), Nullable!(long));\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8wporpi.d(23): Error: no identifier for declarator `lst`\n/tmp/tmph8wporpi.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmph8wporpi.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8wporpi.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long largest = lst.iter().max().unwrap();\n\
    \    long smallest = lst.iter().min().unwrap();\n    \n    if (largest < 0)\n\
    \        return result;\n    \n    if (smallest > 0)\n        return result;\n\
    \    \n    result.0 = Nullable!(largest);\n    result.1 = Nullable!(smallest);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxtbxflod.d(35): Error: found `0.00000` when expecting `;` following
    statement\n/tmp/tmpxtbxflod.d(35): Error: found `=` instead of statement\n/tmp/tmpxtbxflod.d(36):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmpxtbxflod.d(36):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxtbxflod.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) {\n                   result.a\
    \ = Nullable!(null);\n                   result.b = i;\n               } else\
    \ {\n                   result.a = i;\n                   result.b = Nullable!(null);\n\
    \               }\n           });\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4efnjbj_.d(23): Error: no identifier for declarator `i`\n/tmp/tmp4efnjbj_.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp4efnjbj_.d(32): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4efnjbj_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        function(int i) {\n            if (i < 0) {\n             \
    \   result.a = i;\n            } else {\n                result.b = i;\n     \
    \       }\n        }\n    );\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz2kfkh7g.d(23): Error: no identifier for declarator `i`\n/tmp/tmpz2kfkh7g.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpz2kfkh7g.d(31): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2kfkh7g.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) {\n                   result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n               } else {\n     \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \     }\n           });\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcm3_fqmz.d(23): Error: no identifier for declarator `i`\n/tmp/tmpcm3_fqmz.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpcm3_fqmz.d(30): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm3_fqmz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            positive = false;\n           \
    \ largest = x;\n        } else if (x > 0 && x > largest) {\n            largest\
    \ = x;\n        }\n        if (x > 0) {\n            smallest = x;\n        }\n\
    \    }\n    if (positive && smallest == Long.max) {\n        result.a = Nullable!(null);\n\
    \        result.b = Nullable!(null);\n    } else {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkkr6eo4z.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpkkr6eo4z.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpkkr6eo4z.d(36): Error: found `if`
    when expecting `)`\n/tmp/tmpkkr6eo4z.d(36): Error: found `&&` when expecting `)`\n/tmp/tmpkkr6eo4z.d(36):
    Error: missing `{ ... }` for function literal\n/tmp/tmpkkr6eo4z.d(36): Error:
    found `smallest` when expecting `;` following statement\n/tmp/tmpkkr6eo4z.d(36):
    Error: found `==` instead of statement\n/tmp/tmpkkr6eo4z.d(39): Error: declaration
    expected, not `else`\n/tmp/tmpkkr6eo4z.d(41): Error: no identifier for declarator
    `result.b`\n/tmp/tmpkkr6eo4z.d(41): Error: declaration expected, not `=`\n/tmp/tmpkkr6eo4z.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkr6eo4z.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0L) {\n            result.a = e;\n        \
    \    result.b = e;\n        } else {\n            result.a = e;\n            result.b\
    \ = e;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpswyvkex9.d(23): Error: no identifier for declarator `e`\n/tmp/tmpswyvkex9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpswyvkex9.d(23): Error: expression
    expected, not `in`\n/tmp/tmpswyvkex9.d(23): Error: found `lst` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswyvkex9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long largest = lst.iter().max().unwrap();\n\
    \    long smallest = lst.iter().min().unwrap();\n    \n    if (largest < 0)\n\
    \    {\n        result.a = null;\n        result.b = smallest;\n        return\
    \ result;\n    }\n    \n    if (smallest > 0)\n    {\n        result.a = largest;\n\
    \        result.b = null;\n        return result;\n    }\n    \n    result.a =\
    \ null;\n    result.b = null;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy13vq8mx.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmpy13vq8mx.d(26):
    Error: no property `iter` for type `long[]`\n/tmp/tmpy13vq8mx.d(27): Error: no
    property `iter` for type `long[]`\n/tmp/tmpy13vq8mx.d(31): Error: no property
    `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpy13vq8mx.d(32): Error:
    no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpy13vq8mx.d(38):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpy13vq8mx.d(39):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpy13vq8mx.d(43):
    Error: no property `a` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpy13vq8mx.d(44):
    Error: no property `b` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy13vq8mx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i<0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n           else result = Tuple!(Nullable!(long), Nullable!(long))) \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbpkgbyse.d(23): Error: no identifier for declarator `i`\n/tmp/tmpbpkgbyse.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpbpkgbyse.d(24): Error: expression
    expected, not `if`\n/tmp/tmpbpkgbyse.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmpbpkgbyse.d(24): Error: found `=` instead of statement\n/tmp/tmpbpkgbyse.d(25):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpkgbyse.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool is_positive\
    \ = true;\n    long max_value = Long.min;\n    long min_value = Long.max;\n  \
    \  for (long i : lst) {\n        if (is_positive) {\n            if (i < 0) {\n\
    \                is_positive = false;\n                min_value = i;\n      \
    \      }\n        } else {\n            if (i >= 0) {\n                is_positive\
    \ = true;\n                max_value = i;\n            }\n        }\n    }\n \
    \   if (is_positive) {\n        result.a = max_value;\n        result.b = min_value;\n\
    \    } else {\n        result.a = null;\n        result.b = null;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0gur690z.d(25): Error: semicolon expected, not `:`\n/tmp/tmp0gur690z.d(25):
    Error: expression expected, not `:`\n/tmp/tmp0gur690z.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0gur690z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestNegative = 0;\n \
    \   long largestPositive = 0;\n    long smallestNegative = 0;\n    long smallestPositive\
    \ = 0;\n    for (long i : lst)\n    {\n        if (i < 0)\n        {\n       \
    \     foundNegative = true;\n            largestNegative = i;\n        }\n   \
    \     else\n        {\n            foundPositive = true;\n            largestPositive\
    \ = i;\n        }\n    }\n    if (foundNegative)\n    {\n        result.a = Nullable!(largestNegative);\n\
    \        result.b = Nullable!(smallestPositive);\n    }\n    else if (foundPositive)\n\
    \    {\n        result.a = Nullable!(largestPositive);\n        result.b = Nullable!(smallestNegative);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(null);\n        result.b\
    \ = Nullable!(null);\n    }\n    return result;\n}\n/*\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_53toj9h.d(28): Error: semicolon expected, not `:`\n/tmp/tmp_53toj9h.d(28):
    Error: expression expected, not `:`\n/tmp/tmp_53toj9h.d(28): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp_53toj9h.d(58): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_53toj9h.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (long i in lst) {\n        if (i < 0) {\n            result.a = i;\n       \
    \ } else {\n            result.b = i;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqmqiyila.d(23): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmqiyila.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchvp_66m.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpchvp_66m.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpchvp_66m.d(31): Error: found `if`
    when expecting `)`\n/tmp/tmpchvp_66m.d(31): Error: found `==` when expecting `)`\n/tmp/tmpchvp_66m.d(31):
    Error: missing `{ ... }` for function literal\n/tmp/tmpchvp_66m.d(31): Error:
    found `null` when expecting `;` following statement\n/tmp/tmpchvp_66m.d(31): Error:
    found `)` instead of statement\n/tmp/tmpchvp_66m.d(35): Error: declaration expected,
    not `return`\n/tmp/tmpchvp_66m.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchvp_66m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst)\n    {\n        if (i < 0)\n        {\n            negative =\
    \ true;\n        }\n        if (i > largest)\n        {\n            largest =\
    \ i;\n        }\n        if (i < smallest)\n        {\n            smallest =\
    \ i;\n        }\n    }\n    if (negative == false)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(largest, smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long))(null, null);\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp82hdxuuh.d(25): Error: semicolon expected, not `:`\n/tmp/tmp82hdxuuh.d(25):
    Error: expression expected, not `:`\n/tmp/tmp82hdxuuh.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp82hdxuuh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0L) \n    \
    \                Tuple!(Nullable!(long), Nullable!(long)) (\n                \
    \        Nullable!(0L), Nullable!(1L)\n                    )\n               \
    \ else \n                    Tuple!(Nullable!(long), Nullable!(long)) (\n    \
    \                    Nullable!(1L), Nullable!(0L)\n                    )\n   \
    \         )\n    )\n    \n    result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (\n        Nullable!(result.a), Nullable!(result.b)\n    );\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpof8lg8s7.d(23): Error: no identifier for declarator `i`\n/tmp/tmpof8lg8s7.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpof8lg8s7.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmpof8lg8s7.d(24): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpof8lg8s7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n\
    \        {\n            foundNegative = true;\n        }\n        if (i > 0)\n\
    \        {\n            foundPositive = true;\n        }\n        if (foundNegative\
    \ && foundPositive)\n        {\n            break;\n        }\n        if (foundNegative)\n\
    \        {\n            largest = i;\n        }\n        if (foundPositive)\n\
    \        {\n            smallest = i;\n        }\n    }\n    if (foundNegative\
    \ && foundPositive)\n    {\n        result.a = Nullable!(largest);\n        result.b\
    \ = Nullable!(smallest);\n    }\n    else\n    {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjy4681p.d(26): Error: semicolon expected, not `:`\n/tmp/tmpyjy4681p.d(26):
    Error: expression expected, not `:`\n/tmp/tmpyjy4681p.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyjy4681p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = largest_smallest_integers(i));\n\
    \    \n    if (t.a == Nullable!(long))\n    {\n        result.a = t.b;\n     \
    \   result.b = Nullable!(long);\n    }\n    else\n    {\n        result.a = t.a;\n\
    \        result.b = t.b;\n    }\n    \n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbdg0n_na.d(23): Error: no identifier for declarator `i`\n/tmp/tmpbdg0n_na.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpbdg0n_na.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmpbdg0n_na.d(24): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbdg0n_na.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmc71248_.d(23): Error: no identifier for declarator `i`\n/tmp/tmpmc71248_.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpmc71248_.d(267): Error: expression
    expected, not `unittest`\n/tmp/tmpmc71248_.d(268): Error: found `{` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc71248_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    \n    for (long\
    \ i : lst) {\n        if (i < 0) {\n            foundNegative = true;\n      \
    \  } else if (i > 0) {\n            foundPositive = true;\n        }\n    }\n\
    \    \n    if (foundNegative && foundPositive) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    } else if (foundNegative) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    } else if (foundPositive) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphz3c2jl0.d(26): Error: semicolon expected, not `:`\n/tmp/tmphz3c2jl0.d(26):
    Error: expression expected, not `:`\n/tmp/tmphz3c2jl0.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmphz3c2jl0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        Tuple!(Nullable!(long), Nullable!(long)) pair = \n\
    \            Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0L)\
    \ Nullable!(0L) else Nullable!(i),\n                if(i>0L) Nullable!(i) else\
    \ Nullable!(Long.maxValue())\n            );\n        \n        result = pair;\n\
    \    );\n    \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp48_va7na.d(23): Error: no identifier for declarator `i`\n/tmp/tmp48_va7na.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp48_va7na.d(25): Error: found `pair`
    when expecting `)`\n/tmp/tmp48_va7na.d(25): Error: found `=` instead of statement\n/tmp/tmp48_va7na.d(32):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp48_va7na.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    foreach(long i in lst)\n    {\n        if (i < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = i;\n        }\n\
    \        else\n        {\n            foundPositive = true;\n            largestPositive\
    \ = i;\n        }\n    }\n    if (foundNegative)\n    {\n        result.a = Nullable!(largestNegative);\n\
    \        result.b = Nullable!(smallestNegative);\n    }\n    else if (foundPositive)\n\
    \    {\n        result.a = Nullable!(largestPositive);\n        result.b = Nullable!(smallestPositive);\n\
    \    }\n    else\n    {\n        result.a = Nullable!(null);\n        result.b\
    \ = Nullable!(null);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoa670r78.d(28): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa670r78.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long max = 0;\n    long min = 0;\n    for (long i : lst) {\n \
    \       if (i < 0) {\n            negative = true;\n        }\n        if (max\
    \ < i) {\n            max = i;\n        }\n        if (min > i) {\n          \
    \  min = i;\n        }\n    }\n    if (max == 0) {\n        result.a = null;\n\
    \        result.b = null;\n    } else if (min == max) {\n        result.a = null;\n\
    \        result.b = max;\n    } else {\n        result.a = max;\n        result.b\
    \ = min;\n    }\n    if (negative) {\n        result.a = -result.a;\n        result.b\
    \ = -result.b;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_5q5w0cu.d(25): Error: semicolon expected, not `:`\n/tmp/tmp_5q5w0cu.d(25):
    Error: expression expected, not `:`\n/tmp/tmp_5q5w0cu.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_5q5w0cu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst)\n    {\n        if (i < 0)\n\
    \        {\n            foundNegative = true;\n            largest = i;\n    \
    \    }\n        else if (i > 0)\n        {\n            foundPositive = true;\n\
    \            smallest = i;\n        }\n        else\n        {\n            largest\
    \ = Long.min;\n            smallest = Long.max;\n        }\n    }\n    if (foundNegative\
    \ && foundPositive)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \        result.0 = Nullable!(largest);\n        result.1 = Nullable!(smallest);\n\
    \    }\n    else if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = Nullable!(largest);\n        result.1\
    \ = Nullable!(Long.max);\n    }\n    else if (foundPositive)\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.0 = Nullable!(Long.max);\n\
    \        result.1 = Nullable!(smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.0 = Nullable!(Long.max);\n\
    \        result.1 = Nullable!(Long.max);\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmposkqd264.d(26): Error: semicolon expected, not `:`\n/tmp/tmposkqd264.d(26):
    Error: expression expected, not `:`\n/tmp/tmposkqd264.d(26): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmposkqd264.d(47): Error: found
    `0.00000` when expecting `;` following statement\n/tmp/tmposkqd264.d(47): Error:
    found `=` instead of statement\n/tmp/tmposkqd264.d(48): Error: found `0.1` when
    expecting `;` following statement\n/tmp/tmposkqd264.d(48): Error: found `=` instead
    of statement\n/tmp/tmposkqd264.d(53): Error: found `0.00000` when expecting `;`
    following statement\n/tmp/tmposkqd264.d(53): Error: found `=` instead of statement\n/tmp/tmposkqd264.d(54):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmposkqd264.d(54):
    Error: found `=` instead of statement\n/tmp/tmposkqd264.d(59): Error: found `0.00000`
    when expecting `;` following statement\n/tmp/tmposkqd264.d(59): Error: found `=`
    instead of statement\n/tmp/tmposkqd264.d(60): Error: found `0.1` when expecting
    `;` following statement\n/tmp/tmposkqd264.d(60): Error: found `=` instead of statement\n/tmp/tmposkqd264.d(65):
    Error: found `0.00000` when expecting `;` following statement\n/tmp/tmposkqd264.d(65):
    Error: found `=` instead of statement\n/tmp/tmposkqd264.d(66): Error: found `0.1`
    when expecting `;` following statement\n/tmp/tmposkqd264.d(66): Error: found `=`
    instead of statement\n/tmp/tmposkqd264.d(70): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmposkqd264.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.MinValue;\n    long smallest = Long.MaxValue;\n\
    \    for (long i : lst)\n    {\n        if (i < 0)\n        {\n            negative\
    \ = true;\n        }\n        if (i > 0)\n        {\n            if (largest <\
    \ i)\n            {\n                largest = i;\n            }\n           \
    \ if (smallest > i)\n            {\n                smallest = i;\n          \
    \  }\n        }\n    }\n    if (negative == false)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long))(largest, smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long))(null, null);\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4v1rz72y.d(25): Error: semicolon expected, not `:`\n/tmp/tmp4v1rz72y.d(25):
    Error: expression expected, not `:`\n/tmp/tmp4v1rz72y.d(25): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4v1rz72y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else if\
    \ (x > 0) {\n            result.b = x;\n        } else {\n            result.a\
    \ = null;\n            result.b = null;\n        }\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa22_t3t7.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpa22_t3t7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpa22_t3t7.d(34): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa22_t3t7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        Tuple!(Nullable!(long), Nullable!(long)) t = \n           \
    \ Tuple!(Nullable!(long), Nullable!(long)) \n                largest_smallest_integers(\n\
    \                    Array!long[\n                        i : i\n            \
    \        ]\n                )\n        )\n    {\n        if (t.a == null)\n  \
    \      {\n            result.a = null;\n            result.b = null;\n       \
    \ }\n        else if (t.b == null)\n        {\n            result.a = t.a;\n \
    \           result.b = null;\n        }\n        else\n        {\n           \
    \ if (t.a > t.b)\n            {\n                result.a = t.a;\n           \
    \     result.b = t.b;\n            }\n            else\n            {\n      \
    \          result.a = t.b;\n                result.b = t.a;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpefqcvu0b.d(23): Error: no identifier for declarator `i`\n/tmp/tmpefqcvu0b.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpefqcvu0b.d(24): Error: found `t`
    when expecting `)`\n/tmp/tmpefqcvu0b.d(24): Error: found `=` instead of statement\n/tmp/tmpefqcvu0b.d(38):
    Error: declaration expected, not `else`\n/tmp/tmpefqcvu0b.d(41): Error: no identifier
    for declarator `result.b`\n/tmp/tmpefqcvu0b.d(41): Error: declaration expected,
    not `=`\n/tmp/tmpefqcvu0b.d(42): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpefqcvu0b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        foreach(j : lst, \n            \n            if(i\
    \ < j) \n            {\n                result.a = i;\n                result.b\
    \ = j;\n                break;\n            }\n            \n        ));\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9yw_x044.d(23): Error: no identifier for declarator `i`\n/tmp/tmp9yw_x044.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp9yw_x044.d(25): Error: expression
    expected, not `foreach`\n/tmp/tmp9yw_x044.d(25): Error: found `:` when expecting
    `,`\n/tmp/tmp9yw_x044.d(27): Error: expression expected, not `if`\n/tmp/tmp9yw_x044.d(28):
    Error: found `{` when expecting `,`\n/tmp/tmp9yw_x044.d(29): Error: found `;`
    when expecting `,`\n/tmp/tmp9yw_x044.d(30): Error: found `;` when expecting `,`\n/tmp/tmp9yw_x044.d(31):
    Error: expression expected, not `break`\n/tmp/tmp9yw_x044.d(31): Error: found
    `;` when expecting `,`\n/tmp/tmp9yw_x044.d(32): Error: expression expected, not
    `}`\n/tmp/tmp9yw_x044.d(34): Error: use `{ }` for an empty statement, not `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9yw_x044.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ i, lst)\n    {\n        if (i < 0)\n        {\n            negative = true;\n\
    \        }\n        if (i > largest)\n        {\n            largest = i;\n  \
    \      }\n        if (i < smallest)\n        {\n            smallest = i;\n  \
    \      }\n    }\n    if (negative == false)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long)) (largest, smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long)) (null, null);\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n\
    {\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn_6a49_s.d(25): Error: no identifier for declarator `lst`\n/tmp/tmpn_6a49_s.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmpn_6a49_s.d(40): Error: found `if`
    when expecting `)`\n/tmp/tmpn_6a49_s.d(40): Error: found `==` when expecting `)`\n/tmp/tmpn_6a49_s.d(40):
    Error: missing `{ ... }` for function literal\n/tmp/tmpn_6a49_s.d(40): Error:
    found `false` when expecting `;` following statement\n/tmp/tmpn_6a49_s.d(40):
    Error: found `)` instead of statement\n/tmp/tmpn_6a49_s.d(44): Error: declaration
    expected, not `else`\n/tmp/tmpn_6a49_s.d(47): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_6a49_s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = null;\n        result.second\
    \ = null;\n        return result;\n    }\n    \n    long largest = lst.max();\n\
    \    long smallest = lst.min();\n    \n    if (largest < 0)\n    {\n        result.first\
    \ = null;\n        result.second = null;\n        return result;\n    }\n    \n\
    \    if (smallest > 0)\n    {\n        result.first = largest;\n        result.second\
    \ = smallest;\n        return result;\n    }\n    \n    result.first = null;\n\
    \    result.second = null;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsa4ckyfq.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmpsa4ckyfq.d(25):
    Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(26):
    Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(30):
    Error: no property `max` for type `long[]`\n/tmp/tmpsa4ckyfq.d(31): Error: no
    property `min` for type `long[]`\n/tmp/tmpsa4ckyfq.d(35): Error: no property `first`
    for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(36): Error:
    no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(42):
    Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(43):
    Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(47):
    Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpsa4ckyfq.d(48):
    Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsa4ckyfq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.Length;\n   \
    \ while(i < n)\n    {\n        if(lst[i] < 0)\n        {\n            largest\
    \ = Nullable!(long);\n            smallest = Nullable!(long);\n            i =\
    \ j;\n        }\n        else\n        {\n            smallest = Nullable!(long);\n\
    \            largest = Nullable!(long);\n            j = k;\n        }\n     \
    \   while(j < n)\n        {\n            if(lst[j] > 0)\n            {\n     \
    \           smallest = Nullable!(long);\n                largest = Nullable!(long);\n\
    \                k = j;\n                break;\n            }\n            else\n\
    \            {\n                j++;\n            }\n        }\n        if(k ==\
    \ j)\n        {\n            break;\n        }\n        i++;\n    }\n    return\
    \ Tuple!(largest, smallest);\n}\n</code>\n<|/ a tags=c#,algorithm,c++,python |>\n\
    <| c |>\nThis doesn't work if there are two negative numbers in the array. Try\
    \ `largest_smallest_integers([-2L, 4L, -1L, 3L, 5L, 7L])`\n<|/ c |>\n<| c |>\n\
    I didn't test the code with negative numbers. But I believe it works. I tested\
    \ it with the example you provided. `largest_smallest_integers([-2L, 4L, -1L,\
    \ 3L, 5L, 7L])` returns `Tuple(None,1)`\n<|/ c |>\n<| c |>\nYes, it works. I tested\
    \ it with the example you provided. `largest_smallest_integers([-2L, 4L, -1L,\
    \ 3L, 5L, 7L])` returns `Tuple(None,1)`\n<|/ c |>\n<| c |>\nI tested it with the\
    \ example you provided. `largest_smallest_integers([-2L, 4L, -1L, 3L, 5L, 7L])`\
    \ returns `Tuple(None,1)`\n<|/ c |>\n<| c |>\nI tested it with the example you\
    \ provided. `largest_smallest_integers([-2L, 4L, -1L, 3L, 5L, 7L])` returns `Tuple(None,1)`\n\
    <|/ c |>\n<| a |>\n<code>\ndef largest_smallest_integers(lst):\n    largest =\
    \ None\n    smallest = None\n    for x in lst:\n        if x < 0:\n          \
    \  if largest is None:\n                largest = x\n            else:\n     \
    \           smallest = \nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1y8q45pg.d(63): Error: declaration expected, not `<`\n/tmp/tmp1y8q45pg.d(66):
    Error: unterminated character constant\n/tmp/tmp1y8q45pg.d(69): Error: unterminated
    character constant\n/tmp/tmp1y8q45pg.d(95): Error: declaration expected, not `{`\n/tmp/tmp1y8q45pg.d(97):
    Error: declaration expected, not `assert`\n/tmp/tmp1y8q45pg.d(98): Error: declaration
    expected, not `assert`\n/tmp/tmp1y8q45pg.d(99): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1y8q45pg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ foundNegative = false;\n    bool foundPositive = false;\n    \n    for (long\
    \ i : lst)\n    {\n        if (i < 0)\n        {\n            foundNegative =\
    \ true;\n        }\n        if (i > 0)\n        {\n            foundPositive =\
    \ true;\n        }\n    }\n    \n    if (foundNegative && foundPositive)\n   \
    \ {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n    }\n    else\
    \ if (foundNegative)\n    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n\
    \    }\n    else if (foundPositive)\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    else\n    {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpintmga7s.d(26): Error: semicolon expected, not `:`\n/tmp/tmpintmga7s.d(26):
    Error: expression expected, not `:`\n/tmp/tmpintmga7s.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpintmga7s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            positive = false;\n           \
    \ largest = Long.min;\n            smallest = Long.max;\n        } else if (x\
    \ > largest) {\n            largest = x;\n        } else if (x < smallest) {\n\
    \            smallest = x;\n        }\n    }\n    if (positive && largest == Long.min)\
    \ {\n        result.a = Nullable!(null);\n        result.b = Nullable!(null);\n\
    \    } else if (positive && smallest == Long.max) {\n        result.a = Nullable!(null);\n\
    \        result.b = Nullable!(null);\n    } else {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphlif9tkv.d(25): Error: no identifier for declarator `lst`\n/tmp/tmphlif9tkv.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmphlif9tkv.d(36): Error: found `if`
    when expecting `)`\n/tmp/tmphlif9tkv.d(36): Error: found `&&` when expecting `)`\n/tmp/tmphlif9tkv.d(36):
    Error: missing `{ ... }` for function literal\n/tmp/tmphlif9tkv.d(36): Error:
    found `largest` when expecting `;` following statement\n/tmp/tmphlif9tkv.d(36):
    Error: found `==` instead of statement\n/tmp/tmphlif9tkv.d(39): Error: declaration
    expected, not `else`\n/tmp/tmphlif9tkv.d(41): Error: no identifier for declarator
    `result.b`\n/tmp/tmphlif9tkv.d(41): Error: declaration expected, not `=`\n/tmp/tmphlif9tkv.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlif9tkv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool negative\
    \ = false;\n    long largest = -100L;\n    long smallest = 100L;\n    for (long\
    \ i : lst) {\n        if (i < 0) {\n            negative = true;\n        }\n\
    \        if (i > largest) {\n            largest = i;\n        }\n        if (i\
    \ < smallest) {\n            smallest = i;\n        }\n    }\n    if (negative\
    \ == false) {\n        result = Tuple!(Nullable!(long), Nullable!(long)) (largest,\
    \ smallest);\n    } else {\n        result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n    \
    \    auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8v7clg30.d(25): Error: semicolon expected, not `:`\n/tmp/tmp8v7clg30.d(25):
    Error: expression expected, not `:`\n/tmp/tmp8v7clg30.d(25): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmp8v7clg30.d(40): Error: expression
    expected, not `unittest`\n/tmp/tmp8v7clg30.d(41): Error: found `{` when expecting
    `,`\n/tmp/tmp8v7clg30.d(42): Error: expression expected, not `alias`\n/tmp/tmp8v7clg30.d(42):
    Error: found `candidate` when expecting `,`\n/tmp/tmp8v7clg30.d(42): Error: expression
    expected, not `=`\n/tmp/tmp8v7clg30.d(42): Error: found `largest_smallest_integers`
    when expecting `,`\n/tmp/tmp8v7clg30.d(42): Error: expression expected, not `;`\n/tmp/tmp8v7clg30.d(44):
    Error: found `{` when expecting `,`\n/tmp/tmp8v7clg30.d(45): Error: expression
    expected, not `auto`\n/tmp/tmp8v7clg30.d(45): Error: found `result` when expecting
    `,`\n/tmp/tmp8v7clg30.d(45): Error: expression expected, not `=`\n/tmp/tmp8v7clg30.d(45):
    Error: found `candidate` when expecting `,`\n/tmp/tmp8v7clg30.d(45): Error: found
    `;` when expecting `,`\n/tmp/tmp8v7clg30.d(46): Error: found `;` when expecting
    `,`\n/tmp/tmp8v7clg30.d(47): Error: found `;` when expecting `,`\n/tmp/tmp8v7clg30.d(48):
    Error: expression expected, not `}`\n/tmp/tmp8v7clg30.d(50): Error: found `{`
    when expecting `,`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8v7clg30.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long a = lst.iter().max().unwrap();\n\
    \    long b = lst.iter().min().unwrap();\n    \n    if (a < 0)\n        return\
    \ result;\n    \n    if (b > 0)\n        return result;\n    \n    result.0 =\
    \ Nullable!(b);\n    result.1 = Nullable!(a);\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpte3q1l1y.d(35): Error: found `0.00000` when expecting `;` following
    statement\n/tmp/tmpte3q1l1y.d(35): Error: found `=` instead of statement\n/tmp/tmpte3q1l1y.d(36):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmpte3q1l1y.d(36):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpte3q1l1y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    foreach(i : lst)\n    {\n        if (i < 0)\n        {\n            largest\
    \ = i;\n        }\n        else if (i > 0)\n        {\n            smallest =\
    \ i;\n        }\n    }\n    return Tuple!(largest, smallest);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8_lqiyaa.d(23): Error: no identifier for declarator `i`\n/tmp/tmp8_lqiyaa.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8_lqiyaa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            positive = false;\n\
    \            largest = x;\n        }\n        else if (x > 0)\n        {\n   \
    \         smallest = x;\n        }\n        else\n        {\n            largest\
    \ = x;\n        }\n    }\n    if (positive == true)\n    {\n        result.a =\
    \ largest;\n        result.b = smallest;\n    }\n    else\n    {\n        result.a\
    \ = null;\n        result.b = null;\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprc0ndbxb.d(25): Error: no identifier for declarator `lst`\n/tmp/tmprc0ndbxb.d(25):
    Error: found `)` when expecting `;`\n/tmp/tmprc0ndbxb.d(41): Error: found `if`
    when expecting `)`\n/tmp/tmprc0ndbxb.d(41): Error: found `==` when expecting `)`\n/tmp/tmprc0ndbxb.d(41):
    Error: missing `{ ... }` for function literal\n/tmp/tmprc0ndbxb.d(41): Error:
    found `true` when expecting `;` following statement\n/tmp/tmprc0ndbxb.d(41): Error:
    found `)` instead of statement\n/tmp/tmprc0ndbxb.d(46): Error: declaration expected,
    not `else`\n/tmp/tmprc0ndbxb.d(49): Error: no identifier for declarator `result.b`\n/tmp/tmprc0ndbxb.d(49):
    Error: declaration expected, not `=`\n/tmp/tmprc0ndbxb.d(50): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprc0ndbxb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach\
    \ (i, e) in lst {\n        if (e < 0L) {\n            result.a = e;\n        \
    \    result.b = e;\n        } else {\n            result.a = e;\n            result.b\
    \ = e;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpswyvkex9.d(23): Error: no identifier for declarator `e`\n/tmp/tmpswyvkex9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpswyvkex9.d(23): Error: expression
    expected, not `in`\n/tmp/tmpswyvkex9.d(23): Error: found `lst` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpswyvkex9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) \n               {\n     \
    \              result = Tuple!(Nullable!(long), Nullable!(long));\n          \
    \     }\n               else \n               {\n                   result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n               }\n           });\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzm8xe7jf.d(23): Error: no identifier for declarator `i`\n/tmp/tmpzm8xe7jf.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpzm8xe7jf.d(33): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzm8xe7jf.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    foreach(long i in lst)\n    {\n        if (i < 0)\n        {\n   \
    \         foundNegative = true;\n            largestNegative = i;\n        }\n\
    \        else if (i > 0)\n        {\n            foundPositive = true;\n     \
    \       largestPositive = i;\n        }\n        else\n        {\n           \
    \ if (foundNegative && foundPositive)\n            {\n                if (largestNegative\
    \ > largestPositive)\n                {\n                    largestNegative =\
    \ largestPositive;\n                }\n                else\n                {\n\
    \                    largestPositive = largestPositive;\n                }\n \
    \           }\n            else if (foundNegative)\n            {\n          \
    \      largestNegative = i;\n            }\n            else if (foundPositive)\n\
    \            {\n                largestPositive = i;\n            }\n        }\n\
    \    }\n    if (largestNegative > largestPositive)\n    {\n        largestNegative\
    \ = largestPositive;\n    }\n    else\n    {\n        largestPositive = largestPositive;\n\
    \    }\n    if (smallestNegative < smallestPositive)\n    {\n        smallestNegative\
    \ = smallestPositive;\n    }\n    else\n    {\n        smallestPositive = smallestPositive;\n\
    \    }\n    if (largestNegative == largestPositive)\n    {\n        result.first\
    \ = null;\n        result.second = largestNegative;\n    }\n    else if (smallestNegative\
    \ == smallestPositive)\n    {\n        result.first = null;\n        result.second\
    \ = smallestNegative;\n    }\n    else\n    {\n        result.first = largestNegative;\n\
    \        result.second = smallestPositive;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like this solution, though it does require a lot\
    \ of extra code (which I didn't want to do).\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't require any extra code. :)\n<|/ c |>\n<| c |>\nI like your new\
    \ solution, though it does require a lot of extra code (which I didn't want to\
    \ do).\n<|/ c |>\n<| c |>\nI added a version that doesn't require any extra code.\
    \ :)\n<|/ c |>\n<| c |>\nI like your new solution, though it does require a lot\
    \ of extra code (which I didn't want to do).\n<|/ c |>\n<| a |>\nI like \nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmzvzpxzm.d(28): Error: found `in` when expecting `;`\n/tmp/tmpmzvzpxzm.d(96):
    Error: declaration expected, not `<`\n/tmp/tmpmzvzpxzm.d(99): Error: unterminated
    character constant\n/tmp/tmpmzvzpxzm.d(102): Error: unterminated character constant\n/tmp/tmpmzvzpxzm.d(105):
    Error: unterminated character constant\n/tmp/tmpmzvzpxzm.d(108): Error: unterminated
    character constant\n/tmp/tmpmzvzpxzm.d(111): Error: unterminated character constant\n/tmp/tmpmzvzpxzm.d(119):
    Error: declaration expected, not `{`\n/tmp/tmpmzvzpxzm.d(121): Error: declaration
    expected, not `assert`\n/tmp/tmpmzvzpxzm.d(122): Error: declaration expected,
    not `assert`\n/tmp/tmpmzvzpxzm.d(123): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmzvzpxzm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long a = null;\n    long b = null;\n    for (long i : lst) {\n\
    \        if (i < 0) {\n            a = i;\n        } else if (i > 0){\n      \
    \      b = i;\n        }\n    }\n    return Tuple!(a, b);\n}\nunittest\n{\n  \
    \  alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcik53m2m.d(23): Error: semicolon expected, not `:`\n/tmp/tmpcik53m2m.d(23):
    Error: expression expected, not `:`\n/tmp/tmpcik53m2m.d(23): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpcik53m2m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n        return result;\n    \n    long largest = lst.max_element();\n\
    \    long smallest = lst.min_element();\n    \n    if (largest < 0)\n        return\
    \ result;\n    \n    if (smallest > 0)\n        return result;\n    \n    result.0\
    \ = Nullable!(long);\n    result.1 = Nullable!(long);\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjl0buv9x.d(35): Error: found `0.00000` when expecting `;` following
    statement\n/tmp/tmpjl0buv9x.d(35): Error: found `=` instead of statement\n/tmp/tmpjl0buv9x.d(36):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmpjl0buv9x.d(36):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpjl0buv9x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    for (long i : lst) {\n        if (i < 0) {\n            foundNegative\
    \ = true;\n            largestNegative = i;\n        }\n        else {\n     \
    \       foundPositive = true;\n            largestPositive = i;\n        }\n \
    \       if (foundNegative && foundPositive) {\n            break;\n        }\n\
    \    }\n    if (foundNegative) {\n        smallestNegative = largestNegative;\n\
    \    }\n    if (foundPositive) {\n        smallestPositive = largestPositive;\n\
    \    }\n    if (largestNegative > largestPositive) {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = smallestNegative;\n        result.1 =\
    \ largestPositive;\n    }\n    else {\n        result = Tuple!(Nullable!(long),\
    \ Nullable!(long));\n        result.0 = largestNegative;\n        result.1 = smallestPositive;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmkmdm50h.d(28): Error: semicolon expected, not `:`\n/tmp/tmpmkmdm50h.d(28):
    Error: expression expected, not `:`\n/tmp/tmpmkmdm50h.d(28): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpmkmdm50h.d(49): Error: found
    `0.00000` when expecting `;` following statement\n/tmp/tmpmkmdm50h.d(49): Error:
    found `=` instead of statement\n/tmp/tmpmkmdm50h.d(50): Error: found `0.1` when
    expecting `;` following statement\n/tmp/tmpmkmdm50h.d(50): Error: found `=` instead
    of statement\n/tmp/tmpmkmdm50h.d(54): Error: found `0.00000` when expecting `;`
    following statement\n/tmp/tmpmkmdm50h.d(54): Error: found `=` instead of statement\n/tmp/tmpmkmdm50h.d(55):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmpmkmdm50h.d(55):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmkmdm50h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    bool negative = true;\n    long largest = Long.min;\n    long smallest\
    \ = Long.max;\n    for (long i : lst) {\n        if (i < 0) {\n            negative\
    \ = false;\n        } else if (i > 0) {\n            positive = false;\n     \
    \   }\n        if (positive && negative && largest < i) {\n            largest\
    \ = i;\n        } else if (positive && negative && smallest > i) {\n         \
    \   smallest = i;\n        }\n    }\n    if (positive && negative && largest <\
    \ smallest) {\n        result.a = Nullable!(null);\n        result.b = Nullable!(null);\n\
    \    } else if (positive && negative && smallest > largest) {\n        result.a\
    \ = Nullable!(null);\n        result.b = Nullable!(null);\n    } else if (positive\
    \ && negative && largest == smallest) {\n        result.a = Nullable!(null);\n\
    \        result.b = Nullable!(null);\n    } else {\n        result.a = Nullable!(largest);\n\
    \        result.b = Nullable!(smallest);\n    }\n    return result;\n}\n/*\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpenv0eafh.d(26): Error: semicolon expected, not `:`\n/tmp/tmpenv0eafh.d(26):
    Error: expression expected, not `:`\n/tmp/tmpenv0eafh.d(26): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpenv0eafh.d(53): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpenv0eafh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           {\n               if (i < 0L) result.a = Nullable!(long);\n\
    \               else if (i > 0L) result.b = Nullable!(long);\n               else\
    \ result.a = Nullable!(long);\n               result.b = Nullable!(long);\n  \
    \         });\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx9eodl0p.d(23): Error: no identifier for declarator `i`\n/tmp/tmpx9eodl0p.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmpx9eodl0p.d(29): Error: use `{ }`
    for an empty statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx9eodl0p.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    if\
    \ (lst.is_empty())\n    {\n        result.first = null;\n        result.second\
    \ = null;\n    }\n    else\n    {\n        long max = 0;\n        long min = 0;\n\
    \        \n        for (int i = 0; i < lst.size(); ++i)\n        {\n         \
    \   if (lst[i] < min)\n            {\n                min = lst[i];\n        \
    \    }\n            else if (lst[i] > max)\n            {\n                max\
    \ = lst[i];\n            }\n        }\n        \n        result.first = max;\n\
    \        result.second = min;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjrbwo0v5.d(23): Error: no property `is_empty` for type `long[]`\n/tmp/tmpjrbwo0v5.d(25):
    Error: no property `first` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpjrbwo0v5.d(26):
    Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpjrbwo0v5.d(33):
    Error: no property `size` for type `long[]`\n/tmp/tmpjrbwo0v5.d(45): Error: no
    property `first` for type `Tuple!(Nullable!long, Nullable!long)`\n/tmp/tmpjrbwo0v5.d(46):
    Error: no property `second` for type `Tuple!(Nullable!long, Nullable!long)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrbwo0v5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    bool\
    \ positive = true;\n    long max = 0;\n    long min = 0;\n    \n    foreach(long\
    \ x, lst)\n    {\n        if (x < 0)\n        {\n            positive = false;\n\
    \        }\n        \n        if (x > max)\n        {\n            max = x;\n\
    \        }\n        \n        if (x < min)\n        {\n            min = x;\n\
    \        }\n    }\n    \n    if (positive && max > min)\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n     \
    \   result.b = min;\n    }\n    else if (!positive && max < min)\n    {\n    \
    \    result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a = max;\n\
    \        result.b = min;\n    }\n    else if (!positive && max > min)\n    {\n\
    \        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max < min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max > min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max < min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max > min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max < min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max > min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max < min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max > min)\n\
    \    {\n        result = Tuple!(Nullable!(long), Nullable!(long));\n        result.a\
    \ = max;\n        result.b = min;\n    }\n    else if (!positive && max < min)\n\
    \    {\n        result = Tuple!(Nullable!(\nunittest\n{\n    alias candidate =\
    \ largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp98s698qg.d(27): Error: no identifier for declarator `lst`\n/tmp/tmp98s698qg.d(27):
    Error: found `)` when expecting `;`\n/tmp/tmp98s698qg.d(45): Error: found `if`
    when expecting `)`\n/tmp/tmp98s698qg.d(45): Error: found `&&` when expecting `)`\n/tmp/tmp98s698qg.d(45):
    Error: missing `{ ... }` for function literal\n/tmp/tmp98s698qg.d(45): Error:
    found `max` when expecting `;` following statement\n/tmp/tmp98s698qg.d(45): Error:
    found `>` instead of statement\n/tmp/tmp98s698qg.d(51): Error: declaration expected,
    not `else`\n/tmp/tmp98s698qg.d(54): Error: no identifier for declarator `result.a`\n/tmp/tmp98s698qg.d(54):
    Error: declaration expected, not `=`\n/tmp/tmp98s698qg.d(55): Error: no identifier
    for declarator `result.b`\n/tmp/tmp98s698qg.d(55): Error: declaration expected,
    not `=`\n/tmp/tmp98s698qg.d(56): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp98s698qg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst)\n    {\n        if (i < 0L)\n        {\n            result.a = Nullable!(long);\n\
    \            result.b = i;\n        }\n        else if (i > 0L)\n        {\n \
    \           result.a = i;\n            result.b = Nullable!(long);\n        }\n\
    \        else\n        {\n            result.a = Nullable!(long);\n          \
    \  result.b = Nullable!(long);\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphzuue2yf.d(23): Error: no identifier for declarator `i`\n/tmp/tmphzuue2yf.d(23):
    Error: found `:` when expecting `;`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphzuue2yf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i < 0) result = Tuple!(Nullable!(long), Nullable!(long));\
    \ \n           else result = Tuple!(Nullable!(long), Nullable!(long))(Nullable!(long),\
    \ Nullable!(long)));\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp41yc_wpw.d(23): Error: no identifier for declarator `i`\n/tmp/tmp41yc_wpw.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp41yc_wpw.d(24): Error: expression
    expected, not `if`\n/tmp/tmp41yc_wpw.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmp41yc_wpw.d(24): Error: found `=` instead of statement\n/tmp/tmp41yc_wpw.d(25):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41yc_wpw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n           if(i<0) result = Tuple!(Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long),\
    \ Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long))\
    \ (Nullable!(long), Nullable!(long)) (Nullable!(long), Nullable!(long)) (Nullable!(long\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8sutvvp3.d(23): Error: no identifier for declarator `i`\n/tmp/tmp8sutvvp3.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp8sutvvp3.d(24): Error: expression
    expected, not `if`\n/tmp/tmp8sutvvp3.d(24): Error: found `result` when expecting
    `)`\n/tmp/tmp8sutvvp3.d(24): Error: found `=` instead of statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8sutvvp3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool positive\
    \ = true;\n    long largest = Long.min;\n    long smallest = Long.max;\n    for\
    \ (long i : lst)\n    {\n        if (i < 0)\n        {\n            positive =\
    \ false;\n        }\n        if (i > largest)\n        {\n            largest\
    \ = i;\n        }\n        if (i < smallest)\n        {\n            smallest\
    \ = i;\n        }\n    }\n    if (positive && largest < Long.max)\n    {\n   \
    \     result = Tuple!(Nullable!(long), Nullable!(long));\n        result.0 = Nullable!(largest);\n\
    \        result.1 = Nullable!(smallest);\n    }\n    else\n    {\n        result\
    \ = Tuple!(Nullable!(long), Nullable!(long));\n        result.0 = Nullable!(null);\n\
    \        result.1 = Nullable!(null);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpymd9_1o6.d(25): Error: semicolon expected, not `:`\n/tmp/tmpymd9_1o6.d(25):
    Error: expression expected, not `:`\n/tmp/tmpymd9_1o6.d(25): Error: found `lst`
    when expecting `;` following `for` condition\n/tmp/tmpymd9_1o6.d(43): Error: found
    `0.00000` when expecting `;` following statement\n/tmp/tmpymd9_1o6.d(43): Error:
    found `=` instead of statement\n/tmp/tmpymd9_1o6.d(44): Error: found `0.1` when
    expecting `;` following statement\n/tmp/tmpymd9_1o6.d(44): Error: found `=` instead
    of statement\n/tmp/tmpymd9_1o6.d(49): Error: found `0.00000` when expecting `;`
    following statement\n/tmp/tmpymd9_1o6.d(49): Error: found `=` instead of statement\n/tmp/tmpymd9_1o6.d(50):
    Error: found `0.1` when expecting `;` following statement\n/tmp/tmpymd9_1o6.d(50):
    Error: found `=` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpymd9_1o6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largestPositive = 0;\n \
    \   long largestNegative = 0;\n    long smallestPositive = 0;\n    long smallestNegative\
    \ = 0;\n    for (long i : lst) {\n        if (i < 0) {\n            foundNegative\
    \ = true;\n            largestNegative = i;\n        } else if (i > 0){\n    \
    \        foundPositive = true;\n            largestPositive = i;\n        }\n\
    \    }\n    if (foundNegative) {\n        result.first = null;\n        result.second\
    \ = largestNegative;\n    } else if (foundPositive) {\n        result.first =\
    \ largestPositive;\n        result.second = null;\n    } else {\n        result.first\
    \ = null;\n        result.second = null;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0k1xo8ch.d(28): Error: semicolon expected, not `:`\n/tmp/tmp0k1xo8ch.d(28):
    Error: expression expected, not `:`\n/tmp/tmp0k1xo8ch.d(28): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0k1xo8ch.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b;\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpchvp_66m.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpchvp_66m.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpchvp_66m.d(31): Error: found `if`
    when expecting `)`\n/tmp/tmpchvp_66m.d(31): Error: found `==` when expecting `)`\n/tmp/tmpchvp_66m.d(31):
    Error: missing `{ ... }` for function literal\n/tmp/tmpchvp_66m.d(31): Error:
    found `null` when expecting `;` following statement\n/tmp/tmpchvp_66m.d(31): Error:
    found `)` instead of statement\n/tmp/tmpchvp_66m.d(35): Error: declaration expected,
    not `return`\n/tmp/tmpchvp_66m.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchvp_66m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9nbw3ey.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpb9nbw3ey.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb9nbw3ey.d(31): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9nbw3ey.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool has_negative\
    \ = false;\n    bool has_positive = false;\n    long max_negative = 0;\n    long\
    \ min_positive = Long.MAX_VALUE;\n    foreach(long x, lst) {\n        if (x <\
    \ 0) {\n            has_negative = true;\n            if (x > max_negative) {\n\
    \                max_negative = x;\n            }\n        } else {\n        \
    \    has_positive = true;\n            if (x < min_positive) {\n             \
    \   min_positive = x;\n            }\n        }\n    }\n    if (has_negative)\
    \ {\n        result.a = Nullable!(long);\n        result.b = max_negative;\n \
    \   } else {\n        result.a = Nullable!(long);\n        result.b = min_positive;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzr4r_g24.d(26): Error: no identifier for declarator `lst`\n/tmp/tmpzr4r_g24.d(26):
    Error: found `)` when expecting `;`\n/tmp/tmpzr4r_g24.d(39): Error: found `if`
    when expecting `)`\n/tmp/tmpzr4r_g24.d(42): Error: found `else` when expecting
    `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzr4r_g24.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    bool foundNegative\
    \ = false;\n    bool foundPositive = false;\n    long largest = Long.min;\n  \
    \  long smallest = Long.max;\n    for (long i : lst) {\n        if (i < 0) {\n\
    \            foundNegative = true;\n        } else if (i >= 0) {\n           \
    \ foundPositive = true;\n        }\n        if (foundNegative && foundPositive)\
    \ {\n            break;\n        } else if (foundNegative) {\n            largest\
    \ = i;\n        } else if (foundPositive) {\n            smallest = i;\n     \
    \   }\n    }\n    if (foundNegative && foundPositive) {\n        result.first\
    \ = null;\n        result.second = smallest;\n    } else if (foundNegative) {\n\
    \        result.first = null;\n        result.second = largest;\n    } else if\
    \ (foundPositive) {\n        result.first = largest;\n        result.second =\
    \ null;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzh3m00it.d(26): Error: semicolon expected, not `:`\n/tmp/tmpzh3m00it.d(26):
    Error: expression expected, not `:`\n/tmp/tmpzh3m00it.d(26): Error: found `lst`
    when expecting `;` following `for` condition\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzh3m00it.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    var largest = Nullable!(long);\n    var smallest = Nullable!(long);\n\
    \    var i = 0;\n    var j = 0;\n    var k = 0;\n    var n = lst.Length;\n   \
    \ while(i < n && j < n) {\n        if(lst[i] < lst[j]) {\n            smallest\
    \ = Nullable!(long);\n            k = j;\n            smallest = lst[i];\n   \
    \         i = i + 1;\n        } else {\n            largest = Nullable!(long);\n\
    \            k = i;\n            largest = lst[j];\n            j = j + 1;\n \
    \       }\n    }\n    if(i < n) {\n        smallest = Nullable!(long);\n     \
    \   largest = Nullable!(long);\n        smallest = lst[i];\n        i = i + 1;\n\
    \    } else if(j < n) {\n        largest = Nullable!(long);\n        smallest\
    \ = Nullable!(long);\n        largest = lst[j];\n        j = j + 1;\n    }\n \
    \   return Tuple!(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4agmjvj.d(21): Error: undefined identifier `var`\n/tmp/tmpd4agmjvj.d(21):
    Error: type `inout(long)` has no value\n/tmp/tmpd4agmjvj.d(22): Error: undefined
    identifier `var`\n/tmp/tmpd4agmjvj.d(22): Error: type `inout(long)` has no value\n/tmp/tmpd4agmjvj.d(23):
    Error: undefined identifier `var`\n/tmp/tmpd4agmjvj.d(24): Error: undefined identifier
    `var`\n/tmp/tmpd4agmjvj.d(25): Error: undefined identifier `var`\n/tmp/tmpd4agmjvj.d(26):
    Error: undefined identifier `var`\n/tmp/tmpd4agmjvj.d(26): Error: no property
    `Length` for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4agmjvj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        foreach(j : lst, \n            \n            if(i<j)\
    \ \n            {\n                result.a = i;\n                result.b = j;\n\
    \                break;\n            }\n            \n        )\n    );\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7kiy1w_b.d(23): Error: no identifier for declarator `i`\n/tmp/tmp7kiy1w_b.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp7kiy1w_b.d(25): Error: expression
    expected, not `foreach`\n/tmp/tmp7kiy1w_b.d(25): Error: found `:` when expecting
    `,`\n/tmp/tmp7kiy1w_b.d(27): Error: expression expected, not `if`\n/tmp/tmp7kiy1w_b.d(28):
    Error: found `{` when expecting `,`\n/tmp/tmp7kiy1w_b.d(29): Error: found `;`
    when expecting `,`\n/tmp/tmp7kiy1w_b.d(30): Error: found `;` when expecting `,`\n/tmp/tmp7kiy1w_b.d(31):
    Error: expression expected, not `break`\n/tmp/tmp7kiy1w_b.d(31): Error: found
    `;` when expecting `,`\n/tmp/tmp7kiy1w_b.d(32): Error: expression expected, not
    `}`\n/tmp/tmp7kiy1w_b.d(35): Error: use `{ }` for an empty statement, not `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7kiy1w_b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(i\
    \ : lst, \n        \n        Tuple!(Nullable!(long), Nullable!(long)) tuple =\
    \ \n            Tuple!(Nullable!(long), Nullable!(long)) (\n                if(i<0L)\
    \ Nullable!(long) null,\n                if(i>0L) Nullable!(long) i\n        \
    \    );\n        \n        result = tuple;\n    );\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2t93emv9.d(23): Error: no identifier for declarator `i`\n/tmp/tmp2t93emv9.d(23):
    Error: found `:` when expecting `;`\n/tmp/tmp2t93emv9.d(25): Error: found `tuple`
    when expecting `)`\n/tmp/tmp2t93emv9.d(25): Error: found `=` instead of statement\n/tmp/tmp2t93emv9.d(32):
    Error: found `)` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp2t93emv9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in an array.\n    If there\
    \ is no negative or positive integers, return them as null.\n\n    Examples:\n\
    \    >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None,\
    \ 1L)\n    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Tuple!(Nullable!(long), Nullable!(long)) result;\n    \n    foreach(long\
    \ x, lst) {\n        if (x < 0) {\n            result.a = x;\n        } else {\n\
    \            result.b = x;\n        }\n    }\n    \n    if (result.a == null)\
    \ {\n        result.a = result.b == null ? null : result.b;\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpma785txn.d(23): Error: no identifier for declarator `lst`\n/tmp/tmpma785txn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpma785txn.d(31): Error: found `if`
    when expecting `)`\n/tmp/tmpma785txn.d(31): Error: found `==` when expecting `)`\n/tmp/tmpma785txn.d(31):
    Error: missing `{ ... }` for function literal\n/tmp/tmpma785txn.d(31): Error:
    found `null` when expecting `;` following statement\n/tmp/tmpma785txn.d(31): Error:
    found `)` instead of statement\n/tmp/tmpma785txn.d(35): Error: declaration expected,
    not `return`\n/tmp/tmpma785txn.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpma785txn.d", "-I/tmp"]\n'''
  stdout: b''
