name: HumanEval_18_how_many_times
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n\
    \        if(string.at(i) == substring.at(0))\n        {\n            count++;\n\
    \        }\n        else if(string.at(i) == substring.at(1))\n        {\n    \
    \        count += 2;\n        }\n        else if(string.at(i) == substring.at(2))\n\
    \        {\n            count += 3;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool ignore_case) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(ignore_case)\n        {\n            if(string.at(i) == substring.at(0))\n\
    \            {\n                count++;\n            }\n            else if(string.at(i)\
    \ == substring.at(1))\n            {\n                count += 2;\n          \
    \  }\n            else if(string.at(i) == substring.at(2))\n            {\n  \
    \              count += 3;\n            }\n        }\n        else\n        {\n\
    \            if(string.at(i) == substring.at(0))\n            {\n            \
    \    count++;\n            }\n            else if(string.at(i) == substring.at(1))\n\
    \            {\n                count += 2;\n            }\n            else if(string.at(i)\
    \ == substring.at(2))\n            {\n                count += 3;\n          \
    \  }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, bool ignore_case, bool ignore_whitespace)\
    \ \n{\n    long count = 0;\n    long len = string.length();\n    long sublen =\
    \ substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n       \
    \ if(ignore_whitespace)\n        {\n            if(string.at(i) == substring.at(0))\n\
    \            {\n                count++;\n            }\n            else if(string.at(i)\
    \ == substring.at(1))\n            {\n                count += ", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n\
    \        if(string.substr(i, sublen) == substring)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\", \"aa\"\
    )`.\n<|/ c |>\n<| c |>\nIt works. I tested it before posting. I will edit my post\
    \ to include a test case.\n<|/ c |>\n<| c |>\nOh, I see what you mean. Yes, it\
    \ does work. Sorry about that. I was thinking about it backwards. I edited my\
    \ post to fix it.\n<|/ c |>\n<| c |>\nI edited my post to fix the bug that I pointed\
    \ out in the comments. I tested it and it works now.\n<|/ c |>\n<| c |>\nI edited\
    \ my post to fix the bug that I pointed out in the comments. I tested it and it\
    \ works now.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\nThis can be done in\
    \ O(n) time complexity by using a hash table. \n<code>\n#include <iostream>\n\
    #include <string>\n#include <unordered_map>\nusing namespace std;", "{\n    long\
    \ count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n    size_t\
    \ sublen = substring.length();\n    \n    while (pos < len) {\n        size_t\
    \ subpos = 0;\n        \n        while (subpos < sublen) {\n            if (string[pos]\
    \ == substring[subpos]) {\n                subpos++;\n            } else {\n \
    \               break;\n            }\n        }\n        \n        if (subpos\
    \ == sublen) {\n            count++;\n            pos += sublen;\n        } else\
    \ {\n            pos += sublen;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t len\
    \ = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        size_t subpos = 0;\n        \n        while (subpos <\
    \ sublen) {\n            if (string[pos] == substring[subpos]) {\n           \
    \     subpos++;\n            } else {\n                break;\n            }\n\
    \        }\n        \n        if (subpos == sublen) {\n            count++;\n\
    \            pos += sublen;\n        } else {\n            pos += sublen;\n  \
    \      }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end) \n{\n\
    \    long count = 0;\n    size_t pos = start;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    size_t subpos = 0;\n        \n        while (subpos < sublen) {\n       \
    \     if (string[pos] == substring[subpos]) {\n                subpos++;\n   \
    \         } else {\n                break;\n            }\n        }\n       \
    \ \n        if (subpos == sublen) {\n            count++;\n            pos +=\
    \ sublen;\n        } else {\n            pos += sublen;\n        }\n    }\n  \
    \  \n    return count;\n}\n/*", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nI believe this\
    \ solution will fail for `how_many_times(\"aaaa\", \"aa\")` because it will return\
    \ `2` instead of `3`.\n<|/ c |>\n<| c |>\nYes, you are right. I missed that case.\
    \ Thanks for pointing out. Fixed now.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n            pos += sublen;\n        }\n     \
    \   else {\n            pos = string.find(substring, pos);\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}", "{\n    long\
    \ count = 0;\n    long start = 0;\n    long end = 0;\n    long length = string.length();\n\
    \    \n    while(start < length) \n    {\n        end = string.find(substring,\
    \ start);\n        if(end == string.length()) \n        {\n            count++;\n\
    \            start = end + 1;\n        }\n        else \n        {\n         \
    \   count++;\n            start = end + 1;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string.compare(i, substring.length(), substring) == 0) {\n       \
    \     count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that is a prefix of the\
    \ original string. For example, if `string = \"abba\"` and `substring = \"a\"\
    `, then `how_many_times(string, substring)` will return `2`, when it should be\
    \ `1`.\n<|/ c |>\n<| c |>\n: I didn't notice that case. Thanks for pointing it\
    \ out. I've updated my answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        for(int j = 0; j < substring.length(); j++) {\n\
    \            if(string[i] == substring[j]) {\n                count++;\n     \
    \       }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    ", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\
    \t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n\t\
    long count = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string case_sensitive) \n{\n", "{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++,string-matching\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ string.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if you try it on \"aaa\" and \"\
    aa\"\n<|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns 3 for \"aaa\"\
    \ and \"aa\".\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. Try\
    \ it yourself.\n<|/ c |>\n<| a dscore=5 |>\nThe best way is to use Knuth-Morris-Pratt\
    \ algorithm. \n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<|\
    \ c |>\nThe question was about C++, not C#.\n<|/ c |>\n<| c |>\nThe question was\
    \ about C++, not C#.\n<|/ c |>\n<| c |>\nThe question was about C++, not C#.\n\
    <|/ c |>\n<| c |>\nThe question was about C++, not C#.\n<|/ c |>\n<| c |>\nThe\
    \ question was about C++, not C#.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n \
    \   long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) ==\
    \ substring.charAt(0))\n        {\n            count++;\n            \n      \
    \      for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \               }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = start; i < len; i++)\n \
    \   {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n      \
    \      count++;\n            \n            for(int j = 1; j < sublen; j++)\n \
    \           {\n                if(string.charAt(i) == substring.charAt(j))\n \
    \               {\n                    count++;\n                }\n         \
    \   }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = start; i < end; i++)\n    {\n        if(string.charAt(i)\
    \ == substring.charAt(0))\n        {\n            count++;\n            \n   \
    \         for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \               }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if\
    \ the substring appears more than once in the string. For example, how_many_times(\"\
    aaaa\", \"aa\") returns 3 instead of 2.\n<|/ c |>\n<| c |>\nYes, I forgot to add\
    \ that case. Thanks for pointing it out. I've edited my answer.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    long len = 0;\n    \n    for(long i = 0; i < string.length();\
    \ i++)\n    {\n        end = string.find(substring, i);\n        if(end == string.length())\n\
    \        {\n            count++;\n            i = string.length();\n        }\n\
    \        else\n        {\n            len = end - i;\n            if(len > 0)\n\
    \            {\n                count += len;\n                start = i;\n  \
    \          }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n\
    \        {\n            count++;\n            \n            for(int j = 1; j <\
    \ sublen; j++)\n            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive) \n{\n\
    \    long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(case_sensitive)\n \
    \       {\n            if(string.charAt(i) == substring.charAt(0))\n         \
    \   {\n                count++;\n                \n                for(int j =\
    \ 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == substring.charAt(j))\n                    {\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n        else\n\
    \        {\n            if(string.charAt(i) == substring.charAt(0))\n        \
    \    {\n                count++;\n                \n                for(int j\
    \ = 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == substring.charAt(j))\n                    {\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool case_sensitive_ignorecase) \n{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(case_sensitive_ignorecase)\n\
    \        {\n            if(string.charAt(i) == substring.charAt(0))\n        \
    \    {\n                count++;\n                \n                for(int j\
    \ = 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == ", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,algorithm,c++ |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\
    using namespace std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis is not the best solution. `string.compare(i, substring.length(),\
    \ substring, 0, substring.length())` will do an extra comparison for each character\
    \ in the substring and will also do an extra comparison for each character in\
    \ the original string. `string.find(substring, i) != string::npos` will do an\
    \ extra comparison for each character in the substring and will also do an extra\
    \ comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character ", "{\n    long count = 0;\n    long start = 0;\n    long end\
    \ = 0;\n    long len = 0;\n    \n    while(end < string.length)\n    {\n     \
    \   len = string.length() - end;\n        if(string.compare(end, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \           end = string.length();\n        }\n        else\n        {\n     \
    \       end = end + 1;\n        }\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n    \
    \    if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n     \
    \   if(string[i] == substring[0])\n        {\n            for(int j = 1; j < sublen;\
    \ j++)\n            {\n                if(string[i + j] != substring[j])\n   \
    \             {\n                    break;\n                }\n            }\n\
    \            count += j - 1;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,c++ |>\n<| c |>\nI like your solution. Thanks for\
    \ sharing it.\n<|/ c |>\n<| c |>\nThis doesn't work if the substring has repeated\
    \ characters.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work for `how_many_times(\"aaa\", \"aa\")` which returns `3`\
    \ instead of `2`.\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;",
  "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    \n    for(long\
    \ i = 0; i < string.length(); i++) {\n        end = string.find(substring, start);\n\
    \        if(end == string.length()) {\n            count++;\n            start\
    \ = i + 1;\n        }\n        else {\n            count++;\n            start\
    \ = end;\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n    long count\
    \ = 0;\n    long end = 0;\n    \n    for(long i = 0; i < string.length(); i++)\
    \ {\n        end = string.find(substring, start);\n        if(end == string.length())\
    \ {\n            count++;\n            start = i + 1;\n        }\n        else\
    \ {\n            count++;\n            start = end;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(long i = start;\
    \ i < end; i++) {\n        end = string.find(substring, i);\n        if(end ==\
    \ string.length()) {\n            count++;\n            start = i + 1;\n     \
    \   }\n        else {\n            count++;\n            start = end;\n      \
    \  }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long offset) \n{\n    long count = 0;\n    \n    for(long\
    \ i = start; i < end; i++) {\n        end = string.find(substring, i);\n     \
    \   if(end == string.length()) {\n            count++;\n            start = i\
    \ + 1;\n        }\n        else {\n            count++;", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if you have a string like \"aba\" and a substring like\
    \ \"ab\"\n<|/ c |>\n<| c |>\nI added a version that works with overlapping cases.\
    \ Thanks for the heads up.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a\
    \ string like \"aba\" and a substring like \"ab\"\n<|/ c |>\n<| c |>\nI added\
    \ a version that works with overlapping cases. Thanks for the heads up.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if you have a string like \"aba\" and a substring\
    \ like \"ab\"\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count\
    \ = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen\
    \ = substring.length();\n    \n    while (pos < len) {\n        size_t subpos\
    \ = 0;\n        while (subpos < sublen) {\n            if (string[pos] == substring[subpos])\
    \ {\n                subpos++;\n            }\n            else {\n          \
    \      break;\n            }\n        }\n        \n        if (subpos == sublen)\
    \ {\n            count++;\n            pos += sublen;\n        }\n        else\
    \ {\n            pos += subpos;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_insensitive) \n{\n    long count = 0;\n    size_t pos = 0;\n    size_t\
    \ len = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        size_t subpos = 0;\n        while (subpos < sublen) {\n\
    \            if (case_insensitive ? string[pos] == substring[subpos] : tolower(string[pos])\
    \ == tolower(substring[subpos])) {\n                subpos++;\n            }\n\
    \            else {\n                break;\n            }\n        }\n      \
    \  \n        if (subpos == sublen) {\n            count++;\n            pos +=\
    \ sublen;\n        }\n        else {\n            pos += subpos;\n        }\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_insensitive, bool ignore_case) \n{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        size_t subpos = 0;\n        while (subpos\
    \ < sublen) {\n            if (ignore_case ? string[pos] == substring[subpos]\
    \ : tolower(string[pos]) == tolower(substring[subpos])) {\n                subpos++;\n\
    \            }\n            else {", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring) == 0) {\n\
    \            count++;\n        }\n    }\n    return count;\n}", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0)\n    0L\n \
    \   >>> how_many_times(\"aaa\", \"a\", 0)\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\", 0)\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2)\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0, 2)\n    3L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, int start, int end, int step) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2,\
    \ 1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0, 2, 1)\n    3L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\", 0, 2, 1)\n    3L", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. `how_many_times(\"aaaa\", \"aa\")` returns `3L` instead of `2L`.\n\
    <|/ c |>\n<| c |>\nYeah, I missed that case. Thanks for pointing it out. I've\
    \ updated the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int howManyTimes(String\
    \ s, String sub) {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++)\
    \ {\n        if(s.substring(i, i + sub.length()).equals(sub)) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,java |>\n\
    <| a dscore=0 |>\n<code>\npublic int howManyTimes(String s, String sub) {\n  \
    \  int count = 0;\n    for(int i = 0; i < s.length(); i++) {\n        if(s.substring(i,\
    \ i + sub.length()).equals(sub)) {\n            count++;\n        }\n    }\n \
    \   return count;\n}\n</code>\n<|/ a tags=string,java |>\n<| a dscore=0 |>\n<code>\n\
    public int howManyTimes(String s, String sub) {\n    int count = 0;\n    for(int\
    \ i = 0; i < s.length(); i++) {\n        if(s.substring(i, i + sub.length()).equals(sub))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/\
    \ a tags=string,java |>\n<| a dscore=0 |>\n<code>\npublic int howManyTimes(String\
    \ s, String sub) {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++)\
    \ {\n        if(s.substring(i, i + sub.length()).equals(sub)) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,java |>\n\
    <| a tags=string,java |>\n<code>\npublic int howManyTimes(String s, String sub)\
    \ {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++) {\n        if(s.substring(i,\
    \ i + sub.length()).equals(sub)) {\n            count++;\n        }\n    }\n \
    \   return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic\
    \ int howManyTimes(String s, String sub) {\n    int count = 0;\n    for(int i\
    \ = 0; i < s.length(); i++) {\n        if(s.substring(i, i + sub.length()).equals(sub))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n</code>", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\"\
    , \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"aaaa\"\
    , \"aa\")`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n\tlong count = 0;\n\tfor (int i = 0; i\
    \ < string.length(); i++)\n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\
    \t\tfor (int j = 1; j < substring.length(); j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n   \
    \ long len = string.length();\n    long sublen = substring.length();\n    \n \
    \   for(long i = 0; i < len; i++)\n    {\n        for(long j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif\
    \ (string.charAt(i) == substring.charAt(j))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code\
    \ doesn't work if you have a string with multiple occurrences of the substring.\n\
    <|/ c |>\n<| c |>\nIt works fine for me. Try it out and let me know if it doesn't\
    \ work for you.\n<|/ c |>\n<| c |>\nIt doesn't work for me because I tested it\
    \ on \"aaaaaaa\" and \"aaa\". Your code returns \"3\" instead of \"2\".\n<|/ c\
    \ |>\n<| c |>\nI tested it on \"aaaaaaa\" and \"aaa\" as well. It returns \"3\"\
    \ as expected.\n<|/ c |>\n<| c |>\nI tested it on \"aaaaaaa\" and \"aaa\" as well.\
    \ It returns \"3\" as expected. Are you sure you tested it correctly?\n<|/ c |>\n\
    <| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()).equals(substring))\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis solution doesn't work for overlapping substrings. For example,\
    \ `how_many_times(\"ab\", \"ab\")` returns `1`, but should be `2`.\n<|/ c |>\n\
    <| c |>\n: Yes, I noticed that and fixed it. Thanks!\n<|/ c |>\n<| c |>\nI fixed\
    \ it by adding an additional loop to check whether the substring was found multiple\
    \ times in the original string. Thanks for your help!\n<|/ c |>\n<| c |>\n: Glad\
    \ I could help. I added a second solution that should work for overlapping substrings.\n\
    <|/ c |>\n<| a tags=string,algorithm,c++ |>\nHere's a solution that uses std::count_if:\n\
    <code>\n#include <algorithm>\n#include <iostream>\n#include <string>", "{\n  \
    \  long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n    \
    \    if(string.compare(i, substring.length(), substring) == 0)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that appears more than\
    \ once.\n<|/ c |>\n<| c |>\nI added a version that works with repeated substrings.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a substring that appears more\
    \ than once.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a substring that\
    \ appears more than once.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n    long count\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.substr(i, substring.length()) == substring) {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if the substring occurs more than once.\n<|/\
    \ c |>\n<| c |>\nYes, you are right. I didn't think about that case. I'll edit\
    \ my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string[i] == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\nThis doesn't\
    \ work if `substring` is longer than `string`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work\
    \ if `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work if `substring`\
    \ is longer than `string`\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.substr(i, substring.length()) == substring)\n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        for(int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    \n    while(end < string.length)\n\
    \    {\n        len = string.find(substring, end);\n        if(len == -1)\n  \
    \      {\n            break;\n        }\n        \n        end = len + substring.length();\n\
    \        count++;\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n</code>\n<|/\
    \ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if substring is a\
    \ substring of string. For example, how_many_times(\"ab\", \"ab\") returns 2,\
    \ but how_many_times(\"ab\", \"ba\") returns 1.\n<|/ c |>\n<| c |>\n: Yes, you're\
    \ right. I missed that case. I've updated my answer.\n<|/ c |>\n<| c |>\n: Thanks\
    \ for pointing that out. I've updated my answer accordingly.\n<|/ c |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\n\
    This doesn't work if you have a substring that is a prefix of another substring.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. I tested it on `how_many_times(\"aaaa\", \"\
    aa\")` and it returned `3`.\n<|/ c |>\n<| c |>\n: Yes, it does. I tested it on\
    \ `how_many_times(\"aaaa\", \"aa\")` and it returned `3`.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. I tested it on `how_many_times(\"aaaa\", \"aa\")` and it returned\
    \ `3`.\n<|/ c |>\n<| c |>\n: Yes, it does. I tested it on `how_many_times(\"aaaa\"\
    , \"aa\")` and it returned `3`.\n<|/ c |>\n<| a tags=c++,string,algorithm |>\n\
    <code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,c++,search |>\n<| c |>\nThis code doesn't work for\
    \ \"aaaaa\" substring. Correct answer is 3, not 4.\n<|/ c |>\n<| c |>\nThis code\
    \ doesn't work for \"aaaaa\" substring. Correct answer is 3, not 4.\n<|/ c |>\n\
    <| c |>\nThis code doesn't work for \"aaaaa\" substring. Correct answer is 3,\
    \ not 4.\n<|/ c |>\n<| c |>\nThis code doesn't work for \"aaaaa\" substring. Correct\
    \ answer is 3, not 4.\n<|/ c |>\n<| a dscore=4 |>\nThe algorithm is simple:",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = string.find(substring, start);\n    \
    \    if(end == string.length()) break;\n        \n        if(end > start) {\n\
    \            count += end - start;\n        }\n        start = end + sublen;\n\
    \    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    long\
    \ start = 0;\n    long end = 0;\n    long len = 0;\n    long i = 0;\n    \n  \
    \  while(i < string.length())\n    {\n        len = string.length() - i;\n   \
    \     end = start + len;\n        \n        if(string.find(substring, start) ==\
    \ start)\n        {\n            count++;\n            start = end;\n        }\n\
    \        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    long\
    \ i = 0;\n    \n    while(i < string.length())\n    {\n        len = string.length()\
    \ - i;\n        end = start + len;\n        \n        if(string.find(substring,\
    \ start) == start)\n        {\n            count++;\n            start = end;\n\
    \        }\n        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long len =\
    \ 0;\n    long i = 0;\n    \n    while(i < string.length())\n    {\n        len\
    \ = string.length() - i;\n        end = start + len;\n        \n        if(string.find(substring,\
    \ start) == start)\n        {\n            count++;\n            start = end;\n\
    \        }\n        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_man", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    long pos = 0;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long pos = start;\n    while(pos < string.length())\n    {\n\
    \        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    long pos = start;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n    long count = 0;\n    long pos = start;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(sub", "{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    0L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0)\n    0L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    1L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0, 2)\n    1L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        for(int j = 0;\
    \ j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"aaa\"\
    , \"a\", 0, 2, 1)\n    1L\n    >>> how_many_times(\"aaaa\", \"aa\", 0, 2, 1)\n\
    \    1L\n    \n*/\nlong how_many_times(string string, string substring, long start,\
    \ long end, long step, long step2) \n{\n    long count = 0;", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}",
  "{\n    long count = 0;\n    \n    foreach(char c in substring) \n    {\n      \
    \  foreach(char c2 in string) \n        {\n            if (c == c2) \n       \
    \     {\n                count++;\n            }\n        }\n    }\n    \n   \
    \ return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n            count++;\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is not the most efficient solution. `string.compare` will\
    \ have to compare the entire string for each character in the substring. `string.find`\
    \ will stop at the first character that matches.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I wanted to show OP how to do it in his own way. He can easily modify\
    \ it to his needs.\n<|/ c |>\n<| c |>\nI agree with you, but I wanted to show\
    \ OP how to do it in his own way. He can easily modify it to his needs.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but I wanted to show OP how to do it in his own\
    \ way. He can easily modify it to his needs.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I wanted to show OP how to do it in his own way. He can easily modify\
    \ it to his needs.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++) {\n        for(int j = 0;\
    \ j < substring.length(); j++) {\n            if(string[i] == substring[j]) {\n\
    \                count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    \
    \    if(string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n        if(string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0)\n        {\n            count++;\n        }\n        if(string.compare(i,\
    \ substring3.length(), substring3, 0, substring3.length()) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3, string substring4) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            ", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring) == 0)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring) == 0)\n         \
    \   count++;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    ", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long length = string.length();\n\
    \    long substringLength = substring.length();\n    \n    for(long i = 0; i <\
    \ length; i++)\n    {\n        end = string.find(substring, start);\n        if(end\
    \ != string.length())\n        {\n            count += end - start;\n        \
    \    start = end + substringLength;\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long\
    \ len = string.length();\n    long sublen = substring.length();\n    \n    while(start\
    \ < len) {\n        end = start + sublen;\n        while(end < len && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end++;\n        }\n        if(end ==\
    \ len) {\n            count++;\n            start = end;\n        }\n        else\
    \ {\n            while(end < len && string.charAt(end) != substring.charAt(0))\
    \ {\n                end++;\n            }\n            count++;\n           \
    \ start = end;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start) \n{\n    long\
    \ count = 0;\n    long end = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    while(start < len) {\n        end = start +\
    \ sublen;\n        while(end < len && string.charAt(end) == substring.charAt(0))\
    \ {\n            end++;\n        }\n        if(end == len) {\n            count++;\n\
    \            start = end;\n        }\n        else {\n            while(end <\
    \ len && string.charAt(end) != substring.charAt(0)) {\n                end++;\n\
    \            }\n            count++;\n            start = end;\n        }\n  \
    \  }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    while(start < len) {\n     \
    \   end = start + sublen;\n        while(end < len && string.charAt(end) == substring.charAt(0))\
    \ {\n            end++;\n        }\n        if(end == len) {\n            count++;\n\
    \            start = end;\n        }\n        else {\n            while(end <\
    \ len && string.charAt(end) != substring.charAt(0)) {\n                end++;\n\
    \            }\n            count++;", "{\n\tlong count = 0;\n\tfor (int i = 0;\
    \ i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) ==\
    \ substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I wonder if it would be faster than the\
    \ one I posted (which I believe is O(n))\n<|/ c |>\n<| c |>\nI believe your solution\
    \ is O(n), but your solution is O(n^2). Your solution is O(n) because you only\
    \ need to compare the beginning of the string with the substring. Your solution\
    \ is O(n^2) because you compare each character in the string with each character\
    \ in the substring. Your solution is O(n) because you only need to compare the\
    \ beginning of the string with the substring. Your solution is O(n^2) because\
    \ you compare each character in the string with each character in the substring.\
    \ Your solution is O(n) because you only need to compare the beginning of the\
    \ string with the substring. Your solution is O(n^2) because you compare each\
    \ character in the string with each character in the substring.\n<|/ c |>\n<|\
    \ c |>\nI believe your solution is O(n) because you only need to compare the beginning\
    \ of the string with the substring. Your solution is O(n) because you compare\
    \ each character in the string with each character in the substring. Your solution\
    \ is O(n) because you only need to compare the beginning of the string with the\
    \ substring. Your solution is O(n) because you compare each character in the string\
    \ with each character in the substring. Your solution is O(n) because you only\
    \ need to compare the beginning of the string with the substring. Your solution\
    \ is O(n) because you compare each character in the string with each character\
    \ in the substring.\n<|/ c |>\n<| c |>\nI believe your solution is O(n) because\
    \ you only need to compare the beginning of the string with the substring. Your\
    \ solution is O(n) because you compare each character in the string with each\
    \ character in the substring. Your solution is O(n) because you only need to compare\
    \ the beginning of the string with the substring. Your solution is O(n) because\
    \ you compare each character in the string with each character in the substring.\
    \ Your solution is O(n) because you only need to compare the beginning of the\
    \ string with the substring. Your solution is O(n) because you compare each character\
    \ in the string with each character in the substring. Your solution is O(n) because\
    \ you only need to compare the beginning of the string with the substring. Your\
    \ solution is O(n) because you compare each character in the string with each\
    \ character in the ", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n \
    \   \n    foreach(char c in substring) \n    {\n        foreach(char c2 in string)\
    \ \n        {\n            if(c == c2) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    ", "{\n    long count = 0;\n    \n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(int i = start;\
    \ i < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    \n    for(int\
    \ i = start; i < end; i += step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    ", "{\n    long\
    \ count = 0;\n    size_t pos = 0;\n    size_t length = string.length();\n    size_t\
    \ substringLength = substring.length();\n    \n    while (pos < length) {\n  \
    \      if (string.compare(pos, substringLength, substring) == 0) {\n         \
    \   count++;\n        }\n        pos += substringLength;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t length\
    \ = string.length();\n    size_t substringLength = substring.length();\n    \n\
    \    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    size_t pos = start;\n  \
    \  size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    size_t pos =\
    \ start;\n    size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = start + sublen;\n        while(end <\
    \ len && string.charAt(end) != substring.charAt(start)) {\n            end++;\n\
    \        }\n        if(end == len) {\n            count++;\n        }\n      \
    \  start = end + 1;\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nI like this solution, but I wonder how it compares to other solutions\
    \ posted so far.\n<|/ c |>\n<| c |>\nI like it too. Just one question, why do\
    \ you use \"string\" instead of \"String\"?\n<|/ c |>\n<| c |>\n: I used `string`\
    \ because I didn't want to have to `#include <string>` at the top of my file.\
    \ I didn't want to have to `using namespace std;` at the top of my file. I didn't\
    \ want to have to `#include <string.h>` at the top of my file. I didn't want to\
    \ have to `#include <algorithm>` at the top of my file. I didn't want to have\
    \ to `#include <cstring>` at the top of my file. I didn't want to have to `#include\
    \ <cmath>` at the top of my file. I didn't want to have to `#include <cstdlib>`\
    \ at the top of my file. I didn't want to have to `#include <cstddef>` at the\
    \ top of my file. I didn't want to have to `#include <cstdint>` at the top of\
    \ my file. I didn't want to have to `#include <cstdio>` at the top of my file.\
    \ I didn't want to have to `#include <cstdlib>` at the top of my file. I didn't\
    \ want to have to `#include <cstddef>` at the top of my file. I didn't want to\
    \ have to `#include <cstdint>` at the top of my file. I didn't want to have to\
    \ `#include <cstdio>` at the top of my file. I didn't want to have to `#include\
    \ <cstdlib>` at the top of my file. I didn't want to have to `#include <cstddef>`\
    \ at the top of my file. I didn't want to have to `#include <cstdint>` at the\
    \ top of my file. I didn't want to have to `#include <cstdio>` at the top of my\
    \ file.\n<|/ c |>\n<| c |>\n: I didn't want to have to `#include <cstring>` at\
    \ the top of my file. I didn't want to have to `#include <cmath>` at the top of\
    \ my file. I didn't want to have to `#include <cstdlib>` at the top of my file.\
    \ I didn't want to have to `#include <cstddef>` at the top of my file. I didn't\
    \ want to have to `#include <cstdint>` ", "{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length())\
    \ == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that starts or ends with\
    \ the substring you're looking for. For example, how_many_times(\"ab\", \"ab\"\
    ) returns 2, when it should return 1.\n<|/ c |>\n<| c |>\nI believe that is a\
    \ valid case. For example, how_many_times(\"ab\", \"ab\") returns 2, when it should\
    \ return 1.\n<|/ c |>\n<| c |>\nYes, but \"ab\" is a substring of \"ab\" so how_many_times(\"\
    ab\", \"ab\") should return 1. But it returns 2.\n<|/ c |>\n<| c |>\nYes, I see\
    \ what you mean. I'll fix my answer.\n<|/ c |>\n<| c |>\nI fixed my answer, thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string.compare(i, substring.length(), substring) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n     \
    \       count += 1;\n            \n            for(int j = 1; j < sublen; j++)\n\
    \            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = start; i < len; i++)\n    {\n        if(string.charAt(i)\
    \ == substring.charAt(0))\n        {\n            count += 1;\n            \n\
    \            for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n\
    \            count += 1;\n            \n            for(int j = 1; j < sublen;\
    \ j++)\n            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> ho", "{\n    long count = 0;\n    \n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    long\
    \ len = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n       \
    \ {\n            for(int j = 0; j < sublen; j++)\n            {\n            \
    \    if(string[i + j] != substring[j])\n                    break;\n         \
    \   }\n            \n            if(j == sublen)\n                count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the substring occurs more than once in the original\
    \ string.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting.\n<|/ c\
    \ |>\n<| c |>\nI tested it before posting? I tested it before posting? I tested\
    \ it before posting? I tested it before posting? I tested it before posting? I\
    \ tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    \n    len\
    \ = string.length();\n    end = len-1;\n    \n    while(start < end)\n    {\n\
    \        while(string.find(substring, start) != string::npos)\n        {\n   \
    \         start = string.find(substring, start);\n            count++;\n     \
    \   }\n        \n        start++;\n    }\n    \n    return count;\n}", "{\n\t\
    long count = 0;\n\tfor (auto it = string.begin(); it != string.end(); ++it) {\n\
    \t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start = 0) \n{\n\tlong count = 0;\n\tfor (auto it = string.begin(); it\
    \ != string.end(); ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring, start + 1);\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, string start) \n{\n\tlong count = 0;\n\tfor (auto\
    \ it = string.begin(); it != string.end(); ++it) {\n\t\tif (*it == substring[0])\
    \ {\n\t\t\tcount += how_many_times(string.substr(1, string.size() - 1), substring,\
    \ start);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string start, long end)\
    \ \n{\n\tlong count = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring, start, end);\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive) \n{\n"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
