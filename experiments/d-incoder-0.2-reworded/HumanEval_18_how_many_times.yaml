name: HumanEval_18_how_many_times
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n\
    \        if(string.at(i) == substring.at(0))\n        {\n            count++;\n\
    \        }\n        else if(string.at(i) == substring.at(1))\n        {\n    \
    \        count += 2;\n        }\n        else if(string.at(i) == substring.at(2))\n\
    \        {\n            count += 3;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool ignore_case) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(ignore_case)\n        {\n            if(string.at(i) == substring.at(0))\n\
    \            {\n                count++;\n            }\n            else if(string.at(i)\
    \ == substring.at(1))\n            {\n                count += 2;\n          \
    \  }\n            else if(string.at(i) == substring.at(2))\n            {\n  \
    \              count += 3;\n            }\n        }\n        else\n        {\n\
    \            if(string.at(i) == substring.at(0))\n            {\n            \
    \    count++;\n            }\n            else if(string.at(i) == substring.at(1))\n\
    \            {\n                count += 2;\n            }\n            else if(string.at(i)\
    \ == substring.at(2))\n            {\n                count += 3;\n          \
    \  }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, bool ignore_case, bool ignore_whitespace)\
    \ \n{\n    long count = 0;\n    long len = string.length();\n    long sublen =\
    \ substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n       \
    \ if(ignore_whitespace)\n        {\n            if(string.at(i) == substring.at(0))\n\
    \            {\n                count++;\n            }\n            else if(string.at(i)\
    \ == substring.at(1))\n            {\n                count += ", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n\
    \        if(string.substr(i, sublen) == substring)\n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\", \"aa\"\
    )`.\n<|/ c |>\n<| c |>\nIt works. I tested it before posting. I will edit my post\
    \ to include a test case.\n<|/ c |>\n<| c |>\nOh, I see what you mean. Yes, it\
    \ does work. Sorry about that. I was thinking about it backwards. I edited my\
    \ post to fix it.\n<|/ c |>\n<| c |>\nI edited my post to fix the bug that I pointed\
    \ out in the comments. I tested it and it works now.\n<|/ c |>\n<| c |>\nI edited\
    \ my post to fix the bug that I pointed out in the comments. I tested it and it\
    \ works now.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\nThis can be done in\
    \ O(n) time complexity by using a hash table. \n<code>\n#include <iostream>\n\
    #include <string>\n#include <unordered_map>\nusing namespace std;", "{\n    long\
    \ count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n    size_t\
    \ sublen = substring.length();\n    \n    while (pos < len) {\n        size_t\
    \ subpos = 0;\n        \n        while (subpos < sublen) {\n            if (string[pos]\
    \ == substring[subpos]) {\n                subpos++;\n            } else {\n \
    \               break;\n            }\n        }\n        \n        if (subpos\
    \ == sublen) {\n            count++;\n            pos += sublen;\n        } else\
    \ {\n            pos += sublen;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t len\
    \ = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        size_t subpos = 0;\n        \n        while (subpos <\
    \ sublen) {\n            if (string[pos] == substring[subpos]) {\n           \
    \     subpos++;\n            } else {\n                break;\n            }\n\
    \        }\n        \n        if (subpos == sublen) {\n            count++;\n\
    \            pos += sublen;\n        } else {\n            pos += sublen;\n  \
    \      }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start, long end) \n{\n\
    \    long count = 0;\n    size_t pos = start;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    size_t subpos = 0;\n        \n        while (subpos < sublen) {\n       \
    \     if (string[pos] == substring[subpos]) {\n                subpos++;\n   \
    \         } else {\n                break;\n            }\n        }\n       \
    \ \n        if (subpos == sublen) {\n            count++;\n            pos +=\
    \ sublen;\n        } else {\n            pos += sublen;\n        }\n    }\n  \
    \  \n    return count;\n}\n/*", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nI believe this\
    \ solution will fail for `how_many_times(\"aaaa\", \"aa\")` because it will return\
    \ `2` instead of `3`.\n<|/ c |>\n<| c |>\nYes, you are right. I missed that case.\
    \ Thanks for pointing out. Fixed now.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n            pos += sublen;\n        }\n     \
    \   else {\n            pos = string.find(substring, pos);\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n            count++;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}", "{\n    long\
    \ count = 0;\n    long start = 0;\n    long end = 0;\n    long length = string.length();\n\
    \    \n    while(start < length) \n    {\n        end = string.find(substring,\
    \ start);\n        if(end == string.length()) \n        {\n            count++;\n\
    \            start = end + 1;\n        }\n        else \n        {\n         \
    \   count++;\n            start = end + 1;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string.compare(i, substring.length(), substring) == 0) {\n       \
    \     count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that is a prefix of the\
    \ original string. For example, if `string = \"abba\"` and `substring = \"a\"\
    `, then `how_many_times(string, substring)` will return `2`, when it should be\
    \ `1`.\n<|/ c |>\n<| c |>\n: I didn't notice that case. Thanks for pointing it\
    \ out. I've updated my answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i += step) {\n        for(int j = 0; j < substring.length(); j++) {\n\
    \            if(string[i] == substring[j]) {\n                count++;\n     \
    \       }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    ", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\
    \t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start, int end) \n{\n\t\
    long count = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step, string case_sensitive) \n{\n", "{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++,string-matching\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ string.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. Try it\
    \ yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if you try it on \"aaa\" and \"\
    aa\"\n<|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns 3 for \"aaa\"\
    \ and \"aa\".\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. Try\
    \ it yourself.\n<|/ c |>\n<| a dscore=5 |>\nThe best way is to use Knuth-Morris-Pratt\
    \ algorithm. \n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<|\
    \ c |>\nThe question was about C++, not C#.\n<|/ c |>\n<| c |>\nThe question was\
    \ about C++, not C#.\n<|/ c |>\n<| c |>\nThe question was about C++, not C#.\n\
    <|/ c |>\n<| c |>\nThe question was about C++, not C#.\n<|/ c |>\n<| c |>\nThe\
    \ question was about C++, not C#.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n \
    \   long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) ==\
    \ substring.charAt(0))\n        {\n            count++;\n            \n      \
    \      for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \               }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = start; i < len; i++)\n \
    \   {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n      \
    \      count++;\n            \n            for(int j = 1; j < sublen; j++)\n \
    \           {\n                if(string.charAt(i) == substring.charAt(j))\n \
    \               {\n                    count++;\n                }\n         \
    \   }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = start; i < end; i++)\n    {\n        if(string.charAt(i)\
    \ == substring.charAt(0))\n        {\n            count++;\n            \n   \
    \         for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count++;\n \
    \               }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int\
    \ j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if\
    \ the substring appears more than once in the string. For example, how_many_times(\"\
    aaaa\", \"aa\") returns 3 instead of 2.\n<|/ c |>\n<| c |>\nYes, I forgot to add\
    \ that case. Thanks for pointing it out. I've edited my answer.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    long len = 0;\n    \n    for(long i = 0; i < string.length();\
    \ i++)\n    {\n        end = string.find(substring, i);\n        if(end == string.length())\n\
    \        {\n            count++;\n            i = string.length();\n        }\n\
    \        else\n        {\n            len = end - i;\n            if(len > 0)\n\
    \            {\n                count += len;\n                start = i;\n  \
    \          }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n\
    \        {\n            count++;\n            \n            for(int j = 1; j <\
    \ sublen; j++)\n            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count++;\n                }\n        \
    \    }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive) \n{\n\
    \    long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(case_sensitive)\n \
    \       {\n            if(string.charAt(i) == substring.charAt(0))\n         \
    \   {\n                count++;\n                \n                for(int j =\
    \ 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == substring.charAt(j))\n                    {\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n        else\n\
    \        {\n            if(string.charAt(i) == substring.charAt(0))\n        \
    \    {\n                count++;\n                \n                for(int j\
    \ = 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == substring.charAt(j))\n                    {\n                        count++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool case_sensitive_ignorecase) \n{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(case_sensitive_ignorecase)\n\
    \        {\n            if(string.charAt(i) == substring.charAt(0))\n        \
    \    {\n                count++;\n                \n                for(int j\
    \ = 1; j < sublen; j++)\n                {\n                    if(string.charAt(i)\
    \ == ", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,algorithm,c++ |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\
    using namespace std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis is not the best solution. `string.compare(i, substring.length(),\
    \ substring, 0, substring.length())` will do an extra comparison for each character\
    \ in the substring and will also do an extra comparison for each character in\
    \ the original string. `string.find(substring, i) != string::npos` will do an\
    \ extra comparison for each character in the substring and will also do an extra\
    \ comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character in the substring and will also do an extra comparison for each\
    \ character in the original string. `string.find(substring, i) != string::npos`\
    \ will do an extra comparison for each character in the substring and will also\
    \ do an extra comparison for each character in the original string. `string.find(substring,\
    \ i) != string::npos` will do an extra comparison for each character in the substring\
    \ and will also do an extra comparison for each character in the original string.\
    \ `string.find(substring, i) != string::npos` will do an extra comparison for\
    \ each character ", "{\n    long count = 0;\n    long start = 0;\n    long end\
    \ = 0;\n    long len = 0;\n    \n    while(end < string.length)\n    {\n     \
    \   len = string.length() - end;\n        if(string.compare(end, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \           end = string.length();\n        }\n        else\n        {\n     \
    \       end = end + 1;\n        }\n    }\n    return count;\n}", "{\n    long\
    \ count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n    \
    \    if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(int i = 0; i < len; i++)\n    {\n     \
    \   if(string[i] == substring[0])\n        {\n            for(int j = 1; j < sublen;\
    \ j++)\n            {\n                if(string[i + j] != substring[j])\n   \
    \             {\n                    break;\n                }\n            }\n\
    \            count += j - 1;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,c++ |>\n<| c |>\nI like your solution. Thanks for\
    \ sharing it.\n<|/ c |>\n<| c |>\nThis doesn't work if the substring has repeated\
    \ characters.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it.\n<|/ c |>\n<|\
    \ c |>\nIt doesn't work for `how_many_times(\"aaa\", \"aa\")` which returns `3`\
    \ instead of `2`.\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;",
  "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    \n    for(long\
    \ i = 0; i < string.length(); i++) {\n        end = string.find(substring, start);\n\
    \        if(end == string.length()) {\n            count++;\n            start\
    \ = i + 1;\n        }\n        else {\n            count++;\n            start\
    \ = end;\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, long start) \n{\n    long count\
    \ = 0;\n    long end = 0;\n    \n    for(long i = 0; i < string.length(); i++)\
    \ {\n        end = string.find(substring, start);\n        if(end == string.length())\
    \ {\n            count++;\n            start = i + 1;\n        }\n        else\
    \ {\n            count++;\n            start = end;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(long i = start;\
    \ i < end; i++) {\n        end = string.find(substring, i);\n        if(end ==\
    \ string.length()) {\n            count++;\n            start = i + 1;\n     \
    \   }\n        else {\n            count++;\n            start = end;\n      \
    \  }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long offset) \n{\n    long count = 0;\n    \n    for(long\
    \ i = start; i < end; i++) {\n        end = string.find(substring, i);\n     \
    \   if(end == string.length()) {\n            count++;\n            start = i\
    \ + 1;\n        }\n        else {\n            count++;", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if you have a string like \"aba\" and a substring like\
    \ \"ab\"\n<|/ c |>\n<| c |>\nI added a version that works with overlapping cases.\
    \ Thanks for the heads up.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a\
    \ string like \"aba\" and a substring like \"ab\"\n<|/ c |>\n<| c |>\nI added\
    \ a version that works with overlapping cases. Thanks for the heads up.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if you have a string like \"aba\" and a substring\
    \ like \"ab\"\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count\
    \ = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen\
    \ = substring.length();\n    \n    while (pos < len) {\n        size_t subpos\
    \ = 0;\n        while (subpos < sublen) {\n            if (string[pos] == substring[subpos])\
    \ {\n                subpos++;\n            }\n            else {\n          \
    \      break;\n            }\n        }\n        \n        if (subpos == sublen)\
    \ {\n            count++;\n            pos += sublen;\n        }\n        else\
    \ {\n            pos += subpos;\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_insensitive) \n{\n    long count = 0;\n    size_t pos = 0;\n    size_t\
    \ len = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        size_t subpos = 0;\n        while (subpos < sublen) {\n\
    \            if (case_insensitive ? string[pos] == substring[subpos] : tolower(string[pos])\
    \ == tolower(substring[subpos])) {\n                subpos++;\n            }\n\
    \            else {\n                break;\n            }\n        }\n      \
    \  \n        if (subpos == sublen) {\n            count++;\n            pos +=\
    \ sublen;\n        }\n        else {\n            pos += subpos;\n        }\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_insensitive, bool ignore_case) \n{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        size_t subpos = 0;\n        while (subpos\
    \ < sublen) {\n            if (ignore_case ? string[pos] == substring[subpos]\
    \ : tolower(string[pos]) == tolower(substring[subpos])) {\n                subpos++;\n\
    \            }\n            else {", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring) == 0) {\n\
    \            count++;\n        }\n    }\n    return count;\n}", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0)\n    0L\n \
    \   >>> how_many_times(\"aaa\", \"a\", 0)\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\", 0)\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2)\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0, 2)\n    3L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, int start, int end, int step) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2,\
    \ 1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0, 2, 1)\n    3L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\", 0, 2, 1)\n    3L", "{\n    long count = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. `how_many_times(\"aaaa\", \"aa\")` returns `3L` instead of `2L`.\n\
    <|/ c |>\n<| c |>\nYeah, I missed that case. Thanks for pointing it out. I've\
    \ updated the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int howManyTimes(String\
    \ s, String sub) {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++)\
    \ {\n        if(s.substring(i, i + sub.length()).equals(sub)) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,java |>\n\
    <| a dscore=0 |>\n<code>\npublic int howManyTimes(String s, String sub) {\n  \
    \  int count = 0;\n    for(int i = 0; i < s.length(); i++) {\n        if(s.substring(i,\
    \ i + sub.length()).equals(sub)) {\n            count++;\n        }\n    }\n \
    \   return count;\n}\n</code>\n<|/ a tags=string,java |>\n<| a dscore=0 |>\n<code>\n\
    public int howManyTimes(String s, String sub) {\n    int count = 0;\n    for(int\
    \ i = 0; i < s.length(); i++) {\n        if(s.substring(i, i + sub.length()).equals(sub))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/\
    \ a tags=string,java |>\n<| a dscore=0 |>\n<code>\npublic int howManyTimes(String\
    \ s, String sub) {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++)\
    \ {\n        if(s.substring(i, i + sub.length()).equals(sub)) {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,java |>\n\
    <| a tags=string,java |>\n<code>\npublic int howManyTimes(String s, String sub)\
    \ {\n    int count = 0;\n    for(int i = 0; i < s.length(); i++) {\n        if(s.substring(i,\
    \ i + sub.length()).equals(sub)) {\n            count++;\n        }\n    }\n \
    \   return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic\
    \ int howManyTimes(String s, String sub) {\n    int count = 0;\n    for(int i\
    \ = 0; i < s.length(); i++) {\n        if(s.substring(i, i + sub.length()).equals(sub))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n</code>", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `how_many_times(\"aaaa\"\
    , \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"aaaa\"\
    , \"aa\")`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `how_many_times(\"\
    aaaa\", \"aa\")`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n\tlong count = 0;\n\tfor (int i = 0; i\
    \ < string.length(); i++)\n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\
    \t\tfor (int j = 1; j < substring.length(); j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n   \
    \ long len = string.length();\n    long sublen = substring.length();\n    \n \
    \   for(long i = 0; i < len; i++)\n    {\n        for(long j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif\
    \ (string.charAt(i) == substring.charAt(j))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code\
    \ doesn't work if you have a string with multiple occurrences of the substring.\n\
    <|/ c |>\n<| c |>\nIt works fine for me. Try it out and let me know if it doesn't\
    \ work for you.\n<|/ c |>\n<| c |>\nIt doesn't work for me because I tested it\
    \ on \"aaaaaaa\" and \"aaa\". Your code returns \"3\" instead of \"2\".\n<|/ c\
    \ |>\n<| c |>\nI tested it on \"aaaaaaa\" and \"aaa\" as well. It returns \"3\"\
    \ as expected.\n<|/ c |>\n<| c |>\nI tested it on \"aaaaaaa\" and \"aaa\" as well.\
    \ It returns \"3\" as expected. Are you sure you tested it correctly?\n<|/ c |>\n\
    <| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()).equals(substring))\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis solution doesn't work for overlapping substrings. For example,\
    \ `how_many_times(\"ab\", \"ab\")` returns `1`, but should be `2`.\n<|/ c |>\n\
    <| c |>\n: Yes, I noticed that and fixed it. Thanks!\n<|/ c |>\n<| c |>\nI fixed\
    \ it by adding an additional loop to check whether the substring was found multiple\
    \ times in the original string. Thanks for your help!\n<|/ c |>\n<| c |>\n: Glad\
    \ I could help. I added a second solution that should work for overlapping substrings.\n\
    <|/ c |>\n<| a tags=string,algorithm,c++ |>\nHere's a solution that uses std::count_if:\n\
    <code>\n#include <algorithm>\n#include <iostream>\n#include <string>", "{\n  \
    \  long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n    \
    \    if(string.compare(i, substring.length(), substring) == 0)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that appears more than\
    \ once.\n<|/ c |>\n<| c |>\nI added a version that works with repeated substrings.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have a substring that appears more\
    \ than once.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a substring that\
    \ appears more than once.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n    long count\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.substr(i, substring.length()) == substring) {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if the substring occurs more than once.\n<|/\
    \ c |>\n<| c |>\nYes, you are right. I didn't think about that case. I'll edit\
    \ my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string[i] == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\nThis doesn't\
    \ work if `substring` is longer than `string`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work\
    \ if `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work if\
    \ `substring` is longer than `string`\n<|/ c |>\n<| c |>\nIt doesn't work if `substring`\
    \ is longer than `string`\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.substr(i, substring.length()) == substring)\n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        for(int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}", "{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    \n    while(end < string.length)\n\
    \    {\n        len = string.find(substring, end);\n        if(len == -1)\n  \
    \      {\n            break;\n        }\n        \n        end = len + substring.length();\n\
    \        count++;\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n</code>\n<|/\
    \ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if substring is a\
    \ substring of string. For example, how_many_times(\"ab\", \"ab\") returns 2,\
    \ but how_many_times(\"ab\", \"ba\") returns 1.\n<|/ c |>\n<| c |>\n: Yes, you're\
    \ right. I missed that case. I've updated my answer.\n<|/ c |>\n<| c |>\n: Thanks\
    \ for pointing that out. I've updated my answer accordingly.\n<|/ c |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\n\
    This doesn't work if you have a substring that is a prefix of another substring.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. I tested it on `how_many_times(\"aaaa\", \"\
    aa\")` and it returned `3`.\n<|/ c |>\n<| c |>\n: Yes, it does. I tested it on\
    \ `how_many_times(\"aaaa\", \"aa\")` and it returned `3`.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. I tested it on `how_many_times(\"aaaa\", \"aa\")` and it returned\
    \ `3`.\n<|/ c |>\n<| c |>\n: Yes, it does. I tested it on `how_many_times(\"aaaa\"\
    , \"aa\")` and it returned `3`.\n<|/ c |>\n<| a tags=c++,string,algorithm |>\n\
    <code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\
    \ {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,c++,search |>\n<| c |>\nThis code doesn't work for\
    \ \"aaaaa\" substring. Correct answer is 3, not 4.\n<|/ c |>\n<| c |>\nThis code\
    \ doesn't work for \"aaaaa\" substring. Correct answer is 3, not 4.\n<|/ c |>\n\
    <| c |>\nThis code doesn't work for \"aaaaa\" substring. Correct answer is 3,\
    \ not 4.\n<|/ c |>\n<| c |>\nThis code doesn't work for \"aaaaa\" substring. Correct\
    \ answer is 3, not 4.\n<|/ c |>\n<| a dscore=4 |>\nThe algorithm is simple:",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = string.find(substring, start);\n    \
    \    if(end == string.length()) break;\n        \n        if(end > start) {\n\
    \            count += end - start;\n        }\n        start = end + sublen;\n\
    \    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    long\
    \ start = 0;\n    long end = 0;\n    long len = 0;\n    long i = 0;\n    \n  \
    \  while(i < string.length())\n    {\n        len = string.length() - i;\n   \
    \     end = start + len;\n        \n        if(string.find(substring, start) ==\
    \ start)\n        {\n            count++;\n            start = end;\n        }\n\
    \        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    long\
    \ i = 0;\n    \n    while(i < string.length())\n    {\n        len = string.length()\
    \ - i;\n        end = start + len;\n        \n        if(string.find(substring,\
    \ start) == start)\n        {\n            count++;\n            start = end;\n\
    \        }\n        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long len =\
    \ 0;\n    long i = 0;\n    \n    while(i < string.length())\n    {\n        len\
    \ = string.length() - i;\n        end = start + len;\n        \n        if(string.find(substring,\
    \ start) == start)\n        {\n            count++;\n            start = end;\n\
    \        }\n        \n        i++;\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int ", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, int start) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        for(int\
    \ j = 0; j < substring.length(); j++)\n        {\n            if(string[i] ==\
    \ substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_man", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    long pos = 0;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long pos = start;\n    while(pos < string.length())\n    {\n\
    \        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    long pos = start;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n        else\n        {\n            pos\
    \ = string.length();\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n    long count = 0;\n    long pos = start;\n    while(pos < string.length())\n\
    \    {\n        pos = string.find(sub", "{\n    long count = 0;\n    for(int i\
    \ = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    0L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0)\n    0L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end) \n{\n    long count = 0;\n \
    \   for(int i = start; i < end; i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    1L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0, 2)\n    1L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end, long step) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i+=step)\n    {\n        for(int j = 0;\
    \ j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"aaa\"\
    , \"a\", 0, 2, 1)\n    1L\n    >>> how_many_times(\"aaaa\", \"aa\", 0, 2, 1)\n\
    \    1L\n    \n*/\nlong how_many_times(string string, string substring, long start,\
    \ long end, long step, long step2) \n{\n    long count = 0;", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}",
  "{\n    long count = 0;\n    \n    foreach(char c in substring) \n    {\n      \
    \  foreach(char c2 in string) \n        {\n            if (c == c2) \n       \
    \     {\n                count++;\n            }\n        }\n    }\n    \n   \
    \ return count;\n}", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n            count++;\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is not the most efficient solution. `string.compare` will\
    \ have to compare the entire string for each character in the substring. `string.find`\
    \ will stop at the first character that matches.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I wanted to show OP how to do it in his own way. He can easily modify\
    \ it to his needs.\n<|/ c |>\n<| c |>\nI agree with you, but I wanted to show\
    \ OP how to do it in his own way. He can easily modify it to his needs.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but I wanted to show OP how to do it in his own\
    \ way. He can easily modify it to his needs.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I wanted to show OP how to do it in his own way. He can easily modify\
    \ it to his needs.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++) {\n        for(int j = 0;\
    \ j < substring.length(); j++) {\n            if(string[i] == substring[j]) {\n\
    \                count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    \
    \    if(string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n        if(string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0)\n        {\n            count++;\n        }\n        if(string.compare(i,\
    \ substring3.length(), substring3, 0, substring3.length()) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3, string substring4) \n{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            ", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \        }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring) == 0)\n            count++;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n            count++;\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        if(string.compare(i, substring.length(), substring) == 0)\n         \
    \   count++;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step, string pattern) \n{\n    ", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long length = string.length();\n\
    \    long substringLength = substring.length();\n    \n    for(long i = 0; i <\
    \ length; i++)\n    {\n        end = string.find(substring, start);\n        if(end\
    \ != string.length())\n        {\n            count += end - start;\n        \
    \    start = end + substringLength;\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long\
    \ len = string.length();\n    long sublen = substring.length();\n    \n    while(start\
    \ < len) {\n        end = start + sublen;\n        while(end < len && string.charAt(end)\
    \ == substring.charAt(0)) {\n            end++;\n        }\n        if(end ==\
    \ len) {\n            count++;\n            start = end;\n        }\n        else\
    \ {\n            while(end < len && string.charAt(end) != substring.charAt(0))\
    \ {\n                end++;\n            }\n            count++;\n           \
    \ start = end;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start) \n{\n    long\
    \ count = 0;\n    long end = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    while(start < len) {\n        end = start +\
    \ sublen;\n        while(end < len && string.charAt(end) == substring.charAt(0))\
    \ {\n            end++;\n        }\n        if(end == len) {\n            count++;\n\
    \            start = end;\n        }\n        else {\n            while(end <\
    \ len && string.charAt(end) != substring.charAt(0)) {\n                end++;\n\
    \            }\n            count++;\n            start = end;\n        }\n  \
    \  }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    while(start < len) {\n     \
    \   end = start + sublen;\n        while(end < len && string.charAt(end) == substring.charAt(0))\
    \ {\n            end++;\n        }\n        if(end == len) {\n            count++;\n\
    \            start = end;\n        }\n        else {\n            while(end <\
    \ len && string.charAt(end) != substring.charAt(0)) {\n                end++;\n\
    \            }\n            count++;", "{\n\tlong count = 0;\n\tfor (int i = 0;\
    \ i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length()) ==\
    \ substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I wonder if it would be faster than the\
    \ one I posted (which I believe is O(n))\n<|/ c |>\n<| c |>\nI believe your solution\
    \ is O(n), but your solution is O(n^2). Your solution is O(n) because you only\
    \ need to compare the beginning of the string with the substring. Your solution\
    \ is O(n^2) because you compare each character in the string with each character\
    \ in the substring. Your solution is O(n) because you only need to compare the\
    \ beginning of the string with the substring. Your solution is O(n^2) because\
    \ you compare each character in the string with each character in the substring.\
    \ Your solution is O(n) because you only need to compare the beginning of the\
    \ string with the substring. Your solution is O(n^2) because you compare each\
    \ character in the string with each character in the substring.\n<|/ c |>\n<|\
    \ c |>\nI believe your solution is O(n) because you only need to compare the beginning\
    \ of the string with the substring. Your solution is O(n) because you compare\
    \ each character in the string with each character in the substring. Your solution\
    \ is O(n) because you only need to compare the beginning of the string with the\
    \ substring. Your solution is O(n) because you compare each character in the string\
    \ with each character in the substring. Your solution is O(n) because you only\
    \ need to compare the beginning of the string with the substring. Your solution\
    \ is O(n) because you compare each character in the string with each character\
    \ in the substring.\n<|/ c |>\n<| c |>\nI believe your solution is O(n) because\
    \ you only need to compare the beginning of the string with the substring. Your\
    \ solution is O(n) because you compare each character in the string with each\
    \ character in the substring. Your solution is O(n) because you only need to compare\
    \ the beginning of the string with the substring. Your solution is O(n) because\
    \ you compare each character in the string with each character in the substring.\
    \ Your solution is O(n) because you only need to compare the beginning of the\
    \ string with the substring. Your solution is O(n) because you compare each character\
    \ in the string with each character in the substring. Your solution is O(n) because\
    \ you only need to compare the beginning of the string with the substring. Your\
    \ solution is O(n) because you compare each character in the string with each\
    \ character in the ", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n \
    \   \n    foreach(char c in substring) \n    {\n        foreach(char c2 in string)\
    \ \n        {\n            if(c == c2) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    \n    return count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    \n    for(int i = start; i\
    \ < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    \n    for(int i\
    \ = start; i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    ", "{\n    long count = 0;\n    \n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    \n    for(int i = start;\
    \ i < end; i++)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    \n    for(int\
    \ i = start; i < end; i += step)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        for(int j = 0; j < substring.length(); j++)\n        {\n\
    \            if(string[i] == substring[j])\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step)\
    \ \n{\n    long count = 0;\n    for(int i = start; i < end; i+=step)\n    {\n\
    \        for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    ", "{\n    long\
    \ count = 0;\n    size_t pos = 0;\n    size_t length = string.length();\n    size_t\
    \ substringLength = substring.length();\n    \n    while (pos < length) {\n  \
    \      if (string.compare(pos, substringLength, substring) == 0) {\n         \
    \   count++;\n        }\n        pos += substringLength;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t length\
    \ = string.length();\n    size_t substringLength = substring.length();\n    \n\
    \    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    size_t pos = start;\n  \
    \  size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    size_t pos =\
    \ start;\n    size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    while(start < len) {\n        end = start + sublen;\n        while(end <\
    \ len && string.charAt(end) != substring.charAt(start)) {\n            end++;\n\
    \        }\n        if(end == len) {\n            count++;\n        }\n      \
    \  start = end + 1;\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nI like this solution, but I wonder how it compares to other solutions\
    \ posted so far.\n<|/ c |>\n<| c |>\nI like it too. Just one question, why do\
    \ you use \"string\" instead of \"String\"?\n<|/ c |>\n<| c |>\n: I used `string`\
    \ because I didn't want to have to `#include <string>` at the top of my file.\
    \ I didn't want to have to `using namespace std;` at the top of my file. I didn't\
    \ want to have to `#include <string.h>` at the top of my file. I didn't want to\
    \ have to `#include <algorithm>` at the top of my file. I didn't want to have\
    \ to `#include <cstring>` at the top of my file. I didn't want to have to `#include\
    \ <cmath>` at the top of my file. I didn't want to have to `#include <cstdlib>`\
    \ at the top of my file. I didn't want to have to `#include <cstddef>` at the\
    \ top of my file. I didn't want to have to `#include <cstdint>` at the top of\
    \ my file. I didn't want to have to `#include <cstdio>` at the top of my file.\
    \ I didn't want to have to `#include <cstdlib>` at the top of my file. I didn't\
    \ want to have to `#include <cstddef>` at the top of my file. I didn't want to\
    \ have to `#include <cstdint>` at the top of my file. I didn't want to have to\
    \ `#include <cstdio>` at the top of my file. I didn't want to have to `#include\
    \ <cstdlib>` at the top of my file. I didn't want to have to `#include <cstddef>`\
    \ at the top of my file. I didn't want to have to `#include <cstdint>` at the\
    \ top of my file. I didn't want to have to `#include <cstdio>` at the top of my\
    \ file.\n<|/ c |>\n<| c |>\n: I didn't want to have to `#include <cstring>` at\
    \ the top of my file. I didn't want to have to `#include <cmath>` at the top of\
    \ my file. I didn't want to have to `#include <cstdlib>` at the top of my file.\
    \ I didn't want to have to `#include <cstddef>` at the top of my file. I didn't\
    \ want to have to `#include <cstdint>` ", "{\n\tlong count = 0;\n\tfor (int i\
    \ = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length())\
    \ == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that starts or ends with\
    \ the substring you're looking for. For example, how_many_times(\"ab\", \"ab\"\
    ) returns 2, when it should return 1.\n<|/ c |>\n<| c |>\nI believe that is a\
    \ valid case. For example, how_many_times(\"ab\", \"ab\") returns 2, when it should\
    \ return 1.\n<|/ c |>\n<| c |>\nYes, but \"ab\" is a substring of \"ab\" so how_many_times(\"\
    ab\", \"ab\") should return 1. But it returns 2.\n<|/ c |>\n<| c |>\nYes, I see\
    \ what you mean. I'll fix my answer.\n<|/ c |>\n<| c |>\nI fixed my answer, thanks\
    \ for pointing that out.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j\
    \ = 0; j < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\t\
    if (string.compare(i, substring.length(), substring) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n     \
    \       count += 1;\n            \n            for(int j = 1; j < sublen; j++)\n\
    \            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = start; i < len; i++)\n    {\n        if(string.charAt(i)\
    \ == substring.charAt(0))\n        {\n            count += 1;\n            \n\
    \            for(int j = 1; j < sublen; j++)\n            {\n                if(string.charAt(i)\
    \ == substring.charAt(j))\n                {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n\
    \            count += 1;\n            \n            for(int j = 1; j < sublen;\
    \ j++)\n            {\n                if(string.charAt(i) == substring.charAt(j))\n\
    \                {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    \n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> ho", "{\n    long count = 0;\n    \n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    long\
    \ len = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n       \
    \ {\n            for(int j = 0; j < sublen; j++)\n            {\n            \
    \    if(string[i + j] != substring[j])\n                    break;\n         \
    \   }\n            \n            if(j == sublen)\n                count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the substring occurs more than once in the original\
    \ string.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting.\n<|/ c\
    \ |>\n<| c |>\nI tested it before posting? I tested it before posting? I tested\
    \ it before posting? I tested it before posting? I tested it before posting? I\
    \ tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting? I tested it before posting?\
    \ I tested it before posting? I tested it before posting", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    \n    len\
    \ = string.length();\n    end = len-1;\n    \n    while(start < end)\n    {\n\
    \        while(string.find(substring, start) != string::npos)\n        {\n   \
    \         start = string.find(substring, start);\n            count++;\n     \
    \   }\n        \n        start++;\n    }\n    \n    return count;\n}", "{\n\t\
    long count = 0;\n\tfor (auto it = string.begin(); it != string.end(); ++it) {\n\
    \t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start = 0) \n{\n\tlong count = 0;\n\tfor (auto it = string.begin(); it\
    \ != string.end(); ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring, start + 1);\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, string start) \n{\n\tlong count = 0;\n\tfor (auto\
    \ it = string.begin(); it != string.end(); ++it) {\n\t\tif (*it == substring[0])\
    \ {\n\t\t\tcount += how_many_times(string.substr(1, string.size() - 1), substring,\
    \ start);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string start, long end)\
    \ \n{\n\tlong count = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ ++it) {\n\t\tif (*it == substring[0]) {\n\t\t\tcount += how_many_times(string.substr(1,\
    \ string.size() - 1), substring, start, end);\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive) \n{\n", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"aaa\"\
    , \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++) {\n        for(int\
    \ j = 0; j < substring.length(); j++) {\n            if(string[i] == substring[j])\
    \ {\n                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    0L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 0)\n    0L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i++) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(string[i] == substring[j]) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0, 2)\n    3L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, int start, int end, int step) \n{\n    long count = 0;\n    for(int\
    \ i = start; i < end; i += step) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(string[i] == substring[j]) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"aaa\", \"a\", 0, 2, 2)\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0, 2, 2)\n    3L\n    \n*/\nlong how_many_times(string string,\
    \ string substring, int start, int end, int step, int step2) \n{\n    long count\
    \ = 0;\n    for(int i = start; i < end; i += step) {\n        for(int j = 0; j\
    \ < substring", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0)\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    long start = 0;\n    long end = 0;\n    long len = 0;\n    \n    len\
    \ = string.length();\n    end = len-1;\n    \n    while(start < end) {\n     \
    \   while(start < end && string.compare(start, substring, 0, substring.length())\
    \ == 0) {\n            start++;\n        }\n        \n        while(start < end\
    \ && string.compare(end, substring, 0, substring.length()) == 0) {\n         \
    \   end--;\n        }\n        \n        if(start < end) {\n            count++;\n\
    \        }\n        \n        start++;\n        end--;\n    }\n    \n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    long start = 0;\n    long end\
    \ = 0;\n    long len = 0;\n    \n    len = string.length();\n    end = len-1;\n\
    \    \n    while(start < end) {\n        while(start < end && string.compare(start,\
    \ substring, 0, substring.length()) == 0) {\n            start++;\n        }\n\
    \        \n        while(start < end && string.compare(end, substring, 0, substring.length())\
    \ == 0) {\n            end--;\n        }\n        \n        if(start < end) {\n\
    \            count++;\n        }\n        \n        start++;\n        end--;\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < end) {\n        while(start < end &&\
    \ string.compare(start, substring, 0, substring.length()) == 0) {\n          \
    \  start++;\n        }\n        \n        while(start < end && string.compare(end,\
    \ substring, 0, substring.length()) == 0) {\n            ", "{\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()).equals(substring)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n    long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    size_t subpos = 0;\n        while (subpos < sublen) {\n            if (string[pos]\
    \ == substring[subpos]) {\n                subpos++;\n            } else {\n \
    \               break;\n            }\n        }\n        count++;\n        pos++;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        for(int j = 0; j < sublen; j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis doesn't work if the substring appears more than once in the\
    \ original string. For example, how_many_times(\"aaaa\", \"aa\") returns 3 instead\
    \ of 2.\n<|/ c |>\n<| c |>\n: Yes, it does. I tested it before posting it. I even\
    \ tested it before posting it. I even tested it before posting it. I even tested\
    \ it before posting it. I even tested it before posting it. I even tested it before\
    \ posting it. I even tested it before posting it. I even tested it before posting\
    \ it. I even tested it before posting it. I even tested it before posting it.\
    \ I even tested it before posting it. I even tested it before posting it. I even\
    \ tested it before posting it. I even tested it before posting it. I even tested\
    \ it before posting it. I even tested it before posting it. I even tested it before\
    \ posting it. I even tested it before posting it. I even tested it before posting\
    \ it. I even tested it before posting it. I even tested it before posting it.\
    \ I even tested it before posting it. I even tested it before posting it. I even\
    \ tested it before posting it. I even tested it before posting it. I even tested\
    \ it before posting it. I even tested it before posting it. I even tested it before\
    \ posting it. I even tested it before posting it. I even tested it before posting\
    \ it. I even tested it before posting it. I even tested it before posting it.\
    \ I even tested it before posting it. I even tested it before posting it. I even\
    \ tested it before posting it. I even tested it before posting it. I even tested\
    \ it before posting it. I even tested it before posting it. I even tested it before\
    \ posting it. I even tested it before posting it. I even tested it before posting\
    \ it. I even tested it before posting it. I even tested it before posting it.\
    \ I even tested it before posting it. I even tested it before posting it. I even\
    \ tested it before posting it. I even tested it before posting it. I even tested\
    \ it before posting it", "{\n    long count = 0;\n    \n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive) \n{\n    long count = 0;\n    \n    for(int i = 0; i <\
    \ string.length(); i++)\n    {\n        if(case_sensitive)\n        {\n      \
    \      if(string.compare(i, substring.length(), substring) == 0)\n           \
    \ {\n                count++;\n            }\n        }\n        else\n      \
    \  {\n            if(string.compare(i, substring.length(), substring, true) ==\
    \ 0)\n            {\n                count++;\n            }\n        }\n    }\n\
    \    \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case) \n{\n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(case_sensitive)\n      \
    \  {\n            if(ignore_case)\n            {\n                if(string.compare(i,\
    \ substring.length(), substring) == 0)\n                {\n                  \
    \  count++;\n                }\n            }\n            else\n            {\n\
    \                if(string.compare(i, substring.length(), substring, true) ==\
    \ 0)\n                {\n                    count++;\n                }\n   \
    \         }\n        }\n        else\n        {\n            if(ignore_case)\n\
    \            {\n                if(string.compare(i, substring.length(), substring,\
    \ true) == 0)\n                {\n                    count++;\n             \
    \   }\n            }\n            else\n            {\n                if(string.compare(i,\
    \ substring.length(), substring, true) == 0)\n                {\n            \
    \        count++;\n                }\n            }\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_",
  "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n \
    \       if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring) == 0 && string.compare(i\
    \ + substring.length(), substring2.length(), substring2) == 0)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring) ==\
    \ 0 && string.compare(i + substring.length(), substring2.length(), substring2)\
    \ == 0 && string.compare(i + substring2.length(), substring3.length(), substring3)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n    long count\
    \ = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0 && string.compare(i + substring.length(),\
    \ substring2.length(), substring2) == 0 && string.compare(i + substring2.length(),\
    \ substring3.length(), substring3) == 0 && string.compare(i + substring3.length(),\
    \ substring4.length(), substring4) == 0)\n        {\n", "{\n    long count = 0;\n\
    \    long len = string.length();\n    long sublen = substring.length();\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen; j++)\n\
    \        {\n            if(string[i] == substring[j])\n            {\n       \
    \         count++;\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen;\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    long len = string.length();\n    long\
    \ sublen = substring.length();\n    \n    for(int i = start; i < len; i++)\n \
    \   {\n        for(int j = 0; j < sublen; j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n            }\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = start; i < end;\
    \ i++)\n    {\n        for(int j = 0; j < sublen; j++)\n        {\n          \
    \  if(string[i] == substring[j])\n            {\n                count++;\n  \
    \          }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, long start, long end, long\
    \ step) \n{\n    long count = 0;\n    long len = string.length();\n    long sublen\
    \ = substring.length();\n    \n    for(int i = start; i < end; i += step)\n  \
    \  {\n        for(int j = 0; j < sublen; j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count", "{\n\tlong count =\
    \ 0;\n\tfor (auto c : string) \n\t{\n\t\tif (c == substring[0]) \n\t\t{\n\t\t\t\
    count += how_many_times(string.substr(1), substring);\n\t\t}\n\t\telse \n\t\t\
    {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length())\
    \ == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis code doesn't work. Try it with `how_many_times(\"aaa\", \"a\")`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<|\
    \ c |>\nThis code doesn't work. Try it with `how_many_times(\"aaa\", \"a\")`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>\npublic int how_many_times(String string, String substring)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n   \
    \     if (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=java,string |>\n<| a dscore=1 |>\n<code>\npublic int how_many_times(String\
    \ string, String substring) {\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=java,string |>\n<| a dscore=1 |>\n<code>\npublic int how_many_times(String\
    \ string, String substring) {\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=java,string |>\n<| a tags=java,string |>\n<code>\npublic int how_many_times(String\
    \ string, String substring) {\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=java,string |>\n<code>\npublic int how_many_times(String\
    \ string, String substring) {\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      for(int j = 0; j < substring.length(); j++)\n        {\n            if(string[i]\
    \ == substring[j])\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}", "{\n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring)\
    \ == 0)\n\t\t\tcount++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn count;\n}", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ string case_sensitive) \n{\n", "{\n    long count = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(string[i] == substring[0])\n        {\n            for(int\
    \ j = 1; j < sublen; j++)\n            {\n                if(string[i + j] !=\
    \ substring[j])\n                {\n                    break;\n             \
    \   }\n            }\n            \n            if(j == sublen)\n            {\n\
    \                count++;\n            }\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\
    \ {\n        for(int j = 0; j < substring.length(); j++) {\n            if(string[i]\
    \ == substring[j]) {\n                count++;\n            }\n        }\n   \
    \ }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n    for(int i\
    \ = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}", "{\n    long\
    \ count = 0;\n    long start = 0;\n    long end = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(long i = 0; i < len; i++)\n\
    \    {\n        start = i;\n        end = i + sublen;\n        if(string.find(substring,\
    \ start, end) != string::npos)\n        {\n            count++;\n            start\
    \ = end;\n        }\n    }\n    \n    return count;\n}", "{\n    long count =\
    \ 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    size_t pos\
    \ = 0;\n    size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    size_t pos = start;\n    size_t length\
    \ = string.length();\n    size_t substringLength = substring.length();\n    \n\
    \    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    size_t pos = start;\n  \
    \  size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long step) \n{\n    long count = 0;\n    size_t pos =\
    \ start;\n    size_t length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.length();\
    \ j++)\n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\
    \t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++)\n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1;\
    \ j < substring.length(); j++)\n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\
    \t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\n\
    \t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.length();\
    \ j++)\n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t{\n\t\t\t\
    \t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i+=step)\n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor\
    \ (int j = 1; j < substring.length(); j++)\n\t\t\t{\n\t\t\t\tif (string[i + j",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i,\
    \ substring.length()) == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.substr(i, substring.length()) == substring)\
    \ {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end, int step,\
    \ string pattern) \n{\n\t", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2) \n\
    {\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t\tif (string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++)\
    \ {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t\tif (string.compare(i, substring2.length(),\
    \ substring2, 0, substring2.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t\tif (string.compare(i,\
    \ substring3.length(), substring3, 0, substring3.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t\tif (string.compare(i, substring2.length(), substring2, 0, substring2.length()",
  "{\n    long count = 0;\n    long pos = 0;\n    while(pos < string.length())\n \
    \   {\n        pos = string.find(substring, pos);\n        if(pos != string.length())\n\
    \        {\n            count++;\n            pos = string.find(substring, pos\
    \ + substring.length());\n        }\n    }\n    return count;\n}", "{\n\tlong\
    \ count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n\tlong count = 0;\n\tfor (int i = start; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n\tlong count = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n\tlong count = 0;\n\tfor (int i = start;\
    \ i < end; i += step) {\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n\tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.substr(i, substring.length()).equals(substring))\n\
    \t\t\tcount++;\n\t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<|\
    \ c |>\nThis is not the most efficient solution. `string::compare` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string::find`\
    \ does a linear search through the entire string. `string::find` does a linear\
    \ search through the entire string. `string::find` does a linear search through\
    \ the entire string. `string::find` does a linear search through the entire string.\
    \ `string::find` does a linear search through the entire string. `string", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your answer but I think it can be optimized a little bit.\
    \ `how_many_times` can be simplified to `return string.count(substring);`\n<|/\
    \ c |>\n<| c |>\nYes, that would be better. Thanks!\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>\npublic int howManyTimes(String str, String subStr) {\n    int count =\
    \ 0;\n    for(int i = 0; i < str.length(); i++) {\n        if(str.substring(i,\
    \ subStr.length()).equals(subStr)) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,java,substring |>\n<| a tags=string,java,substring\
    \ |>\n<code>\npublic int howManyTimes(String str, String subStr) {\n    int count\
    \ = 0;\n    for(int i = 0; i < str.length(); i++) {\n        if(str.substring(i,\
    \ subStr.length()).equals(subStr)) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,java,substring\
    \ |>\n<code>\npublic int howManyTimes(String str, String subStr) {\n    int count\
    \ = 0;\n    for(int i = 0; i < str.length(); i++) {\n        if(str.substring(i,\
    \ subStr.length()).equals(subStr)) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\npublic int\
    \ howManyTimes(String str, String subStr) {\n    int count = 0;\n    for(int i\
    \ = 0; i < str.length(); i++) {\n        if(str.substring(i, subStr.length()).equals(subStr))\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/\
    \ a dscore=1 tags=string,java,substring |>\n<| a tags=string,java,substring |>\n\
    <code>\npublic int howManyTimes(String str, String subStr) {\n    int count =\
    \ 0;\n    for(int i = 0; i < str.length(); i++) {\n        if(str.substring(i,\
    \ subStr.length()).equals(subStr)) {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,java,substring\
    \ |>\n<code>\npublic int howManyTimes(String str, String subStr) {\n    int count\
    \ = 0;\n    for(int i = 0; i < str", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>", "{\n\
    \    long count = 0;\n    size_t pos = 0;\n    size_t len = string.length();\n\
    \    size_t sublen = substring.length();\n    \n    while (pos < len) {\n    \
    \    if (string.compare(pos, sublen, substring) == 0) {\n            count++;\n\
    \        }\n        pos += sublen;\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, bool ignore_case) \n{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (ignore_case ? string.compare(pos,\
    \ sublen, substring, true) == 0 : \n            string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n        }\n        pos += sublen;\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"aaaa\"\
    , \"aa\", true)\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool ignore_case, bool ignore_whitespace) \n{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (ignore_case ? string.compare(pos,\
    \ sublen, substring, true) == 0 : \n            string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n        }\n        if (ignore_whitespace) {\n\
    \            while (pos < len && isspace(string[pos])) {\n                pos++;\n\
    \            }\n        }\n        pos += sublen;\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaaa\", \"aa\", true, true)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, bool ignore_case,\
    \ bool ignore_whitespace, bool ignore_newlines) \n{\n    long count = 0;\n   \
    \ size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (ignore_case ? string.compare(pos,\
    \ sublen, substring, true) == 0 : \n            string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n        }\n        if (ignore_whitespace) {\n\
    \            while (pos < len && isspace(string", "{\n    long count = 0;\n  \
    \  for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n  \
    \      if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code does not work. `how_many_times(\"\
    aaaa\", \"aa\")` returns `3L` instead of `2L`.\n<|/ c |>\n<| c |>\nI fixed the\
    \ bug, thanks for pointing it out. :)\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    long len = string.length();\n\
    \    long sublen = substring.length();\n    \n    for(long i = 0; i < len; i++)\
    \ \n    {\n        end = string.find(substring, i);\n        if(end == string::npos)\
    \ \n        {\n            end = len;\n        }\n        \n        if(end > start)\
    \ \n        {\n            count += end - start;\n            start = end;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string.substr(i, substring.length())\
    \ == substring) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    \n    foreach(char c in substring) \n    {\n        foreach(char\
    \ c2 in string) \n        {\n            if (c == c2) \n            {\n      \
    \          count++;\n                break;\n            }\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\n\
    This doesn't work if you have a substring that appears more than once in the original\
    \ string. For example, how_many_times(\"abcabc\", \"abc\") returns 3 instead of\
    \ 2.\n<|/ c |>\n<| c |>\n: Yes, you are right. I missed that case. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a |>\n<code>", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This code doesn't work if you have a string like \"aba\" and you search for \"\
    ab\". It will count the occurrences of \"ab\" in the string \"aba\".\n<|/ c |>\n\
    <| c |>\nYes, you are right. I've edited my answer to fix this issue.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "{\n    long count = 0;\n    long start = 0;\n    long\
    \ end = 0;\n    \n    for(long i = 0; i < string.length(); i++) {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n            count++;\n\
    \            start = i;\n            end = i + substring.length();\n        }\n\
    \    }\n    \n    return count;\n}", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't\
    \ work if you have a string like \"aaaaaaa\" and a substring like \"aaa\"\n<|/\
    \ c |>\n<| c |>\nYes, it does. I tested it before posting. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI tested it myself and I got 3 for \"aaaaaaa\" and \"aaa\"\
    \ but I think you meant 2\n<|/ c |>\n<| c |>\nYes, I meant 2. My bad. Sorry about\
    \ that.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a string like \"aaaaaaa\"\
    \ and a substring like \"aaa\"\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n\
    <code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.substr(i, substring.length()) == substring)\n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t{\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length(); j++) {\n\
    \t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n\
    \    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    \n    for(int i = start; i < end; i++)\n    {\n  \
    \      if(string.substr(i, substring.length()) == substring)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n    long count = 0;\n    \n    for(int i = start; i < end; i+=step)\n\
    \    {\n        if(string.substr(i, substring.length()) == substring)\n      \
    \  {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong ", "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n\
    \    long len = 0;\n    long i = 0;\n    \n    while(i < string.length())\n  \
    \  {\n        end = string.find(substring, start);\n        if(end == string.length())\n\
    \        {\n            count++;\n            start = end + 1;\n        }\n  \
    \      else\n        {\n            count++;\n            start = end + 1;\n \
    \           len = end - start + 1;\n        }\n        i++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n    long count = 0;\n    long start = 0;\n    long end\
    \ = 0;\n    long len = 0;\n    long i = 0;\n    \n    while(i < string.length())\n\
    \    {\n        end = string.find(substring, start);\n        if(end == string.length())\n\
    \        {\n            count++;\n            start = end + 1;\n        }\n  \
    \      else\n        {\n            count++;\n            start = end + 1;\n \
    \           len = end - start + 1;\n        }\n        i++;\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n    long count = 0;\n    long start\
    \ = 0;\n    long end = 0;\n    long len = 0;\n    long i = 0;\n    \n    while(i\
    \ < string.length())\n    {\n        end = string.find(substring, start);\n  \
    \      if(end == string.length())\n        {\n            count++;\n         \
    \   start = end + 1;\n        }\n        else\n        {\n            count++;\n\
    \            start = end + 1;\n            len = end - start + 1;\n        }\n\
    \        i++;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aa", "{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}", "{\n\tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.substr(i, substring.length()) == substring) {\n\t\t\t\
    count++;\n\t\t}\n\t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThis doesn't work if\
    \ the substring appears more than once in the original string. For example, if\
    \ `string = \"aaa\"` and `substring = \"aa\"`, then `how_many_times(string, \"\
    aa\")` returns 2, not 3.\n<|/ c |>\n<| c |>\nYes, you are right. I didn't think\
    \ about that case. I'll edit the answer to fix it.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    \n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. `how_many_times(\"aaaa\", \"aa\")` returns `3` when it should be `2`.\n\
    <|/ c |>\n<| c |>\nYes, I noticed that and fixed it. I had forgotten that `compare`\
    \ returns `0` if the strings are equal, and `1` if the first string is greater\
    \ than the second.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    size_t pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (string.compare(pos, sublen, substring)\
    \ == 0) {\n            count++;\n        }\n        pos += sublen;\n    }\n  \
    \  return count;\n}\n/*\n Find how many times a given substring can be found in\
    \ the original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"\
    a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive) \n{\n    long count = 0;\n    size_t pos = 0;\n    size_t\
    \ len = string.length();\n    size_t sublen = substring.length();\n    \n    while\
    \ (pos < len) {\n        if (case_sensitive) {\n            if (string.compare(pos,\
    \ sublen, substring) == 0) {\n                count++;\n            }\n      \
    \  } else {\n            if (string.compare(pos, sublen, substring, 0, sublen)\
    \ == 0) {\n                count++;\n            }\n        }\n        pos +=\
    \ sublen;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case) \n{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        if (ignore_case) {\n            if (string.compare(pos,\
    \ sublen, substring) == 0) {\n                count++;\n            }\n      \
    \  } else {\n            if (string.compare(pos, sublen, substring, 0, sublen)\
    \ == 0) {\n                count++;\n            }\n        }\n        pos +=\
    \ sublen;\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_", "{\n\tlong count = 0;\n\tfor (int i = 0;\
    \ i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string.compare(i, substring2.length(),\
    \ substring2, 0, substring2.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3) \n{\n\tlong count = 0;\n\tfor (int i =\
    \ 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t\telse if\
    \ (string.compare(i, substring2.length(), substring2, 0, substring2.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t\telse if (string.compare(i, substring3.length(),\
    \ substring3, 0, substring3.length()) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2, string substring3, string substring4) \n{\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (string.compare(i, substring2.length(), substring2, 0, ", "{\n\
    \    long count = 0;\n    long start = 0;\n    long end = 0;\n    \n    for(long\
    \ i = 0; i < string.length(); i++) {\n        end = string.find(substring, start);\n\
    \        if(end == string.length()) {\n            break;\n        }\n       \
    \ \n        count += end - start;\n        start = end + 1;\n    }\n    \n   \
    \ return count;\n}", "{\n    long count = 0;\n    size_t pos = 0;\n    size_t\
    \ length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) {\n        if (string.compare(pos, substringLength,\
    \ substring) == 0) {\n            count++;\n        }\n        pos += substringLength;\n\
    \    }\n    return count;\n}", "{\n    long count = 0;\n    \n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    long\
    \ len = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        for(int j = 0; j < sublen; j++)\n     \
    \   {\n            if(string[i] == substring[j])\n            {\n            \
    \    count++;\n            }\n        }\n    }\n    return count;\n}", "{\n  \
    \  long count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n    \
    \    if(string.compare(i, substring.length(), substring) == 0)\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring) == 0)\n        {\n    \
    \        count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\", 0)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", 0)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", 0)\n    3L\n\
    \    \n*/\nlong how_many_times(string string, string substring, int start, int\
    \ end) \n{\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n\
    \        if(string.compare(i, substring.length(), substring) == 0)\n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\", 0, 0)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", 0, 0)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", 0, 0)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i+=step)\n    {\n        if(string.compare(i, substring.length(), substring)\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2)\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\", 0, 2)\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", 0, 2)\n    3L\n    \n*/\nlong ", "{\n    long count = 0;\n   \
    \ for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a substring that appears more than\
    \ once in the original string. For example, how_many_times(\"aaaa\", \"aa\") returns\
    \ 3, but how_many_times(\"aaaa\", \"aaa\") returns 4.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I see that now. Thanks for pointing that out. I've updated my answer to fix\
    \ it.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I've updated my answer\
    \ to fix it.\n<|/ c |>\n<| a tags=c++,string,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j <\
    \ substring.length(); j++) {\n\t\t\tif (string[i] == substring[j]) {\n\t\t\t\t\
    count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong\
    \ count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n\t\t{\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\t\n\treturn count;\n}", "{\n\tlong count = 0;\n\t\n\tfor (int i =\
    \ 0; i < string.length(); i++)\n\t{\n\t\tif (string[i] == substring[0]) \n\t\t\
    {\n\t\t\tfor (int j = 1; j < substring.length(); j++)\n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \t\n\t\t\tif (j == substring.length())\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\
    \t}\n\t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0;\
    \ i < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring) == 0)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(case_sensitive)\n        {\n            if(string.compare(i,\
    \ substring.length(), substring) == 0)\n            {\n                count++;\n\
    \            }\n        }\n        else\n        {\n            if(string.compare(i,\
    \ substring.length(), substring, true) == 0)\n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, bool case_sensitive, bool\
    \ ignore_case) \n{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(case_sensitive)\n        {\n            if(string.compare(i,\
    \ substring.length(), substring) == 0)\n            {\n                count++;\n\
    \            }\n        }\n        else\n        {\n            if(ignore_case)\n\
    \            {\n                if(string.compare(i, substring.length(), substring,\
    \ true) == 0)\n                {\n                    count++;\n             \
    \   }\n            }\n            else\n            {\n                if(string.compare(i,\
    \ substring.length(), substring, true) == 0)\n                {\n            \
    \        count++;\n                }\n            }\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case, bool ignore_whitespace) \n{\n    long\
    \ count = 0;\n    for(int ", "{\n    long count = 0;\n    long start = 0;\n  \
    \  long end = 0;\n    long len = 0;\n    long i = 0;\n    \n    len = string.length();\n\
    \    end = len-1;\n    \n    while(start < end) {\n        while(string.at(start)\
    \ == substring.at(0) && start < end) {\n            start++;\n        }\n    \
    \    while(string.at(end) == substring.at(len-1) && end > start) {\n         \
    \   end--;\n        }\n        if(start < end) {\n            count++;\n     \
    \       start = end;\n        }\n    }\n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, long start) \n{\n   \
    \ long count = 0;\n    long end = 0;\n    long len = 0;\n    long i = 0;\n   \
    \ \n    len = string.length();\n    end = len-1;\n    \n    while(start < end)\
    \ {\n        while(string.at(start) == substring.at(0) && start < end) {\n   \
    \         start++;\n        }\n        while(string.at(end) == substring.at(len-1)\
    \ && end > start) {\n            end--;\n        }\n        if(start < end) {\n\
    \            count++;\n            start = end;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long len = 0;\n    long\
    \ i = 0;\n    \n    len = string.length();\n    end = len-1;\n    \n    while(start\
    \ < end) {\n        while(string.at(start) == substring.at(0) && start < end)\
    \ {\n            start++;\n        }\n        while(string.at(end) == substring.at(len-1)\
    \ && end > start) {\n            end--;\n        }\n        if(start < end) {\n\
    \            count++;\n            start = end;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original ",
  "{\n    long count = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    \n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    \n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\", 0)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 0)\n    3L\n  \
    \  >>> how_many_times(\"aaaa\", \"aa\", 0)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, long start, long end) \n{\n    long count = 0;\n \
    \   \n    for(int i = start; i < end; i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"a\", \"a\", 0, 2)\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\", 0, 2)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", 0, 2)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, long start,\
    \ long end, long step) \n{\n    long count = 0;\n    \n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\", 0, 2, 1)\n    0L\n", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aaa\", \"a\", 2)\n    3L\n\
    \    >>> how_many_times(\"aaaa\", \"aa\", 2)\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int start, int end) \n{\n    long count = 0;\n   \
    \ for(int i = start; i < end; i++)\n    {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0)\n        {\n            count++;\n \
    \       }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    aaa\", \"a\", 2, 3)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", 2, 3)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step) \n{\n    long count = 0;\n    for(int i = start; i < end;\
    \ i += step)\n    {\n        if(string.compare(i, substring.length(), substring,\
    \ 0, substring.length()) == 0)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    aaa\", \"a\", 2, 3)\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\", 2, 3)\n\
    \    3L\n    \n*/\nlong how_many_times(string string, string substring, int start,\
    \ int end, int step, string pattern) \n{\n    long count = 0;\n    for(int i =\
    \ start; i < end; i += ", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This is not the most efficient solution, since it does a lot of unnecessary comparisons.\
    \ A better solution would be to count the occurrences of substrings starting at\
    \ position `i` and ending at position `i+1`, where `i` is the index of the first\
    \ character of the substring.\n<|/ c |>\n<| c |>\n: Yes, I agree with you. But\
    \ the OP asked for the most efficient solution. So, I have written the most efficient\
    \ solution. :)\n<|/ c |>\n<| c |>\n: Yes, I agree with you. But the OP asked for\
    \ the most efficient solution. So, I have written the most efficient solution.\
    \ :)\n<|/ c |>\n<| c |>\n: Yes, I agree with you. But the OP asked for the most\
    \ efficient solution. So, I have written the most efficient solution. :)\n<|/\
    \ c |>\n<| c |>\n: Yes, I agree with you. But the OP asked for the most efficient\
    \ solution. So, I have written the most efficient solution. :)\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n    long\
    \ count = 0;\n    for(int i = start; i < string.length(); i++)\n    {\n      \
    \  if(string.substr(i, substring.length()) == substring)\n        {\n        \
    \    count++;\n        }\n    }\n    return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int start, int end) \n{\n\
    \    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}", "{\n    long\
    \ count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = 0; j < sublen; j++)\n            {\n     \
    \           if(string[i + j] != substring[j])\n                {\n           \
    \         break;\n                }\n            }\n            \n           \
    \ count += 1;\n            \n            if((i + j) == sublen)\n            {\n\
    \                break;\n            }\n        }\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| a dscore=1 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;", "{\n    long count\
    \ = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0)\n        {\n   \
    \         count++;\n        }\n    }\n    \n    return count;\n}\n</code>\n<|/\
    \ a tags=string,c++,algorithm |>\n<| c |>\nThis does not answer the question.\
    \ He wants to count the number of times a substring appears in a string. Your\
    \ code only counts the number of times a substring appears anywhere in the string.\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll edit my answer accordingly.\n\
    <|/ c |>\n<| c |>\nI believe this answer is wrong. `how_many_times(\"aaa\", \"\
    a\")` returns `3` instead of `2`.\n<|/ c |>\n<| c |>\nI believe this answer is\
    \ wrong. `how_many_times(\"aaa\", \"a\")` returns `3` instead of `2`.\n<|/ c |>\n\
    <| c |>\nI believe this answer is wrong. `how_many_times(\"aaa\", \"a\")` returns\
    \ `3` instead of `2`.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    long count = 0;\n\
    \    \n    foreach(char c in string) {\n        foreach(char c2 in substring)\
    \ {\n            if (c == c2) {\n                count++;\n            }\n   \
    \     }\n    }\n    \n    return count;\n}", "{\n    long count = 0;\n    size_t\
    \ pos = 0;\n    size_t len = string.length();\n    size_t sublen = substring.length();\n\
    \    \n    while (pos < len) {\n        size_t subpos = 0;\n        while (subpos\
    \ < sublen) {\n            if (string[pos] == substring[subpos]) {\n         \
    \       subpos++;\n            }\n            pos++;\n        }\n        count++;\n\
    \    }\n    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.compare(i,\
    \ substring.length(), substring) == 0)\n        {\n            count++;\n    \
    \    }\n    }\n    return count;\n}", "{\n    long count = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start) \n{\n    long count = 0;\n    for(int i = start; i < string.length();\
    \ i++)\n    {\n        if(string.substr(i, substring.length()) == substring)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end) \n\
    {\n    long count = 0;\n    for(int i = start; i < end; i++)\n    {\n        if(string.substr(i,\
    \ substring.length()) == substring)\n        {\n            count++;\n       \
    \ }\n    }\n    return count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end, int step) \n{\n    long count = 0;\n    for(int i = start;\
    \ i < end; i+=step)\n    {\n        if(string.substr(i, substring.length()) ==\
    \ substring)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    for(int i = 0; i\
    \ < string.length(); i++)\n    {\n        if(string.substr(i, substring.length())\
    \ == substring)\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `how_many_times(\"\
    aaaa\", \"aa\")` returns `3L` instead of `2L`.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting. What is your input? What is your expected output?\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I must have had a typo when\
    \ I tried it the first time.\n<|/ c |>\n<| c |>\nI tested it again and it works.\
    \ I must have had a typo when I tried it the first time.\n<|/ c |>\n<| c |>\n\
    I tested it again and it works. I must have had a typo when I tried it the first\
    \ time.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.compare(i, substring.length(),\
    \ substring, 0, substring.length()) == 0) {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<|\
    \ c |>\nThis is not the most efficient solution, since it requires O(n) extra\
    \ space to store the substrings array.\n<|/ c |>\n<| c |>\n: I agree. However,\
    \ the OP asked for a solution that does not require extra space. He also asked\
    \ for efficiency, which I believe is the most important factor.\n<|/ c |>\n<|\
    \ c |>\n: I agree. However, the OP asked for a solution that does not require\
    \ extra space. He also asked for efficiency, which I believe is the most important\
    \ factor.\n<|/ c |>\n<| c |>\n: I agree. However, the OP asked for a solution\
    \ that does not require extra space. He also asked for efficiency, which I believe\
    \ is the most important factor.\n<|/ c |>\n<| c |>\n: I agree. However, the OP\
    \ asked for a solution that does not require extra space. He also asked for efficiency,\
    \ which I believe is the most important factor.\n<|/ c |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include\
    \ <vector>", "{\n    long count = 0;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.compare(i, substring.length(), substring, 0,\
    \ substring.length()) == 0)\n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count\
    \ = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = 1; j < sublen; j++)\n            {\n     \
    \           if(string[i + j] != substring[j])\n                    break;\n  \
    \          }\n            \n            if(j == sublen)\n                count++;\n\
    \        }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, bool case_sensitive) \n{\n \
    \   long count = 0;\n    long len = string.length();\n    long sublen = substring.length();\n\
    \    \n    for(int i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n\
    \        {\n            for(int j = 1; j < sublen; j++)\n            {\n     \
    \           if(string[i + j] != substring[j] || (!case_sensitive && string[i]\
    \ == substring[j]))\n                    break;\n            }\n            \n\
    \            if(j == sublen)\n                count++;\n        }\n    }\n   \
    \ \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool case_sensitive, bool ignore_case) \n{\n    long count = 0;\n    long len\
    \ = string.length();\n    long sublen = substring.length();\n    \n    for(int\
    \ i = 0; i < len; i++)\n    {\n        if(string[i] == substring[0])\n       \
    \ {\n            for(int j = 1; j < sublen; j++)\n            {\n            \
    \    if(string[i + j] != substring[j] || (!case_sensitive && string[i] == substring[j]\
    \ && !ignore_case))\n                    break;\n            }\n            \n\
    \            if(j == sublen)\n                count++;\n        }\n    }\n   \
    \ \n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_",
  "{\n    long count = 0;\n    long start = 0;\n    long end = 0;\n    long length\
    \ = 0;\n    \n    while(end < string.length)\n    {\n        length = string.length-end;\n\
    \        if(string.substring_at(end, length) == substring)\n        {\n      \
    \      count++;\n            end = end+length;\n        }\n        else\n    \
    \    {\n            end = end+length;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start) \n{\n    long count = 0;\n    long end = 0;\n    long length = 0;\n\
    \    \n    while(end < string.length)\n    {\n        length = string.length-end;\n\
    \        if(string.substring_at(end, length) == substring)\n        {\n      \
    \      count++;\n            end = end+length;\n        }\n        else\n    \
    \    {\n            end = end+length;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end) \n{\n    long count = 0;\n    long length = 0;\n    \n\
    \    while(end < string.length)\n    {\n        length = string.length-end;\n\
    \        if(string.substring_at(end, length) == substring)\n        {\n      \
    \      count++;\n            end = end+length;\n        }\n        else\n    \
    \    {\n            end = end+length;\n        }\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ long start, long end, long length) \n{\n    long count = 0;\n    \n    while(end\
    \ < string.length", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start) \n{\n\tlong\
    \ count = 0;\n\tfor (int i = start; i < string.length(); i++) {\n\t\tif (string.compare(i,\
    \ substring.length(), substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int start, int end) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i++)\
    \ {\n\t\tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, int start, int end, int\
    \ step) \n{\n\tlong count = 0;\n\tfor (int i = start; i < end; i += step) {\n\t\
    \tif (string.compare(i, substring.length(), substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_", "{\n    long count = 0;\n    size_t pos = 0;\n    size_t\
    \ length = string.length();\n    size_t substringLength = substring.length();\n\
    \    \n    while (pos < length) \n    {\n        if (string.compare(pos, substringLength,\
    \ substring, 0, substringLength) == 0) \n        {\n            count++;\n   \
    \         pos += substringLength;\n        }\n        else\n        {\n      \
    \      pos += 1;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\npublic int countSubstring(String str, String subStr)\
    \ {\n    int count = 0;\n    int len = str.length();\n    int subLen = subStr.length();\n\
    \    int i = 0;\n    int j = 0;\n    while (i < len) {\n        while (j < subLen\
    \ && str.charAt(i) == subStr.charAt(j)) {\n            j++;\n        }\n     \
    \   if (j == subLen) {\n            count++;\n        }\n        j = 0;\n    \
    \    i++;\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,algorithm,java\
    \ |>\n<| a tags=string,algorithm,java |>\n<code>\npublic int countSubstring(String\
    \ str, String subStr) {\n    int count = 0;\n    int len = str.length();\n   \
    \ int subLen = subStr.length();\n    int i = 0;\n    int j = 0;\n    while (i\
    \ < len) {\n        while (j < subLen && str.charAt(i) == subStr.charAt(j)) {\n\
    \            j++;\n        }\n        if (j == subLen) {\n            count++;\n\
    \        }\n        j = 0;\n        i++;\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\npublic int countSubstring(String\
    \ str, String subStr) {\n    int count = 0;\n    int len = str.length();\n   \
    \ int subLen = subStr.length();\n    int i = 0;\n    int j = 0;\n    while (i\
    \ < len) {\n        while (j < subLen && str.charAt(i) == subStr.charAt(j)) {\n\
    \            j++;\n        }\n        if (j == subLen) {\n            count++;\n\
    \        }\n        j = 0;\n        i++;\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,algorithm,java |>\n<| a tags=string,algorithm,java |>\n<code>\n\
    public int countSubstring(String str, String subStr) {\n    int count = 0;\n \
    \   int len = str.length();\n    int subLen = subStr.length();\n    int i = 0;\n\
    \    int j = 0;\n    while (i < len) {\n        while (j < subLen && str.charAt(i)\
    \ == subStr.charAt(j)) {\n            j++;\n        }\n        if (j == subLen)\
    \ {\n"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
