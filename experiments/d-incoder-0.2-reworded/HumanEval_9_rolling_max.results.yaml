language: d
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    long\
    \ currentMax = numbers[0];\n    \n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n        \n        if(numbers[i] > max)\n        {\n            max\
    \ = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    long currentMin = numbers[0];\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n    }\n    \n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    long currentSum = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        currentSum += numbers[i];\n        \n        if(currentSum\
    \ > 0)\n        {\n            sum += currentSum;\n        }\n    }\n    \n  \
    \  for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] roll\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnwm0u_sj.d(110): Error: semicolon expected, not `unittest`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwm0u_sj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| c |>\nThis doesn't seem to work. `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L})` returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it out yourself. I tested it on `rolling_max(new long[]{1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n\
    <| c |>\nYes, it works. But it also returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]` for\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L, 2L, 3L, 4L, 2L})`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on `rolling_max(new\
    \ long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a solution in\
    \ Java that uses no loops and is O(n) time complexity. \n<code>\npublic static\
    \ long[] rolling_max(long[] numbers) {\n    long[] result = new long[numbers.length];\n\
    \    int maxIndex = 0;\n    long maxValue = numbers[0];\n    for (int i = 1; i\
    \ < numbers.length; i++) {\n        if (numbers[i] > maxValue) {\n           \
    \ maxValue = numbers[i];\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl0vzoaca.d(29): Error: declaration expected, not `<`\n/tmp/tmpl0vzoaca.d(32):
    Error: unterminated character constant\n/tmp/tmpl0vzoaca.d(53): Error: declaration
    expected, not `for`\n/tmp/tmpl0vzoaca.d(53): Error: no identifier for declarator
    `i`\n/tmp/tmpl0vzoaca.d(53): Error: declaration expected, not `<`\n/tmp/tmpl0vzoaca.d(53):
    Error: no identifier for declarator `i`\n/tmp/tmpl0vzoaca.d(53): Error: declaration
    expected, not `++`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0vzoaca.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long\
    \ max = 0;\n    \n    while(j < numbers.length)\n    {\n        if(numbers[j]\
    \ > max)\n        {\n            max = numbers[j];\n        }\n        j++;\n\
    \    }\n    \n    while(i < numbers.length)\n    {\n        result[i] = max;\n\
    \        i++;\n        j = 0;\n        \n        while(j < numbers.length)\n \
    \       {\n            if(numbers[j] > max)\n            {\n                max\
    \ = numbers[j];\n            }\n            j++;\n        }\n    }\n    \n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long min = 0;\n \
    \   \n    while(j < numbers.length)\n    {\n        if(numbers[j] < min)\n   \
    \     {\n            min = numbers[j];\n        }\n        j++;\n    }\n    \n\
    \    while(i < numbers.length)\n    {\n        result[i] = min;\n        i++;\n\
    \        j = 0;\n        \n        while(j < numbers.length)\n        {\n    \
    \        if(numbers[j] < min)\n            {\n                min = numbers[j];\n\
    \            }\n            j++;\n        }\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 9L, 9L, 12L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    long sum = 0;\n    \n    while(j < numbers.length)\n    {\n\
    \        sum += numbers[j];\n        j++;\n    }\n    \n    while(i < numbers.length)\n\
    \    {\n        result[i] = sum;\n        i++;\n        j = 0;\n        \n   \
    \     while(j < numbers.length)\n        {\n            sum += numbers[j];\n \
    \           j++;\n        }\n    }\n    \n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product of element found until\
    \ given moment\n    in the sequence.\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpks72c3uj.d(120): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpks72c3uj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = 1; i < n; i++)\n    {\n        result[i] = max(result[i-1], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6rpizjuj.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\n/tmp/tmp6rpizjuj.d(22): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6rpizjuj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long maxValue = numbers[0];\n\
    \    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > maxValue)\n  \
    \      {\n            maxValue = numbers[i];\n        }\n    }\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = maxValue;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long minValue = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n    \
    \    if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] =\
    \ minValue;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n    }\n   \
    \ for(int i = 0; i < n; i++)\n    {\n        result[i] = sum / n;\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long median = 0;\n    long sum = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n        if(sum\
    \ % 2 == 0)\n        {\n            median = numbers[i];\n        }\n    }\n \
    \   for(int i = 0; i < n; i++)\n    {\n        result[i] = median;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling standard deviation \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp88aroryp.d(102): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp88aroryp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = numbers[0];\n    long currentMaxIndex = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n       \
    \ {\n            maxValue = numbers[i];\n            currentMax = numbers[i];\n\
    \            currentMaxIndex = i;\n        }\n        else\n        {\n      \
    \      currentMax = maxValue;\n            currentMaxIndex = i;\n        }\n \
    \   }\n    result[currentMaxIndex] = currentMax;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpj2xsh7_j.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285ce]\n??:? long[] tmpj2xsh7_j.rolling_max(long[]) [0x427e62]\n??:?
    void tmpj2xsh7_j.__unittest_L33_C1() [0x427fae]\n??:? void tmpj2xsh7_j.__modtest()
    [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289e0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428967]\n??:? _d_run_main [0x4288d2]\n??:? main [0x4282af]\n??:?
    __libc_start_main [0xafa38554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    result[max_so_far_pos]\
    \ = max_so_far;\n    for(int i = max_so_far_pos + 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    result[min_so_far_pos]\
    \ = min_so_far;\n    for(int i = min_so_far_pos + 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long avg_so_far\
    \ = 0;\n    long avg_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        avg_so_far += numbers[i];\n        if(numbers[i] > avg_so_far)\n\
    \        {\n            avg_so_far = numbers[i];\n            avg_so_far_pos =\
    \ i;\n        }\n    }\n    result[avg_so_far_pos] = avg_so_far;\n    for(int\
    \ i = avg_so_far_pos + 1; i < numbers.length; i++)\n    {\n        result[i] =\
    \ numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmzau1k4y.d(85): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpmzau1k4y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n-1;\
    \ i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n       \
    \     if(result[j] > result[i])\n            {\n                result[i] = result[j];\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n\
    \            if(result[j] < result[i])\n            {\n                result[i]\
    \ = result[j];\n            }\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            result[i] += result[j];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 12L, 24L, 24L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(int i = n-1; i >= 0; i--)\n    {\n        for(int\
    \ j = 0; j < i; j++)\n        {\n            result[i] *= result[j];\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw465fh5m.d(102): Error: found `unittest` instead of statement\n/tmp/tmpw465fh5m.d(111):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpw465fh5m.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw465fh5m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  result[i] = currentMax;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    long currentMin = minValue;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = currentMin;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        currentSum += numbers[i];\n        if(currentSum > sum)\n    \
    \    {\n            sum = currentSum;\n        }\n    }\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = 1;\n    long currentProduct = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        currentProduct *= numbers[i];\n        if(currentProduct\
    \ > product)\n        {\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppm365eck.d(96): Error: found `unittest` instead of statement\n/tmp/tmppm365eck.d(105):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppm365eck.d(105):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppm365eck.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long current = 0;\n    for (int i = 0; i < n; i++) {\n        current = numbers[i];\n\
    \        if (current > max) {\n            max = current;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpca_eowsq.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpca_eowsq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if (current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L,\
    \ 6L, 6L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long product = 1;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        product *= current;\n        result[i] = product;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ quotient element found until given moment\n    in the sequence.\n    >>> rolling_quotient([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphfkyqe3l.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphfkyqe3l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == maxValue)\n        {\n            result[maxIndex] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    int minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == minValue)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ avg = 0;\n    int count = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        count++;\n    }\n    avg = sum / count;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ avg)\n        {\n            result[i] = avg;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzuhfqran.d(101): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzuhfqran.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long[] result = new long[numbers.length];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n    \
    \    {\n            max = numbers[i];\n        }\n        result[i] = max;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long sum = 0;\n    long avg = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        avg = sum / numbers.length;\n        result[i] = avg;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> rolling_std([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n    long sum = 0;\n \
    \   long \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8wxtu1a3.d(94): Error: no identifier for declarator `long`\n/tmp/tmp8wxtu1a3.d(94):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8wxtu1a3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if (cur > max)\n        {\n            max = cur;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        cur =\
    \ numbers[i];\n        if (cur < min)\n        {\n            min = cur;\n   \
    \     }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n        if (sum / numbers.length == numbers.length)\n        {\n  \
    \          result[i] = sum / numbers.length;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph3oxkij1.d(92): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph3oxkij1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_so_far =\
    \ numbers[0];\n    long max_so_far_index = 0;\n    for (int i = 1; i < n; i++)\
    \ {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    for (int i = 1; i < n; i++) {\n        if (numbers[i] < max_so_far)\
    \ {\n            result[max_so_far_index] = max_so_far;\n        }\n        max_so_far\
    \ = numbers[i];\n        max_so_far_index = i;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmsugupv2.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmsugupv2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        max = numbers[i];\n        for(int\
    \ j = i; j < n; j++)\n        {\n            if(numbers[j] > max)\n          \
    \  {\n                max = numbers[j];\n            }\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        min = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            if(numbers[j] < min)\n            {\n                min\
    \ = numbers[j];\n            }\n        }\n        result[i] = min;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of element found until given moment\n    in the sequence.\n \
    \   >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L,\
    \ 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        sum = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            sum += numbers[j];\n        }\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L,\
    \ 6L, 6L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long prod = 1;\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        prod = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            prod *= numbers[j];\n        }\n        result[i] = prod;\n\
    \    }\n    return result;\n}\n/*\n From \nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphkm8hydl.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkm8hydl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    while(i < numbers.length)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ < min)\n            {\n                min = numbers[j];\n            }\n  \
    \      }\n        result[i] = min;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    while(i < numbers.length)\n    {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    double avg = sum / numbers.length;\n    while(i < numbers.length)\n\
    \    {\n        result[i] = numbers[i] - avg;\n        i++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long median = 0;\n    while(i < numbers.length)\n    {\n\
    \        median = (numbers[i]+numbers[i+1])/2;\n        for(int j = i; j < \n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0d12sgvo.d(98): Error: expression expected, not `unittest`\n/tmp/tmp0d12sgvo.d(99):
    Error: found `{` when expecting `;` following `for` condition\n/tmp/tmp0d12sgvo.d(100):
    Error: expression expected, not `alias`\n/tmp/tmp0d12sgvo.d(100): Error: found
    `candidate` when expecting `)`\n/tmp/tmp0d12sgvo.d(100): Error: found `=` instead
    of statement\n/tmp/tmp0d12sgvo.d(107): Error: found `End of File` when expecting
    `}` following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0d12sgvo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    result[max_so_far_index] = max_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    result[min_so_far_index] = min_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum_so_far = 0;\n    long sum_so_far_index = -1;\n  \
    \  for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum_so_far;\n    }\n    result[sum_so_far_index] = sum_so_far;\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2f3vin1s.d(85): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2f3vin1s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long max_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[max_index];\n        max_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_value =\
    \ numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[min_index];\n        min_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwsrwb4c6.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwsrwb4c6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkgqacuki.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\n/tmp/tmpkgqacuki.d(22): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkgqacuki.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_pos]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[min_so_far_pos] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_pos = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n        if(sum_so_far\
    \ >= numbers[i])\n        {\n            sum_so_far_pos = i;\n        }\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ sum_so_far)\n        {\n            result[sum_so_far_pos] = numbers[i];\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5pgoscya.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5pgoscya.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_index = -1;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[max_index] = max;\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long min_index = -1;\n    for\
    \ (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n            min_index = i;\n      \
    \  }\n    }\n    long[] result = new long[numbers.length];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n  \
    \  result[min_index] = min;\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    long sum = 0;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        sum += result[i];\n\
    \    }\n    result[0] = sum;\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    long sum = 0;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        sum += result[i];\n\
    \    }\n    double avg = sum / numbers.length;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7517988q.d(102): Error: found `unittest` instead of statement\n/tmp/tmp7517988q.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7517988q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max;\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpubio7mpq.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284a5]\n??:? void tmpubio7mpq.__unittest_L31_C1() [0x428029]\n??:?
    void tmpubio7mpq.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c583]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b416]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306a1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b50]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43062d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3ed]\n??:? runModuleUnitTests [0x42c359]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428968]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ef]\n??:? _d_run_main [0x42885a]\n??:? main [0x42823b]\n??:?
    __libc_start_main [0x44b1a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = maxIndex; i < numbers.length; i++)\n    {\n      \
    \  result[i - maxIndex] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = minIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i - minIndex] = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[i] = sum;\n        }\n        else\n        {\n            result[i]\
    \ = sum / sumIndex;\n        }\n        sumIndex++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[i] = \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph2zthf0k.d(100): Error: expression expected, not `unittest`\n/tmp/tmph2zthf0k.d(101):
    Error: found `{` when expecting `;` following statement\n/tmp/tmph2zthf0k.d(109):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmph2zthf0k.d(109):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2zthf0k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] + numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] / 2;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplr8kadqk.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplr8kadqk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            result[max_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_value = numbers[0];\n\
    \    long min_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            result[min_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        long avg = sum / count;\n        result[i] = avg;\n   \
    \     sum += numbers[i];\n        count++;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long count = 0;\n    \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgbjmxzjo.d(100): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgbjmxzjo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = std.math.max(result[i], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzyg8zvw4.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\n/tmp/tmpzyg8zvw4.d(22): Error: undefined
    identifier `max` in module `std.math`, did you mean function `fmax`?\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzyg8zvw4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkgqacuki.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\n/tmp/tmpkgqacuki.d(22): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkgqacuki.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        if(sum == numbers[i])\n        {\n       \
    \     sumIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[sumIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long product\
    \ = 1;\n    long productIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        product *= numbers[i];\n        if(product == numbers[i])\n  \
    \      {\n            productIndex = i;\n        }\n    }\n    long[] result =\
    \ new long[numbers.length];\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0b7hrbyw.d(101): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0b7hrbyw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    long\
    \ cur = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        max = cur;\n        \n        for(; i < numbers.length && numbers[i]\
    \ > cur; i++)\n        {\n            max = cur;\n            cur = numbers[i];\n\
    \        }\n        \n        result[i] = max;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    long cur = 0;\n    \n    for(; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        min = cur;\n        \n        for(;\
    \ i < numbers.length && numbers[i] < cur; i++)\n        {\n            min = cur;\n\
    \            cur = numbers[i];\n        }\n        \n        result[i] = min;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    long cur = 0;\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        sum = cur;\n        \n        for(; i < numbers.length && numbers[i]\
    \ > cur; i++)\n        {\n            sum = cur;\n            cur = numbers[i];\n\
    \        }\n        \n        result[i] = sum;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbc8n4kp_.d(105): Error: no identifier for declarator `long`\n/tmp/tmpbc8n4kp_.d(105):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbc8n4kp_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = numbers[0];\n\
    \    long max_so_far = numbers[0];\n    for (int i = 1; i < n; i++) {\n      \
    \  if (numbers[i] > max) {\n            max = numbers[i];\n            max_so_far\
    \ = max;\n        }\n    }\n    result[0] = max_so_far;\n    for (int i = 1; i\
    \ < n; i++) {\n        result[i] = numbers[i];\n        if (numbers[i] > max_so_far)\
    \ {\n            result[i] = max_so_far;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = numbers[0];\n    long min_so_far = numbers[0];\n    for (int i\
    \ = 1; i < n; i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n\
    \            min_so_far = min;\n        }\n    }\n    result[0] = min_so_far;\n\
    \    for (int i = 1; i < n; i++) {\n        result[i] = numbers[i];\n        if\
    \ (numbers[i] < min_so_far) {\n            result[i] = min_so_far;\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long count = 0;\n  \
    \  for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    long max_so_far = numbers[0];\n    long\
    \ min_so_far = numbers[0];\n    for (int i = 1; i < n; i++) {\n        if (numbers[i]\
    \ > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        if\
    \ (numbers[i] < min_so_far) {\n            min_so_far = numbers[i];\n        }\n\
    \    }\n    result[0] = max_so_far;\n    result[1] = min_so_far;\n    for (int\
    \ i = 2; i < n; i++) {\n        result[i] = numbers[i];\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8zu4ik5t.d(91): Error: found `unittest` instead of statement\n/tmp/tmp8zu4ik5t.d(100):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zu4ik5t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; ++i)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; ++i)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min_value)\n\
    \        {\n            min_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; ++i)\n    {\n        result[i] = min_value;\n        min_value\
    \ -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n    }\n    for(;\
    \ i < numbers.length; ++i)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum -= numbers[i] * result[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; ++i)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; ++i)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum -= numbers[i] * \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp51of6q76.d(98): Error: expression expected, not `unittest`\n/tmp/tmp51of6q76.d(99):
    Error: found `{` when expecting `;` following statement\n/tmp/tmp51of6q76.d(107):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51of6q76.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far_index;\n        }\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far_index;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long avg_so_far = numbers[0];\n    long avg_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > avg_so_far)\n\
    \        {\n            avg_so_far = numbers[i];\n            avg_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == avg_so_far)\n        {\n            result[i] = avg_so_far_index;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> \nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuslmhgwj.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuslmhgwj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling count element found until given moment\n    in the sequence.\n\
    \    >>> rolling_count([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4706ed32.d(92): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4706ed32.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       min_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(i\
    \ + numbers.length / 2) % numbers.length];\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn3row1cx.d(95): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn3row1cx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            result[max_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[min_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum_so_far = 0;\n    long sum_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        sum_so_far_index += i;\n    }\n    long avg_so_far =\
    \ sum_so_far / sum_so_far_index;\n    long avg_so_far_index = sum_so_far_index;\n\
    \    for(int i = 1; i < numbers.length; i++)\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4gr348co.d(83): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4gr348co.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpi7sdjxyl.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428566]\n??:? long[] tmpi7sdjxyl.rolling_max(long[]) [0x427e62]\n??:?
    void tmpi7sdjxyl.__unittest_L26_C1() [0x427f4a]\n??:? void tmpi7sdjxyl.__modtest()
    [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428978]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ff]\n??:? _d_run_main [0x42886a]\n??:? main [0x42824b]\n??:?
    __libc_start_main [0x4feec554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long index = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            index = i;\n        }\n\
    \    }\n    result[index] = max;\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            index = i;\n \
    \       }\n    }\n    result[index] = min;\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 3L, 6L, 10L, 6L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        if(sum > 0)\n        {\n            index\
    \ = i;\n        }\n    }\n    result[index] = sum;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 4L, 3L, 4L, 5L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        if(sum > 0)\n        {\n            index\
    \ = i;\n        }\n    }\n    double avg = sum / numbers.length;\n    result[index]\
    \ = avg;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp21vvaubp.d(96): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp21vvaubp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    while(i < numbers.length)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n        \n        result[i] = max;\n\
    \        i++;\n    }\n    \n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = 0;\n    int i\
    \ = 0;\n    \n    while(i < numbers.length)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n        \n        result[i]\
    \ = min;\n        i++;\n    }\n    \n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    \n \
    \   while(i < numbers.length)\n    {\n        result[i] = numbers[i] + numbers[i\
    \ + 1];\n        i++;\n    }\n    \n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    \n \
    \   while(i < numbers.length)\n    {\n        result[i] = numbers[i] + numbers[i\
    \ + 1];\n        i++;\n    }\n    \n    long sum = 0;\n    for(long number : result)\n\
    \    {\n        sum += number;\n    }\n    \n    double average = sum / result.length;\n\
    \    \n    for(long number : result)\n    {\n        number /= average;\n    }\n\
    \    \n    return result;\n}\n/*\n From a given array of \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqnozcwwd.d(94): Error: semicolon expected, not `:`\n/tmp/tmpqnozcwwd.d(94):
    Error: expression expected, not `:`\n/tmp/tmpqnozcwwd.d(94): Error: found `result`
    when expecting `;` following `for` condition\n/tmp/tmpqnozcwwd.d(101): Error:
    semicolon expected, not `:`\n/tmp/tmpqnozcwwd.d(101): Error: expression expected,
    not `:`\n/tmp/tmpqnozcwwd.d(101): Error: found `result` when expecting `;` following
    `for` condition\n/tmp/tmpqnozcwwd.d(108): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqnozcwwd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ ++i)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_pos = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n \
    \   {\n        result[i] = numbers[max_pos];\n        max_pos++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long min_value = numbers[0];\n    long\
    \ min_pos = 0;\n    for(int i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_pos\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[min_pos];\n\
    \        min_pos++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling median element found until given moment\n    in the sequence.\n \
    \   >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4_ufvjyc.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4_ufvjyc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min = numbers[0];\n    long minIndex = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n     \
    \       min = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[minIndex];\n        minIndex++;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum % 2 == 0)\n        {\n\
    \            result[i] = numbers[numbers.length / 2];\n        }\n        else\n\
    \        {\n            result[i] = (numbers[numbers.length / 2] + numbers[numbers.length\
    \ / 2 - 1]) / 2;\n        }\n    }\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp05ykfs6q.d(98): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp05ykfs6q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        sumIndex++;\n    }\n    long avg = sum / sumIndex;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[sumIndex - 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sumIndex++;\n    }\n    long avg = sum / sumIndex;\n    long sumSquare\
    \ = 0;\n    long sumSquare\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuw2y4jv9.d(98): Error: semicolon expected, not `unittest`\n/tmp/tmpuw2y4jv9.d(98):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpuw2y4jv9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = max_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far_index;\n        }\n        else\n\
    \        {\n            result[i] = min_so_far;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ if(sum_so_far >= numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum_so_far)\n        {\n            result[i]\
    \ = sum_so_far_index;\nunittest\n{\n    alias candidate = rolling_max;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnp70k76m.d(95): Error: found `unittest` instead of statement\n/tmp/tmpnp70k76m.d(104):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnp70k76m.d(104):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnp70k76m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int max = 0;\n    \n    while (j < numbers.length)\n    {\n    \
    \    if (numbers[j] > max)\n        {\n            max = numbers[j];\n       \
    \     k = j;\n        }\n        j++;\n    }\n    \n    while (i < numbers.length)\n\
    \    {\n        if (numbers[i] > max)\n        {\n            result[k] = numbers[i];\n\
    \            k++;\n        }\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int min = 0;\n    \n    while (j < numbers.length)\n\
    \    {\n        if (numbers[j] < min)\n        {\n            min = numbers[j];\n\
    \            k = j;\n        }\n        j++;\n    }\n    \n    while (i < numbers.length)\n\
    \    {\n        if (numbers[i] < min)\n        {\n            result[k] = numbers[i];\n\
    \            k++;\n        }\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    long sum = 0;\n    \n    while (j < numbers.length)\n\
    \    {\n        sum = sum + numbers[j];\n        j++;\n    }\n    \n    while\
    \ (i < numbers.length)\n    {\n        sum = sum + numbers[i];\n        result[k]\
    \ = sum;\n        k++;\n        i++;\n    }\n    \n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprtdhen6x.d(116): Error: no identifier for declarator `long`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprtdhen6x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n        }\n        else\n \
    \       {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L, 4L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sumIndex == 0)\n        {\n            result[i] = sum;\n        }\n\
    \        else\n        {\n            result[i] = sum - result[sumIndex];\n  \
    \      }\n        sumIndex++;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfh9tiw7t.d(108): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfh9tiw7t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            currentMax = maxValue;\n        }\n        else\n        {\n    \
    \        currentMax = maxValue;\n        }\n        result[i] = currentMax;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpp29bp3pq.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428596]\n??:? long[] tmpp29bp3pq.rolling_max(long[]) [0x427e62]\n??:?
    void tmpp29bp3pq.__unittest_L30_C1() [0x427f76]\n??:? void tmpp29bp3pq.__modtest()
    [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b456]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b90]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43066d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b42d]\n??:? runModuleUnitTests [0x42c399]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42892f]\n??:? _d_run_main [0x42889a]\n??:? main [0x428277]\n??:?
    __libc_start_main [0xe19e0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long cur = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur < min)\n        {\n            min = cur;\n        }\n       \
    \ result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n        result[i] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        sum += cur;\n        result[i] = sum\
    \ / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnu8q93zd.d(93): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnu8q93zd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long maxIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum / numbers.length ==\
    \ numbers[i])\n        {\n            result[i] = numbers[i];\n        }\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5qwwsb7e.d(94): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5qwwsb7e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n\
    \    while(i < numbers.length)\n    {\n        max = numbers[i];\n        \n \
    \       for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ > max)\n            {\n                max = numbers[j];\n            }\n  \
    \      }\n        \n        result[i] = max;\n        i++;\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprb52z0hl.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmprb52z0hl.__unittest_L34_C1() [0x428059]\n??:?
    void tmprb52z0hl.__modtest() [0x428258]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x42826b]\n??:?
    __libc_start_main [0x5447f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   int i = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    \n \
    \   for(i = 0; i < n; i++)\n    {\n        result[i] = max;\n    }\n    \n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min = 0;\n    int i = 0;\n    \n \
    \   for(i = 0; i < n; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        result[i] = min;\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    int i = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n        result[i] =\
    \ numbers[i];\n    }\n    \n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling product of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 6L, 6L, 24L, 24L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    int i = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n        result[i] =\
    \ numbers[i] * numbers[i];\n    }\n    \n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling quotient of element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu7yvh3kd.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu7yvh3kd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[maxIndex] = numbers[i];\n            maxIndex++;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnio55h86.d(38): unittest failure\n----------------\n??:?
    _d_unittestp [0x42850d]\n??:? void tmpnio55h86.__unittest_L33_C1() [0x42808d]\n??:?
    void tmpnio55h86.__modtest() [0x42828c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b47e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430709]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430695]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b455]\n??:? runModuleUnitTests [0x42c3c1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289d0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428957]\n??:? _d_run_main [0x4288c2]\n??:? main [0x42829f]\n??:?
    __libc_start_main [0x15c7a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[0] = max;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    long minIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    result[0] = min;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    long avg = sum / count;\n    long sum2 = 0;\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        sum2 += numbers[i]\
    \ * numbers[i];\n    }\n    sum2 = sum2 / count;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] += avg;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmjm_anls.d(105): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjm_anls.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    result[0] = max_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[i] = max_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    result[0]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[i] = min_so_far;\n        }\n \
    \       else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = numbers[0];\n    long sum_so_far_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_pos = i;\n        }\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i = 1; i < numbers.length\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_7xnhgwh.d(94): Error: found `unittest` when expecting `;` following
    `for` condition\n/tmp/tmp_7xnhgwh.d(103): Error: found `void` when expecting `)`\n/tmp/tmp_7xnhgwh.d(103):
    Error: found `{` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_7xnhgwh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > currentMax)\n        {\n            result[i] = currentMax;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long currentMin\
    \ = minValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n        }\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            result[i] = currentMin;\n        }\n \
    \       else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        currentSum += numbers[i];\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > 0)\n        {\n            result[i] = currentSum / numbers[i];\n        }\n\
    \        else\n        {\n            result[i] = 0;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1zot214b.d(100): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zot214b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    result[max_pos] = max_value;\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_value\
    \ = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_pos = i;\n        }\n    }\n    result[min_pos]\
    \ = min_value;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long count = 0;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        count++;\n    }\n    long avg\
    \ = sum / count;\n    for(int i = 0; i < numbers.length; i++)\n    {\n       \
    \ result[i] = numbers[i] - avg;\n    }\n    long max_pos = 0;\nunittest\n{\n \
    \   alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi66oyerp.d(96): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi66oyerp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n        sum = numbers[i];\n    }\n\
    \    long median = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < median\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpys65hevy.d(103): Error: found `unittest` when expecting `)`\n/tmp/tmpys65hevy.d(112):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpys65hevy.d(112):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpys65hevy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    result[0] = max_value;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] >= max_value)\n        {\n            result[i]\
    \ = max_pos;\n        }\n        else\n        {\n            result[i] = result[i-1]\
    \ + 1;\n        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    long\
    \ min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_pos\
    \ = i;\n        }\n    }\n    result[0] = min_value;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] <= min_value)\n        {\n            result[i]\
    \ = min_pos;\n        }\n        else\n        {\n            result[i] = result[i-1]\
    \ + 1;\n        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long pos = 0;\n \
    \   for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum >= numbers[i])\n        {\n            pos = i;\n        }\n \
    \   }\n    result[0] = sum;\n    for(int i = 1; i < numbers.length; i++)\n   \
    \ {\n        if(sum >= numbers[i])\n        {\n            result[i] = pos;\n\
    \        }\n        else\n        {\n            result[i] = result[i-1] + 1;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling product element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n\
    \    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi56oy8z4.d(105): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi56oy8z4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max_value = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpzc54l_tf.d(14): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42856e]\n??:? long[] tmpzc54l_tf.rolling_max(long[]) [0x427e69]\n??:?
    void tmpzc54l_tf.__unittest_L31_C1() [0x427f52]\n??:? void tmpzc54l_tf.__modtest()
    [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c59b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b42e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430645]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b405]\n??:? runModuleUnitTests [0x42c371]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428980]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428907]\n??:? _d_run_main [0x428872]\n??:? main [0x428253]\n??:?
    __libc_start_main [0xde4e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for (int i = 0; i < n; i++) {\n        max = numbers[i];\n        for (int\
    \ j = i; j < n; j++) {\n            if (numbers[j] > max) {\n                max\
    \ = numbers[j];\n            }\n        }\n        result[i] = max;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        min = numbers[i];\n        for (int j = i; j < n; j++) {\n\
    \            if (numbers[j] < min) {\n                min = numbers[j];\n    \
    \        }\n        }\n        result[i] = min;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 9L, 9L, 9L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum = numbers[i];\n\
    \        for (int j = i; j < n; j++) {\n            sum += numbers[j];\n     \
    \   }\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 12L, 12L, 24L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long product = 1;\n    for (int i = 0; i < n; i++) {\n        product = numbers[i];\n\
    \        for (int j = i; j < n; j++) {\n            product *= numbers[j];\n \
    \       }\n        result[i] = product;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling quotient element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_quotient([1L, \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqacza9lt.d(91): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpqacza9lt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1m2lumkn.d(30): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284c5]\n??:? void tmp1m2lumkn.__unittest_L24_C1() [0x4280e2]\n??:?
    void tmp1m2lumkn.__modtest() [0x428244]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b436]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43064d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b40d]\n??:? runModuleUnitTests [0x42c379]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42890f]\n??:? _d_run_main [0x42887a]\n??:? main [0x428257]\n??:?
    __libc_start_main [0x98834554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpffruxasd.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x42849d]\n??:? void tmpffruxasd.__unittest_L28_C1() [0x428021]\n??:?
    void tmpffruxasd.__modtest() [0x428220]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c57b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b40e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430699]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b48]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430625]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3e5]\n??:? runModuleUnitTests [0x42c351]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428960]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288e7]\n??:? _d_run_main [0x428852]\n??:? main [0x428233]\n??:?
    __libc_start_main [0x60a90554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = -1;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long minIndex = -1;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sumOfSquares = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n  \
    \      sumOfSquares += numbers[i] * numbers[i];\n    }\n    long avg = sum / numbers.length;\n\
    \    long avgOfSquares = sumOfSquares / numbers.length;\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = avg;\n        result[i] +=\
    \ numbers[i] * numbers[i];\n    }\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] /= numbers.length;\n        result[i] += avgOfSquares;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long median = 0;\n    long medianOfSquares\
    \ = 0;\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp83c3bngg.d(92): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp83c3bngg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[max_index] = max;\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm\
    \ |>\n<| c |>\nThis is not the correct answer. Try it with the input `[1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]`\n<|/ c |>\n<| c |>\nYes, I didn't notice that he wanted\
    \ the max element in the last rolling window. I've updated my answer to reflect\
    \ that.\n<|/ c |>\n<| c |>\nThis is not the correct answer. Try it with the input\
    \ `[1L, 2L, 3L, 2L, 3L, 4L, 2L]`\n<|/ c |>\n<| c |>\nYes, I didn't notice that\
    \ he wanted the max element in the last rolling window. I've updated my answer\
    \ to reflect that.\n<|/ c |>\n<| a tags=c#,algorithm |>\nI wrote a little C# program\
    \ to test the performance of the different solutions proposed so far. \nThe program\
    \ is based on a test case where I generated a random sequence of integers between\
    \ 0 and 100000, and I ran the program several times to see how long it took to\
    \ run. \nThe program is as follows:\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_wr7u8jf.d(30): Error: declaration expected, not `<`\n/tmp/tmp_wr7u8jf.d(36):
    Error: unterminated character constant\n/tmp/tmp_wr7u8jf.d(36): Error: unterminated
    character constant\n/tmp/tmp_wr7u8jf.d(42): Error: unterminated character constant\n/tmp/tmp_wr7u8jf.d(42):
    Error: unterminated character constant\n/tmp/tmp_wr7u8jf.d(50): Error: semicolon
    expected, not `.`\n/tmp/tmp_wr7u8jf.d(50): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmp_wr7u8jf.d(51): Error: semicolon expected, not
    `.`\n/tmp/tmp_wr7u8jf.d(51): Error: no identifier for declarator `.Linq`\n/tmp/tmp_wr7u8jf.d(52):
    Error: semicolon expected, not `.`\n/tmp/tmp_wr7u8jf.d(52): Error: no identifier
    for declarator `.Text`\n/tmp/tmp_wr7u8jf.d(53): Error: semicolon expected, not
    `.`\n/tmp/tmp_wr7u8jf.d(53): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wr7u8jf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        max = cur;\n        for(int j = i; j < n; j++)\n        {\n         \
    \   if(numbers[j] > max)\n            {\n                max = numbers[j];\n \
    \           }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        min = cur;\n        for(int j = i; j < n;\
    \ j++)\n        {\n            if(numbers[j] < min)\n            {\n         \
    \       min = numbers[j];\n            }\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum = cur;\n \
    \       for(int j = i; j < n; j++)\n        {\n            sum += numbers[j];\n\
    \        }\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling product of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long prod = 1;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        prod = \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpse0rmhoy.d(101): Error: expression expected, not `unittest`\n/tmp/tmpse0rmhoy.d(102):
    Error: found `{` when expecting `;` following statement\n/tmp/tmpse0rmhoy.d(110):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpse0rmhoy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long\
    \ min_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n        }\n        result[i]\
    \ = min_so_far;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] + numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] / 2;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_var([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_var(long[] numbers) \n{\n    long\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu7w19w34.d(87): Error: no identifier for declarator `long`\n/tmp/tmpu7w19w34.d(87):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpu7w19w34.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far =\
    \ numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = min_so_far;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long average = sum / count;\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = average;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling standard deviation element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_std([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp5yldwhg.d(92): Error: found `unittest` when expecting `;` following
    statement\n/tmp/tmpp5yldwhg.d(101): Error: found `End of File` when expecting
    `}` following compound statement\n/tmp/tmpp5yldwhg.d(101): Error: found `End of
    File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpp5yldwhg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_var([1L, 2L, 3L, 2L, 3L, 4\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnskybe15.d(91): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnskybe15.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += result[i-1];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L,\
    \ 24L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] *= result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling quotient\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_quotient([1L,\
    \ 2L, 3L, \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa6u61lyw.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpa6u61lyw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n  \
    \  for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpjotu9ka_.d(12): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428576]\n??:? long[] tmpjotu9ka_.rolling_max(long[]) [0x427e4b]\n??:?
    void tmpjotu9ka_.__unittest_L27_C1() [0x427f5a]\n??:? void tmpjotu9ka_.__modtest()
    [0x428248]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b436]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43064d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b40d]\n??:? runModuleUnitTests [0x42c379]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42890f]\n??:? _d_run_main [0x42887a]\n??:? main [0x42825b]\n??:?
    __libc_start_main [0x1af69554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.max(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.min(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.add(result[i], numbers[i]) / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.add(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling count element found until given moment\n    in the sequence.\n  \
    \  >>> rolling_count([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg9vjmfg8.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpg9vjmfg8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n \
    \           maxIndex = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            result[i] = maxValue;\n        }\n        else\n     \
    \   {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpik8251xw.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428636]\n??:? long[] tmpik8251xw.rolling_max(long[]) [0x427e62]\n??:?
    void tmpik8251xw.__unittest_L37_C1() [0x42801a]\n??:? void tmpik8251xw.__modtest()
    [0x428308]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c663]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4f6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430781]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c30]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43070d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4cd]\n??:? runModuleUnitTests [0x42c439]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a48]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4289cf]\n??:? _d_run_main [0x42893a]\n??:? main [0x42831b]\n??:?
    __libc_start_main [0xe1f38554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpf221vkqe.d(12): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428566]\n??:? long[] tmpf221vkqe.rolling_max(long[]) [0x427e4b]\n??:?
    void tmpf221vkqe.__unittest_L24_C1() [0x427f4a]\n??:? void tmpf221vkqe.__modtest()
    [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428978]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ff]\n??:? _d_run_main [0x42886a]\n??:? main [0x42824b]\n??:?
    __libc_start_main [0xe4d0c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n        else\n        {\n            currentMax = maxValue;\n    \
    \    }\n        result[i] = currentMax;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n        else\n        {\n            currentMin =\
    \ minValue;\n        }\n        result[i] = currentMin;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        currentSum += numbers[i];\n    }\n\
    \    long average = currentSum / numbers.length;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = average - numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphze_129s.d(93): Error: found `unittest` instead of statement\n/tmp/tmphze_129s.d(102):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphze_129s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n \
    \           maxIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == maxValue)\n        {\n            result[i]\
    \ = maxIndex;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ minIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n \
    \           minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == minValue)\n        {\n            result[i]\
    \ = minIndex;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long avg = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    avg = sum / count;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == avg)\n\
    \        {\n            result[i] = avg;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg14utdyt.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg14utdyt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    long max = 0;\n    long maxIndex = 0;\n    \n    while(j < numbers.length)\n\
    \    {\n        max = numbers[j];\n        maxIndex = j;\n        \n        for(i\
    \ = j; i < numbers.length; i++)\n        {\n            if(numbers[i] > max)\n\
    \            {\n                max = numbers[i];\n                maxIndex =\
    \ i;\n            }\n        }\n        \n        result[k] = max;\n        j++;\n\
    \        k++;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprjwbula9.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284e5]\n??:? void tmprjwbula9.__unittest_L40_C1() [0x428065]\n??:?
    void tmprjwbula9.__modtest() [0x428264]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5c3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b456]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b90]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43066d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b42d]\n??:? runModuleUnitTests [0x42c399]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289a8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42892f]\n??:? _d_run_main [0x42889a]\n??:? main [0x428277]\n??:?
    __libc_start_main [0xbd618554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpidfh0dvl.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmpidfh0dvl.__unittest_L29_C1() [0x428055]\n??:?
    void tmpidfh0dvl.__modtest() [0x428254]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x428267]\n??:?
    __libc_start_main [0xf949d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == maxValue)\n        {\n            result[i] = maxIndex;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long minIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == minValue)\n        {\n            result[i] = minIndex;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long product = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n        result[i] = product;\n\
    \    }\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkr1wydxp.d(104): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkr1wydxp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpcclpj6ph.d(25): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428586]\n??:? long[] tmpcclpj6ph.rolling_max(long[]) [0x427f1a]\n??:?
    void tmpcclpj6ph.__unittest_L30_C1() [0x427ff2]\n??:? void tmpcclpj6ph.__modtest()
    [0x428258]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x42826b]\n??:?
    __libc_start_main [0x229a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max_value = numbers[0];\n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpnbwk6_jh.d(14): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285a6]\n??:? long[] tmpnbwk6_jh.rolling_max(long[]) [0x427e69]\n??:?
    void tmpnbwk6_jh.__unittest_L29_C1() [0x427f86]\n??:? void tmpnbwk6_jh.__modtest()
    [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b466]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43067d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b43d]\n??:? runModuleUnitTests [0x42c3a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42893f]\n??:? _d_run_main [0x4288aa]\n??:? main [0x428287]\n??:?
    __libc_start_main [0xee811554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_value)\n        {\n            result[max_pos] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 3L, 3L, 3L, 4L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_value = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_pos = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_value)\n        {\n            result[min_pos]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == avg)\n    \
    \    {\n            result[i] = avg;\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long count = 0;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprrmbcef0.d(100): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprrmbcef0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n     \
    \       result[i] = max;\n            max = numbers[i];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6ht2n5fc.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x428565]\n??:? void tmp6ht2n5fc.__unittest_L39_C1() [0x4280e5]\n??:?
    void tmp6ht2n5fc.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a28]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4289af]\n??:? _d_run_main [0x42891a]\n??:? main [0x4282f7]\n??:?
    __libc_start_main [0x43f37554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long min = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur < min)\n        {\n            min = cur;\n        }\n       \
    \ result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum of element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n        result[i] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling product of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long prod = 1;\n    long cur = 0;\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        prod *= cur;\n \
    \       result[i] = prod;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling quotient of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4aymmcua.d(93): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4aymmcua.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_so_far = numbers[0];\n    for(int i = 1; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n     \
    \       max = numbers[i];\n            max_so_far = max;\n        }\n        else\n\
    \        {\n            max_so_far = max(max_so_far, numbers[i]);\n        }\n\
    \    }\n    return new long[] {max_so_far, max};\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min = numbers[0];\n    long min_so_far = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            min_so_far = min;\n        }\n\
    \        else\n        {\n            min_so_far = min(min_so_far, numbers[i]);\n\
    \        }\n    }\n    return new long[] {min_so_far, min};\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    long sum2 = 0;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        sum2 += numbers[i] * numbers[i];\n  \
    \  }\n    long avg2 = sum2 / count;\n    return new long[] {avg2, avg};\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpch61i7g1.d(26): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpch61i7g1.d(26): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpch61i7g1.d(26): Deprecation: use `{ }` for an empty
    statement, not `;`\n/tmp/tmpch61i7g1.d(51): Error: found `{` when expecting `;`
    following `return` statement\n/tmp/tmpch61i7g1.d(51): Error: found `}` when expecting
    `;` following statement\n/tmp/tmpch61i7g1.d(51): Deprecation: use `{ }` for an
    empty statement, not `;`\n/tmp/tmpch61i7g1.d(76): Error: found `{` when expecting
    `;` following `return` statement\n/tmp/tmpch61i7g1.d(76): Error: found `}` when
    expecting `;` following statement\n/tmp/tmpch61i7g1.d(76): Deprecation: use `{
    }` for an empty statement, not `;`\n/tmp/tmpch61i7g1.d(95): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpch61i7g1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       min_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < median)\n        {\n            median\
    \ = numbers[i];\n        }\n        count++;\n\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp18z70kkp.d(99): Error: found `unittest` instead of statement\n/tmp/tmp18z70kkp.d(108):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18z70kkp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long i = 0;\n   \
    \ for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n      \
    \  {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n    }\n    long mid = numbers.length\
    \ / 2;\n    long left = 0;\n    long right = numbers.length - 1;\n    long midSum\
    \ = 0;\n    while(left < right)\n    {\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppot_1fub.d(101): Error: found `unittest` instead of statement\n/tmp/tmppot_1fub.d(110):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppot_1fub.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n\
    \    while(i < numbers.length)\n    {\n        max = numbers[i];\n        \n \
    \       for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ > max)\n            {\n                max = numbers[j];\n            }\n  \
    \      }\n        \n        result[i] = max;\n        i++;\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprb52z0hl.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmprb52z0hl.__unittest_L34_C1() [0x428059]\n??:?
    void tmprb52z0hl.__modtest() [0x428258]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x42826b]\n??:?
    __libc_start_main [0x5447f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    int i =\
    \ 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = sum -\
    \ numbers[i] * numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * numbers[i];\n    }\n    long median = 0;\n \
    \   for(\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0h12mnrm.d(101): Error: found `unittest` instead of statement\n/tmp/tmp0h12mnrm.d(106):
    Error: found `;` when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp0h12mnrm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n\
    \ - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdd92bhww.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\n/tmp/tmpdd92bhww.d(20): Error: undefined
    identifier `max`, did you mean function `fmax`?\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpdd92bhww.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    long max = 0;\n    long max2 = 0;\n    long max3 = 0;\n    long\
    \ max4 = 0;\n    long max5 = 0;\n    long max6 = 0;\n    long max7 = 0;\n    long\
    \ max8 = 0;\n    long max9 = 0;\n    long max10 = 0;\n    long max11 = 0;\n  \
    \  long max12 = 0;\n    long max13 = 0;\n    long max14 = 0;\n    long max15 =\
    \ 0;\n    long max16 = 0;\n    long max17 = 0;\n    long max18 = 0;\n    long\
    \ max19 = 0;\n    long max20 = 0;\n    long max21 = 0;\n    long max22 = 0;\n\
    \    long max23 = 0;\n    long max24 = 0;\n    long max25 = 0;\n    long max26\
    \ = 0;\n    long max27 = 0;\n    long max28 = 0;\n    long max29 = 0;\n    long\
    \ max30 = 0;\n    long max31 = 0;\n    long max32 = 0;\n    long max33 = 0;\n\
    \    long max34 = 0;\n    long max35 = 0;\n    long max36 = 0;\n    long max37\
    \ = 0;\n    long max38 = 0;\n    long max39 = 0;\n    long max40 = 0;\n    long\
    \ max41 = 0;\n    long max42 = 0;\n    long max43 = 0;\n    long max44 = 0;\n\
    \    long max45 = 0;\n    long max46 = 0;\n    long max47 = 0;\n    long max48\
    \ = 0;\n    long max49 = 0;\n    long max50 = 0;\n    long max51 = 0;\n    long\
    \ max52 = 0;\n    long max53 = 0;\n    long max54 = 0;\n    long max55 = 0;\n\
    \    long max56 = 0;\n    long max57 = 0;\n    long max58 = 0;\n    long max59\
    \ = 0;\n    long max60 = 0;\n    long max61 = 0;\n    long max62 = 0;\n    long\
    \ max63 = 0;\n    long max64 = 0;\n    long max65 = 0;\n    long max66 = 0;\n\
    \    long max67 = 0;\n    long max68 = 0;\n    long max69 = 0;\n    long max70\
    \ = 0;\n    long max71 = 0;\n    long max72 = 0;\n    long max73 = 0;\n    long\
    \ max74 = 0;\n    long max75 = 0;\n    long max76 = 0;\n    long max77 = 0;\n\
    \    long max78 = 0;\n    long max79 = 0;\n    long max80 = 0;\n    long max81\
    \ = 0;\n    long max82 = 0;\n    \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp651h8top.d(99): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp651h8top.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    long currentMax = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            currentMax\
    \ = numbers[i];\n            maxIndex = i;\n        }\n    }\n    result[0] =\
    \ currentMax;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            result[i] = numbers[maxIndex];\n     \
    \   }\n        else\n        {\n            result[i] = numbers[i];\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long minIndex = 0;\n    long currentMin\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n           \
    \ minIndex = i;\n        }\n    }\n    result[0] = currentMin;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < currentMin)\n\
    \        {\n            result[i] = numbers[minIndex];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sumIndex = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(sum > currentSum)\n        {\n            currentSum = sum;\n           \
    \ sumIndex = i;\n        }\n    }\n    result[0] = currentSum;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sum\
    \ > currentSum)\n        {\n            result[i] = numbers[sumIndex];\n     \
    \   }\n        else\n        {\n            result\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy3kvt96p.d(106): Error: found `unittest` when expecting `;`
    following statement\n/tmp/tmpy3kvt96p.d(115): Error: found `End of File` when
    expecting `}` following compound statement\n/tmp/tmpy3kvt96p.d(115): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmpy3kvt96p.d(115):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy3kvt96p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long minValue = numbers[0];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = minValue;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long median = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < median)\n        {\n            median = numbers[i];\n        }\n    }\n \
    \   for(; i < numbers.length; i++)\n    {\n        result[i] = median;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling standard deviation element found until given \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsogbta5g.d(100): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsogbta5g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    long index = 0;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n            maxIndex = i;\n        }\n    }\n   \
    \ long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[index]\
    \ = max;\n            index++;\n        }\n        else\n        {\n         \
    \   result[index] = numbers[i];\n            index++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpwyun851_.d(45): unittest failure\n----------------\n??:?
    _d_unittestp [0x42853d]\n??:? void tmpwyun851_.__unittest_L39_C1() [0x42815a]\n??:?
    void tmpwyun851_.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c61b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430739]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430be8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306c5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b485]\n??:? runModuleUnitTests [0x42c3f1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428987]\n??:? _d_run_main [0x4288f2]\n??:? main [0x4282cf]\n??:?
    __libc_start_main [0x410a2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for(int i = 0; i < n; ++i)\n    {\n        max = numbers[i];\n        for(int\
    \ j = i; j < n; ++j)\n        {\n            if(numbers[j] > max)\n          \
    \  {\n                max = numbers[j];\n            }\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdkp4je70.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdkp4je70.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if (cur > max)\n        {\n            max = cur;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = maxIndex; i < numbers.length; i++)\n    {\n      \
    \  result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    for(int i = minIndex; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        if(sum == 0)\n        {\n            sumIndex = i;\n\
    \        }\n    }\n    for(int i = sumIndex; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sum == 0)\n        {\n          \
    \  sumIndex = i;\n        }\n    }\n    for(int \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzdv1ni5l.d(102): Error: no identifier for declarator `int`\n/tmp/tmpzdv1ni5l.d(102):
    Error: expression expected, not `unittest`\n/tmp/tmpzdv1ni5l.d(103): Error: found
    `{` when expecting `;` following `for` condition\n/tmp/tmpzdv1ni5l.d(104): Error:
    expression expected, not `alias`\n/tmp/tmpzdv1ni5l.d(104): Error: found `candidate`
    when expecting `)`\n/tmp/tmpzdv1ni5l.d(104): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzdv1ni5l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    int\
    \ i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n        }\n  \
    \  }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i] = max_value;\n\
    \        max_value += numbers[i];\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp2circkg3.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285a6]\n??:? long[] tmp2circkg3.rolling_max(long[]) [0x427e62]\n??:?
    void tmp2circkg3.__unittest_L32_C1() [0x427f86]\n??:? void tmp2circkg3.__modtest()
    [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b466]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43067d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b43d]\n??:? runModuleUnitTests [0x42c3a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42893f]\n??:? _d_run_main [0x4288aa]\n??:? main [0x428287]\n??:?
    __libc_start_main [0xf0625554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n\
    \ - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i + 1]);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = min(result[i], numbers[i + 1]);\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        result[i] = sum(result[i],\
    \ numbers[i + 1]);\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n\
    \ - 1; i >= 0; i--)\n    {\n        result[i] = sum(result[i], numbers[i + 1])\
    \ / numbers[i + 1];\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7n55qvw.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpi7n55qvw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[max_so_far_index] = numbers[i];\n        max_so_far_index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp91e6bifc.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285ae]\n??:? long[] tmp91e6bifc.rolling_max(long[]) [0x427e62]\n??:?
    void tmp91e6bifc.__unittest_L30_C1() [0x427f92]\n??:? void tmp91e6bifc.__modtest()
    [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b46e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430685]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b445]\n??:? runModuleUnitTests [0x42c3b1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289c0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428947]\n??:? _d_run_main [0x4288b2]\n??:? main [0x428293]\n??:?
    __libc_start_main [0x26d2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp0s72t1bj.d(23): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42853e]\n??:? long[] tmp0s72t1bj.rolling_max(long[]) [0x427ee1]\n??:?
    void tmp0s72t1bj.__unittest_L26_C1() [0x427f22]\n??:? void tmp0s72t1bj.__modtest()
    [0x428210]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c56b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430689]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b38]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430615]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3d5]\n??:? runModuleUnitTests [0x42c341]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428950]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288d7]\n??:? _d_run_main [0x428842]\n??:? main [0x428223]\n??:?
    __libc_start_main [0xaed13554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_i = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_i = i;\n        }\n    }\n    result[0] = max_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[i] = max_so_far_i;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min_so_far = numbers[0];\n    long min_so_far_i = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n            min_so_far_i = i;\n\
    \        }\n    }\n    result[0] = min_so_far;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            result[i]\
    \ = min_so_far_i;\n        }\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n\
    \    long sum_so_far_i = 0;\n    for(int i = 1; i < numbers.length; i++)\n   \
    \ {\n        sum_so_far += numbers[i];\n        sum_so_far_i = i;\n    }\n   \
    \ result[0] = sum_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        sum_so_far += numbers[i];\n        result[i] = sum_so_far_i;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    \nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph89s0j00.d(88): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph89s0j00.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n     \
    \       result[i] = max;\n            max = numbers[i];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfc81v5jq.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x428565]\n??:? void tmpfc81v5jq.__unittest_L39_C1() [0x4280e5]\n??:?
    void tmpfc81v5jq.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a28]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4289af]\n??:? _d_run_main [0x42891a]\n??:? main [0x4282f7]\n??:?
    __libc_start_main [0x6ea79554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long max_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[max_index];\n        max_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_value =\
    \ numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[min_index];\n        min_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 3L, 6L, 10L, 6L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    long sum = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += result[i];\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 6L, 24L, 6L, 24L, 120L, 24L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    long product = 1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       product *= \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7qn0mrwi.d(100): Error: expression expected, not `unittest`\n/tmp/tmp7qn0mrwi.d(101):
    Error: found `{` when expecting `;` following statement\n/tmp/tmp7qn0mrwi.d(109):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7qn0mrwi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n\
    \        {\n            min_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = min_value;\n        min_value\
    \ -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            result[i] += numbers[j];\n        }\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling product element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L,\
    \ 12L, 12L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            result[i] *= numbers[j];\n        }\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling quotient element found until given moment\n\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqc6kphsc.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpqc6kphsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_value)\n        {\n            result[max_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_value = numbers[0];\n\
    \    long min_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_value)\n        {\n            result[min_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / number\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvkh22a6s.d(100): Error: found `unittest` when expecting `;`
    following statement\n/tmp/tmpvkh22a6s.d(109): Error: found `End of File` when
    expecting `}` following compound statement\n/tmp/tmpvkh22a6s.d(109): Error: found
    `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpvkh22a6s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if(current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if(current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product of element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 6L, 12L, 24L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long product = 1;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        product *= current;\n        result[i] = product;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L,\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0wtphqai.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp0wtphqai.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long\
    \ sum = 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumIndex++;\n    }\n    long avg =\
    \ sum / sumIndex;\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    Arrays.sort(numbers);\n    for(int i = 0; i < \n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpke2n4dwd.d(105): Error: expression expected, not `unittest`\n/tmp/tmpke2n4dwd.d(106):
    Error: found `{` when expecting `;` following `for` condition\n/tmp/tmpke2n4dwd.d(107):
    Error: expression expected, not `alias`\n/tmp/tmpke2n4dwd.d(107): Error: found
    `candidate` when expecting `)`\n/tmp/tmpke2n4dwd.d(107): Error: found `=` instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpke2n4dwd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n        maxValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = minValue;\n        minValue\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ *= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling quotient element found until given moment\n   \
    \ in the sequence.\n    >>> rolling_quotient([1\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp66stnave.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp66stnave.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        max = Math.max(max, current);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a |>\n<code>\npublic static\
    \ void main(String[] args) {\n    int[] arr = {1, 2, 3, 4, 5};\n    System.out.println(Arrays.toString(rolling_max(arr)));\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7mfzo5y3.d(23): Error: declaration expected, not `<`\n/tmp/tmp7mfzo5y3.d(29):
    Error: identifier expected following `.` instead of `out`\n/tmp/tmp7mfzo5y3.d(29):
    Error: no identifier for declarator `System`\n/tmp/tmp7mfzo5y3.d(29): Error: declaration
    expected, not `out`\n/tmp/tmp7mfzo5y3.d(30): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7mfzo5y3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = numbers[0];\n\
    \    long max_so_far = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n  \
    \      if(numbers[i] > max)\n        {\n            max = numbers[i];\n      \
    \  }\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far =\
    \ numbers[i];\n        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n     \
    \   result[i] = max_so_far;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/10845146)\n<|/ c |>\n<| c |>\nThis does provide\
    \ an answer to the question. He wants to find the maximum element in a rolling\
    \ window of size n. He also wants to know which element was the maximum element\
    \ in the window and which was the maximum element in the entire array. He also\
    \ wants to know which element was the maximum element in the window and which\
    \ was the maximum element in the entire array. He also wants to know which element\
    \ was the maximum element in the window and which was the maximum element in the\
    \ entire array. He also wants to know which element was the maximum element in\
    \ the window and which was the maximum element in the entire array. He also wants\
    \ to know which element was the maximum element in the window and which was the\
    \ maximum element in the entire array. He also wants to know which element was\
    \ the maximum element in the window and which was the maximum element in the entire\
    \ array. He also wants to know which element was the maximum element in the window\
    \ and which was the maximum element in the entire array. He also wants to know\
    \ which element was the maximum element in the window and which was the maximum\
    \ element in the entire array. He also wants to know which element was the maximum\
    \ element in the window and which was the maximum element in the entire array.\
    \ He also wants to know which element was the maximum element in the window and\
    \ which was the maximum element in the entire array. He also wants to know which\
    \ element was the maximum element in the window and which was the maximum element\
    \ in the entire array.\n<|/ c |>\n<| c |>\nThis does not provide an answer to\
    \ the question. To critique or request clarification from an author, leave a comment\
    \ below their post. - [From Review](/review/low-quality-\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8g54zrw.d(33): Error: declaration expected, not `<`\n/tmp/tmpc8g54zrw.d(47):
    Error: declaration expected, not `assert`\n/tmp/tmpc8g54zrw.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmpc8g54zrw.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmpc8g54zrw.d(50): Error: declaration expected, not `assert`\n/tmp/tmpc8g54zrw.d(51):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8g54zrw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the array is empty or contains only a single element\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if you pass in an empty array. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| a tags=c#,arrays,algorithm |>\n<code>\npublic static int[] GetMax(int[]\
    \ array)\n{\n    int max = 0;\n    int maxIndex = 0;\n    for (int i = 0; i <\
    \ array.Length; i++)\n    {\n        if (array[i] > max)\n        {\n        \
    \    max = array[i];\n            maxIndex = i;\n        }\n    }\n    int[] result\
    \ = new int[array.Length];\n    for (int i = 0; i < array.Length; i++)\n    {\n\
    \        result[i] = array[maxIndex];\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't work if the array is empty or contains\
    \ only a single element\n<|/ c |>\n<| c |>\nIt works with empty array and single\
    \ element. Try it yourself.\n<|/ c |>\n<| c |>\nIt works with empty array and\
    \ single element. Try it yourself.\n<|/ c |>\n<| c |>\nIt works with empty array\
    \ and single element. Try it yourself.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic\
    \ static int[] GetMax(int[] array)\n{\n    int max = 0;\n    int maxIndex = 0;\n\
    \    for (int i = 0; i < array.Length; i++)\n    {\n        if (array[i] > max)\n\
    \        {\n            max = array[i];\n            maxIndex = i;\n        }\n\
    \    }\n    int[] result = new int[array.Length];\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[i] = array[maxIndex];\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,array\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpykgholfq.d(29): Error: declaration expected, not `<`\n/tmp/tmpykgholfq.d(32):
    Error: unterminated character constant\n/tmp/tmpykgholfq.d(38): Error: unterminated
    character constant\n/tmp/tmpykgholfq.d(52): Error: declaration expected, not `for`\n/tmp/tmpykgholfq.d(52):
    Error: no identifier for declarator `i`\n/tmp/tmpykgholfq.d(52): Error: declaration
    expected, not `<`\n/tmp/tmpykgholfq.d(52): Error: no identifier for declarator
    `i`\n/tmp/tmpykgholfq.d(52): Error: declaration expected, not `++`\n/tmp/tmpykgholfq.d(57):
    Error: no identifier for declarator `maxIndex`\n/tmp/tmpykgholfq.d(57): Error:
    declaration expected, not `=`\n/tmp/tmpykgholfq.d(58): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpykgholfq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long min = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long sum = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n        sum = numbers[i];\n    }\n\
    \    long median = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < median\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0goy8j54.d(103): Error: found `unittest` when expecting `)`\n/tmp/tmp0goy8j54.d(112):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0goy8j54.d(112):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0goy8j54.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum % 2 == 0)\n        {\n\
    \            result[i] = numbers[numbers.length / 2 - 1];\n        }\n       \
    \ else\n        {\n            result[i] = numbers[numbers.length / 2];\n    \
    \    }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling standard deviation \nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp98es0k39.d(98): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp98es0k39.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    for(int i = maxIndex; i < numbers.length; i++)\n    {\n      \
    \  result[maxIndex] = numbers[i];\n        maxIndex++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = minIndex; i < numbers.length;\
    \ i++)\n    {\n        result[minIndex] = numbers[i];\n        minIndex++;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ sumIndex++;\n    }\n    for(int i = sumIndex; i < numbers.length; i++)\n   \
    \ {\n        result[sumIndex] = numbers[i] - sum / sumIndex;\n        sumIndex++;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long median = 0;\n    long medianIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < \n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpspxjajrb.d(96): Error: expression expected, not `unittest`\n/tmp/tmpspxjajrb.d(97):
    Error: found `{` when expecting `)`\n/tmp/tmpspxjajrb.d(105): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpspxjajrb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    long max = 0;\n    long current = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        for(; j < i; j++)\n    \
    \    {\n            if(numbers[j] > current)\n            {\n                max\
    \ = current;\n                k = j;\n            }\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp74tazpn_.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284b5]\n??:? void tmp74tazpn_.__unittest_L34_C1() [0x428035]\n??:?
    void tmp74tazpn_.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428978]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ff]\n??:? _d_run_main [0x42886a]\n??:? main [0x428247]\n??:?
    __libc_start_main [0x5b6cf554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=java,arrays,algorithm |>\n<code>\npublic class MaxRoller {\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo5vy2yuk.d(26): Error: declaration expected, not `<`\n/tmp/tmpo5vy2yuk.d(35):
    Error: declaration expected, not `assert`\n/tmp/tmpo5vy2yuk.d(36): Error: declaration
    expected, not `assert`\n/tmp/tmpo5vy2yuk.d(37): Error: declaration expected, not
    `assert`\n/tmp/tmpo5vy2yuk.d(38): Error: declaration expected, not `assert`\n/tmp/tmpo5vy2yuk.d(39):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5vy2yuk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur < min)\n        {\n            min = cur;\n        }\n       \
    \ result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n    }\n    double avg = sum / numbers.length;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        result[i]\
    \ = avg;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n    }\n    double avg = sum / numbers.length;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        cur = numbers[i];\n        result[i]\
    \ = avg;\n    }\n    long middle = numbers.length / 2;\n    for(int \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkpju6pu2.d(99): Error: no identifier for declarator `int`\n/tmp/tmpkpju6pu2.d(99):
    Error: expression expected, not `unittest`\n/tmp/tmpkpju6pu2.d(100): Error: found
    `{` when expecting `;` following `for` condition\n/tmp/tmpkpju6pu2.d(101): Error:
    expression expected, not `alias`\n/tmp/tmpkpju6pu2.d(101): Error: found `candidate`
    when expecting `)`\n/tmp/tmpkpju6pu2.d(101): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkpju6pu2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i <\
    \ numbers.length; i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpaq6yru_x.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmpaq6yru_x.__unittest_L32_C1() [0x428055]\n??:?
    void tmpaq6yru_x.__modtest() [0x428254]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x428267]\n??:?
    __libc_start_main [0xdfaef554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long maxIndex = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] < min)\n        {\n            min = numbers[i];\n   \
    \         minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling variance element found until given moment\n\
    \    in the sequence.\n    >>> rolling_var([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz6a2e_ds.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpz6a2e_ds.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[i]\
    \ = min_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = (numbers[i] / count);\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6_ow8_lb.d(92): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp6_ow8_lb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n        result[i] = max;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] + numbers[i\
    \ + 1];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product of element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 6L, 2L, 6L, 12L, 12L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * numbers[i + 1];\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ quotient of element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_quotient(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfuay60kc.d(90): Error: expression expected, not `unittest`\n/tmp/tmpfuay60kc.d(91):
    Error: found `{` when expecting `;` following statement\n/tmp/tmpfuay60kc.d(99):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfuay60kc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_so_far =\
    \ numbers[0];\n    long max_so_far_pos = 0;\n    for (int i = 1; i < n; ++i) {\n\
    \        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    result[max_so_far_pos]\
    \ = max_so_far;\n    for (int i = max_so_far_pos + 1; i < n; ++i) {\n        result[i]\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 2L, 3L, 3L, 3L, 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long min_so_far =\
    \ numbers[0];\n    long min_so_far_pos = 0;\n    for (int i = 1; i < n; ++i) {\n\
    \        if (numbers[i] < min_so_far) {\n            min_so_far = numbers[i];\n\
    \            min_so_far_pos = i;\n        }\n    }\n    result[min_so_far_pos]\
    \ = min_so_far;\n    for (int i = min_so_far_pos + 1; i < n; ++i) {\n        result[i]\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    long sum_so_far = 0;\n\
    \    long sum_so_far_pos = 0;\n    for (int i = 1; i < n; ++i) {\n        sum_so_far\
    \ += numbers[i];\n        if (sum_so_far >= sum_so_far_pos) {\n            sum_so_far_pos\
    \ = i;\n        }\n    }\n    result[sum_so_far_pos] = sum_so_far;\n    for (int\
    \ i = sum_so_far_pos + 1; i < n; ++i) {\n        result[i] = numbers[i];\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp69dhpppy.d(78): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp69dhpppy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    foreach(long\
    \ number in numbers) {\n        if(number > max) {\n            max = number;\n\
    \        }\n        result[i++] = max;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg5szscdu.d(15): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg5szscdu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = avg;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(numbers.length\
    \ - 1) - std.math.floor((numbers.length - 1) / 2)];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ devi\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcil0akiz.d(95): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcil0akiz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    long\
    \ max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_value)\n        {\n            result[i]\
    \ = max_value;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    long\
    \ min_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_value)\n        {\n            result[i]\
    \ = min_value;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] / count;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    long count = 0;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcruam9yo.d(104): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcruam9yo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[0] = max_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[i] = numbers[max_so_far_index];\n        }\n  \
    \      else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    result[0] = min_so_far;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            result[i] = numbers[min_so_far_index];\n        }\n  \
    \      else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ if(sum_so_far >= numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9idby08l.d(94): Error: semicolon expected, not `unittest`\n/tmp/tmp9idby08l.d(94):
    Error: expression expected, not `unittest`\n/tmp/tmp9idby08l.d(95): Error: found
    `{` when expecting `;` following `for` condition\n/tmp/tmp9idby08l.d(96): Error:
    expression expected, not `alias`\n/tmp/tmp9idby08l.d(96): Error: found `candidate`
    when expecting `)`\n/tmp/tmp9idby08l.d(96): Error: found `=` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9idby08l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n \
    \           maxIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == maxValue)\n        {\n            result[i]\
    \ = maxIndex;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 2L, 2L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ minIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n \
    \           minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == minValue)\n        {\n            result[i]\
    \ = minIndex;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    long average = sum / count;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] == average)\n       \
    \ {\n            result[i] = average;\n        }\n        else\n        {\n  \
    \          result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg47w9whz.d(108): Error: no identifier for declarator `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg47w9whz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpa49k_8ss.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42856e]\n??:? long[] tmpa49k_8ss.rolling_max(long[]) [0x427e62]\n??:?
    void tmpa49k_8ss.__unittest_L28_C1() [0x427f52]\n??:? void tmpa49k_8ss.__modtest()
    [0x428240]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c59b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b42e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430645]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b405]\n??:? runModuleUnitTests [0x42c371]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428980]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428907]\n??:? _d_run_main [0x428872]\n??:? main [0x428253]\n??:?
    __libc_start_main [0x839fa554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur < min)\n        {\n            min = cur;\n        }\n       \
    \ result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L,\
    \ 6L, 6L, 9L, 9L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n        result[i] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n    }\n    long avg = sum / numbers.length;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9dt00pjj.d(93): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp9dt00pjj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   int i = 0;\n    \n    while(i < numbers.length)\n    {\n        cur = numbers[i];\n\
    \        max = cur;\n        \n        for(i++; i < numbers.length; i++)\n   \
    \     {\n            if(numbers[i] > max)\n            {\n                max\
    \ = numbers[i];\n            }\n        }\n        \n        result[i] = max;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpwueqeolz.d(30): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42857e]\n??:? long[] tmpwueqeolz.rolling_max(long[]) [0x427f11]\n??:?
    void tmpwueqeolz.__unittest_L35_C1() [0x427fe6]\n??:? void tmpwueqeolz.__modtest()
    [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428917]\n??:? _d_run_main [0x428882]\n??:? main [0x42825f]\n??:?
    __libc_start_main [0x4c2cd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpc2yn5d1c.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428566]\n??:? long[] tmpc2yn5d1c.rolling_max(long[]) [0x427e62]\n??:?
    void tmpc2yn5d1c.__unittest_L26_C1() [0x427f4a]\n??:? void tmpc2yn5d1c.__modtest()
    [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428978]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ff]\n??:? _d_run_main [0x42886a]\n??:? main [0x42824b]\n??:?
    __libc_start_main [0x45e06554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    foreach(long n in numbers) {\n        if (max < n) {\n            max = n;\n\
    \        }\n        result[i] = max;\n        i++;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjnzgy3qg.d(16): Error: found `in` when expecting `;`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjnzgy3qg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmhsybiu4.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpmhsybiu4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpeic8pg76.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmpeic8pg76.__unittest_L29_C1() [0x428055]\n??:?
    void tmpeic8pg76.__modtest() [0x428254]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x428267]\n??:?
    __libc_start_main [0xdc2dd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n    }\n    for(int i = 0; i < n; i++)\n\
    \    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = sum / n;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < n; i++)\n\
    \    {\n        result[i] = sum / n;\n    }\n    long mid = sum / n;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        if(numbers[i] < mid)\n        {\n       \
    \     result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of roll\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuficmu71.d(105): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuficmu71.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long cur = 0;\n    for (int i = 0; i < n; ++i) {\n        cur = numbers[i];\n\
    \        if (cur > max) {\n            max = cur;\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf214k3ax.d(12): Error: cannot implicitly convert expression
    `numbers.length` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpf214k3ax.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min = numbers[0];\n    long minIndex = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n     \
    \       min = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[minIndex];\n        minIndex++;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(int)\
    \ (i + 1)/2 - 1];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of roll\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3bsw_778.d(93): Error: C style cast illegal, use `cast(int)(i
    + 1)`\n/tmp/tmp3bsw_778.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3bsw_778.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long\
    \ max = numbers[0];\n    \n    while(i < numbers.length)\n    {\n        max =\
    \ std.math.reduce(max, numbers[i++]);\n        \n        if(max != numbers[i])\n\
    \        {\n            result[j++] = max;\n            max = numbers[i];\n  \
    \      }\n    }\n    \n    result[j++] = max;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvy_gtw87.d(19): Error: undefined identifier `reduce` in module
    `std.math`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvy_gtw87.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_index = -1;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpzrp2jms0.d(12): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285ae]\n??:? long[] tmpzrp2jms0.rolling_max(long[]) [0x427e4b]\n??:?
    void tmpzrp2jms0.__unittest_L29_C1() [0x427f92]\n??:? void tmpzrp2jms0.__modtest()
    [0x428280]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5db]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b46e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430685]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b445]\n??:? runModuleUnitTests [0x42c3b1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289c0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428947]\n??:? _d_run_main [0x4288b2]\n??:? main [0x428293]\n??:?
    __libc_start_main [0xf240554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[maxIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            result[minIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n    long\
    \ sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        if(sum == 0)\n        {\n            sumIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(sum == 0)\n        {\n  \
    \          result[sumIndex] = numbers[i];\n        }\n        else\n        {\n\
    \            result[sumIndex] = numbers[i] + result[sumIndex];\n        }\n  \
    \      sum -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4h46zwd.d(105): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd4h46zwd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n    }\n    result[0] = currentMax;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > currentMax)\n        {\n            result[i]\
    \ = currentMax;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ currentMin = minValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < currentMin)\n        {\n            currentMin = numbers[i];\n\
    \        }\n    }\n    result[0] = currentMin;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            result[i]\
    \ = currentMin;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long currentSum =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    long average = sum / numbers.length;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > average)\n        {\n            currentSum\
    \ = numbers[i];\n        }\n    }\n    result[0] = currentSum;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > average)\n   \
    \     {\n            result[i] = currentSum;\n        }\n        else\n      \
    \  {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given \nunittest\n{\n    alias candidate = rolling_max;\n\n   \
    \ assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp09eq6t81.d(107): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09eq6t81.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    while(i < numbers.length)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n        \n        result[i] = max;\n\
    \        i++;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n\
    \        {\n            min_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = min_value;\n        min_value\
    \ = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ *= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling quotient element found until given moment\n   \
    \ in the sequence.\n    >>> rolling_quotient([1L, \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp41_8f67z.d(97): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp41_8f67z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        current =\
    \ numbers[i];\n        if(current > max)\n        {\n            max = current;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    long i = 0;\n    \n    for(i = 0; i < numbers.length; i++)\n    {\n     \
    \   current = numbers[i];\n        max = Math.max(max, current);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbfhl0yzd.d(20): Error: undefined identifier `Math`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfhl0yzd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > currentMax)\n        {\n            result[i] = currentMax;\n\
    \            currentMax = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long currentMin = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentMin)\n        {\n            result[i]\
    \ = currentMin;\n            currentMin = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long currentSum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > currentSum)\n    \
    \    {\n            currentSum = sum;\n        }\n    }\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sum >\
    \ currentSum)\n        {\n            result[i] = sum;\n            currentSum\
    \ = sum;\n        }\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5jiabyl6.d(92): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp5jiabyl6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n     \
    \       result[i] = max;\n            max = numbers[i];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfc81v5jq.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x428565]\n??:? void tmpfc81v5jq.__unittest_L39_C1() [0x4280e5]\n??:?
    void tmpfc81v5jq.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a28]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4289af]\n??:? _d_run_main [0x42891a]\n??:? main [0x4282f7]\n??:?
    __libc_start_main [0x6ea79554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        if(sumIndex == 0)\n        {\n           \
    \ sumIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long product\
    \ = 1;\n    long productIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        product *= numbers[i];\n        if(productIndex == 0)\n      \
    \  {\n            productIndex = i;\n        }\n    }\n    long[] result = new\
    \ long[numbers.length];\n    \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpakj_7see.d(102): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpakj_7see.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += result[i-1];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += result[i-1];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] /= numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7i8q669q.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7i8q669q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if (numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = maxValue;\n    result[1]\
    \ = maxIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] > maxValue)\n        {\n            result[i] = maxValue;\n    \
    \        result[i - 1]++;\n        }\n        else\n        {\n            result[i]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    long minIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[0] = minValue;\n    result[1]\
    \ = minIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] < minValue)\n        {\n            result[i] = minValue;\n    \
    \        result[i - 1]++;\n        }\n        else\n        {\n            result[i]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long average = sum / count;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - average;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 2\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdqq3197p.d(99): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpdqq3197p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 10L,\
    \ 10L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_average([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_average(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_variance([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L,\
    \ 3L, 4L, 4L]\n    \n*/\nlong[] \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptse15m6x.d(95): Error: no identifier for declarator `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptse15m6x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far =\
    \ numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = min_so_far;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_prod([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_prod(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i] * numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling quotient\
    \ element found until given moment\n    in the sequence.\n    >>> \nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnt2dvcbs.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnt2dvcbs.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp6eitlthy.d(14): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285a6]\n??:? long[] tmp6eitlthy.rolling_max(long[]) [0x427e69]\n??:?
    void tmp6eitlthy.__unittest_L32_C1() [0x427f86]\n??:? void tmp6eitlthy.__modtest()
    [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b466]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43067d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b43d]\n??:? runModuleUnitTests [0x42c3a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42893f]\n??:? _d_run_main [0x4288aa]\n??:? main [0x428287]\n??:?
    __libc_start_main [0x3489554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = maxValue;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long minValue = numbers[0];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = minValue;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        int j = (i + 1) >> 1;\n        if(numbers[i]\
    \ < numbers[j])\n        {\n            result[i] = numbers[i];\n        }\n \
    \       else\n        {\n            result[i] = numbers[j];\n        }\n    }\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[numbers.length\
    \ - 1 - i];\n    }\n    return result;\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpagzi8czo.d(103): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagzi8czo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            result[max_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[min_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum_so_far = 0;\n    long sum_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        if(sum_so_far > numbers[i])\n        {\n           \
    \ sum_so_far = numbers[i];\n            sum_so_far_index = i;\n        }\n   \
    \ }\n    result[sum_so_far_index] = sum_so_far;\n    for(int i = 1; i < numbers.length\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8w4zkwh_.d(86): Error: found `unittest` when expecting `;` following
    `for` condition\n/tmp/tmp8w4zkwh_.d(95): Error: found `void` when expecting `)`\n/tmp/tmp8w4zkwh_.d(95):
    Error: found `{` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp8w4zkwh_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n\
    \        max = Math.max(max, cur);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long min = 0;\n    long cur = 0;\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        cur = numbers[i];\n        min = Math.min(min, cur);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    int n = numbers.length;\n    long[] result = new long[n];\n    long sum\
    \ = 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur\
    \ = numbers[i];\n        sum += cur;\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long prod = 1;\n    long cur = 0;\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        prod *= cur;\n \
    \       result[i] = prod;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling quotient element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppgzrurq0.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmppgzrurq0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n        }\n    }\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        result[i] = maxValue;\n\
    \        maxValue = numbers[i];\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpclxa5kvg.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285a6]\n??:? long[] tmpclxa5kvg.rolling_max(long[]) [0x427e62]\n??:?
    void tmpclxa5kvg.__unittest_L32_C1() [0x427f86]\n??:? void tmpclxa5kvg.__modtest()
    [0x428274]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5d3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b466]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306f1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ba0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43067d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b43d]\n??:? runModuleUnitTests [0x42c3a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289b8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42893f]\n??:? _d_run_main [0x4288aa]\n??:? main [0x428287]\n??:?
    __libc_start_main [0x1de20554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       min_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(numbers.length\
    \ - 1) - std.math.floor((numbers.length - 1) / 2)];\n    }\n    return result;\n\
    }\n/*\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_7mhc_e4.d(95): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_7mhc_e4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if(current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if(current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    sum += current;\n    }\n    double avg = sum / numbers.length;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp54bxdx_a.d(93): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp54bxdx_a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ len = numbers.length;\n    long[] result = new long[len];\n    long max = 0;\n\
    \    long cur = 0;\n    for(int i = 0; i < len; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nThis doesn't seem to work. Try it with a list of `[1,2,3,4,5,6,7,8,9,10]`\
    \ - it returns `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `long` instead of `int` because I thought it would be more efficient.\
    \ `int` would require a lot of casting.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `long` instead of `int` because I thought it would be more efficient.\
    \ `int` would require a lot of casting.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `long` instead of `int` because I thought it would be more efficient.\
    \ `int` would require a lot of casting.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `long` instead of `int` because I thought it would be more efficient.\
    \ `int` would require a lot of casting.\n<|/ c |>\n<| a tags=java,arrays |>\n\
    <code>\npublic static void main(String[] args) {\n    int[] numbers = {1,2,3,4,5,6,7,8,9,10};\n\
    \    int[] result = new int[numbers.length];\n    Arrays.sort(numbers);\n    int\
    \ max = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    System.out.println(Arrays.toString(result));\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. Try it with a list of `[1,2,3,4,5,6,7,8,9,10]`\
    \ - it returns `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `int` instead of `long` because I thought it would be more efficient.\
    \ `int` would require a lot of casting.\n<|/ c |>\n<| c |>\nI tested it and it\
    \ works. I used `int` instead of `long` because I thought it would be more efficient\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp93bhxhjx.d(27): Error: declaration expected, not `<`\n/tmp/tmp93bhxhjx.d(30):
    Error: unterminated character constant\n/tmp/tmp93bhxhjx.d(49): Error: function
    declaration without return type. (Note that constructors are always named `this`)\n/tmp/tmp93bhxhjx.d(49):
    Error: no identifier for declarator `Arrays.sort(numbers)`\n/tmp/tmp93bhxhjx.d(51):
    Error: declaration expected, not `for`\n/tmp/tmp93bhxhjx.d(51): Error: no identifier
    for declarator `i`\n/tmp/tmp93bhxhjx.d(51): Error: declaration expected, not `<`\n/tmp/tmp93bhxhjx.d(51):
    Error: no identifier for declarator `i`\n/tmp/tmp93bhxhjx.d(51): Error: declaration
    expected, not `++`\n/tmp/tmp93bhxhjx.d(56): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93bhxhjx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    int i =\
    \ 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = sum -\
    \ numbers[i] * numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * numbers[i];\n    }\n    long median = result[(number\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprhp7q5ar.d(99): Error: found `unittest` when expecting `)`\n/tmp/tmprhp7q5ar.d(101):
    Error: found `{` when expecting `,`\n/tmp/tmprhp7q5ar.d(102): Error: expression
    expected, not `alias`\n/tmp/tmprhp7q5ar.d(102): Error: found `candidate` when
    expecting `,`\n/tmp/tmprhp7q5ar.d(102): Error: expression expected, not `=`\n/tmp/tmprhp7q5ar.d(102):
    Error: found `rolling_max` when expecting `,`\n/tmp/tmprhp7q5ar.d(102): Error:
    expression expected, not `;`\n/tmp/tmprhp7q5ar.d(104): Error: found `assert` when
    expecting `,`\n/tmp/tmprhp7q5ar.d(104): Error: found `;` when expecting `,`\n/tmp/tmprhp7q5ar.d(105):
    Error: found `;` when expecting `,`\n/tmp/tmprhp7q5ar.d(106): Error: found `;`
    when expecting `,`\n/tmp/tmprhp7q5ar.d(107): Error: found `;` when expecting `,`\n/tmp/tmprhp7q5ar.d(108):
    Error: expression expected, not `}`\n/tmp/tmprhp7q5ar.d(109): Error: found `void`
    when expecting `,`\n/tmp/tmprhp7q5ar.d(109): Error: found `{` when expecting `,`\n/tmp/tmprhp7q5ar.d(109):
    Error: expression expected, not `}`\n/tmp/tmprhp7q5ar.d(109): Error: found `End
    of File` when expecting `,`\n/tmp/tmprhp7q5ar.d(109): Error: found `End of File`
    when expecting `]`\n/tmp/tmprhp7q5ar.d(109): Error: semicolon expected, not `End
    of File`\n/tmp/tmprhp7q5ar.d(109): Error: found `End of File` when expecting `}`
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhp7q5ar.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[(numbers.length - 1) - std.math.floor((numbers.length - 1) / 2)];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling standard deviation element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz_fcgfsk.d(95): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpz_fcgfsk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[0] = max;\n    result[1] = maxIndex;\n    for (int\
    \ i = 2; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n    \
    \    {\n            result[i] = max;\n        }\n        else\n        {\n   \
    \         result[i] = numbers[i - 1];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long minIndex = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[0] = min;\n    result[1]\
    \ = minIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] < min)\n        {\n            result[i] = min;\n        }\n   \
    \     else\n        {\n            result[i] = numbers[i - 1];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    result[0] = sum;\n    for\
    \ (int i = 1; i < numbers.length; i++)\n    {\n        result[i] = numbers[i -\
    \ 1];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_average(long[] numbers) \n{\n    long[] result\
    \ = \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy8w6ttkb.d(105): Error: expression expected, not `unittest`\n/tmp/tmpy8w6ttkb.d(106):
    Error: semicolon expected, not `{`\n/tmp/tmpy8w6ttkb.d(114): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy8w6ttkb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if (cur > max)\n        {\n            max = cur;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        cur =\
    \ numbers[i];\n        if (cur < min)\n        {\n            min = cur;\n   \
    \     }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n    }\n    long avg = sum / numbers.length;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        result[i] = avg;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        cur =\
    \ numbers[i];\n        sum += cur;\n    }\n    long avg = sum / numbers.length;\n\
    \    long mid = numbers.length / 2;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        if (i == mid)\n        {\n        \
    \    result[i] = avg;\n        }\n        else\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1mw3naew.d(101): Error: found `unittest` instead of statement\n/tmp/tmp1mw3naew.d(110):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1mw3naew.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long currentMax =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        max =\
    \ numbers[i];\n        currentMax = max;\n        for(; i < numbers.length; i++)\n\
    \        {\n            if(numbers[i] > max)\n            {\n                max\
    \ = numbers[i];\n                currentMax = max;\n            }\n        }\n\
    \        result[i] = currentMax;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI believe this solution will fail for negative numbers.\
    \ Try it out with [-1L, -2L, -3L, -2L, -3L, -4L, -2L]\n<|/ c |>\n<| c |>\nYes,\
    \ it will. That's why I said \"given array of integers\". Of course it can be\
    \ easily modified to handle negative numbers. I added a comment to the code explaining\
    \ that.\n<|/ c |>\n<| a tags=c#,algorithm |>\n<code>\npublic static int[] rolling_max(int[]\
    \ numbers)\n{\n    int[] result = new int[numbers.Length];\n    int max = 0;\n\
    \    int currentMax = 0;\n    int i = 0;\n    foreach (int number in numbers)\n\
    \    {\n        max = number;\n        currentMax = max;\n        foreach (int\
    \ number in numbers)\n        {\n            if (number > max)\n            {\n\
    \                max = number;\n                currentMax = max;\n          \
    \  }\n        }\n        result[i] = currentMax;\n        i++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwvaz8187.d(32): Error: declaration expected, not `<`\n/tmp/tmpwvaz8187.d(38):
    Error: unterminated character constant\n/tmp/tmpwvaz8187.d(48): Error: declaration
    expected, not `foreach`\n/tmp/tmpwvaz8187.d(51): Error: no identifier for declarator
    `currentMax`\n/tmp/tmpwvaz8187.d(51): Error: declaration expected, not `=`\n/tmp/tmpwvaz8187.d(52):
    Error: declaration expected, not `foreach`\n/tmp/tmpwvaz8187.d(57): Error: no
    identifier for declarator `currentMax`\n/tmp/tmpwvaz8187.d(57): Error: declaration
    expected, not `=`\n/tmp/tmpwvaz8187.d(58): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwvaz8187.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == max)\n        {\n            result[i] = max;\n        }\n\
    \        else\n        {\n            result[i] = max;\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    long minIndex = -1;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n            minIndex = i;\n       \
    \ }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == min)\n        {\n            result[i] = min;\n        }\n        else\n\
    \        {\n            result[i] = min;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        sum += numbers[i];\n        if(sum == numbers[i])\n        {\n\
    \            sumIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum)\n        {\n            result[i]\
    \ = sum;\n        }\n        else\n        {\n            result[i] = sum;\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling product element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzsouakvl.d(110): Error: no identifier for declarator `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzsouakvl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    \n    while(j < numbers.length)\n    {\n        if(numbers[j] >\
    \ numbers[k])\n        {\n            result[i] = numbers[j];\n            i++;\n\
    \            j++;\n        }\n        else\n        {\n            result[i] =\
    \ numbers[k];\n            i++;\n            k++;\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp90k6t736.d(19): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4285be]\n??:? long[] tmp90k6t736.rolling_max(long[]) [0x427ea5]\n??:?
    void tmp90k6t736.__unittest_L35_C1() [0x428026]\n??:? void tmp90k6t736.__modtest()
    [0x42828c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5eb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b47e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430709]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430bb8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430695]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b455]\n??:? runModuleUnitTests [0x42c3c1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289d0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428957]\n??:? _d_run_main [0x4288c2]\n??:? main [0x42829f]\n??:?
    __libc_start_main [0x3528b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[0] = max_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[i] = max_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    result[0]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[i] = min_so_far;\n        }\n \
    \       else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = numbers[0];\n    long sum_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i = 1; i < numbers.length\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb0vyb3e5.d(94): Error: found `unittest` when expecting `;` following
    `for` condition\n/tmp/tmpb0vyb3e5.d(103): Error: found `void` when expecting `)`\n/tmp/tmpb0vyb3e5.d(103):
    Error: found `{` when expecting `;` following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpb0vyb3e5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg3wavwin.d(30): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284c5]\n??:? void tmpg3wavwin.__unittest_L24_C1() [0x4280e2]\n??:?
    void tmpg3wavwin.__modtest() [0x428244]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b436]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43064d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b40d]\n??:? runModuleUnitTests [0x42c379]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428988]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42890f]\n??:? _d_run_main [0x42887a]\n??:? main [0x428257]\n??:?
    __libc_start_main [0x697d9554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_i = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_i = i;\n        }\n    }\n    result[max_so_far_i] = max_so_far;\n\
    \    for(int i = max_so_far_i + 1; i + 1 < numbers.length; i++)\n    {\n     \
    \   result[i] = numbers[i];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppqfh27he.d(24): Error: cannot implicitly convert expression
    `max_so_far_i + 1L` of type `long` to `int`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmppqfh27he.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] + numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L, 12L, 12L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * numbers[i + 1];\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling quotient element found until given moment\n\
    \    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3kt02t8_.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3kt02t8_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   long i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long currentMax =\
    \ 0;\n    long currentNumber = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        currentNumber = numbers[i];\n        max = currentNumber;\n  \
    \      currentMax = currentNumber;\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            currentMax = max(currentMax, numbers[j]);\n   \
    \     }\n        result[i] = currentMax;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long currentMin = 0;\n    long currentNumber = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n     \
    \   min = currentNumber;\n        currentMin = currentNumber;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            currentMin = min(currentMin,\
    \ numbers[j]);\n        }\n        result[i] = currentMin;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long currentSum = 0;\n    long currentNumber = 0;\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n\
    \        sum = sum + currentNumber;\n        currentSum = sum;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            currentSum = currentSum\
    \ + numbers[j];\n        }\n        result[i] = currentSum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiu08ohj0.d(89): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiu08ohj0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long max_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            max_pos = i;\n\
    \        }\n    }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            result[i - max_pos] = max;\n\
    \            max = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_pos = i;\n        }\n    }\n    for(int i = numbers.length -\
    \ 1; i >= 0; i--)\n    {\n        if(numbers[i] < min)\n        {\n          \
    \  result[i - min_pos] = min;\n            min = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sum_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > numbers[i])\n    \
    \    {\n            sum = numbers[i];\n            sum_pos = i;\n        }\n \
    \   }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n        sum +=\
    \ numbers[i];\n        if(sum > numbers[i])\n        {\n            result[i -\
    \ sum_pos] = sum;\n            sum = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi46bajwr.d(95): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpi46bajwr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long cur\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            result[i] = max;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long cur = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] < min)\n        {\n            result[i] = min;\n        }\n\
    \        else\n        {\n            result[i] = numbers[i];\n        }\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum /\
    \ numbers.length;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long cur = numbers[0];\n\
    \    long sum = 0;\n    for(int i = 1; i < numbers.length\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8vpq8yq.d(102): Error: found `unittest` when expecting `;`
    following `for` condition\n/tmp/tmph8vpq8yq.d(111): Error: found `void` when expecting
    `)`\n/tmp/tmph8vpq8yq.d(111): Error: found `{` when expecting `;` following statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8vpq8yq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm |>\n<| a dscore=0\
    \ |>\nI wrote a C# version based on your code. \n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmparo4tzrl.d(29): Error: declaration expected, not `<`\n/tmp/tmparo4tzrl.d(35):
    Error: semicolon expected, not `.`\n/tmp/tmparo4tzrl.d(35): Error: no identifier
    for declarator `.Collections.Generic`\n/tmp/tmparo4tzrl.d(36): Error: semicolon
    expected, not `.`\n/tmp/tmparo4tzrl.d(36): Error: no identifier for declarator
    `.Linq`\n/tmp/tmparo4tzrl.d(37): Error: semicolon expected, not `.`\n/tmp/tmparo4tzrl.d(37):
    Error: no identifier for declarator `.Text`\n/tmp/tmparo4tzrl.d(38): Error: semicolon
    expected, not `.`\n/tmp/tmparo4tzrl.d(38): Error: no identifier for declarator
    `.Threading.Tasks`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmparo4tzrl.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n\
    \ - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n  \
    \          if(result[j] > result[i])\n            {\n                result[i]\
    \ = result[j];\n            }\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            if(result[j] < result[i])\n            {\n           \
    \     result[i] = result[j];\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            result[i] += result[j];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product of element found until given moment\n    in the sequence.\n    >>> rolling_prod([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_prod(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j <\
    \ i; j++)\n        {\n            result[i] *= result[j];\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6du4e7cz.d(101): Error: found `unittest` instead of statement\n/tmp/tmp6du4e7cz.d(110):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp6du4e7cz.d(110):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6du4e7cz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if(cur < min)\n        {\n            min = cur;\n        }\n       \
    \ result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L,\
    \ 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        sum += cur;\n        result[i] = sum;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 3L, 3L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 3\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj08mfpmd.d(89): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpj08mfpmd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_value =\
    \ numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < n; i++)\n    {\n\
    \        if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \            max_pos = i;\n        }\n    }\n    result[0] = max_value;\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(numbers[i] > max_value)\n        {\n \
    \           result[i] = max_value;\n        }\n        else\n        {\n     \
    \       result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min_value = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i\
    \ < n; i++)\n    {\n        if(numbers[i] < min_value)\n        {\n          \
    \  min_value = numbers[i];\n            min_pos = i;\n        }\n    }\n    result[0]\
    \ = min_value;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] <\
    \ min_value)\n        {\n            result[i] = min_value;\n        }\n     \
    \   else\n        {\n            result[i] = numbers[i];\n        }\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long sum2 = 0;\n   \
    \ long sum3 = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n\
    \    long sum7 = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 =\
    \ 0;\n    long sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long\
    \ sum14 = 0;\n    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n\
    \    long sum18 = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21\
    \ = 0;\n    long sum22 = 0;\n    \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx7x_vv7c.d(107): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx7x_vv7c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == maxValue)\n        {\n            result[maxIndex] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == minValue)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long average = sum / count;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == average)\n\
    \        {\n            result[i] = average;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptg46kgyf.d(100): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptg46kgyf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long\
    \ sum = 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumIndex = i;\n    }\n    long avg\
    \ = sum / numbers.length;\n    long[] result = new long[numbers.length];\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > avg)\n\
    \        {\n            result[i] = avg;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling standard deviation\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu56iesjq.d(108): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu56iesjq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long currentMax =\
    \ 0;\n    long currentNumber = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        currentNumber = numbers[i];\n        currentMax = max;\n     \
    \   max = currentNumber;\n        for(int j = i; j < numbers.length; j++)\n  \
    \      {\n            if(numbers[j] > currentNumber)\n            {\n        \
    \        currentMax = max;\n                max = currentNumber;\n           \
    \ }\n        }\n        result[i] = currentMax;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbwzs4h38.d(38): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284cd]\n??:? void tmpbwzs4h38.__unittest_L33_C1() [0x42804d]\n??:?
    void tmpbwzs4h38.__modtest() [0x42824c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428917]\n??:? _d_run_main [0x428882]\n??:? main [0x42825f]\n??:?
    __libc_start_main [0xdae79554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        sumIndex++;\n    }\n    long avg = sum / sumIndex;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[sumIndex - 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    long medianIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < median)\n        {\n            median\
    \ = numbers[i];\n            medianIndex = i;\n        }\nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpousvqnmc.d(98): Error: found `unittest` instead of statement\n/tmp/tmpousvqnmc.d(107):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpousvqnmc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[0] = max;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    long minIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    result[0] = min;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    double avg = sum / count;\n    long sum2 = 0;\n\
    \    long count2 = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n  \
    \      sum2 += numbers[i] * numbers[i];\n        count2++;\n    }\n    double\
    \ avg2 = sum2 / count2;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] * avg;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptonpvpwr.d(103): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptonpvpwr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    int\
    \ max_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    result[max_index] = max_so_far;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpnlj448eo.d(13): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x428566]\n??:? long[] tmpnlj448eo.rolling_max(long[]) [0x427e62]\n??:?
    void tmpnlj448eo.__unittest_L26_C1() [0x427f4a]\n??:? void tmpnlj448eo.__modtest()
    [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428978]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4288ff]\n??:? _d_run_main [0x42886a]\n??:? main [0x42824b]\n??:?
    __libc_start_main [0x8540e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for (int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for\
    \ (int i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = min(result[i], numbers[i]);\n    }\n   \
    \ \n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = result[i] + (numbers[i] - result[i]) / n;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 2L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = result[i] + (numbers[i] - result[i]) / n;\n\
    \    }\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n        result[i] =\
    \ result[i] + (numbers[i] - result[i]) / n;\n    }\n    \nunittest\n{\n    alias\
    \ candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx_32doj7.d(102): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_32doj7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sumIndex = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (sum == numbers[i])\n  \
    \      {\n            sumIndex = i;\n        }\n    }\n    result[sumIndex] =\
    \ sum;\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if (sum == numbers[i])\n        {\n            sumIndex = i;\n        }\n  \
    \  }\n    double avg = sum / numbers.length;\n    result[sumIndex] = avg;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling standard deviation element found \nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9qqovtr.d(96): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpb9qqovtr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = max_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far_index;\n        }\n        else\n\
    \        {\n            result[i] = min_so_far;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ sum_so_far_index += numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum_so_far_index / numbers.length;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling median element found until given moment\n    in the sequence.\n \
    \   >>> \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpohssijsm.d(92): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpohssijsm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    int i =\
    \ 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = sum -\
    \ numbers[i] * result[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * result[i];\n    }\n    long median = 0;\n  \
    \  for(\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpitjt5s3w.d(101): Error: found `unittest` instead of statement\n/tmp/tmpitjt5s3w.d(106):
    Error: found `;` when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpitjt5s3w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        max = cur;\n        for(int j = i; j < numbers.length; j++)\n       \
    \ {\n            if(numbers[j] > max)\n            {\n                max = numbers[j];\n\
    \            }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        min = cur;\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] < min)\n            {\n         \
    \       min = numbers[j];\n            }\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 9L,\
    \ 9L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum =\
    \ cur;\n        for(int j = i; j < numbers.length; j++)\n        {\n         \
    \   sum += numbers[j];\n        }\n        result[i] = sum;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product of element found until given moment\n    in the sequence.\n    >>> rolling_prod([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 6L, 24L, 24L, 24L, 120L, 120L]\n    \n*/\n\
    long[] rolling_prod(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long prod = 1;\n    long cur = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        prod = cur;\n        for(int\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfih_yhfv.d(98): Error: no identifier for declarator `int`\n/tmp/tmpfih_yhfv.d(98):
    Error: expression expected, not `unittest`\n/tmp/tmpfih_yhfv.d(99): Error: found
    `{` when expecting `;` following `for` condition\n/tmp/tmpfih_yhfv.d(100): Error:
    expression expected, not `alias`\n/tmp/tmpfih_yhfv.d(100): Error: found `candidate`
    when expecting `)`\n/tmp/tmpfih_yhfv.d(100): Error: found `=` instead of statement\n/tmp/tmpfih_yhfv.d(107):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfih_yhfv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    while(i < numbers.length)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ < min)\n            {\n                min = numbers[j];\n            }\n  \
    \      }\n        result[i] = min;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    while(i < numbers.length)\n    {\n        sum = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            sum +=\
    \ numbers[j];\n        }\n        result[i] = sum;\n        i++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long sum = 0;\n    while(i < numbers.length)\n    {\n   \
    \     sum = numbers[i];\n        for(int j = i; j < numbers.length; j++)\n   \
    \     {\n            sum += numbers[j];\n        }\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjkat__a_.d(100): Error: found `unittest` instead of statement\n/tmp/tmpjkat__a_.d(109):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkat__a_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.max(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.min(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of element found until given moment\n    in the sequence.\n \
    \   >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 3L, 6L, 9L,\
    \ 9L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.sum(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 2L, 6L,\
    \ 24L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.product(result[i], numbers[i]);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_zwhm3vh.d(87): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_zwhm3vh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index] = min_so_far;\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[sum_so_far_index]\
    \ = sum_so_far;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe1f49ry2.d(83): Error: no identifier for declarator `long`\n/tmp/tmpe1f49ry2.d(83):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpe1f49ry2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_so_far =\
    \ numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] >\
    \ max_so_far)\n        {\n            max_so_far = numbers[i];\n        }\n  \
    \  }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = max_so_far;\n\
    \        max_so_far = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min_so_far = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n  \
    \      if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] =\
    \ min_so_far;\n        min_so_far = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum_so_far = 0;\n    long sum_of_squares = 0;\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        sum_so_far += numbers[i];\n        sum_of_squares\
    \ += numbers[i] * numbers[i];\n    }\n    for(int i = 0; i < n; i++)\n    {\n\
    \        result[i] = sum_so_far / sum_of_squares;\n        sum_so_far = sum_of_squares\
    \ = 0;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl3uox0qq.d(91): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl3uox0qq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long max_index = numbers[0];\n    for (int i =\
    \ 1; i < numbers.length; ++i)\n    {\n        if (numbers[i] > max_value)\n  \
    \      {\n            max_value = numbers[i];\n            max_index = i;\n  \
    \      }\n    }\n    long[] result = new long[numbers.length];\n    result[max_index]\
    \ = max_value;\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmp8awfgr9z.d(12): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x42857e]\n??:? long[] tmp8awfgr9z.rolling_max(long[]) [0x427e4b]\n??:?
    void tmp8awfgr9z.__unittest_L26_C1() [0x427f62]\n??:? void tmp8awfgr9z.__modtest()
    [0x428250]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b78]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430655]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b415]\n??:? runModuleUnitTests [0x42c381]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428917]\n??:? _d_run_main [0x428882]\n??:? main [0x428263]\n??:?
    __libc_start_main [0xbe2d3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    \n\
    \    for(int j = 0; j < numbers.length; j++)\n    {\n        if(numbers[j] > max)\n\
    \        {\n            max = numbers[j];\n        }\n    }\n    \n    for(int\
    \ j = 0; j < numbers.length; j++)\n    {\n        if(numbers[j] == max)\n    \
    \    {\n            result[i] = max;\n            i++;\n        }\n        else\n\
    \        {\n            result[i] = numbers[j];\n        }\n    }\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6wlva9ps.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x42852d]\n??:? void tmp6wlva9ps.__unittest_L39_C1() [0x4280b1]\n??:?
    void tmp6wlva9ps.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c60b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b49e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b475]\n??:? runModuleUnitTests [0x42c3e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4289f0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428977]\n??:? _d_run_main [0x4288e2]\n??:? main [0x4282c3]\n??:?
    __libc_start_main [0xffcff554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    \n\
    \    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n   \
    \     {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i <\
    \ numbers.length; i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpaq6yru_x.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x4284d5]\n??:? void tmpaq6yru_x.__unittest_L32_C1() [0x428055]\n??:?
    void tmpaq6yru_x.__modtest() [0x428254]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430b80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43065d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b41d]\n??:? runModuleUnitTests [0x42c389]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42891f]\n??:? _d_run_main [0x42888a]\n??:? main [0x428267]\n??:?
    __libc_start_main [0xdfaef554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    long\
    \ cur = 0;\n    while(i < numbers.length)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ i++;\n    }\n    for(i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long min = 0;\n    long cur = 0;\n\
    \    while(i < numbers.length)\n    {\n        cur = numbers[i];\n        if(cur\
    \ < min)\n        {\n            min = cur;\n        }\n        i++;\n    }\n\
    \    for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = min;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    long cur = 0;\n\
    \    while(i < numbers.length)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n        i++;\n    }\n    for(i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long product = 1;\n    long cur = 0;\n    while(i < numbers.length)\n   \
    \ {\n        cur = numbers[i];\n        product *= cur;\n        i++;\n    }\n\
    \    for(i = 0; i < number\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8r7sm3sj.d(104): Error: found `unittest` when expecting `;`
    following `for` condition\n/tmp/tmp8r7sm3sj.d(113): Error: found `void` when expecting
    `)`\n/tmp/tmp8r7sm3sj.d(113): Error: found `{` when expecting `;` following statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8r7sm3sj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    for(int i = numbers.length - 1; i > max_so_far_index; i--)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    for(int i = numbers.length - 1; i > min_so_far_index; i--)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] += result[i - 1];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4duil0v6.d(83): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp4duil0v6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[min_so_far_index] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long avg_so_far = numbers[0];\n    long avg_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > avg_so_far)\n        {\n            avg_so_far = numbers[i];\n           \
    \ avg_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == avg_so_far)\n        {\n            result[avg_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9zm87kek.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp9zm87kek.d", "-I/tmp"]\n'''
  stdout: b''
