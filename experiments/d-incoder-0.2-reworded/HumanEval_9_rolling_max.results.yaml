name: HumanEval_9_rolling_max
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    long\
    \ currentMax = numbers[0];\n    \n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n        \n        if(numbers[i] > max)\n        {\n            max\
    \ = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max;\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    long currentMin = numbers[0];\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n    }\n    \n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    long currentSum = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        currentSum += numbers[i];\n        \n        if(currentSum\
    \ > 0)\n        {\n            sum += currentSum;\n        }\n    }\n    \n  \
    \  for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] roll\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnwm0u_sj.d(110): Error: semicolon expected, not `unittest`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnwm0u_sj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| c |>\nThis doesn't seem to work. `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L})` returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it out yourself. I tested it on `rolling_max(new long[]{1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n\
    <| c |>\nYes, it works. But it also returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]` for\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L, 2L, 3L, 4L, 2L})`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on `rolling_max(new\
    \ long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a solution in\
    \ Java that uses no loops and is O(n) time complexity. \n<code>\npublic static\
    \ long[] rolling_max(long[] numbers) {\n    long[] result = new long[numbers.length];\n\
    \    int maxIndex = 0;\n    long maxValue = numbers[0];\n    for (int i = 1; i\
    \ < numbers.length; i++) {\n        if (numbers[i] > maxValue) {\n           \
    \ maxValue = numbers[i];\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl0vzoaca.d(29): Error: declaration expected, not `<`\\n/tmp/tmpl0vzoaca.d(32):\
    \ Error: unterminated character constant\\n/tmp/tmpl0vzoaca.d(53): Error: declaration\
    \ expected, not `for`\\n/tmp/tmpl0vzoaca.d(53): Error: no identifier for declarator\
    \ `i`\\n/tmp/tmpl0vzoaca.d(53): Error: declaration expected, not `<`\\n/tmp/tmpl0vzoaca.d(53):\
    \ Error: no identifier for declarator `i`\\n/tmp/tmpl0vzoaca.d(53): Error: declaration\
    \ expected, not `++`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl0vzoaca.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long\
    \ max = 0;\n    \n    while(j < numbers.length)\n    {\n        if(numbers[j]\
    \ > max)\n        {\n            max = numbers[j];\n        }\n        j++;\n\
    \    }\n    \n    while(i < numbers.length)\n    {\n        result[i] = max;\n\
    \        i++;\n        j = 0;\n        \n        while(j < numbers.length)\n \
    \       {\n            if(numbers[j] > max)\n            {\n                max\
    \ = numbers[j];\n            }\n            j++;\n        }\n    }\n    \n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long min = 0;\n \
    \   \n    while(j < numbers.length)\n    {\n        if(numbers[j] < min)\n   \
    \     {\n            min = numbers[j];\n        }\n        j++;\n    }\n    \n\
    \    while(i < numbers.length)\n    {\n        result[i] = min;\n        i++;\n\
    \        j = 0;\n        \n        while(j < numbers.length)\n        {\n    \
    \        if(numbers[j] < min)\n            {\n                min = numbers[j];\n\
    \            }\n            j++;\n        }\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 9L, 9L, 12L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    long sum = 0;\n    \n    while(j < numbers.length)\n    {\n\
    \        sum += numbers[j];\n        j++;\n    }\n    \n    while(i < numbers.length)\n\
    \    {\n        result[i] = sum;\n        i++;\n        j = 0;\n        \n   \
    \     while(j < numbers.length)\n        {\n            sum += numbers[j];\n \
    \           j++;\n        }\n    }\n    \n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product of element found until\
    \ given moment\n    in the sequence.\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpks72c3uj.d(120): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpks72c3uj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = 1; i < n; i++)\n    {\n        result[i] = max(result[i-1], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rpizjuj.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6rpizjuj.d(22): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6rpizjuj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long maxValue = numbers[0];\n\
    \    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > maxValue)\n  \
    \      {\n            maxValue = numbers[i];\n        }\n    }\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = maxValue;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long minValue = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n    \
    \    if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] =\
    \ minValue;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long sum = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n    }\n   \
    \ for(int i = 0; i < n; i++)\n    {\n        result[i] = sum / n;\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long median = 0;\n    long sum = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n        if(sum\
    \ % 2 == 0)\n        {\n            median = numbers[i];\n        }\n    }\n \
    \   for(int i = 0; i < n; i++)\n    {\n        result[i] = median;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling standard deviation \nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp88aroryp.d(102): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp88aroryp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = numbers[0];\n    long currentMaxIndex = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n       \
    \ {\n            maxValue = numbers[i];\n            currentMax = numbers[i];\n\
    \            currentMaxIndex = i;\n        }\n        else\n        {\n      \
    \      currentMax = maxValue;\n            currentMaxIndex = i;\n        }\n \
    \   }\n    result[currentMaxIndex] = currentMax;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmpj2xsh7_j.d(13): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4285ce]\\n??:? long[] tmpj2xsh7_j.rolling_max(long[])\
    \ [0x427e62]\\n??:? void tmpj2xsh7_j.__unittest_L33_C1() [0x427fae]\\n??:? void\
    \ tmpj2xsh7_j.__modtest() [0x42829c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c5fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b48e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430719]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b465]\\n??:? runModuleUnitTests [0x42c3d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4289e0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428967]\\n??:? _d_run_main [0x4288d2]\\n??:? main [0x4282af]\\\
    n??:? __libc_start_main [0xafa38554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] > max_so_far)\n        {\n            max_so_far = numbers[i];\n\
    \            max_so_far_pos = i;\n        }\n    }\n    result[max_so_far_pos]\
    \ = max_so_far;\n    for(int i = max_so_far_pos + 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    result[min_so_far_pos]\
    \ = min_so_far;\n    for(int i = min_so_far_pos + 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long avg_so_far\
    \ = 0;\n    long avg_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        avg_so_far += numbers[i];\n        if(numbers[i] > avg_so_far)\n\
    \        {\n            avg_so_far = numbers[i];\n            avg_so_far_pos =\
    \ i;\n        }\n    }\n    result[avg_so_far_pos] = avg_so_far;\n    for(int\
    \ i = avg_so_far_pos + 1; i < numbers.length; i++)\n    {\n        result[i] =\
    \ numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmzau1k4y.d(85): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmzau1k4y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n-1;\
    \ i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n       \
    \     if(result[j] > result[i])\n            {\n                result[i] = result[j];\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n\
    \            if(result[j] < result[i])\n            {\n                result[i]\
    \ = result[j];\n            }\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            result[i] += result[j];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 12L, 24L, 24L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(int i = n-1; i >= 0; i--)\n    {\n        for(int\
    \ j = 0; j < i; j++)\n        {\n            result[i] *= result[j];\n\nunittest\n\
    {\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw465fh5m.d(102): Error: found `unittest` instead of statement\\\
    n/tmp/tmpw465fh5m.d(111): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpw465fh5m.d(111): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpw465fh5m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > currentMax)\n        {\n            currentMax = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  result[i] = currentMax;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    long currentMin = minValue;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = currentMin;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        currentSum += numbers[i];\n        if(currentSum > sum)\n    \
    \    {\n            sum = currentSum;\n        }\n    }\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = 1;\n    long currentProduct = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        currentProduct *= numbers[i];\n        if(currentProduct\
    \ > product)\n        {\nunittest\n{\n    alias candidate = rolling_max;\n\n \
    \   assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppm365eck.d(96): Error: found `unittest` instead of statement\\\
    n/tmp/tmppm365eck.d(105): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmppm365eck.d(105): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppm365eck.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   long current = 0;\n    for (int i = 0; i < n; i++) {\n        current = numbers[i];\n\
    \        if (current > max) {\n            max = current;\n        }\n       \
    \ result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpca_eowsq.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpca_eowsq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        if (current > max)\n        {\n            max = current;\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if (current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L,\
    \ 6L, 6L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long product = 1;\n    long current = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        product *= current;\n        result[i] = product;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ quotient element found until given moment\n    in the sequence.\n    >>> rolling_quotient([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L\nunittest\n{\n   \
    \ alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphfkyqe3l.d(89): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphfkyqe3l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    int\
    \ maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == maxValue)\n        {\n            result[maxIndex] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    int minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == minValue)\n        {\n            result[minIndex]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ avg = 0;\n    int count = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        count++;\n    }\n    avg = sum / count;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ avg)\n        {\n            result[i] = avg;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzuhfqran.d(101): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzuhfqran.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max = numbers[0];\n    long[] result = new long[numbers.length];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n    \
    \    {\n            max = numbers[i];\n        }\n        result[i] = max;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long sum = 0;\n    long avg = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        avg = sum / numbers.length;\n        result[i] = avg;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> rolling_std([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n    long sum = 0;\n \
    \   long \nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8wxtu1a3.d(94): Error: no identifier for declarator `long`\\\
    n/tmp/tmp8wxtu1a3.d(94): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8wxtu1a3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if (cur > max)\n        {\n            max = cur;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        cur =\
    \ numbers[i];\n        if (cur < min)\n        {\n            min = cur;\n   \
    \     }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n        if (sum / numbers.length == numbers.length)\n        {\n  \
    \          result[i] = sum / numbers.length;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L\nunittest\n{\n    alias candidate = rolling_max;\n\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph3oxkij1.d(92): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph3oxkij1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_so_far =\
    \ numbers[0];\n    long max_so_far_index = 0;\n    for (int i = 1; i < n; i++)\
    \ {\n        if (numbers[i] > max_so_far) {\n            max_so_far = numbers[i];\n\
    \            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    for (int i = 1; i < n; i++) {\n        if (numbers[i] < max_so_far)\
    \ {\n            result[max_so_far_index] = max_so_far;\n        }\n        max_so_far\
    \ = numbers[i];\n        max_so_far_index = i;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmsugupv2.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpmsugupv2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        max = numbers[i];\n        for(int\
    \ j = i; j < n; j++)\n        {\n            if(numbers[j] > max)\n          \
    \  {\n                max = numbers[j];\n            }\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 2L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        min = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            if(numbers[j] < min)\n            {\n                min\
    \ = numbers[j];\n            }\n        }\n        result[i] = min;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of element found until given moment\n    in the sequence.\n \
    \   >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L,\
    \ 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        sum = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            sum += numbers[j];\n        }\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L,\
    \ 6L, 6L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long prod = 1;\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        prod = numbers[i];\n        for(int j = i; j < n; j++)\n\
    \        {\n            prod *= numbers[j];\n        }\n        result[i] = prod;\n\
    \    }\n    return result;\n}\n/*\n From \nunittest\n{\n    alias candidate =\
    \ rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) ==\
    \ [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L,\
    \ 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphkm8hydl.d(101): Error: unterminated /* */ comment\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphkm8hydl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    while(i\
    \ < numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i;\
    \ j < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n    \
    \        {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n        i++;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    while(i < numbers.length)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ < min)\n            {\n                min = numbers[j];\n            }\n  \
    \      }\n        result[i] = min;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    while(i < numbers.length)\n    {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    double avg = sum / numbers.length;\n    while(i < numbers.length)\n\
    \    {\n        result[i] = numbers[i] - avg;\n        i++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long median = 0;\n    while(i < numbers.length)\n    {\n\
    \        median = (numbers[i]+numbers[i+1])/2;\n        for(int j = i; j < \n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0d12sgvo.d(98): Error: expression expected, not `unittest`\\\
    n/tmp/tmp0d12sgvo.d(99): Error: found `{` when expecting `;` following `for` condition\\\
    n/tmp/tmp0d12sgvo.d(100): Error: expression expected, not `alias`\\n/tmp/tmp0d12sgvo.d(100):\
    \ Error: found `candidate` when expecting `)`\\n/tmp/tmp0d12sgvo.d(100): Error:\
    \ found `=` instead of statement\\n/tmp/tmp0d12sgvo.d(107): Error: found `End\
    \ of File` when expecting `}` following compound statement\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0d12sgvo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    result[max_so_far_index] = max_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    result[min_so_far_index] = min_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum_so_far = 0;\n    long sum_so_far_index = -1;\n  \
    \  for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum_so_far;\n    }\n    result[sum_so_far_index] = sum_so_far;\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L,\
    \ 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2f3vin1s.d(85): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2f3vin1s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long\
    \ max_value = numbers[0];\n    long max_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[max_index];\n        max_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_value =\
    \ numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_index = i;\n        }\n    }\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[min_index];\n        min_index++;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling median element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3\nunittest\n{\n    alias candidate = rolling_max;\n\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwsrwb4c6.d(89): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwsrwb4c6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
    \ generate an array of rolling maximum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int i =\
    \ 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\
    \n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n\
    \    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkgqacuki.d(12): Error: cannot implicitly convert expression `numbers.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkgqacuki.d(22): Error: undefined identifier\
    \ `max`, did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpkgqacuki.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
