name: HumanEval_87_get_row
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> \n    {\n        if(lst[i][j] == x)\n   \
    \     {\n            Tuple!(long, long)[] coord = new Tuple!(long, long)[] {i,\
    \ j};\n            foreach(k -> foreach(l -> \n            {\n               \
    \ if(lst[k][l] == x)\n                {\n                    Tuple!(long, long)[]\
    \ coord2 = new Tuple!(long, long)[] {k, l};\n                    foreach(m ->\
    \ foreach(n -> \n                    {\n                        if(lst[m][n] ==\
    \ x)\n                        {\n                            Tuple!(long, long)[]\
    \ coord3 = new Tuple!(long, long)[] {m, n};\n                            foreach(o\
    \ -> foreach(p -> \n                            {\n                          \
    \      if(lst[o][p] == x)\n                                {\n               \
    \                     Tuple!(long, long)[] coord4 = new Tuple!(long, long)[] {o,\
    \ p};\n                                    foreach(q -> foreach(r -> \n      \
    \                              {\n                                        if(lst[r][q]\
    \ == x)\n                                        {\n                         \
    \                   Tuple!(long, long)[] coord5 = new Tuple!(long, long)[] {r,\
    \ q};\n                                            foreach(s -> foreach(t -> \n\
    \                                            {\n                             \
    \                   if(lst[t][s] == x)\n                                     \
    \           {\n                                                    Tuple!(long,\
    \ long)[] coord6 = new Tuple!(long, long)[] {t, s};\n                        \
    \                            foreach(u -> foreach(v -> \n                    \
    \                                {\n                                         \
    \               if(lst[u][v] == x)\n                                         \
    \               {\n                                                          \
    \  Tuple!(long, long)[] coord7 = new Tuple!(long, long)[] {u, v};\n          \
    \                                                  foreach(w -> foreach(x -> \n\
    \                                                            {\n             \
    \                                                   if(lst[x][w] == x)\n     \
    \                                                           {\n              \
    \                                                      Tuple!(long, long)[] coord8\
    \ = new Tuple!(long, long)[] {x, w};\n                                       \
    \                             foreach(y -> foreach(z -> \n                   \
    \                                                 {\n                        \
    \                                                if(lst[z][y] == x)\n        \
    \                                                                {\n         \
    \                                                                   Tuple!(long,\
    \ long)[] coord9 = new Tuple!(long, long)[] {z, y};\n                        \
    \                                                    foreach(a -> foreach(b ->\
    \ \n                                                                         \
    \   {\n                                                                      \
    \          if(lst[a][b] == x)\n                                              \
    \                                  {\n                                       \
    \                                             Tuple!(long, long)[] coord10 = new\
    \ Tuple!(long, long)[] {a, b};\n                                             \
    \                                       foreach(c -> foreach(d -> \n         \
    \                                                                           {\n\
    \                                                                            \
    \            if(lst[d][c] == x)\n                                            \
    \                                            {\n                             \
    \                                                               Tuple!(long, long)[]\
    \ coord11 = new Tuple!(long, long)[] {d, c};\n                               \
    \                                                             foreach(e -> foreach(f\
    \ -> \n                                                                      \
    \                      {\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2thlb4eu.d(27): Error: no identifier for declarator `i`\\n/tmp/tmp2thlb4eu.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmp2thlb4eu.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmp2thlb4eu.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmp2thlb4eu.d(28): Error: use `.` for member lookup, not `->`\\n/tmp/tmp2thlb4eu.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmp2thlb4eu.d(30): Error: found\
    \ `{` when expecting `;` following statement\\n/tmp/tmp2thlb4eu.d(31): Error:\
    \ semicolon expected, not `{`\\n/tmp/tmp2thlb4eu.d(31): Error: found `}` when\
    \ expecting `;` following statement\\n/tmp/tmp2thlb4eu.d(31): Deprecation: use\
    \ `{ }` for an empty statement, not `;`\\n/tmp/tmp2thlb4eu.d(32): Error: no identifier\
    \ for declarator `k`\\n/tmp/tmp2thlb4eu.d(32): Error: found `-` when expecting\
    \ `;`\\n/tmp/tmp2thlb4eu.d(32): Error: expression expected, not `>`\\n/tmp/tmp2thlb4eu.d(32):\
    \ Error: found `foreach` when expecting `)`\\n/tmp/tmp2thlb4eu.d(33): Error: use\
    \ `.` for member lookup, not `->`\\n/tmp/tmp2thlb4eu.d(32): Error: found `if`\
    \ when expecting `)`\\n/tmp/tmp2thlb4eu.d(35): Error: found `{` when expecting\
    \ `;` following statement\\n/tmp/tmp2thlb4eu.d(36): Error: semicolon expected,\
    \ not `{`\\n/tmp/tmp2thlb4eu.d(36): Error: found `}` when expecting `;` following\
    \ statement\\n/tmp/tmp2thlb4eu.d(36): Deprecation: use `{ }` for an empty statement,\
    \ not `;`\\n/tmp/tmp2thlb4eu.d(37): Error: no identifier for declarator `m`\\\
    n/tmp/tmp2thlb4eu.d(37): Error: found `-` when expecting `;`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2thlb4eu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row) do\n\
    \    {\n        foreach(col) do\n        {\n            if(col == x)\n       \
    \     {\n                result ~= Tuple!(row, col);\n            }\n        }\n\
    \    }\n    \n    sort(result);\n    sort(result, descending);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ldmjiqb.d(27): Error: no identifier for declarator `row`\\n/tmp/tmp4ldmjiqb.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp4ldmjiqb.d(27): Error: expression\
    \ expected, not `do`\\n/tmp/tmp4ldmjiqb.d(28): Error: found `{` when expecting\
    \ `)`\\n/tmp/tmp4ldmjiqb.d(29): Error: no identifier for declarator `col`\\n/tmp/tmp4ldmjiqb.d(29):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp4ldmjiqb.d(29): Error: expression\
    \ expected, not `do`\\n/tmp/tmp4ldmjiqb.d(30): Error: found `{` when expecting\
    \ `)`\\n/tmp/tmp4ldmjiqb.d(36): Error: unrecognized declaration\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ldmjiqb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            if(lst[i][j] == x)\n\
    \            {\n                row.push((i, j));\n            }\n        });\n\
    \        res.push(row);\n    }), 0);\n    \n    foreach(i -> foreach(j -> {\n\
    \        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k\
    \ -> {\n            if(lst[i][j] == x)\n            {\n                row.push((i,\
    \ j));\n            }\n        });\n        res.push(row);\n    }), 1);\n    \n\
    \    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long,\
    \ long)[];\n        foreach(k -> {\n            if(lst[i][j] == x)\n         \
    \   {\n                row.push((i, j));\n            }\n        });\n       \
    \ res.push(row);\n    }), 2);\n    \n    foreach(i -> foreach(j -> {\n       \
    \ Tuple!(long, long)[] row = new Tuple!(long, long)[];\n        foreach(k -> {\n\
    \            if(lst[i][j] == x)\n            {\n                row.push((i, j));\n\
    \            }\n        });\n        res.push(row);\n    }), 3);\n    \n    foreach(i\
    \ -> foreach(j -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n\
    \        foreach(k -> {\n            if(lst[i][j] == x)\n            {\n     \
    \           row.push((i, j));\n            }\n        });\n        res.push(row);\n\
    \    }), 4);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(lst[i][j]\
    \ == x)\n            {\n                row.push((i, j));\n            }\n   \
    \     });\n        res.push(row);\n    }), 5);\n    \n    foreach(i -> foreach(j\
    \ -> {\n        Tuple!(long, long)[] row = new Tuple!(long, long)[];\n       \
    \ foreach(k -> {\n            if(lst[i][j] == x)\n            {\n            \
    \    row.push((i, j));\n            }\n        });\n        res.push(row);\n \
    \   }), 6);\n    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[]\
    \ row = new Tuple!(long, long)[];\n        foreach(k -> {\n            if(lst[i][j]\
    \ == x)\n            {\n                row.push((i, j));\n            }\n   \
    \     });\n        res.push(row);\n    }), 7);\n\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8sy0p6in.d(27): Error: no identifier for declarator `i`\\n/tmp/tmp8sy0p6in.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmp8sy0p6in.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmp8sy0p6in.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmp8sy0p6in.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmp8sy0p6in.d(27):\
    \ Error: found `Tuple` when expecting `)`\\n/tmp/tmp8sy0p6in.d(28): Error: found\
    \ `!` when expecting `;` following statement\\n/tmp/tmp8sy0p6in.d(28): Error:\
    \ found `,` when expecting `.` following long\\n/tmp/tmp8sy0p6in.d(28): Error:\
    \ found `long` when expecting identifier following `long`.\\n/tmp/tmp8sy0p6in.d(28):\
    \ Error: found `row` when expecting `;` following statement\\n/tmp/tmp8sy0p6in.d(28):\
    \ Error: found `=` instead of statement\\n/tmp/tmp8sy0p6in.d(29): Error: no identifier\
    \ for declarator `k`\\n/tmp/tmp8sy0p6in.d(29): Error: found `-` when expecting\
    \ `;`\\n/tmp/tmp8sy0p6in.d(29): Error: expression expected, not `>`\\n/tmp/tmp8sy0p6in.d(29):\
    \ Error: found `{` when expecting `)`\\n/tmp/tmp8sy0p6in.d(34): Error: declaration\
    \ expected, not `)`\\n/tmp/tmp8sy0p6in.d(35): Error: function declaration without\
    \ return type. (Note that constructors are always named `this`)\\n/tmp/tmp8sy0p6in.d(35):\
    \ Error: no identifier for declarator `res.push(row)`\\n/tmp/tmp8sy0p6in.d(36):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp8sy0p6in.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res;\n    \n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res = Tuple!(long, long)[](row,col);\n            }\n\
    \        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnwgi57kv.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmpnwgi57kv.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpnwgi57kv.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmpnwgi57kv.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmpnwgi57kv.d(36): Error: found `}` when expecting `)`\\n/tmp/tmpnwgi57kv.d(40):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmpnwgi57kv.d(51): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnwgi57kv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row,lst) \n    {\n        foreach(col,row) \n        {\n  \
    \          if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row,col)));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res,true);\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp35p4022n.d(27): Error: no identifier for declarator `lst`\\n/tmp/tmp35p4022n.d(27):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp35p4022n.d(29): Error: no identifier\
    \ for declarator `row`\\n/tmp/tmp35p4022n.d(29): Error: found `)` when expecting\
    \ `;`\\n/tmp/tmp35p4022n.d(36): Error: found `}` when expecting `)`\\n/tmp/tmp35p4022n.d(43):\
    \ Error: found `unittest` when expecting `)`\\n/tmp/tmp35p4022n.d(54): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp35p4022n.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst) \n    {\n        foreach(column: row) \n        {\n\
    \            if(column == x) \n            {\n                result.push(Tuple!(long,\
    \ long)((row, column)));\n            }\n        }\n    }\n    \n    sort(result);\n\
    \    sort(result, (a, b) => a.first > b.first);\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl1yd0j8e.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpl1yd0j8e.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpl1yd0j8e.d(29): Error: no identifier\
    \ for declarator `column`\\n/tmp/tmpl1yd0j8e.d(29): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl1yd0j8e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res, (a, b) -> {\n        if(a.i > b.i)\n            return 1;\n      \
    \  if(a.i < b.i)\n            return -1;\n        return 0;\n    });\n    \n \
    \   sort(res, (a, b) -> {\n        if(a.c > b.c)\n            return 1;\n    \
    \    if(a.c < b.c)\n            return -1;\n        return 0;\n    });\n    \n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz3ytb79w.d(27): Error: no identifier for declarator `i`\\n/tmp/tmpz3ytb79w.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmpz3ytb79w.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmpz3ytb79w.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmpz3ytb79w.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmpz3ytb79w.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmpz3ytb79w.d(29): Error: found\
    \ `res` when expecting `;` following statement\\n/tmp/tmpz3ytb79w.d(30): Error:\
    \ declaration expected, not `)`\\n/tmp/tmpz3ytb79w.d(32): Error: unexpected `(`\
    \ in declarator\\n/tmp/tmpz3ytb79w.d(32): Error: basic type expected, not `(`\\\
    n/tmp/tmpz3ytb79w.d(32): Error: function declaration without return type. (Note\
    \ that constructors are always named `this`)\\n/tmp/tmpz3ytb79w.d(32): Error:\
    \ found `-` when expecting `)`\\n/tmp/tmpz3ytb79w.d(32): Error: no identifier\
    \ for declarator `sort(res, _error_(a, b))`\\n/tmp/tmpz3ytb79w.d(32): Error: semicolon\
    \ expected following function declaration\\n/tmp/tmpz3ytb79w.d(32): Error: declaration\
    \ expected, not `>`\\n/tmp/tmpz3ytb79w.d(35): Error: declaration expected, not\
    \ `if`\\n/tmp/tmpz3ytb79w.d(37): Error: declaration expected, not `return`\\n/tmp/tmpz3ytb79w.d(38):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz3ytb79w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if (lst[i][j] == x) \n       \
    \     res[res.length] = Tuple!(i, j);\n    }), std.range(0, lst.length));\n  \
    \  \n    sort(res, (a, b) => a.first > b.first);\n    sort(res, (a, b) => a.second\
    \ > b.second);\n    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwei9q574.d(27): Error: no identifier for declarator `i`\\n/tmp/tmpwei9q574.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmpwei9q574.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmpwei9q574.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmpwei9q574.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmpwei9q574.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmpwei9q574.d(29): Error: found\
    \ `res` when expecting `;` following statement\\n/tmp/tmpwei9q574.d(30): Error:\
    \ declaration expected, not `)`\\n/tmp/tmpwei9q574.d(32): Error: unexpected `(`\
    \ in declarator\\n/tmp/tmpwei9q574.d(32): Error: basic type expected, not `(`\\\
    n/tmp/tmpwei9q574.d(32): Error: function declaration without return type. (Note\
    \ that constructors are always named `this`)\\n/tmp/tmpwei9q574.d(32): Error:\
    \ found `=>` when expecting `)`\\n/tmp/tmpwei9q574.d(32): Error: no identifier\
    \ for declarator `sort(res, _error_(a, b))`\\n/tmp/tmpwei9q574.d(32): Error: semicolon\
    \ expected following function declaration\\n/tmp/tmpwei9q574.d(32): Error: no\
    \ identifier for declarator `a.first`\\n/tmp/tmpwei9q574.d(32): Error: declaration\
    \ expected, not `>`\\n/tmp/tmpwei9q574.d(33): Error: unexpected `(` in declarator\\\
    n/tmp/tmpwei9q574.d(33): Error: basic type expected, not `(`\\n/tmp/tmpwei9q574.d(33):\
    \ Error: function declaration without return type. (Note that constructors are\
    \ always named `this`)\\n/tmp/tmpwei9q574.d(33): Error: found `=>` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwei9q574.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res.add((i, j));\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    sort(res, true);\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdrzvps6s.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmpdrzvps6s.d(32): Error:\
    \ no property `add` for type `Tuple!(long, long)[]`\\n/tmp/tmpdrzvps6s.d(37):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmpdrzvps6s.d(38):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrzvps6s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n        {\n\
    \            ret.push((i, j));\n        }\n    }), std.range(0, lst.length));\n\
    \    \n    ret.sort(function(a, b) {\n        return a[0] - b[0];\n    });\n \
    \   \n    ret.sort(function(a, b) {\n        return a[1] - b[1];\n    });\n  \
    \  \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy7qg0x6n.d(27): Error: no identifier for declarator `i`\\n/tmp/tmpy7qg0x6n.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmpy7qg0x6n.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmpy7qg0x6n.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmpy7qg0x6n.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmpy7qg0x6n.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmpy7qg0x6n.d(29): Error: found\
    \ `{` when expecting `;` following statement\\n/tmp/tmpy7qg0x6n.d(32): Error:\
    \ unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpy7qg0x6n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n\
    \            if(col == x) \n            {\n                res.push(Tuple!(long,\
    \ long)((row, col)));\n            }\n        }\n    }\n    \n    res.sort();\n\
    \    foreach(row::lst) \n    {\n        foreach(col::row) \n        {\n      \
    \      if(col > x) \n            {\n                res.push(Tuple!(long, long)((row,\
    \ col)));\n            }\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp48oi3wcd.d(27): Error: no identifier for declarator `row`\\n/tmp/tmp48oi3wcd.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmp48oi3wcd.d(27): Error: expression\
    \ expected, not `:`\\n/tmp/tmp48oi3wcd.d(27): Error: found `lst` when expecting\
    \ `)`\\n/tmp/tmp48oi3wcd.d(27): Error: found `)` instead of statement\\n/tmp/tmp48oi3wcd.d(35):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp48oi3wcd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n\
    \    \n    foreach(row: lst)\n    {\n        foreach(column: row)\n        {\n\
    \            if(column == x)\n            {\n                result.push(Tuple!(long,\
    \ long)((row, column)));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbqks_0ev.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpbqks_0ev.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpbqks_0ev.d(29): Error: no identifier\
    \ for declarator `column`\\n/tmp/tmpbqks_0ev.d(29): Error: found `:` when expecting\
    \ `;`\\n/tmp/tmpbqks_0ev.d(38): Error: missing `{ ... }` for function literal\\\
    n/tmp/tmpbqks_0ev.d(38): Error: expression expected, not `>`\\n/tmp/tmpbqks_0ev.d(38):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpbqks_0ev.d(39): Error: missing\
    \ `{ ... }` for function literal\\n/tmp/tmpbqks_0ev.d(39): Error: expression expected,\
    \ not `>`\\n/tmp/tmpbqks_0ev.d(39): Error: found `a` when expecting `,`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbqks_0ev.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = null;\n    foreach(row: lst)\
    \ {\n        foreach(col: row) {\n            if (col == x) {\n              \
    \  res = Tuple!(long, long)[](row, col);\n            }\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfrqi53x6.d(26): Error: no identifier for declarator `row`\\n/tmp/tmpfrqi53x6.d(26):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpfrqi53x6.d(27): Error: no identifier\
    \ for declarator `col`\\n/tmp/tmpfrqi53x6.d(27): Error: found `:` when expecting\
    \ `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrqi53x6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    for(int i = 0; i < lst.length; i++){\n        if(lst[i].length == x){\n \
    \           for(int j = 0; j < lst[i].length; j++){\n                if(lst[i][j]\
    \ == x){\n                    res.push(new Tuple!(i, j));\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp30ng5f8u.d(25): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `Tuple!(long, long)[]`\\'s\\n/tmp/tmp30ng5f8u.d(30): Error:\
    \ no property `push` for type `Tuple!(long, long)[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp30ng5f8u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n            res[res.length]\
    \ = Tuple!(i, j);\n    }), 0..lst.length-1);\n    sort(res);\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt8au2uj_.d(26): Error: no identifier for declarator `i`\\n/tmp/tmpt8au2uj_.d(26):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmpt8au2uj_.d(26): Error: expression\
    \ expected, not `>`\\n/tmp/tmpt8au2uj_.d(26): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmpt8au2uj_.d(26): Error: use `.` for member lookup, not `->`\\n/tmp/tmpt8au2uj_.d(26):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmpt8au2uj_.d(28): Error: found\
    \ `res` when expecting `;` following statement\\n/tmp/tmpt8au2uj_.d(29): Error:\
    \ declaration expected, not `)`\\n/tmp/tmpt8au2uj_.d(30): Error: function declaration\
    \ without return type. (Note that constructors are always named `this`)\\n/tmp/tmpt8au2uj_.d(30):\
    \ Error: no identifier for declarator `sort(res)`\\n/tmp/tmpt8au2uj_.d(31): Error:\
    \ declaration expected, not `return`\\n/tmp/tmpt8au2uj_.d(32): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt8au2uj_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] result;\n    \n    foreach(row: lst,\
    \ i: int) \n    {\n        foreach(col: row, j: int) \n        {\n           \
    \ if (col == x) \n            {\n                Tuple!(long, long)[] coord =\
    \ Tuple!(i, j);\n                sort(coord, (x, y) => y - x);\n             \
    \   sort(coord, (x, y) => y - x);\n                foreach(coord : coord, i :\
    \ int ) \n                {\n                    result = append(result, coord);\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaz0rt67w.d(27): Error: no identifier for declarator `row`\\n/tmp/tmpaz0rt67w.d(27):\
    \ Error: found `:` when expecting `;`\\n/tmp/tmpaz0rt67w.d(27): Error: found `:`\
    \ when expecting `)`\\n/tmp/tmpaz0rt67w.d(27): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmpaz0rt67w.d(27): Error: found `)` instead of statement\\n/tmp/tmpaz0rt67w.d(36):\
    \ Error: no identifier for declarator `coord`\\n/tmp/tmpaz0rt67w.d(36): Error:\
    \ found `:` when expecting `;`\\n/tmp/tmpaz0rt67w.d(36): Error: found `:` when\
    \ expecting `)`\\n/tmp/tmpaz0rt67w.d(36): Error: no identifier for declarator\
    \ `int`\\n/tmp/tmpaz0rt67w.d(36): Error: found `)` instead of statement\\n/tmp/tmpaz0rt67w.d(40):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpaz0rt67w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), range(0, lst.length));\n    \n  \
    \  sort(res, (i, j) -> {\n        if(i < j)\n            return 1;\n        else\
    \ if(i > j)\n            return -1;\n        else\n            return 0;\n   \
    \ });\n    \n    sort(res, (i, j) -> {\n        if(i < j)\n            return\
    \ -1;\n        else if(i > j)\n            return 1;\n        else\n         \
    \   return 0;\n    });\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptr0zui4b.d(27): Error: no identifier for declarator `i`\\n/tmp/tmptr0zui4b.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmptr0zui4b.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmptr0zui4b.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmptr0zui4b.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmptr0zui4b.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmptr0zui4b.d(29): Error: found\
    \ `res` when expecting `;` following statement\\n/tmp/tmptr0zui4b.d(30): Error:\
    \ declaration expected, not `)`\\n/tmp/tmptr0zui4b.d(32): Error: unexpected `(`\
    \ in declarator\\n/tmp/tmptr0zui4b.d(32): Error: basic type expected, not `(`\\\
    n/tmp/tmptr0zui4b.d(32): Error: function declaration without return type. (Note\
    \ that constructors are always named `this`)\\n/tmp/tmptr0zui4b.d(32): Error:\
    \ found `-` when expecting `)`\\n/tmp/tmptr0zui4b.d(32): Error: no identifier\
    \ for declarator `sort(res, _error_(i, j))`\\n/tmp/tmptr0zui4b.d(32): Error: semicolon\
    \ expected following function declaration\\n/tmp/tmptr0zui4b.d(32): Error: declaration\
    \ expected, not `>`\\n/tmp/tmptr0zui4b.d(35): Error: declaration expected, not\
    \ `else`\\n/tmp/tmptr0zui4b.d(37): Error: declaration expected, not `else`\\n/tmp/tmptr0zui4b.d(39):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmptr0zui4b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ col = new Tuple!(long, long)[];\n            foreach(l -> {\n              \
    \  Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.first\
    \ = i;\n                coord.second = j;\n                col.first = k;\n  \
    \              col.second = l;\n                row.push(coord);\n           \
    \ });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ col = new Tuple!(long, long)[];\n            foreach(l -> {\n              \
    \  Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.first\
    \ = i;\n                coord.second = j;\n                col.first = k;\n  \
    \              col.second = l;\n                row.push(coord);\n           \
    \ });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ col = new Tuple!(long, long)[];\n            foreach(l -> {\n              \
    \  Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.first\
    \ = i;\n                coord.second = j;\n                col.first = k;\n  \
    \              col.second = l;\n                row.push(coord);\n           \
    \ });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> {\n            Tuple!(long, long)[]\
    \ col = new Tuple!(long, long)[];\n            foreach(l -> {\n              \
    \  Tuple!(long, long)[] coord = new Tuple!(long, long)[];\n                coord.first\
    \ = i;\n                coord.second = j;\n                col.first = k;\n  \
    \              col.second = l;\n                row.push(coord);\n           \
    \ });\n            row.push(col);\n        });\n        res.push(row);\n    }));\n\
    \    \n    foreach(i -> foreach(j -> {\n        Tuple!(long, long)[] row = new\
    \ Tuple!(long, long)[];\n        foreach(k -> \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfdt2zlv4.d(27): Error: no identifier for declarator `i`\\n/tmp/tmpfdt2zlv4.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmpfdt2zlv4.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmpfdt2zlv4.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmpfdt2zlv4.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmpfdt2zlv4.d(27):\
    \ Error: found `Tuple` when expecting `)`\\n/tmp/tmpfdt2zlv4.d(28): Error: found\
    \ `!` when expecting `;` following statement\\n/tmp/tmpfdt2zlv4.d(28): Error:\
    \ found `,` when expecting `.` following long\\n/tmp/tmpfdt2zlv4.d(28): Error:\
    \ found `long` when expecting identifier following `long`.\\n/tmp/tmpfdt2zlv4.d(28):\
    \ Error: found `row` when expecting `;` following statement\\n/tmp/tmpfdt2zlv4.d(28):\
    \ Error: found `=` instead of statement\\n/tmp/tmpfdt2zlv4.d(29): Error: no identifier\
    \ for declarator `k`\\n/tmp/tmpfdt2zlv4.d(29): Error: found `-` when expecting\
    \ `;`\\n/tmp/tmpfdt2zlv4.d(29): Error: expression expected, not `>`\\n/tmp/tmpfdt2zlv4.d(29):\
    \ Error: found `{` when expecting `)`\\n/tmp/tmpfdt2zlv4.d(31): Error: no identifier\
    \ for declarator `l`\\n/tmp/tmpfdt2zlv4.d(31): Error: found `-` when expecting\
    \ `;`\\n/tmp/tmpfdt2zlv4.d(31): Error: expression expected, not `>`\\n/tmp/tmpfdt2zlv4.d(31):\
    \ Error: found `{` when expecting `)`\\n/tmp/tmpfdt2zlv4.d(38): Error: declaration\
    \ expected, not `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfdt2zlv4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    int[] row = new int[lst.Length];\n    int[] col = new\
    \ int[lst.Length];\n    \n    for(int i = 0; i < lst.Length; i++)\n    {\n   \
    \     if(lst[i].Length > 0)\n        {\n            row[i] = i;\n            col[i]\
    \ = lst[i].Length - 1;\n        }\n    }\n    \n    Array.Sort(row);\n    Array.Sort(col);\n\
    \    \n    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.Length];\n\
    \    \n    for(int i = 0; i < lst.Length; i++)\n    {\n        if(lst[i].Length\
    \ > 0)\n        {\n            for(int j = 0; j < lst[i].Length; j++)\n      \
    \      {\n                if(lst[i][j] == x)\n                {\n            \
    \        result[i] = Tuple!(i, j);\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6f5t8kxv.d(25): Error: no property `Length` for type `long[][]`\\\
    n/tmp/tmp6f5t8kxv.d(26): Error: no property `Length` for type `long[][]`\\n/tmp/tmp6f5t8kxv.d(28):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp6f5t8kxv.d(30): Error:\
    \ no property `Length` for type `long[]`\\n/tmp/tmp6f5t8kxv.d(33): Error: no property\
    \ `Length` for type `long[]`\\n/tmp/tmp6f5t8kxv.d(37): Error: undefined identifier\
    \ `Array`\\n/tmp/tmp6f5t8kxv.d(38): Error: undefined identifier `Array`\\n/tmp/tmp6f5t8kxv.d(40):\
    \ Error: no property `Length` for type `long[][]`\\n/tmp/tmp6f5t8kxv.d(42): Error:\
    \ no property `Length` for type `long[][]`\\n/tmp/tmp6f5t8kxv.d(44): Error: no\
    \ property `Length` for type `long[]`\\n/tmp/tmp6f5t8kxv.d(46): Error: no property\
    \ `Length` for type `long[]`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(501):\
    \ Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter\
    \ to non-global template `parseSpecs(Specs...)`\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(614):\
    \ Error: CTFE failed because of previous errors in `injectNamedFields`\\n/tmp/tmp6f5t8kxv.d(50):\
    \ Error: template instance `tmp6f5t8kxv.get_row.Tuple!(i, j)` error instantiating\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6f5t8kxv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested arrays,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the array,\n    and return array of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \    >>> get_row([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L)\n    [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]\n    >>> get_row([], 1L)\n    []\n    >>> get_row([[], [1L],\
    \ [1L, 2L, 3L]], 3L)\n    [tuple(2L, 2L)]\n    \n*/\nTuple!(long, long)[] get_row(long[][]\
    \ lst, long x) \n{\n    Tuple!(long, long)[] res = new Tuple!(long, long)[];\n\
    \    \n    foreach(i -> foreach(j -> {\n        if(lst[i][j] == x)\n         \
    \   res[res.length] = Tuple!(i, j);\n    }), 0 .. lst.length - 1);\n    \n   \
    \ sort(res);\n    sort(res, (a, b) -> -cmp(a.1, b.1));\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7u03t7bt.d(27): Error: no identifier for declarator `i`\\n/tmp/tmp7u03t7bt.d(27):\
    \ Error: found `-` when expecting `;`\\n/tmp/tmp7u03t7bt.d(27): Error: expression\
    \ expected, not `>`\\n/tmp/tmp7u03t7bt.d(27): Error: found `foreach` when expecting\
    \ `)`\\n/tmp/tmp7u03t7bt.d(27): Error: use `.` for member lookup, not `->`\\n/tmp/tmp7u03t7bt.d(27):\
    \ Error: found `if` when expecting `)`\\n/tmp/tmp7u03t7bt.d(29): Error: found\
    \ `res` when expecting `;` following statement\\n/tmp/tmp7u03t7bt.d(30): Error:\
    \ declaration expected, not `)`\\n/tmp/tmp7u03t7bt.d(32): Error: function declaration\
    \ without return type. (Note that constructors are always named `this`)\\n/tmp/tmp7u03t7bt.d(32):\
    \ Error: no identifier for declarator `sort(res)`\\n/tmp/tmp7u03t7bt.d(33): Error:\
    \ unexpected `(` in declarator\\n/tmp/tmp7u03t7bt.d(33): Error: basic type expected,\
    \ not `(`\\n/tmp/tmp7u03t7bt.d(33): Error: function declaration without return\
    \ type. (Note that constructors are always named `this`)\\n/tmp/tmp7u03t7bt.d(33):\
    \ Error: found `-` when expecting `)`\\n/tmp/tmp7u03t7bt.d(33): Error: no identifier\
    \ for declarator `sort(res, _error_(a, b))`\\n/tmp/tmp7u03t7bt.d(33): Error: semicolon\
    \ expected following function declaration\\n/tmp/tmp7u03t7bt.d(33): Error: declaration\
    \ expected, not `>`\\n/tmp/tmp7u03t7bt.d(35): Error: declaration expected, not\
    \ `return`\\n/tmp/tmp7u03t7bt.d(36): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7u03t7bt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
