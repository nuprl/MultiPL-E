name: HumanEval_9_rolling_max
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\n From a given array of integers,\
  \ generate an array of rolling maximum element found until given moment\n    in\
  \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
  \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L])\
  \ == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long max = 0;\n    long currentMax = numbers[0];\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > currentMax)\n        {\n            currentMax\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n    }\n    \n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    long currentMin = numbers[0];\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n    }\n    \n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    long currentSum = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        currentSum += numbers[i];\n        \n        if(currentSum\
    \ > 0)\n        {\n            sum += currentSum;\n        }\n    }\n    \n  \
    \  for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] roll", "{\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n<|\
    \ c |>\nThis doesn't seem to work. `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L})` returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it out yourself. I tested it on `rolling_max(new long[]{1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n\
    <| c |>\nYes, it works. But it also returns `[1L, 2L, 3L, 3L, 3L, 4L, 4L]` for\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L, 2L, 3L, 4L, 2L})`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on `rolling_max(new\
    \ long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out yourself. I tested it on\
    \ `rolling_max(new long[]{1L, 2L, 3L, 2L, 3L, 4L, 2L})` and it returned `[1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]`.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a solution in\
    \ Java that uses no loops and is O(n) time complexity. \n<code>\npublic static\
    \ long[] rolling_max(long[] numbers) {\n    long[] result = new long[numbers.length];\n\
    \    int maxIndex = 0;\n    long maxValue = numbers[0];\n    for (int i = 1; i\
    \ < numbers.length; i++) {\n        if (numbers[i] > maxValue) {\n           \
    \ maxValue = numbers[i];", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    long max = 0;\n    \n    while(j < numbers.length)\n\
    \    {\n        if(numbers[j] > max)\n        {\n            max = numbers[j];\n\
    \        }\n        j++;\n    }\n    \n    while(i < numbers.length)\n    {\n\
    \        result[i] = max;\n        i++;\n        j = 0;\n        \n        while(j\
    \ < numbers.length)\n        {\n            if(numbers[j] > max)\n           \
    \ {\n                max = numbers[j];\n            }\n            j++;\n    \
    \    }\n    }\n    \n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long\
    \ min = 0;\n    \n    while(j < numbers.length)\n    {\n        if(numbers[j]\
    \ < min)\n        {\n            min = numbers[j];\n        }\n        j++;\n\
    \    }\n    \n    while(i < numbers.length)\n    {\n        result[i] = min;\n\
    \        i++;\n        j = 0;\n        \n        while(j < numbers.length)\n \
    \       {\n            if(numbers[j] < min)\n            {\n                min\
    \ = numbers[j];\n            }\n            j++;\n        }\n    }\n    \n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum of element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 9L, 9L, 12L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    long sum = 0;\n    \n    while(j < numbers.length)\n\
    \    {\n        sum += numbers[j];\n        j++;\n    }\n    \n    while(i < numbers.length)\n\
    \    {\n        result[i] = sum;\n        i++;\n        j = 0;\n        \n   \
    \     while(j < numbers.length)\n        {\n            sum += numbers[j];\n \
    \           j++;\n        }\n    }\n    \n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product of element found until\
    \ given moment\n    in the sequence.", "{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    \n    for(int i = 0; i < n; i++)\n    {\n       \
    \ result[i] = numbers[i];\n    }\n    \n    for(int i = 1; i < n; i++)\n    {\n\
    \        result[i] = max(result[i-1], numbers[i]);\n    }\n    \n    return result;\n\
    }", "{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ maxValue = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n        }\n    }\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = maxValue;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long minValue = numbers[0];\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(numbers[i] < minValue)\n        {\n  \
    \          minValue = numbers[i];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        result[i] = minValue;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = sum / n;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long median = 0;\n    long sum = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n        if(sum\
    \ % 2 == 0)\n        {\n            median = numbers[i];\n        }\n    }\n \
    \   for(int i = 0; i < n; i++)\n    {\n        result[i] = median;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling standard deviation ", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    long\
    \ currentMaxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            currentMax = numbers[i];\n            currentMaxIndex = i;\n    \
    \    }\n        else\n        {\n            currentMax = maxValue;\n        \
    \    currentMaxIndex = i;\n        }\n    }\n    result[currentMaxIndex] = currentMax;\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max_so_far = numbers[0];\n    long max_so_far_pos = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_pos =\
    \ i;\n        }\n    }\n    result[max_so_far_pos] = max_so_far;\n    for(int\
    \ i = max_so_far_pos + 1; i < numbers.length; i++)\n    {\n        result[i] =\
    \ numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_pos = i;\n        }\n    }\n    result[min_so_far_pos]\
    \ = min_so_far;\n    for(int i = min_so_far_pos + 1; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long avg_so_far\
    \ = 0;\n    long avg_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        avg_so_far += numbers[i];\n        if(numbers[i] > avg_so_far)\n\
    \        {\n            avg_so_far = numbers[i];\n            avg_so_far_pos =\
    \ i;\n        }\n    }\n    result[avg_so_far_pos] = avg_so_far;\n    for(int\
    \ i = avg_so_far_pos + 1; i < numbers.length; i++)\n    {\n        result[i] =\
    \ numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers, ",
  "{\n    int n = numbers.length;\n    long[] result = new long[n];\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n        {\n\
    \            if(result[j] > result[i])\n            {\n                result[i]\
    \ = result[j];\n            }\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            if(result[j] < result[i])\n            {\n           \
    \     result[i] = result[j];\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n-1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            result[i] += result[j];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 12L, 24L, 24L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(int i = n-1; i >= 0; i--)\n    {\n        for(int\
    \ j = 0; j < i; j++)\n        {\n            result[i] *= result[j];\n", "{\n\
    \    long[] result = new long[numbers.length];\n    long maxValue = numbers[0];\n\
    \    long currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            currentMax\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = currentMax;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long currentMin = minValue;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < currentMin)\n        {\n            currentMin\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = currentMin;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        currentSum += numbers[i];\n        if(currentSum > sum)\n    \
    \    {\n            sum = currentSum;\n        }\n    }\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = 1;\n    long currentProduct = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        currentProduct *= numbers[i];\n        if(currentProduct\
    \ > product)\n        {", "{\n    int n = numbers.length;\n    long[] result =\
    \ new long[n];\n    long max = 0;\n    long current = 0;\n    for (int i = 0;\
    \ i < n; i++) {\n        current = numbers[i];\n        if (current > max) {\n\
    \            max = current;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        current = numbers[i];\n        if (current > max)\n        {\n\
    \            max = current;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        if (current < min)\n   \
    \     {\n            min = current;\n        }\n        result[i] = min;\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L, 6L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long current = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        current = numbers[i];\n        sum += current;\n      \
    \  result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling product element found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 6L, 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_product(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long product = 1;\n\
    \    long current = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        current = numbers[i];\n        product *= current;\n        result[i]\
    \ = product;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling quotient element found until given moment\n   \
    \ in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n \
    \   [1L, 1L, 1L, 1L, 1L, 1L, 1L", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    int maxIndex = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n\
    \            maxValue = numbers[i];\n            maxIndex = i;\n        }\n  \
    \  }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == maxValue)\n        {\n            result[maxIndex] = numbers[i];\n      \
    \  }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    int minIndex = 0;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < minValue)\n\
    \        {\n            minValue = numbers[i];\n            minIndex = i;\n  \
    \      }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == minValue)\n        {\n            result[minIndex] = numbers[i];\n      \
    \  }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long avg = 0;\n    int count =\
    \ 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    avg = sum / count;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == avg)\n        {\n            result[i]\
    \ = avg;\n        }\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n", "{\n\
    \    long max = numbers[0];\n    long[] result = new long[numbers.length];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long sum = 0;\n    long avg = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        avg = sum / numbers.length;\n        result[i] = avg;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> rolling_std([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_std(long[] numbers) \n{\n    long sum = 0;\n \
    \   long ", "{\n    long[] result = new long[numbers.length];\n    long max =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        if (cur > max)\n        {\n            max\
    \ = cur;\n        }\n        result[i] = max;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        if (cur < min)\n        {\n            min\
    \ = cur;\n        }\n        result[i] = min;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n        if (sum / numbers.length == numbers.length)\n        {\n  \
    \          result[i] = sum / numbers.length;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L", "{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for (int i = 1; i < n; i++) {\n        if (numbers[i] > max_so_far)\
    \ {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    result[max_so_far_index] = max_so_far;\n    for (int i\
    \ = 1; i < n; i++) {\n        if (numbers[i] < max_so_far) {\n            result[max_so_far_index]\
    \ = max_so_far;\n        }\n        max_so_far = numbers[i];\n        max_so_far_index\
    \ = i;\n    }\n    return result;\n}", "{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long max = 0;\n    for(int i = 0; i < n; i++)\n \
    \   {\n        max = numbers[i];\n        for(int j = i; j < n; j++)\n       \
    \ {\n            if(numbers[j] > max)\n            {\n                max = numbers[j];\n\
    \            }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    for(int i = 0; i < n; i++)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < n; j++)\n        {\n            if(numbers[j] < min)\n\
    \            {\n                min = numbers[j];\n            }\n        }\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum of element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    int n = numbers.length;\n    long[] result = new long[n];\n    long sum\
    \ = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum = numbers[i];\n   \
    \     for(int j = i; j < n; j++)\n        {\n            sum += numbers[j];\n\
    \        }\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling product of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L, 6L, 6L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long prod = 1;\n    for(int i = 0; i < n; i++)\n    {\n        prod = numbers[i];\n\
    \        for(int j = i; j < n; j++)\n        {\n            prod *= numbers[j];\n\
    \        }\n        result[i] = prod;\n    }\n    return result;\n}\n/*\n From ",
  "{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    long max\
    \ = 0;\n    while(i < numbers.length)\n    {\n        max = numbers[i];\n    \
    \    for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ > max)\n            {\n                max = numbers[j];\n            }\n  \
    \      }\n        result[i] = max;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    while(i < numbers.length)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ < min)\n            {\n                min = numbers[j];\n            }\n  \
    \      }\n        result[i] = min;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    while(i < numbers.length)\n    {\n        sum += numbers[i];\n\
    \        i++;\n    }\n    double avg = sum / numbers.length;\n    while(i < numbers.length)\n\
    \    {\n        result[i] = numbers[i] - avg;\n        i++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long median = 0;\n    while(i < numbers.length)\n    {\n\
    \        median = (numbers[i]+numbers[i+1])/2;\n        for(int j = i; j < ",
  "{\n    long max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    result[max_so_far_index] = max_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    result[min_so_far_index] = min_so_far;\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling sum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long sum_so_far = 0;\n    long sum_so_far_index = -1;\n  \
    \  for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum_so_far;\n    }\n    result[sum_so_far_index] = sum_so_far;\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.",
  "{\n    long max_value = numbers[0];\n    long max_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n      \
    \  {\n            max_value = numbers[i];\n            max_index = i;\n      \
    \  }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n \
    \       max_index++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min_value = numbers[0];\n    long min_index = 0;\n    for(int i =\
    \ 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n   \
    \     {\n            min_value = numbers[i];\n            min_index = i;\n   \
    \     }\n    }\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \        min_index++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling median element found until given moment\n    in the sequence.\n \
    \   >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3", "{\n  \
    \  int n = numbers.length;\n    long[] result = new long[n];\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n  \
    \  for(int i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i],\
    \ numbers[i]);\n    }\n    \n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_pos\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_pos = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_pos]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n \
    \   {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_pos = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[min_so_far_pos] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_pos = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n        if(sum_so_far\
    \ >= numbers[i])\n        {\n            sum_so_far_pos = i;\n        }\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ sum_so_far)\n        {\n            result[sum_so_far_pos] = numbers[i];\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.", "{\n    long max = numbers[0];\n    long max_index = -1;\n \
    \   for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n            max_index = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n  \
    \  }\n    result[max_index] = max;\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long min = numbers[0];\n    long min_index = -1;\n    for (int i =\
    \ 1; i < numbers.length; i++)\n    {\n        if (numbers[i] < min)\n        {\n\
    \            min = numbers[i];\n            min_index = i;\n        }\n    }\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    result[min_index] =\
    \ min;\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    long sum = 0;\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum += result[i];\n    }\n    result[0]\
    \ = sum;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    long sum = 0;\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum += result[i];\n    }\n    double\
    \ avg = sum / numbers.length;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n\
    \    int i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    \n \
    \   for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = max;\n   \
    \ }\n    \n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    for(int i = maxIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i - maxIndex] = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = minIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i - minIndex] = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[i] = sum;\n        }\n        else\n        {\n            result[i]\
    \ = sum / sumIndex;\n        }\n        sumIndex++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[i] = ", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            maxIndex = i;\n        }\n \
    \   }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long\
    \ min = 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            result[i] = min;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] + numbers[i\
    \ + 1];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] / 2;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling variance element found\
    \ until given moment\n    in the sequence.\n    >>> ", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max_value = numbers[0];\n    long max_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_value)\n        {\n            result[max_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_value = numbers[0];\n\
    \    long min_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            result[min_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        long avg = sum / count;\n        result[i] = avg;\n   \
    \     sum += numbers[i];\n        count++;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long count = 0;\n    ", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    \n    for(int i = 0; i < n; i++)\n\
    \    {\n        result[i] = std.math.max(result[i], numbers[i]);\n    }\n    \n\
    \    return result;\n}", "{\n    int n = numbers.length;\n    long[] result =\
    \ new long[n];\n    \n    for(int i = 0; i < n; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    \n    for(int i = n - 1; i >= 0; i--)\n    {\n   \
    \     result[i] = max(result[i], numbers[i]);\n    }\n    \n    return result;\n\
    }", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        if(sum == numbers[i])\n        {\n       \
    \     sumIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[sumIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long product\
    \ = 1;\n    long productIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        product *= numbers[i];\n        if(product == numbers[i])\n  \
    \      {\n            productIndex = i;\n        }\n    }\n    long[] result =\
    \ new long[numbers.length];", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long max = 0;\n    long cur = 0;\n    \n    for(; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        max = cur;\n        \n     \
    \   for(; i < numbers.length && numbers[i] > cur; i++)\n        {\n          \
    \  max = cur;\n            cur = numbers[i];\n        }\n        \n        result[i]\
    \ = max;\n    }\n    \n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long min = 0;\n    long\
    \ cur = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        min = cur;\n        \n        for(; i < numbers.length && numbers[i]\
    \ < cur; i++)\n        {\n            min = cur;\n            cur = numbers[i];\n\
    \        }\n        \n        result[i] = min;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    long cur = 0;\n    \n    for(; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        sum = cur;\n        \n        for(;\
    \ i < numbers.length && numbers[i] > cur; i++)\n        {\n            sum = cur;\n\
    \            cur = numbers[i];\n        }\n        \n        result[i] = sum;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long ", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = numbers[0];\n    long max_so_far\
    \ = numbers[0];\n    for (int i = 1; i < n; i++) {\n        if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n            max_so_far = max;\n        }\n\
    \    }\n    result[0] = max_so_far;\n    for (int i = 1; i < n; i++) {\n     \
    \   result[i] = numbers[i];\n        if (numbers[i] > max_so_far) {\n        \
    \    result[i] = max_so_far;\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = numbers[0];\n    long min_so_far = numbers[0];\n    for (int i\
    \ = 1; i < n; i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n\
    \            min_so_far = min;\n        }\n    }\n    result[0] = min_so_far;\n\
    \    for (int i = 1; i < n; i++) {\n        result[i] = numbers[i];\n        if\
    \ (numbers[i] < min_so_far) {\n            result[i] = min_so_far;\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long count = 0;\n  \
    \  for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    long max_so_far = numbers[0];\n    long\
    \ min_so_far = numbers[0];\n    for (int i = 1; i < n; i++) {\n        if (numbers[i]\
    \ > max_so_far) {\n            max_so_far = numbers[i];\n        }\n        if\
    \ (numbers[i] < min_so_far) {\n            min_so_far = numbers[i];\n        }\n\
    \    }\n    result[0] = max_so_far;\n    result[1] = min_so_far;\n    for (int\
    \ i = 2; i < n; i++) {\n        result[i] = numbers[i];", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    int i = 0;\n\
    \    for(; i < numbers.length; ++i)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; ++i)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; ++i)\n    {\n        if(numbers[i] < min_value)\n\
    \        {\n            min_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; ++i)\n    {\n        result[i] = min_value;\n        min_value\
    \ -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; ++i)\n    {\n        sum += numbers[i];\n    }\n    for(;\
    \ i < numbers.length; ++i)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum -= numbers[i] * result[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; ++i)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; ++i)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum -= numbers[i] * ", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max_so_far)\n        {\n            result[i]\
    \ = max_so_far_index;\n        }\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[i] = min_so_far_index;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long avg_so_far = numbers[0];\n    long avg_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > avg_so_far)\n\
    \        {\n            avg_so_far = numbers[i];\n            avg_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == avg_so_far)\n        {\n            result[i] = avg_so_far_index;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling count element found until given moment\n    in the sequence.\n\
    \    >>> rolling_count([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L", "{\n    long max = numbers[0];\n    long max_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            max_pos = i;\n        }\n  \
    \  }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[max_pos - i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long min_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            min_pos = i;\n        }\n  \
    \  }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[min_pos - i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - avg;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[(i + numbers.length / 2) % numbers.length];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, ", "{\n  \
    \  long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    long max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            result[max_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[min_so_far_index] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum_so_far = 0;\n    long sum_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        sum_so_far_index += i;\n    }\n    long avg_so_far =\
    \ sum_so_far / sum_so_far_index;\n    long avg_so_far_index = sum_so_far_index;\n\
    \    for(int i = 1; i < numbers.length; i++)", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    long maxIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[maxIndex] = max;\n  \
    \  return result;\n}", "{\n    long[] result = new long[numbers.length];\n   \
    \ long max = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            index = i;\n        }\n    }\n    result[index] = max;\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            index = i;\n        }\n    }\n    result[index] = min;\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 3L, 6L, 10L, 6L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > 0)\n        {\n  \
    \          index = i;\n        }\n    }\n    result[index] = sum;\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 4L, 3L, 4L, 5L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > 0)\n        {\n  \
    \          index = i;\n        }\n    }\n    double avg = sum / numbers.length;\n\
    \    result[index] = avg;\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    \n    while(i < numbers.length)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n        \n        result[i] = max;\n        i++;\n    }\n    \n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    int i = 0;\n    \n    while(i < numbers.length)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \    }\n        \n        result[i] = min;\n        i++;\n    }\n    \n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    \n    while(i < numbers.length)\n    {\n        result[i]\
    \ = numbers[i] + numbers[i + 1];\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    \n    while(i < numbers.length)\n    {\n        result[i] = numbers[i] +\
    \ numbers[i + 1];\n        i++;\n    }\n    \n    long sum = 0;\n    for(long\
    \ number : result)\n    {\n        sum += number;\n    }\n    \n    double average\
    \ = sum / result.length;\n    \n    for(long number : result)\n    {\n       \
    \ number /= average;\n    }\n    \n    return result;\n}\n/*\n From a given array\
    \ of ", "{\n    long max_value = numbers[0];\n    long max_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; ++i)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n            max_pos = i;\n  \
    \      }\n    }\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[max_pos];\n\
    \        max_pos++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min_value = numbers[0];\n    long min_pos = 0;\n    for(int i = 1;\
    \ i < numbers.length; ++i)\n    {\n        if(numbers[i] < min_value)\n      \
    \  {\n            min_value = numbers[i];\n            min_pos = i;\n        }\n\
    \    }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i <\
    \ numbers.length; ++i)\n    {\n        result[i] = numbers[min_pos];\n       \
    \ min_pos++;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; ++i)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; ++i)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling median element found until given moment\n    in the sequence.\n \
    \   >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n", "{\n    long max = 0;\n\
    \    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \        maxIndex++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min = numbers[0];\n    long minIndex = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n     \
    \       min = numbers[i];\n            minIndex = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[minIndex];\n        minIndex++;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum % 2 == 0)\n        {\n\
    \            result[i] = numbers[numbers.length / 2];\n        }\n        else\n\
    \        {\n            result[i] = (numbers[numbers.length / 2] + numbers[numbers.length\
    \ / 2 - 1]) / 2;\n        }\n    }", "{\n    long max = 0;\n    long maxIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        sumIndex++;\n    }\n    long avg = sum / sumIndex;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[sumIndex - 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        sumIndex++;\n    }\n    long avg = sum / sumIndex;\n    long sumSquare\
    \ = 0;\n    long sumSquare", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_so_far)\n        {\n            result[i] = max_so_far_index;\n\
    \        }\n        else\n        {\n            result[i] = max_so_far;\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[i]\
    \ = min_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = min_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum_so_far = 0;\n \
    \   long sum_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum_so_far += numbers[i];\n        if(sum_so_far >= numbers[i])\n\
    \        {\n            sum_so_far = numbers[i];\n            sum_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == sum_so_far)\n        {\n            result[i] = sum_so_far_index;",
  "{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int max = 0;\n    \n    while (j < numbers.length)\n    {\n\
    \        if (numbers[j] > max)\n        {\n            max = numbers[j];\n   \
    \         k = j;\n        }\n        j++;\n    }\n    \n    while (i < numbers.length)\n\
    \    {\n        if (numbers[i] > max)\n        {\n            result[k] = numbers[i];\n\
    \            k++;\n        }\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int min = 0;\n    \n    while (j < numbers.length)\n\
    \    {\n        if (numbers[j] < min)\n        {\n            min = numbers[j];\n\
    \            k = j;\n        }\n        j++;\n    }\n    \n    while (i < numbers.length)\n\
    \    {\n        if (numbers[i] < min)\n        {\n            result[k] = numbers[i];\n\
    \            k++;\n        }\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    long sum = 0;\n    \n    while (j < numbers.length)\n\
    \    {\n        sum = sum + numbers[j];\n        j++;\n    }\n    \n    while\
    \ (i < numbers.length)\n    {\n        sum = sum + numbers[i];\n        result[k]\
    \ = sum;\n        k++;\n        i++;\n    }\n    \n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = 0;\n    long maxIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > max)\n        {\n            result[i] = max;\n        }\n\
    \        else\n        {\n            result[i] = numbers[i];\n        }\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long minIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            minIndex = i;\n        }\n \
    \   }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            result[i] = min;\n        }\n        else\n \
    \       {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sumIndex == 0)\n        {\n     \
    \       result[i] = sum;\n        }\n        else\n        {\n            result[i]\
    \ = sum - result[sumIndex];\n        }\n        sumIndex++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n", "{\n    long[] result = new long[numbers.length];\n   \
    \ long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            maxValue = numbers[i];\n            currentMax = maxValue;\n\
    \        }\n        else\n        {\n            currentMax = maxValue;\n    \
    \    }\n        result[i] = currentMax;\n    }\n    return result;\n}", "{\n \
    \   long[] result = new long[numbers.length];\n    long max = 0;\n    long cur\
    \ = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        cur\
    \ = numbers[i];\n        if(cur > max)\n        {\n            max = cur;\n  \
    \      }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long cur = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        if(cur < min)\n        {\n        \
    \    min = cur;\n        }\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        sum += cur;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n      \
    \  sum += cur;\n        result[i] = sum / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n", "{\n    long max = numbers[0];\n    long maxIndex\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum / numbers.length ==\
    \ numbers[i])\n        {\n            result[i] = numbers[i];\n        }\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling standard deviation element found until given moment\n    in the sequence.\n\
    \    >>> ", "{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long max = 0;\n    \n    while(i < numbers.length)\n    {\n        max =\
    \ numbers[i];\n        \n        for(int j = i; j < numbers.length; j++)\n   \
    \     {\n            if(numbers[j] > max)\n            {\n                max\
    \ = numbers[j];\n            }\n        }\n        \n        result[i] = max;\n\
    \        i++;\n    }\n    \n    return result;\n}", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    int i = 0;\n    \n \
    \   for(i = 0; i < n; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        result[i] = max;\n    }\n    \n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    int i = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \    }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        result[i] = min;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    int i = 0;\n    \n    for(i = 0; i < n;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product of\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 6L, 24L, 24L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    int i = 0;\n    \n    for(i = 0; i < n; i++)\n  \
    \  {\n        result[i] = numbers[i] * numbers[i];\n    }\n    \n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling quotient\
    \ of element found until given moment\n    in the sequence.\n    >>> rolling_quotient([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, ", "{\n    long max = 0;\n    long maxIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            result[maxIndex] = numbers[i];\n            maxIndex++;\n \
    \       }\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    long maxIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = max;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            result[i] = max;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long minIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[0] = min;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            result[i] = min;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long sum2 = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum2 += numbers[i] * numbers[i];\n    }\n    sum2 = sum2 / count;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ += avg;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_pos =\
    \ i;\n        }\n    }\n    result[0] = max_so_far;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            result[i]\
    \ = max_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n  \
    \      if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \            min_so_far_pos = i;\n        }\n    }\n    result[0] = min_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            result[i] = min_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far\
    \ = numbers[0];\n    long sum_so_far_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum_so_far += numbers[i];\n        if(sum_so_far > numbers[i])\n\
    \        {\n            sum_so_far = numbers[i];\n            sum_so_far_pos =\
    \ i;\n        }\n    }\n    result[0] = sum_so_far;\n    for(int i = 1; i < numbers.length",
  "{\n    long[] result = new long[numbers.length];\n    long maxValue = numbers[0];\n\
    \    long currentMax = maxValue;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            currentMax\
    \ = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            result[i]\
    \ = currentMax;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ currentMin = minValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < currentMin)\n        {\n            currentMin = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] < currentMin)\n        {\n            result[i] = currentMin;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        currentSum += numbers[i];\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > 0)\n        {\n            result[i] = currentSum / numbers[i];\n        }\n\
    \        else\n        {\n            result[i] = 0;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ median element found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, ", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max_value = numbers[0];\n    long max_pos =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_pos\
    \ = i;\n        }\n    }\n    result[max_pos] = max_value;\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_value\
    \ = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_pos = i;\n        }\n    }\n    result[min_pos]\
    \ = min_value;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long count = 0;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        count++;\n    }\n    long avg\
    \ = sum / count;\n    for(int i = 0; i < numbers.length; i++)\n    {\n       \
    \ result[i] = numbers[i] - avg;\n    }\n    long max_pos = 0;", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n        sum = numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n        sum = numbers[i];\n    }\n\
    \    long median = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < median", "{\n    long[] result = new long[numbers.length];\n    long max_value\
    \ = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_pos = i;\n        }\n    }\n    result[0] = max_value;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] >=\
    \ max_value)\n        {\n            result[i] = max_pos;\n        }\n       \
    \ else\n        {\n            result[i] = result[i-1] + 1;\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_value = numbers[0];\n    long min_pos =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_value)\n        {\n            min_value = numbers[i];\n            min_pos\
    \ = i;\n        }\n    }\n    result[0] = min_value;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] <= min_value)\n        {\n            result[i]\
    \ = min_pos;\n        }\n        else\n        {\n            result[i] = result[i-1]\
    \ + 1;\n        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long pos = 0;\n \
    \   for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        if(sum >= numbers[i])\n        {\n            pos = i;\n        }\n \
    \   }\n    result[0] = sum;\n    for(int i = 1; i < numbers.length; i++)\n   \
    \ {\n        if(sum >= numbers[i])\n        {\n            result[i] = pos;\n\
    \        }\n        else\n        {\n            result[i] = result[i-1] + 1;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling product element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4", "{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max_value = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n    }\n   \
    \ \n    return result;\n}", "{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    long max = 0;\n    for (int i = 0; i < n; i++) {\n     \
    \   max = numbers[i];\n        for (int j = i; j < n; j++) {\n            if (numbers[j]\
    \ > max) {\n                max = numbers[j];\n            }\n        }\n    \
    \    result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    int n = numbers.length;\n    long[] result = new long[n];\n    long min\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        min = numbers[i];\n       \
    \ for (int j = i; j < n; j++) {\n            if (numbers[j] < min) {\n       \
    \         min = numbers[j];\n            }\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 9L, 9L,\
    \ 9L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        sum = numbers[i];\n        for (int j = i; j < n; j++) {\n\
    \            sum += numbers[j];\n        }\n        result[i] = sum;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 6L, 12L,\
    \ 12L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    int n =\
    \ numbers.length;\n    long[] result = new long[n];\n    long product = 1;\n \
    \   for (int i = 0; i < n; i++) {\n        product = numbers[i];\n        for\
    \ (int j = i; j < n; j++) {\n            product *= numbers[j];\n        }\n \
    \       result[i] = product;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling quotient element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_quotient([1L, ", "{\n  \
    \  long[] result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n   \
    \ int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    long maxIndex = -1;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[maxIndex] = max;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    long minIndex = -1;\n\
    \    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] <\
    \ min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    result[minIndex] = min;\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumOfSquares = 0;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumOfSquares += numbers[i] * numbers[i];\n\
    \    }\n    long avg = sum / numbers.length;\n    long avgOfSquares = sumOfSquares\
    \ / numbers.length;\n    for (int i = 0; i < numbers.length; i++)\n    {\n   \
    \     result[i] = avg;\n        result[i] += numbers[i] * numbers[i];\n    }\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] /= numbers.length;\n\
    \        result[i] += avgOfSquares;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling median element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    long medianOfSquares = 0;", "{\n    long max = numbers[0];\n    long\
    \ max_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] > max)\n        {\n            max = numbers[i];\n          \
    \  max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    result[max_index] = max;\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm\
    \ |>\n<| c |>\nThis is not the correct answer. Try it with the input `[1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]`\n<|/ c |>\n<| c |>\nYes, I didn't notice that he wanted\
    \ the max element in the last rolling window. I've updated my answer to reflect\
    \ that.\n<|/ c |>\n<| c |>\nThis is not the correct answer. Try it with the input\
    \ `[1L, 2L, 3L, 2L, 3L, 4L, 2L]`\n<|/ c |>\n<| c |>\nYes, I didn't notice that\
    \ he wanted the max element in the last rolling window. I've updated my answer\
    \ to reflect that.\n<|/ c |>\n<| a tags=c#,algorithm |>\nI wrote a little C# program\
    \ to test the performance of the different solutions proposed so far. \nThe program\
    \ is based on a test case where I generated a random sequence of integers between\
    \ 0 and 100000, and I ran the program several times to see how long it took to\
    \ run. \nThe program is as follows:\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;", "{\n \
    \   int n = numbers.length;\n    long[] result = new long[n];\n    long max =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n        cur =\
    \ numbers[i];\n        max = cur;\n        for(int j = i; j < n; j++)\n      \
    \  {\n            if(numbers[j] > max)\n            {\n                max = numbers[j];\n\
    \            }\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        min = cur;\n        for(int j = i; j < n;\
    \ j++)\n        {\n            if(numbers[j] < min)\n            {\n         \
    \       min = numbers[j];\n            }\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum = cur;\n \
    \       for(int j = i; j < n; j++)\n        {\n            sum += numbers[j];\n\
    \        }\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling product of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long prod = 1;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        prod = ", "{\n    long max_so_far = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n        }\n        result[i] = max_so_far;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long min_so_far = numbers[0];\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n        }\n        result[i] = min_so_far;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ + numbers[i + 1];\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] / 2;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling variance\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_var([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_var(long[] numbers) \n{\n    long", "{\n    long max_so_far = numbers[0];\n\
    \    long max_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = max_so_far;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long average = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = average;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling standard deviation\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result", "{\n   \
    \ long max = numbers[0];\n    long max_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        min_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling variance element found until given moment\n    in the sequence.\n\
    \    >>> rolling_var([1L, 2L, 3L, 2L, 3L, 4", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n        max = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L, 24L, 24L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ *= result[i-1];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling quotient element found until given moment\n   \
    \ in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, ", "{\n    long max_so_far\
    \ = numbers[0];\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = std.math.max(result[i], numbers[i]);\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = std.math.min(result[i],\
    \ numbers[i]);\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.add(result[i], numbers[i]) / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.add(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling count element found until given moment\n    in the sequence.\n  \
    \  >>> rolling_count([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, ", "{\n\
    \    long[] result = new long[numbers.length];\n    long maxValue = numbers[0];\n\
    \    long maxIndex = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = maxValue;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n\
    \        {\n            result[i] = maxValue;\n        }\n        else\n     \
    \   {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }", "{\n    long max_so_far = numbers[0];\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n        }\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n\
    \        {\n            currentMax = numbers[i];\n        }\n        else\n  \
    \      {\n            currentMax = maxValue;\n        }\n        result[i] = currentMax;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long currentMin\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n        }\n\
    \        else\n        {\n            currentMin = minValue;\n        }\n    \
    \    result[i] = currentMin;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        currentSum += numbers[i];\n    }\n\
    \    long average = currentSum / numbers.length;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        result[i] = average - numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long maxIndex = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n       \
    \ {\n            maxValue = numbers[i];\n            maxIndex = i;\n        }\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == maxValue)\n        {\n            result[i] = maxIndex;\n        }\n    \
    \    else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long minIndex =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == minValue)\n        {\n            result[i] = minIndex;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long avg = 0;\n    long count\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    avg = sum / count;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == avg)\n        {\n            result[i]\
    \ = avg;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]\n    \n", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    long max = 0;\n    long maxIndex\
    \ = 0;\n    \n    while(j < numbers.length)\n    {\n        max = numbers[j];\n\
    \        maxIndex = j;\n        \n        for(i = j; i < numbers.length; i++)\n\
    \        {\n            if(numbers[i] > max)\n            {\n                max\
    \ = numbers[i];\n                maxIndex = i;\n            }\n        }\n   \
    \     \n        result[k] = max;\n        j++;\n        k++;\n    }\n    \n  \
    \  return result;\n}", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            maxIndex = i;\n        }\n \
    \   }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[maxIndex];\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long maxValue = numbers[0];\n\
    \    long maxIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == maxValue)\n        {\n            result[i]\
    \ = maxIndex;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ minIndex = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == minValue)\n        {\n            result[i] = minIndex;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long product = 1;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        product *= numbers[i];\n        result[i] = product;\n\
    \    }\n", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n            maxIndex = i;\n        }\n    }\n   \
    \ long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[maxIndex];\n        maxIndex++;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long max_value = numbers[0];\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = max_value;\n        max_value += numbers[i];\n    }\n   \
    \ return result;\n}", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max_value = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_pos = i;\n        }\n    }\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] == max_value)\n     \
    \   {\n            result[max_pos] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L, 4L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min_value = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n        {\n\
    \            min_value = numbers[i];\n            min_pos = i;\n        }\n  \
    \  }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == min_value)\n        {\n            result[min_pos] = numbers[i];\n      \
    \  }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long count = 0;\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] == avg)\n        {\n            result[i] = avg;\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;", "{\n    long[] result = new long[numbers.length];\n    int i =\
    \ 0;\n    long max = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n   \
    \     if(numbers[i] > max)\n        {\n            max = numbers[i];\n       \
    \ }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n            max = numbers[i];\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    \n    return result;\n}", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n\
    \        {\n            max = cur;\n        }\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if(cur < min)\n\
    \        {\n            min = cur;\n        }\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of element found until given moment\n    in the sequence.\n \
    \   >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long prod = 1;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        prod *= cur;\n        result[i] = prod;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n", "{\n    long max =\
    \ numbers[0];\n    long max_so_far = numbers[0];\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            max_so_far = max;\n        }\n        else\n        {\n         \
    \   max_so_far = max(max_so_far, numbers[i]);\n        }\n    }\n    return new\
    \ long[] {max_so_far, max};\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_so_far = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_so_far = min;\n        }\n        else\n        {\n         \
    \   min_so_far = min(min_so_far, numbers[i]);\n        }\n    }\n    return new\
    \ long[] {min_so_far, min};\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long sum2 = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum2 += numbers[i] * numbers[i];\n    }\n    long avg2 = sum2 / count;\n\
    \    return new long[] {avg2, avg};\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n", "{\n    long max = numbers[0];\n\
    \    long max_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            max = numbers[i];\n     \
    \       max_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       min_pos = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_pos\
    \ - i];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] - avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < median)\n        {\n            median\
    \ = numbers[i];\n        }\n        count++;\n", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n    }\n    long mid = numbers.length\
    \ / 2;\n    long left = 0;\n    long right = numbers.length - 1;\n    long midSum\
    \ = 0;\n    while(left < right)\n    {", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long max = 0;\n    \n    while(i < numbers.length)\n    {\n\
    \        max = numbers[i];\n        \n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] > max)\n            {\n         \
    \       max = numbers[j];\n            }\n        }\n        \n        result[i]\
    \ = max;\n        i++;\n    }\n    \n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n  \
    \  for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = sum -\
    \ numbers[i] * numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * numbers[i];\n    }\n    long median = 0;\n \
    \   for(", "{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        result[i] = max(result[i],\
    \ numbers[i]);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    long max = 0;\n    long max2\
    \ = 0;\n    long max3 = 0;\n    long max4 = 0;\n    long max5 = 0;\n    long max6\
    \ = 0;\n    long max7 = 0;\n    long max8 = 0;\n    long max9 = 0;\n    long max10\
    \ = 0;\n    long max11 = 0;\n    long max12 = 0;\n    long max13 = 0;\n    long\
    \ max14 = 0;\n    long max15 = 0;\n    long max16 = 0;\n    long max17 = 0;\n\
    \    long max18 = 0;\n    long max19 = 0;\n    long max20 = 0;\n    long max21\
    \ = 0;\n    long max22 = 0;\n    long max23 = 0;\n    long max24 = 0;\n    long\
    \ max25 = 0;\n    long max26 = 0;\n    long max27 = 0;\n    long max28 = 0;\n\
    \    long max29 = 0;\n    long max30 = 0;\n    long max31 = 0;\n    long max32\
    \ = 0;\n    long max33 = 0;\n    long max34 = 0;\n    long max35 = 0;\n    long\
    \ max36 = 0;\n    long max37 = 0;\n    long max38 = 0;\n    long max39 = 0;\n\
    \    long max40 = 0;\n    long max41 = 0;\n    long max42 = 0;\n    long max43\
    \ = 0;\n    long max44 = 0;\n    long max45 = 0;\n    long max46 = 0;\n    long\
    \ max47 = 0;\n    long max48 = 0;\n    long max49 = 0;\n    long max50 = 0;\n\
    \    long max51 = 0;\n    long max52 = 0;\n    long max53 = 0;\n    long max54\
    \ = 0;\n    long max55 = 0;\n    long max56 = 0;\n    long max57 = 0;\n    long\
    \ max58 = 0;\n    long max59 = 0;\n    long max60 = 0;\n    long max61 = 0;\n\
    \    long max62 = 0;\n    long max63 = 0;\n    long max64 = 0;\n    long max65\
    \ = 0;\n    long max66 = 0;\n    long max67 = 0;\n    long max68 = 0;\n    long\
    \ max69 = 0;\n    long max70 = 0;\n    long max71 = 0;\n    long max72 = 0;\n\
    \    long max73 = 0;\n    long max74 = 0;\n    long max75 = 0;\n    long max76\
    \ = 0;\n    long max77 = 0;\n    long max78 = 0;\n    long max79 = 0;\n    long\
    \ max80 = 0;\n    long max81 = 0;\n    long max82 = 0;\n    ", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n\
    \    long currentMax = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > currentMax)\n        {\n            currentMax\
    \ = numbers[i];\n            maxIndex = i;\n        }\n    }\n    result[0] =\
    \ currentMax;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            result[i] = numbers[maxIndex];\n     \
    \   }\n        else\n        {\n            result[i] = numbers[i];\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long minIndex = 0;\n    long currentMin\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n           \
    \ minIndex = i;\n        }\n    }\n    result[0] = currentMin;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < currentMin)\n\
    \        {\n            result[i] = numbers[minIndex];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sumIndex = 0;\n    long currentSum = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if(sum > currentSum)\n        {\n            currentSum = sum;\n           \
    \ sumIndex = i;\n        }\n    }\n    result[0] = currentSum;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        if(sum\
    \ > currentSum)\n        {\n            result[i] = numbers[sumIndex];\n     \
    \   }\n        else\n        {\n            result", "{\n    long[] result = new\
    \ long[numbers.length];\n    long maxValue = numbers[0];\n    int i = 0;\n   \
    \ for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n \
    \       {\n            maxValue = numbers[i];\n        }\n    }\n    for(; i <\
    \ numbers.length; i++)\n    {\n        result[i] = maxValue;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long minValue = numbers[0];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = minValue;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum +=\
    \ numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long median = 0;\n \
    \   int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < median)\n        {\n            median = numbers[i];\n        }\n    }\n \
    \   for(; i < numbers.length; i++)\n    {\n        result[i] = median;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling standard deviation element found until given ", "{\n    long max\
    \ = 0;\n    long maxIndex = 0;\n    long index = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[index] = max;\n            index++;\n        }\n\
    \        else\n        {\n            result[index] = numbers[i];\n          \
    \  index++;\n        }\n    }\n    return result;\n}", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    for(int i = 0; i < n;\
    \ ++i)\n    {\n        max = numbers[i];\n        for(int j = i; j < n; ++j)\n\
    \        {\n            if(numbers[j] > max)\n            {\n                max\
    \ = numbers[j];\n            }\n        }\n        result[i] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = 0;\n    long cur = 0;\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        cur = numbers[i];\n        if (cur > max)\n        {\n       \
    \     max = cur;\n        }\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n   \
    \ long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n   \
    \     if(numbers[i] > max)\n        {\n            max = numbers[i];\n       \
    \     maxIndex = i;\n        }\n    }\n    for(int i = maxIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    for(int i = minIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sum == 0)\n        {\n          \
    \  sumIndex = i;\n        }\n    }\n    for(int i = sumIndex; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        if(sum == 0)\n        {\n          \
    \  sumIndex = i;\n        }\n    }\n    for(int ", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max_value = numbers[0];\n    int i = 0;\n  \
    \  \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    \n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    \n    return result;\n}", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = max(result[i], numbers[i + 1]);\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        result[i] = min(result[i],\
    \ numbers[i + 1]);\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    for(int i = 0; i <\
    \ n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = n -\
    \ 1; i >= 0; i--)\n    {\n        result[i] = sum(result[i], numbers[i + 1]);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n   \
    \     result[i] = numbers[i];\n    }\n    for(int i = n - 1; i >= 0; i--)\n  \
    \  {\n        result[i] = sum(result[i], numbers[i + 1]) / numbers[i + 1];\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, ", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[max_so_far_index] = numbers[i];\n        max_so_far_index--;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long maxIndex = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[maxIndex] = max;\n  \
    \  return result;\n}", "{\n    long[] result = new long[numbers.length];\n   \
    \ long max_so_far = numbers[0];\n    long max_so_far_i = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_i = i;\n \
    \       }\n    }\n    result[0] = max_so_far;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            result[i]\
    \ = max_so_far_i;\n        }\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_i = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_i = i;\n        }\n    }\n    result[0]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[i] = min_so_far_i;\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum_so_far = numbers[0];\n    long sum_so_far_i\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far\
    \ += numbers[i];\n        sum_so_far_i = i;\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        result[i] = sum_so_far_i;\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling average element found\
    \ until given moment\n    ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    \n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n            max = numbers[i];\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    \n    return result;\n}", "{\n    long max_value = numbers[0];\n\
    \    long max_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[max_index];\n\
    \        max_index++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n\
    {\n    long min_value = numbers[0];\n    long min_index = 0;\n    for(int i =\
    \ 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n   \
    \     {\n            min_value = numbers[i];\n            min_index = i;\n   \
    \     }\n    }\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[min_index];\n\
    \        min_index++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 3L, 6L, 10L, 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    long sum = 0;\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        sum += result[i];\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 6L, 24L, 6L,\
    \ 24L, 120L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    long product = 1;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        product *= ", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_value)\n\
    \        {\n            max_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max_value;\n        max_value\
    \ += numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_value = numbers[0];\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_value)\n\
    \        {\n            min_value = numbers[i];\n        }\n    }\n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = min_value;\n        min_value\
    \ -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling sum element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L,\
    \ 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            result[i] += numbers[j];\n        }\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling product element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L,\
    \ 12L, 12L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            result[i] *= numbers[j];\n        }\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling quotient element found until given moment\n", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_value = numbers[0];\n    long max_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_value)\n        {\n            result[max_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 2L, 2L, 2L, 2L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_value = numbers[0];\n\
    \    long min_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \            min_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_value)\n        {\n            result[min_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / number", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    if(current > max)\n        {\n            max = current;\n        }\n   \
    \     result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if(current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product of element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 6L, 12L, 24L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long product = 1;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        product *= current;\n        result[i] = product;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, ",
  "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[i] = max;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long\
    \ sum = 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumIndex++;\n    }\n    long avg =\
    \ sum / sumIndex;\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    Arrays.sort(numbers);\n    for(int i = 0; i < ",
  "{\n    long[] result = new long[numbers.length];\n    long maxValue = numbers[0];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > maxValue)\n        {\n            maxValue = numbers[i];\n        }\n    }\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = maxValue;\n  \
    \      maxValue = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = minValue;\n        minValue = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] *= numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1",
  "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n    long current\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current =\
    \ numbers[i];\n        max = Math.max(max, current);\n        result[i] = max;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a |>\n<code>\n\
    public static void main(String[] args) {\n    int[] arr = {1, 2, 3, 4, 5};\n \
    \   System.out.println(Arrays.toString(rolling_max(arr)));\n}", "{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    long max = numbers[0];\n\
    \    long max_so_far = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n  \
    \      if(numbers[i] > max)\n        {\n            max = numbers[i];\n      \
    \  }\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far =\
    \ numbers[i];\n        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n     \
    \   result[i] = max_so_far;\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/10845146)\n<|/ c |>\n<| c |>\nThis does provide\
    \ an answer to the question. He wants to find the maximum element in a rolling\
    \ window of size n. He also wants to know which element was the maximum element\
    \ in the window and which was the maximum element in the entire array. He also\
    \ wants to know which element was the maximum element in the window and which\
    \ was the maximum element in the entire array. He also wants to know which element\
    \ was the maximum element in the window and which was the maximum element in the\
    \ entire array. He also wants to know which element was the maximum element in\
    \ the window and which was the maximum element in the entire array. He also wants\
    \ to know which element was the maximum element in the window and which was the\
    \ maximum element in the entire array. He also wants to know which element was\
    \ the maximum element in the window and which was the maximum element in the entire\
    \ array. He also wants to know which element was the maximum element in the window\
    \ and which was the maximum element in the entire array. He also wants to know\
    \ which element was the maximum element in the window and which was the maximum\
    \ element in the entire array. He also wants to know which element was the maximum\
    \ element in the window and which was the maximum element in the entire array.\
    \ He also wants to know which element was the maximum element in the window and\
    \ which was the maximum element in the entire array. He also wants to know which\
    \ element was the maximum element in the window and which was the maximum element\
    \ in the entire array.\n<|/ c |>\n<| c |>\nThis does not provide an answer to\
    \ the question. To critique or request clarification from an author, leave a comment\
    \ below their post. - [From Review](/review/low-quality-", "{\n    long max =\
    \ 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm |>\n<|\
    \ c |>\nThis doesn't work if the array is empty or contains only a single element\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if you pass in an empty array. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt works with empty array and single element. Try it yourself.\n\
    <|/ c |>\n<| a tags=c#,arrays,algorithm |>\n<code>\npublic static int[] GetMax(int[]\
    \ array)\n{\n    int max = 0;\n    int maxIndex = 0;\n    for (int i = 0; i <\
    \ array.Length; i++)\n    {\n        if (array[i] > max)\n        {\n        \
    \    max = array[i];\n            maxIndex = i;\n        }\n    }\n    int[] result\
    \ = new int[array.Length];\n    for (int i = 0; i < array.Length; i++)\n    {\n\
    \        result[i] = array[maxIndex];\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't work if the array is empty or contains\
    \ only a single element\n<|/ c |>\n<| c |>\nIt works with empty array and single\
    \ element. Try it yourself.\n<|/ c |>\n<| c |>\nIt works with empty array and\
    \ single element. Try it yourself.\n<|/ c |>\n<| c |>\nIt works with empty array\
    \ and single element. Try it yourself.\n<|/ c |>\n<| a dscore=4 |>\n<code>\npublic\
    \ static int[] GetMax(int[] array)\n{\n    int max = 0;\n    int maxIndex = 0;\n\
    \    for (int i = 0; i < array.Length; i++)\n    {\n        if (array[i] > max)\n\
    \        {\n            max = array[i];\n            maxIndex = i;\n        }\n\
    \    }\n    int[] result = new int[array.Length];\n    for (int i = 0; i < array.Length;\
    \ i++)\n    {\n        result[i] = array[maxIndex];\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,array", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long max = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n        max = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    for(; i\
    \ < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = numbers[i];\n    }\n    long median = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < median", "{\n    long max = 0;\n    long\
    \ maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum % 2 == 0)\n        {\n\
    \            result[i] = numbers[numbers.length / 2 - 1];\n        }\n       \
    \ else\n        {\n            result[i] = numbers[numbers.length / 2];\n    \
    \    }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling standard deviation ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    for(int i = maxIndex; i < numbers.length;\
    \ i++)\n    {\n        result[maxIndex] = numbers[i];\n        maxIndex++;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long minIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            minIndex = i;\n        }\n \
    \   }\n    for(int i = minIndex; i < numbers.length; i++)\n    {\n        result[minIndex]\
    \ = numbers[i];\n        minIndex++;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling average element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        sum += numbers[i];\n        sumIndex++;\n    }\n    for(int i =\
    \ sumIndex; i < numbers.length; i++)\n    {\n        result[sumIndex] = numbers[i]\
    \ - sum / sumIndex;\n        sumIndex++;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long median\
    \ = 0;\n    long medianIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < ", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    long max = 0;\n    long current\
    \ = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n        current = numbers[i];\n\
    \        for(; j < i; j++)\n        {\n            if(numbers[j] > current)\n\
    \            {\n                max = current;\n                k = j;\n     \
    \       }\n        }\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n    long current\
    \ = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        current =\
    \ numbers[i];\n        if (current > max)\n        {\n            max = current;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=java,arrays,algorithm |>\n<code>\npublic class MaxRoller\
    \ {", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n \
    \   long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  cur = numbers[i];\n        if(cur > max)\n        {\n            max = cur;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        if(cur < min)\n        {\n            min\
    \ = cur;\n        }\n        result[i] = min;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n    }\n    double avg = sum /\
    \ numbers.length;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  cur = numbers[i];\n        result[i] = avg;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n    }\n    double\
    \ avg = sum / numbers.length;\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        cur = numbers[i];\n        result[i] = avg;\n    }\n    long middle\
    \ = numbers.length / 2;\n    for(int ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    \n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max;\n        max = numbers[i];\n    }\n    \n    return result;\n}", "{\n\
    \    long max = numbers[0];\n    long maxIndex = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] < min)\n        {\n            min = numbers[i];\n   \
    \         minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ deviation element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ / numbers.length;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling variance element found until given moment\n\
    \    in the sequence.\n    >>> rolling_var([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_so_far)\n        {\n            result[i] = max_so_far;\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[i]\
    \ = min_so_far;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long count = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        count++;\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = (numbers[i] / count);\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3", "{\n    long max = numbers[0];\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            min = numbers[i];\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] + numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product of\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 2L, 6L, 12L, 12L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * numbers[i + 1];\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling quotient of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_quotient(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = ", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max_so_far = numbers[0];\n    long\
    \ max_so_far_pos = 0;\n    for (int i = 1; i < n; ++i) {\n        if (numbers[i]\
    \ > max_so_far) {\n            max_so_far = numbers[i];\n            max_so_far_pos\
    \ = i;\n        }\n    }\n    result[max_so_far_pos] = max_so_far;\n    for (int\
    \ i = max_so_far_pos + 1; i < n; ++i) {\n        result[i] = numbers[i];\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long min_so_far = numbers[0];\n    long\
    \ min_so_far_pos = 0;\n    for (int i = 1; i < n; ++i) {\n        if (numbers[i]\
    \ < min_so_far) {\n            min_so_far = numbers[i];\n            min_so_far_pos\
    \ = i;\n        }\n    }\n    result[min_so_far_pos] = min_so_far;\n    for (int\
    \ i = min_so_far_pos + 1; i < n; ++i) {\n        result[i] = numbers[i];\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum_so_far = 0;\n    long sum_so_far_pos\
    \ = 0;\n    for (int i = 1; i < n; ++i) {\n        sum_so_far += numbers[i];\n\
    \        if (sum_so_far >= sum_so_far_pos) {\n            sum_so_far_pos = i;\n\
    \        }\n    }\n    result[sum_so_far_pos] = sum_so_far;\n    for (int i =\
    \ sum_so_far_pos + 1; i < n; ++i) {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    foreach(long number in numbers) {\n  \
    \      if(number > max) {\n            max = number;\n        }\n        result[i++]\
    \ = max;\n    }\n    return result;\n}", "{\n    long max = 0;\n    long maxIndex\
    \ = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long sum = 0;\n \
    \   long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n    \
    \    sum += numbers[i];\n        count++;\n    }\n    long avg = sum / count;\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = avg;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[(numbers.length\
    \ - 1) - std.math.floor((numbers.length - 1) / 2)];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling standard\
    \ devi", "{\n    long[] result = new long[numbers.length];\n    long max_value\
    \ = numbers[0];\n    long max_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_value)\n        {\n            max_value\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == max_value)\n  \
    \      {\n            result[i] = max_value;\n        }\n        else\n      \
    \  {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_value\
    \ = numbers[0];\n    long min_index = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_value)\n        {\n            min_value\
    \ = numbers[i];\n            min_index = i;\n        }\n    }\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_value)\n  \
    \      {\n            result[i] = min_value;\n        }\n        else\n      \
    \  {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] / count;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    long count = 0;", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    result[0] = max_so_far;\n    for(int i = 1; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n\
    \            result[i] = numbers[max_so_far_index];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min_so_far = numbers[0];\n    long min_so_far_index = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            min_so_far = numbers[i];\n            min_so_far_index\
    \ = i;\n        }\n    }\n    result[0] = min_so_far;\n    for(int i = 1; i <\
    \ numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n\
    \            result[i] = numbers[min_so_far_index];\n        }\n        else\n\
    \        {\n            result[i] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ if(sum_so_far >= numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i", "{\n    long[] result = new long[numbers.length];\n    long maxValue\
    \ = numbers[0];\n    long maxIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            maxValue\
    \ = numbers[i];\n            maxIndex = i;\n        }\n    }\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == maxValue)\n   \
    \     {\n            result[i] = maxIndex;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    long minIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < minValue)\n        {\n            minValue\
    \ = numbers[i];\n            minIndex = i;\n        }\n    }\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == minValue)\n   \
    \     {\n            result[i] = minIndex;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    long average = sum /\
    \ count;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == average)\n        {\n            result[i] = average;\n        }\n      \
    \  else\n        {\n            result[i] = numbers[i];\n        }\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] ", "{\n    long[] result = new long[numbers.length];\n    long\
    \ maxValue = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = maxValue;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n        {\n \
    \           max = cur;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        if(cur < min)\n        {\n \
    \           min = cur;\n        }\n        result[i] = min;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ sum element found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 9L, 9L]\n    \n*/\nlong[]\
    \ rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum +=\
    \ cur;\n    }\n    long avg = sum / numbers.length;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = avg;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_median([1L, 2L, 3L,\
    \ 2L, 3L, ", "{\n    long[] result = new long[numbers.length];\n    long max =\
    \ 0;\n    long cur = 0;\n    int i = 0;\n    \n    while(i < numbers.length)\n\
    \    {\n        cur = numbers[i];\n        max = cur;\n        \n        for(i++;\
    \ i < numbers.length; i++)\n        {\n            if(numbers[i] > max)\n    \
    \        {\n                max = numbers[i];\n            }\n        }\n    \
    \    \n        result[i] = max;\n    }\n    \n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    long\
    \ maxIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if (numbers[i] > max)\n        {\n            max = numbers[i];\n          \
    \  maxIndex = i;\n        }\n    }\n    result[maxIndex] = max;\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n   \
    \ int i = 0;\n    \n    foreach(long n in numbers) {\n        if (max < n) {\n\
    \            max = n;\n        }\n        result[i] = max;\n        i++;\n   \
    \ }\n    \n    return result;\n}", "{\n    int n = numbers.length;\n    long[]\
    \ result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < n; i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n  \
    \      {\n            max = cur;\n        }\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n        max = numbers[i];\n    }\n    return result;\n}", "{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max = 0;\n \
    \   for(int i = 0; i < n; i++)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n        }\n    }\n    for(int i = 0; i < n; i++)\n\
    \    {\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    for(int i = 0; i < n; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = sum / n;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for(int i = 0; i < n;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < n; i++)\n\
    \    {\n        result[i] = sum / n;\n    }\n    long mid = sum / n;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        if(numbers[i] < mid)\n        {\n       \
    \     result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of roll", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for\
    \ (int i = 0; i < n; ++i) {\n        cur = numbers[i];\n        if (cur > max)\
    \ {\n            max = cur;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n            maxIndex = i;\n        }\n    }\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[maxIndex];\n        maxIndex++;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \        minIndex++;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling average element found until given moment\n\
    \    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n\
    {\n    long sum = 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        count++;\n    }\n    long avg\
    \ = sum / count;\n    long[] result = new long[numbers.length];\n    for(int i\
    \ = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] - avg;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[(int) (i + 1)/2 - 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of roll", "{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long\
    \ max = numbers[0];\n    \n    while(i < numbers.length)\n    {\n        max =\
    \ std.math.reduce(max, numbers[i++]);\n        \n        if(max != numbers[i])\n\
    \        {\n            result[j++] = max;\n            max = numbers[i];\n  \
    \      }\n    }\n    \n    result[j++] = max;\n    \n    return result;\n}", "{\n\
    \    long max = numbers[0];\n    long max_index = -1;\n    for (int i = 1; i <\
    \ numbers.length; i++)\n    {\n        if (numbers[i] > max)\n        {\n    \
    \        max = numbers[i];\n            max_index = i;\n        }\n    }\n   \
    \ long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[max_index];\n    }\n    return result;\n\
    }", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            result[maxIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n\
    \        {\n            result[minIndex] = numbers[i];\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n    long\
    \ sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        if(sum == 0)\n        {\n            sumIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(sum == 0)\n        {\n  \
    \          result[sumIndex] = numbers[i];\n        }\n        else\n        {\n\
    \            result[sumIndex] = numbers[i] + result[sumIndex];\n        }\n  \
    \      sum -= numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n", "{\n    long[] result = new long[numbers.length];\n    long\
    \ maxValue = numbers[0];\n    long currentMax = maxValue;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n     \
    \   {\n            currentMax = numbers[i];\n        }\n    }\n    result[0] =\
    \ currentMax;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > currentMax)\n        {\n            result[i] = currentMax;\n        }\n \
    \       else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long currentMin\
    \ = minValue;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < currentMin)\n        {\n            currentMin = numbers[i];\n        }\n\
    \    }\n    result[0] = currentMin;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < currentMin)\n        {\n            result[i]\
    \ = currentMin;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    long currentSum =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    long average = sum / numbers.length;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > average)\n        {\n            currentSum\
    \ = numbers[i];\n        }\n    }\n    result[0] = currentSum;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > average)\n   \
    \     {\n            result[i] = currentSum;\n        }\n        else\n      \
    \  {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given ", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = 0;\n    int i = 0;\n    \n    while(i < numbers.length)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n        \n        result[i] = max;\n        i++;\n    }\n    \n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max_value\
    \ = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] > max_value)\n        {\n            max_value = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max_value;\n        max_value = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_value\
    \ = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min_value)\n        {\n            min_value = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = min_value;\n        min_value = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] *= numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling quotient element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_quotient([1L, ",
  "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n    long current\
    \ = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if(current > max)\n        {\n            max = current;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = 0;\n    long current = 0;\n\
    \    long i = 0;\n    \n    for(i = 0; i < numbers.length; i++)\n    {\n     \
    \   current = numbers[i];\n        max = Math.max(max, current);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long currentMax = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n\
    \        {\n            currentMax = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > currentMax)\n\
    \        {\n            result[i] = currentMax;\n            currentMax = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long minValue = numbers[0];\n    long\
    \ currentMin = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < currentMin)\n        {\n            currentMin = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] < currentMin)\n        {\n            result[i] = currentMin;\n\
    \            currentMin = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long currentSum = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        if(sum > currentSum)\n        {\n\
    \            currentSum = sum;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > currentSum)\n    \
    \    {\n            result[i] = sum;\n            currentSum = sum;\n        }\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    ", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = 0;\n    int i = 0;\n    \n    for(; i < numbers.length; i++)\n    {\n    \
    \    if(numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n\
    \    }\n    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            result[i] = max;\n            max = numbers[i];\n\
    \        }\n        else\n        {\n            result[i] = numbers[i];\n   \
    \     }\n    }\n    \n    return result;\n}", "{\n    long max = 0;\n    long\
    \ maxIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            maxIndex = i;\n\
    \        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = 0;\n \
    \   long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < min)\n        {\n            min = numbers[i];\n     \
    \       minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long sum = 0;\n \
    \   long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n \
    \       sum += numbers[i];\n        if(sumIndex == 0)\n        {\n           \
    \ sumIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long product\
    \ = 1;\n    long productIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        product *= numbers[i];\n        if(productIndex == 0)\n      \
    \  {\n            productIndex = i;\n        }\n    }\n    long[] result = new\
    \ long[numbers.length];\n    ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n        max = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] += result[i-1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    for(; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] += result[i-1];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] /= numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n", "{\n    long[]\
    \ result = new long[numbers.length];\n    long maxValue = numbers[0];\n    long\
    \ maxIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n       \
    \ if (numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = maxValue;\n    result[1]\
    \ = maxIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] > maxValue)\n        {\n            result[i] = maxValue;\n    \
    \        result[i - 1]++;\n        }\n        else\n        {\n            result[i]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long minValue = numbers[0];\n\
    \    long minIndex = 0;\n    for (int i = 1; i < numbers.length; i++)\n    {\n\
    \        if (numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[0] = minValue;\n    result[1]\
    \ = minIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] < minValue)\n        {\n            result[i] = minValue;\n    \
    \        result[i - 1]++;\n        }\n        else\n        {\n            result[i]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long average = sum / count;\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - average;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling median element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 2", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            max = numbers[i];\n            maxIndex = i;\n        }\n \
    \   }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[maxIndex];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 10L, 10L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_average(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling variance element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_variance([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] ",
  "{\n    long max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min_so_far =\
    \ numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    long[]\
    \ result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        result[i] = min_so_far;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product element found until given moment\n    in the sequence.\n\
    \    >>> rolling_prod([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_prod(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i] * numbers[i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling quotient\
    \ element found until given moment\n    in the sequence.\n    >>> ", "{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    long max = numbers[0];\n\
    \    \n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n        }\n    }\n    \n    for(; i\
    \ < numbers.length; i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n\
    \    }\n    \n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n            maxValue\
    \ = numbers[i];\n        }\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = maxValue;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long minValue\
    \ = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n \
    \       if(numbers[i] < minValue)\n        {\n            minValue = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = minValue;\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        int j = (i + 1) >> 1;\n        if(numbers[i] < numbers[j])\n \
    \       {\n            result[i] = numbers[i];\n        }\n        else\n    \
    \    {\n            result[i] = numbers[j];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[numbers.length - 1 - i];\n    }\n \
    \   return result;", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    result[max_so_far_index] = max_so_far;\n    for(int i =\
    \ 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n  \
    \      {\n            result[max_so_far_index] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index] = min_so_far;\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min_so_far)\n\
    \        {\n            result[min_so_far_index] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum_so_far = 0;\n    long sum_so_far_index =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        sum_so_far +=\
    \ numbers[i];\n        if(sum_so_far > numbers[i])\n        {\n            sum_so_far\
    \ = numbers[i];\n            sum_so_far_index = i;\n        }\n    }\n    result[sum_so_far_index]\
    \ = sum_so_far;\n    for(int i = 1; i < numbers.length", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long max = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        max = Math.max(max,\
    \ cur);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min = 0;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        min = Math.min(min, cur);\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        cur = numbers[i];\n        sum += cur;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long prod = 1;\n    long cur = 0;\n    for(int i = 0; i < n; i++)\n    {\n\
    \        cur = numbers[i];\n        prod *= cur;\n        result[i] = prod;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L,\
    \ 3L, 4L, 4L", "{\n    long[] result = new long[numbers.length];\n    long maxValue\
    \ = numbers[0];\n    int i = 0;\n    \n    for(; i < numbers.length; i++)\n  \
    \  {\n        if(numbers[i] > maxValue)\n        {\n            maxValue = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = maxValue;\n        maxValue = numbers[i];\n    }\n    \n    return result;\n\
    }", "{\n    long max = numbers[0];\n    long max_pos = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n            max_pos = i;\n        }\n    }\n  \
    \  long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[max_pos - i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = numbers[0];\n    long min_pos = 0;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            min = numbers[i];\n            min_pos = i;\n        }\n  \
    \  }\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[min_pos - i];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long count = 0;\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        count++;\n\
    \    }\n    long avg = sum / count;\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ - avg;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[(numbers.length - 1) - std.math.floor((numbers.length\
    \ - 1) / 2)];\n    }\n    return result;\n}\n/*\n", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    if(current > max)\n        {\n            max = current;\n        }\n   \
    \     result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = 0;\n    long\
    \ current = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        current\
    \ = numbers[i];\n        if(current < min)\n        {\n            min = current;\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long current = 0;\n    for(int i = 0; i < numbers.length; i++)\n   \
    \ {\n        current = numbers[i];\n        sum += current;\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long current = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        current = numbers[i];\n    \
    \    sum += current;\n    }\n    double avg = sum / numbers.length;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        result[i] = avg;\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling median element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_median([1L, 2L, 3L, 2L, 3L, ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long cur = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n        {\n \
    \           max = cur;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    int len = numbers.length;\n    long[] result = new long[len];\n\
    \    long max = 0;\n    long cur = 0;\n    for(int i = 0; i < len; i++)\n    {\n\
    \        cur = numbers[i];\n        if(cur > max)\n        {\n            max\
    \ = cur;\n        }\n        result[i] = max;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,arrays |>\n<| c |>\nThis doesn't seem to work. Try it\
    \ with a list of `[1,2,3,4,5,6,7,8,9,10]` - it returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `long` instead of `int` because\
    \ I thought it would be more efficient. `int` would require a lot of casting.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `long` instead of `int` because\
    \ I thought it would be more efficient. `int` would require a lot of casting.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `long` instead of `int` because\
    \ I thought it would be more efficient. `int` would require a lot of casting.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `long` instead of `int` because\
    \ I thought it would be more efficient. `int` would require a lot of casting.\n\
    <|/ c |>\n<| a tags=java,arrays |>\n<code>\npublic static void main(String[] args)\
    \ {\n    int[] numbers = {1,2,3,4,5,6,7,8,9,10};\n    int[] result = new int[numbers.length];\n\
    \    Arrays.sort(numbers);\n    int max = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    System.out.println(Arrays.toString(result));\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work. Try it with\
    \ a list of `[1,2,3,4,5,6,7,8,9,10]` - it returns `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `int` instead of `long` because\
    \ I thought it would be more efficient. `int` would require a lot of casting.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used `int` instead of `long` because\
    \ I thought it would be more efficient", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max;\n        max = numbers[i];\n    }\n    return result;\n}\n/*\n From a\
    \ given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L, 3L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n   \
    \     if(numbers[i] < min)\n        {\n            min = numbers[i];\n       \
    \ }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = min;\n\
    \        min = numbers[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum / numbers.length;\n        sum = sum - numbers[i] * numbers[i];\n\
    \    }\n    long median = result[(number", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] > max)\n        {\n            max = numbers[i];\n    \
    \    }\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] =\
    \ max;\n        max = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(;\
    \ i < numbers.length; i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = numbers[i];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[(numbers.length - 1) - std.math.floor((numbers.length\
    \ - 1) / 2)];\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling standard deviation element found until given moment\n\
    \    in the sequence.\n    >>> rolling_", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    long maxIndex = 0;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = max;\n    result[1]\
    \ = maxIndex;\n    for (int i = 2; i < numbers.length; i++)\n    {\n        if\
    \ (numbers[i] > max)\n        {\n            result[i] = max;\n        }\n   \
    \     else\n        {\n            result[i] = numbers[i - 1];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    long minIndex = 0;\n\
    \    for (int i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] <\
    \ min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    result[0] = min;\n    result[1] = minIndex;\n    for (int\
    \ i = 2; i < numbers.length; i++)\n    {\n        if (numbers[i] < min)\n    \
    \    {\n            result[i] = min;\n        }\n        else\n        {\n   \
    \         result[i] = numbers[i - 1];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    result[0] = sum;\n    for (int i = 1; i < numbers.length; i++)\n \
    \   {\n        result[i] = numbers[i - 1];\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_average([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_average(long[] numbers) \n{\n    long[] result = ", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        if\
    \ (cur > max)\n        {\n            max = cur;\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long cur = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        if\
    \ (cur < min)\n        {\n            min = cur;\n        }\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for (int i\
    \ = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n    }\n    long avg = sum / numbers.length;\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        cur = numbers[i];\n        result[i]\
    \ = avg;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n    }\n    long avg = sum / numbers.length;\n    long mid = numbers.length\
    \ / 2;\n    for (int i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n\
    \        if (i == mid)\n        {\n            result[i] = avg;\n        }\n \
    \       else", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = 0;\n    long currentMax = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        max = numbers[i];\n        currentMax = max;\n        for(;\
    \ i < numbers.length; i++)\n        {\n            if(numbers[i] > max)\n    \
    \        {\n                max = numbers[i];\n                currentMax = max;\n\
    \            }\n        }\n        result[i] = currentMax;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI believe this solution will\
    \ fail for negative numbers. Try it out with [-1L, -2L, -3L, -2L, -3L, -4L, -2L]\n\
    <|/ c |>\n<| c |>\nYes, it will. That's why I said \"given array of integers\"\
    . Of course it can be easily modified to handle negative numbers. I added a comment\
    \ to the code explaining that.\n<|/ c |>\n<| a tags=c#,algorithm |>\n<code>\n\
    public static int[] rolling_max(int[] numbers)\n{\n    int[] result = new int[numbers.Length];\n\
    \    int max = 0;\n    int currentMax = 0;\n    int i = 0;\n    foreach (int number\
    \ in numbers)\n    {\n        max = number;\n        currentMax = max;\n     \
    \   foreach (int number in numbers)\n        {\n            if (number > max)\n\
    \            {\n                max = number;\n                currentMax = max;\n\
    \            }\n        }\n        result[i] = currentMax;\n        i++;\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n\
    using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\
    using System.Threading.Tasks;", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    long maxIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = max;\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    long minIndex\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n            minIndex = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == min)\n        {\n            result[i] = min;\n        }\n\
    \        else\n        {\n            result[i] = min;\n        }\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sumIndex = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum == numbers[i])\n   \
    \     {\n            sumIndex = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == sum)\n        {\n            result[i]\
    \ = sum;\n        }\n        else\n        {\n            result[i] = sum;\n \
    \       }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling product element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L,\
    \ 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] ", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    \n    while(j < numbers.length)\n\
    \    {\n        if(numbers[j] > numbers[k])\n        {\n            result[i]\
    \ = numbers[j];\n            i++;\n            j++;\n        }\n        else\n\
    \        {\n            result[i] = numbers[k];\n            i++;\n          \
    \  k++;\n        }\n    }\n    \n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    result[0] = max_so_far;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            result[i] = max_so_far;\n        }\n        else\n   \
    \     {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    result[0]\
    \ = min_so_far;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            result[i] = min_so_far;\n        }\n \
    \       else\n        {\n            result[i] = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = numbers[0];\n    long sum_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n\
    \        if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[0] = sum_so_far;\n\
    \    for(int i = 1; i < numbers.length", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = numbers[i];\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_i = 0;\n    for(int i\
    \ = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_i = i;\n\
    \        }\n    }\n    result[max_so_far_i] = max_so_far;\n    for(int i = max_so_far_i\
    \ + 1; i + 1 < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    return result;\n}", "{\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long min = numbers[0];\n\
    \    long minIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] < min)\n        {\n            min = numbers[i];\n    \
    \        minIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[minIndex];\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = numbers[i] + numbers[i + 1];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 6L, 6L, 12L, 12L]\n    \n*/\nlong[]\
    \ rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i]\
    \ * numbers[i + 1];\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling quotient element found until given moment\n\
    \    in the sequence.\n    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long cur = 0;\n    long i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        cur = numbers[i];\n        if(cur > max)\n        {\n \
    \           max = cur;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = 0;\n    long currentMax = 0;\n    long currentNumber = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n  \
    \      max = currentNumber;\n        currentMax = currentNumber;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            currentMax = max(currentMax,\
    \ numbers[j]);\n        }\n        result[i] = currentMax;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[]\
    \ rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = 0;\n    long currentMin = 0;\n    long currentNumber = 0;\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n\
    \        min = currentNumber;\n        currentMin = currentNumber;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            currentMin = min(currentMin,\
    \ numbers[j]);\n        }\n        result[i] = currentMin;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long currentSum = 0;\n    long currentNumber = 0;\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n\
    \        sum = sum + currentNumber;\n        currentSum = sum;\n        for(int\
    \ j = i; j < numbers.length; j++)\n        {\n            currentSum = currentSum\
    \ + numbers[j];\n        }\n        result[i] = currentSum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) ", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    long max_pos =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n            max_pos = i;\n\
    \        }\n    }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n \
    \       if(numbers[i] > max)\n        {\n            result[i - max_pos] = max;\n\
    \            max = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            min_pos = i;\n        }\n    }\n    for(int i = numbers.length -\
    \ 1; i >= 0; i--)\n    {\n        if(numbers[i] < min)\n        {\n          \
    \  result[i - min_pos] = min;\n            min = numbers[i];\n        }\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sum_pos = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if(sum > numbers[i])\n    \
    \    {\n            sum = numbers[i];\n            sum_pos = i;\n        }\n \
    \   }\n    for(int i = numbers.length - 1; i >= 0; i--)\n    {\n        sum +=\
    \ numbers[i];\n        if(sum > numbers[i])\n        {\n            result[i -\
    \ sum_pos] = sum;\n            sum = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    long cur = numbers[0];\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n   \
    \         max = numbers[i];\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            result[i]\
    \ = max;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    long cur\
    \ = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            result[i] = min;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long cur = numbers[0];\n    long sum = 0;\n    for(int i = 1; i < numbers.length",
  "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[maxIndex];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm |>\n<| a dscore=0\
    \ |>\nI wrote a C# version based on your code. \n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;",
  "{\n    int n = numbers.length;\n    long[] result = new long[n];\n    for(int i\
    \ = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int\
    \ i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n       \
    \ {\n            if(result[j] > result[i])\n            {\n                result[i]\
    \ = result[j];\n            }\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            if(result[j] < result[i])\n            {\n           \
    \     result[i] = result[j];\n            }\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n    }\n\
    \    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j < i; j++)\n\
    \        {\n            result[i] += result[j];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ product of element found until given moment\n    in the sequence.\n    >>> rolling_prod([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_prod(long[] numbers) \n{\n    int n = numbers.length;\n    long[] result\
    \ = new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = numbers[i];\n\
    \    }\n    for(int i = n - 1; i >= 0; i--)\n    {\n        for(int j = 0; j <\
    \ i; j++)\n        {\n            result[i] *= result[j];", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long cur = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        if(cur\
    \ > max)\n        {\n            max = cur;\n        }\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        if(cur\
    \ < min)\n        {\n            min = cur;\n        }\n        result[i] = min;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 6L,\
    \ 6L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        sum +=\
    \ cur;\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling average element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1.5L, 3L, 3L, 3L, 3L, 3L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum += cur;\n        result[i] = sum / numbers.length;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 3", "{\n    int n = numbers.length;\n    long[] result = new long[n];\n    long\
    \ max_value = numbers[0];\n    long max_pos = 0;\n    for(int i = 1; i < n; i++)\n\
    \    {\n        if(numbers[i] > max_value)\n        {\n            max_value =\
    \ numbers[i];\n            max_pos = i;\n        }\n    }\n    result[0] = max_value;\n\
    \    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] > max_value)\n \
    \       {\n            result[i] = max_value;\n        }\n        else\n     \
    \   {\n            result[i] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min_value = numbers[0];\n    long min_pos = 0;\n    for(int i = 1; i\
    \ < n; i++)\n    {\n        if(numbers[i] < min_value)\n        {\n          \
    \  min_value = numbers[i];\n            min_pos = i;\n        }\n    }\n    result[0]\
    \ = min_value;\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] <\
    \ min_value)\n        {\n            result[i] = min_value;\n        }\n     \
    \   else\n        {\n            result[i] = numbers[i];\n        }\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    long sum2 = 0;\n   \
    \ long sum3 = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n\
    \    long sum7 = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 =\
    \ 0;\n    long sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long\
    \ sum14 = 0;\n    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n\
    \    long sum18 = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21\
    \ = 0;\n    long sum22 = 0;\n    ", "{\n    long[] result = new long[numbers.length];\n\
    \    long maxValue = numbers[0];\n    long maxIndex = 0;\n    for(int i = 1; i\
    \ < numbers.length; i++)\n    {\n        if(numbers[i] > maxValue)\n        {\n\
    \            maxValue = numbers[i];\n            maxIndex = i;\n        }\n  \
    \  }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ == maxValue)\n        {\n            result[maxIndex] = numbers[i];\n      \
    \  }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long minValue = numbers[0];\n    long minIndex =\
    \ 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < minValue)\n        {\n            minValue = numbers[i];\n            minIndex\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == minValue)\n        {\n            result[minIndex] =\
    \ numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    long\
    \ count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        count++;\n    }\n    long average = sum / count;\n \
    \   for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == average)\n\
    \        {\n            result[i] = average;\n        }\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_median(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long median = 0;\n    ", "{\n    long max = 0;\n    long maxIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           result[i] = max;\n        }\n        else\n        {\n           \
    \ result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            result[i]\
    \ = min;\n        }\n        else\n        {\n            result[i] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling average element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long\
    \ sum = 0;\n    long sumIndex = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum += numbers[i];\n        sumIndex = i;\n    }\n    long avg\
    \ = sum / numbers.length;\n    long[] result = new long[numbers.length];\n   \
    \ for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > avg)\n\
    \        {\n            result[i] = avg;\n        }\n        else\n        {\n\
    \            result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling standard deviation\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_std([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_std(long[] numbers) ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    long currentMax = 0;\n    long currentNumber = 0;\n  \
    \  for(int i = 0; i < numbers.length; i++)\n    {\n        currentNumber = numbers[i];\n\
    \        currentMax = max;\n        max = currentNumber;\n        for(int j =\
    \ i; j < numbers.length; j++)\n        {\n            if(numbers[j] > currentNumber)\n\
    \            {\n                currentMax = max;\n                max = currentNumber;\n\
    \            }\n        }\n        result[i] = currentMax;\n    }\n    return\
    \ result;\n}", "{\n    long max = 0;\n    long maxIndex = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n\
    \            max = numbers[i];\n            maxIndex = i;\n        }\n    }\n\
    \    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[maxIndex];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min = 0;\n    long minIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n            minIndex = i;\n        }\n    }\n \
    \   long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[minIndex];\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long sum = 0;\n    long sumIndex = 0;\n    for(int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        sumIndex++;\n\
    \    }\n    long avg = sum / sumIndex;\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[sumIndex\
    \ - 1];\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long median = 0;\n    long medianIndex = 0;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] < median)\n\
    \        {\n            median = numbers[i];\n            medianIndex = i;\n \
    \       }", "{\n    long[] result = new long[numbers.length];\n    long max =\
    \ numbers[0];\n    long maxIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \            maxIndex = i;\n        }\n    }\n    result[0] = max;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n     \
    \   {\n            result[i] = max;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    long minIndex = 0;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[0] = min;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n     \
    \   {\n            result[i] = min;\n        }\n        else\n        {\n    \
    \        result[i] = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long count = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        sum += numbers[i];\n        count++;\n    }\n    double avg = sum / count;\n\
    \    long sum2 = 0;\n    long count2 = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum2 += numbers[i] * numbers[i];\n        count2++;\n \
    \   }\n    double avg2 = sum2 / count2;\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i] * avg;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling median element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_median([1L,\
    \ 2L, 3L, 2", "{\n    long[] result = new long[numbers.length];\n    long max_so_far\
    \ = numbers[0];\n    int max_index = -1;\n    for(int i = 1; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_index = i;\n        }\n    }\n    result[max_index]\
    \ = max_so_far;\n    return result;\n}", "{\n    int n = numbers.length;\n   \
    \ long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >= 0;\
    \ i--)\n    {\n        result[i] = max(result[i], numbers[i]);\n    }\n    \n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = min(result[i], numbers[i]);\n    }\n   \
    \ \n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = result[i] + (numbers[i] - result[i]) / n;\n\
    \    }\n    \n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 2L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    \n    for (int i = 0; i < n; i++)\n   \
    \ {\n        result[i] = numbers[i];\n    }\n    \n    for (int i = n - 1; i >=\
    \ 0; i--)\n    {\n        result[i] = result[i] + (numbers[i] - result[i]) / n;\n\
    \    }\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n        result[i] =\
    \ result[i] + (numbers[i] - result[i]) / n;\n    }\n    ", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = 0;\n    long maxIndex = 0;\n   \
    \ for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] > max)\n\
    \        {\n            max = numbers[i];\n            maxIndex = i;\n       \
    \ }\n    }\n    result[maxIndex] = max;\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ 0;\n    long minIndex = 0;\n    for (int i = 0; i < numbers.length; i++)\n \
    \   {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \            minIndex = i;\n        }\n    }\n    result[minIndex] = min;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum = 0;\n    long sumIndex = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n        if (sum == numbers[i])\n  \
    \      {\n            sumIndex = i;\n        }\n    }\n    result[sumIndex] =\
    \ sum;\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    long sumIndex = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n       \
    \ if (sum == numbers[i])\n        {\n            sumIndex = i;\n        }\n  \
    \  }\n    double avg = sum / numbers.length;\n    result[sumIndex] = avg;\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling standard deviation element found ", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n\
    \        {\n            max_so_far = numbers[i];\n            max_so_far_index\
    \ = i;\n        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        if(numbers[i] == max_so_far)\n        {\n            result[i] = max_so_far_index;\n\
    \        }\n        else\n        {\n            result[i] = max_so_far;\n   \
    \     }\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 2L, 2L, 2L, 3L,\
    \ 3L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == min_so_far)\n        {\n            result[i]\
    \ = min_so_far_index;\n        }\n        else\n        {\n            result[i]\
    \ = min_so_far;\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling average element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far = 0;\n\
    \    long sum_so_far_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        sum_so_far += numbers[i];\n        sum_so_far_index += numbers[i];\n\
    \    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = sum_so_far_index / numbers.length;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling median element found\
    \ until given moment\n    in the sequence.\n    >>> ", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n \
    \           max = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = max;\n        max = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    int i = 0;\n    for(;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] < min)\n        {\n \
    \           min = numbers[i];\n        }\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = min;\n        min = numbers[i];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = 0;\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        sum += numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = sum / numbers.length;\n        sum = sum -\
    \ numbers[i] * result[i];\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment\n\
    \    in the sequence.\n    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = 0;\n    int\
    \ i = 0;\n    for(; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \    }\n    for(; i < numbers.length; i++)\n    {\n        result[i] = sum / numbers.length;\n\
    \        sum = sum - numbers[i] * result[i];\n    }\n    long median = 0;\n  \
    \  for(", "{\n    long[] result = new long[numbers.length];\n    long max = 0;\n\
    \    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n     \
    \   cur = numbers[i];\n        max = cur;\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] > max)\n            {\n         \
    \       max = numbers[j];\n            }\n        }\n        result[i] = max;\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = 0;\n    long cur = 0;\n    for(int i =\
    \ 0; i < numbers.length; i++)\n    {\n        cur = numbers[i];\n        min =\
    \ cur;\n        for(int j = i; j < numbers.length; j++)\n        {\n         \
    \   if(numbers[j] < min)\n            {\n                min = numbers[j];\n \
    \           }\n        }\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 6L, 6L, 9L, 9L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ 0;\n    long cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n\
    \        cur = numbers[i];\n        sum = cur;\n        for(int j = i; j < numbers.length;\
    \ j++)\n        {\n            sum += numbers[j];\n        }\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling product of element found until given moment\n    in the\
    \ sequence.\n    >>> rolling_prod([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 6L,\
    \ 24L, 24L, 24L, 120L, 120L]\n    \n*/\nlong[] rolling_prod(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long prod = 1;\n    long\
    \ cur = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        cur =\
    \ numbers[i];\n        prod = cur;\n        for(int ", "{\n    long[] result =\
    \ new long[numbers.length];\n    int i = 0;\n    long max = 0;\n    while(i <\
    \ numbers.length)\n    {\n        max = numbers[i];\n        for(int j = i; j\
    \ < numbers.length; j++)\n        {\n            if(numbers[j] > max)\n      \
    \      {\n                max = numbers[j];\n            }\n        }\n      \
    \  result[i] = max;\n        i++;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long min = 0;\n    while(i < numbers.length)\n    {\n        min = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            if(numbers[j]\
    \ < min)\n            {\n                min = numbers[j];\n            }\n  \
    \      }\n        result[i] = min;\n        i++;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long sum = 0;\n    while(i < numbers.length)\n    {\n        sum = numbers[i];\n\
    \        for(int j = i; j < numbers.length; j++)\n        {\n            sum +=\
    \ numbers[j];\n        }\n        result[i] = sum;\n        i++;\n    }\n    return\
    \ result;\n}\n/*\n From a given array of integers, generate an array of rolling\
    \ average element found until given moment\n    in the sequence.\n    >>> rolling_avg([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 4L, 4L, 4L]\n    \n*/\nlong[]\
    \ rolling_avg(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long sum = 0;\n    while(i < numbers.length)\n    {\n   \
    \     sum = numbers[i];\n        for(int j = i; j < numbers.length; j++)\n   \
    \     {\n            sum += numbers[j];\n        }", "{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.max(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2L, 2L, 2L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.min(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of element found until given moment\n    in the sequence.\n \
    \   >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 3L, 6L, 9L,\
    \ 9L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length; i++)\n\
    \    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.sum(result[i], numbers[i]);\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 2L, 6L,\
    \ 24L, 24L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    int i = 0;\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(; i < numbers.length;\
    \ i++)\n    {\n        result[i] = std.math.product(result[i], numbers[i]);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling quotient of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_quotient([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 2",
  "{\n    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    long max_so_far_index = 0;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max_so_far)\n        {\n            max_so_far\
    \ = numbers[i];\n            max_so_far_index = i;\n        }\n    }\n    result[max_so_far_index]\
    \ = max_so_far;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min_so_far = numbers[0];\n    long min_so_far_index\
    \ = 0;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    result[min_so_far_index] = min_so_far;\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum element found until given moment\n    in the sequence.\n    >>>\
    \ rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n\
    \    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long sum_so_far = 0;\n    long sum_so_far_index = 0;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        sum_so_far += numbers[i];\n       \
    \ if(sum_so_far > numbers[i])\n        {\n            sum_so_far = numbers[i];\n\
    \            sum_so_far_index = i;\n        }\n    }\n    result[sum_so_far_index]\
    \ = sum_so_far;\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long", "{\n    int\
    \ n = numbers.length;\n    long[] result = new long[n];\n    long max_so_far =\
    \ numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n        if(numbers[i] >\
    \ max_so_far)\n        {\n            max_so_far = numbers[i];\n        }\n  \
    \  }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] = max_so_far;\n\
    \        max_so_far = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long min_so_far = numbers[0];\n    for(int i = 1; i < n; i++)\n    {\n  \
    \      if(numbers[i] < min_so_far)\n        {\n            min_so_far = numbers[i];\n\
    \        }\n    }\n    for(int i = 0; i < n; i++)\n    {\n        result[i] =\
    \ min_so_far;\n        min_so_far = numbers[i];\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling average element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_avg(long[]\
    \ numbers) \n{\n    int n = numbers.length;\n    long[] result = new long[n];\n\
    \    long sum_so_far = 0;\n    long sum_of_squares = 0;\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        sum_so_far += numbers[i];\n        sum_of_squares\
    \ += numbers[i] * numbers[i];\n    }\n    for(int i = 0; i < n; i++)\n    {\n\
    \        result[i] = sum_so_far / sum_of_squares;\n        sum_so_far = sum_of_squares\
    \ = 0;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling median element found until given moment\n    in the sequence.\n\
    \    >>> rolling_median([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n*/\nlong[] rolling_median(long[] numbers) \n{\n    int n = numbers.length;\n\
    \    ", "{\n    long max_value = numbers[0];\n    long max_index = numbers[0];\n\
    \    for (int i = 1; i < numbers.length; ++i)\n    {\n        if (numbers[i] >\
    \ max_value)\n        {\n            max_value = numbers[i];\n            max_index\
    \ = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n    result[max_index]\
    \ = max_value;\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    long max = 0;\n    \n    for(int j = 0; j < numbers.length;\
    \ j++)\n    {\n        if(numbers[j] > max)\n        {\n            max = numbers[j];\n\
    \        }\n    }\n    \n    for(int j = 0; j < numbers.length; j++)\n    {\n\
    \        if(numbers[j] == max)\n        {\n            result[i] = max;\n    \
    \        i++;\n        }\n        else\n        {\n            result[i] = numbers[j];\n\
    \        }\n    }\n    \n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    int i = 0;\n    \n    for(; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n    }\n    \n    for(; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max;\n        max = numbers[i];\n    }\n    \n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    int i = 0;\n    long max =\
    \ 0;\n    long cur = 0;\n    while(i < numbers.length)\n    {\n        cur = numbers[i];\n\
    \        if(cur > max)\n        {\n            max = cur;\n        }\n       \
    \ i++;\n    }\n    for(i = 0; i < numbers.length; i++)\n    {\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long min = 0;\n    long cur = 0;\n\
    \    while(i < numbers.length)\n    {\n        cur = numbers[i];\n        if(cur\
    \ < min)\n        {\n            min = cur;\n        }\n        i++;\n    }\n\
    \    for(i = 0; i < numbers.length; i++)\n    {\n        result[i] = min;\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of element found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    long sum = 0;\n    long cur = 0;\n\
    \    while(i < numbers.length)\n    {\n        cur = numbers[i];\n        sum\
    \ += cur;\n        i++;\n    }\n    for(i = 0; i < numbers.length; i++)\n    {\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n\
    \    long product = 1;\n    long cur = 0;\n    while(i < numbers.length)\n   \
    \ {\n        cur = numbers[i];\n        product *= cur;\n        i++;\n    }\n\
    \    for(i = 0; i < number", "{\n    long max_so_far = numbers[0];\n    long max_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > max_so_far)\n        {\n            max_so_far = numbers[i];\n           \
    \ max_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = max_so_far;\n\
    \    }\n    for(int i = numbers.length - 1; i > max_so_far_index; i--)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long min_so_far = numbers[0];\n    long min_so_far_index =\
    \ -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ < min_so_far)\n        {\n            min_so_far = numbers[i];\n           \
    \ min_so_far_index = i;\n        }\n    }\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = min_so_far;\n\
    \    }\n    for(int i = numbers.length - 1; i > min_so_far_index; i--)\n    {\n\
    \        result[i] = numbers[i];\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        result[i] = numbers[i];\n    }\n    for(int i = 0; i <\
    \ numbers.length; i++)\n    {\n        result[i] += result[i - 1];\n    }\n  \
    \  return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling average element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_average([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L]\n    \n", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max_so_far = numbers[0];\n    long max_so_far_index = -1;\n    for(int i = 1;\
    \ i < numbers.length; i++)\n    {\n        if(numbers[i] > max_so_far)\n     \
    \   {\n            max_so_far = numbers[i];\n            max_so_far_index = i;\n\
    \        }\n    }\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == max_so_far)\n        {\n            result[max_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 3L, 2L, 3L, 4L, 2L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min_so_far = numbers[0];\n\
    \    long min_so_far_index = -1;\n    for(int i = 1; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] < min_so_far)\n        {\n            min_so_far\
    \ = numbers[i];\n            min_so_far_index = i;\n        }\n    }\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] == min_so_far)\n\
    \        {\n            result[min_so_far_index] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling average element found until given moment\n    in the sequence.\n\
    \    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L,\
    \ 4L]\n    \n*/\nlong[] rolling_avg(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long avg_so_far = numbers[0];\n    long avg_so_far_index\
    \ = -1;\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i]\
    \ > avg_so_far)\n        {\n            avg_so_far = numbers[i];\n           \
    \ avg_so_far_index = i;\n        }\n    }\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(numbers[i] == avg_so_far)\n        {\n            result[avg_so_far_index]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling median element found until given moment"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
