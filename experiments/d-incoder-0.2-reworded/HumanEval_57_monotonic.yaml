name: HumanEval_57_monotonic
language: d
prompt: "import std.math;\nimport std.typecons;\n/*\nReturn true is array elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n\
  \    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
  \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i < l.length;\
    \ ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\t\tif (l[i] > max)\n\t\t\
    \tmax = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    long min = l[0];\n   \
    \ long max = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n            min = l[i];\n        if(l[i] > max)\n            max = l[i];\n\
    \    }\n    return min < max;\n}", "{\n    long max = l[0];\n    long min = l[0];\n\
    \    bool result = true;\n    for (int i = 1; i < l.length; ++i) {\n        if\
    \ (l[i] > max) {\n            result = false;\n            break;\n        }\n\
    \        if (l[i] < min) {\n            result = false;\n            break;\n\
    \        }\n    }\n    return result;\n}", "{\n\tlong min = l[0];\n\tlong max\
    \ = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t\
    {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\
    \t}\n\t}\n\treturn (min <= max);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\
    \tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i) {\n\t\tif (l[i]\
    \ < min) {\n\t\t\tmin = l[i];\n\t\t}\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\
    \t\t}\n\t\tif (l[i] < min) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t\tif (l[i]\
    \ > max) {\n\t\t\tisMonotonic = false;\n\t\t}\n\t}\n\treturn isMonotonic;\n}",
  "{\n    long i = 0;\n    long j = 1;\n    long k = 0;\n    long n = l.length;\n\
    \    long m = n - 1;\n    long x = l[0];\n    long y = l[1];\n    long z = l[2];\n\
    \    long w = l[3];\n    long a = l[4];\n    long b = l[5];\n    long c = l[6];\n\
    \    long d = l[7];\n    long e = l[8];\n    long f = l[9];\n    long g = l[10];\n\
    \    long h = l[11];\n    long i = l[12];\n    long j = l[13];\n    long k = l[14];\n\
    \    long l = l[15];\n    long m = l[16];\n    long n = l[17];\n    long o = l[18];\n\
    \    long p = l[19];\n    long q = l[20];\n    long r = l[21];\n    long s = l[22];\n\
    \    long t = l[23];\n    long u = l[24];\n    long v = l[25];\n    long w = l[26];\n\
    \    long x = l[27];\n    long y = l[28];\n    long z = l[29];\n    long a = l[30];\n\
    \    long b = l[31];\n    long c = l[32];\n    long d = l[33];\n    long e = l[34];\n\
    \    long f = l[35];\n    long g = l[36];\n    long h = l[37];\n    long i = l[38];\n\
    \    long j = l[39];\n    long k = l[40];\n    long l = l[41];\n    long m = l[42];\n\
    \    long n = l[43];\n    long o = l[44];\n    long p = l[45];\n    long q = l[46];\n\
    \    long r = l[47];\n    long s = l[48];\n    long t = l[49];\n    long u = l[50];\n\
    \    long v = l[51];\n    long w = l[52];\n    long x = l[53];\n    long y = l[54];\n\
    \    long z = l[55];\n    long a = l[56];\n    long b = l[57];\n    long c = l[58];\n\
    \    long d = l[59];\n    long e = l[60];\n    long f = l[61];\n    long g = l[62];\n\
    \    ", "{\n\tlong max = 0;\n\tlong min = 0;\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] > max)\n\t\t\tmax = l[i];\n\t\tif (l[i] < min)\n\t\t\
    \tmin = l[i];\n\t}\n\treturn (min <= max);\n}", "{\n    int i = 0;\n    int j\
    \ = l.length - 1;\n    bool isIncreasing = true;\n    bool isDecreasing = true;\n\
    \    while (i < j) {\n        if (l[i] > l[j]) {\n            isIncreasing = false;\n\
    \        }\n        if (l[i] < l[j]) {\n            isDecreasing = false;\n  \
    \      }\n        i++;\n        j--;\n    }\n    return isIncreasing || isDecreasing;\n\
    }", "{\n    long prev = 0;\n    long curr = l[0];\n    bool result = true;\n \
    \   for(int i = 1; i < l.length; i++) \n    {\n        if(curr < l[i]) \n    \
    \    {\n            result = false;\n            break;\n        }\n        else\
    \ if(curr > l[i]) \n        {\n            result = true;\n            break;\n\
    \        }\n        prev = curr;\n        curr = l[i];\n    }\n    return result;\n\
    }", "{\n    int n = l.length;\n    if (n == 0) return true;\n    if (n == 1) return\
    \ false;\n    if (l[0] == l[1]) return true;\n    \n    long m = l[0];\n    long\
    \ l = l[1];\n    \n    for (int i = 2; i < n; i++) {\n        long x = l[i];\n\
    \        long y = l[i - 1];\n        \n        if (x < y) \n            return\
    \ false;\n        if (x > y) \n            return true;\n    }\n    \n    return\
    \ true;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\tfor (int i = 1; i <\
    \ l.length; ++i)\n\t{\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\
    \tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\t}\n\treturn (max < min);\n\
    }", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tbool result = true;\n\tfor (int\
    \ i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\
    \t\t}\n\t\telse if (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t\telse\n\t\
    \t{\n\t\t\tresult = false;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long max\
    \ = l[0];\n    long min = l[0];\n    for(int i = 1; i < l.length; ++i)\n    {\n\
    \        if(l[i] < min)\n            min = l[i];\n        if(l[i] > max)\n   \
    \         max = l[i];\n    }\n    return max >= min;\n}", "{\n    long min = l[0];\n\
    \    long max = l[0];\n    for(int i = 1; i < l.length; ++i) {\n        if(l[i]\
    \ < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n    return min\
    \ <= max;\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (int i = 1; i\
    \ < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tmin = l[i];\n\t\t}\n\
    \t\tif (l[i] > max)\n\t\t{\n\t\t\tmax = l[i];\n\t\t}\n\t}\n\treturn (min <= max);\n\
    }", "{\n    long min = l[0];\n    long max = l[0];\n    bool isMonotonic = true;\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n      \
    \  {\n            isMonotonic = false;\n            min = l[i];\n        }\n \
    \       else if(l[i] > max)\n        {\n            isMonotonic = false;\n   \
    \         max = l[i];\n        }\n    }\n    return isMonotonic;\n}\n</code>\n\
    <|/ a tags=c++,arrays,sorting |>\n<| c |>\nThis doesn't work if the array is all\
    \ zeroes. Try it with `monotonic([0L, 0L, 0L, 0L])`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it with `monotonic([0L, 0L, 0L, 0L])`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if all elements are zero. Try it with `monotonic([0L, 0L, 0L, 0L])`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `monotonic([0L, 0L, 0L, 0L])`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if all elements are zero. Try it with `monotonic([0L,\
    \ 0L, 0L, 0L])`.\n<|/ c |>\n<| a tags=c++,arrays,sorting |>\n<code>", "{\n\tlong\
    \ max = l[0];\n\tlong min = l[0];\n\tbool result = true;\n\tfor (int i = 1; i\
    \ < l.length; ++i)\n\t{\n\t\tif (l[i] < min)\n\t\t{\n\t\t\tresult = false;\n\t\
    \t\tbreak;\n\t\t}\n\t\tif (l[i] > max)\n\t\t{\n\t\t\tresult = false;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tbool isMonotonic = true;\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] < min)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t\tif\
    \ (l[i] > max)\n\t\t{\n\t\t\tisMonotonic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\
    return isMonotonic;\n}", "{\n    long min = l[0];\n    long max = l[0];\n    bool\
    \ result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < min)\n        {\n            min = l[i];\n        }\n        else if(l[i]\
    \ > max)\n        {\n            max = l[i];\n        }\n        else\n      \
    \  {\n            result = false;\n            break;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long min = 0;\n    long max = l[0];\n    bool changed =\
    \ true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i] < min)\n\
    \        {\n            min = l[i];\n        }\n        if(l[i] > max)\n     \
    \   {\n            max = l[i];\n        }\n        if(l[i] < min)\n        {\n\
    \            changed = false;\n        }\n    }\n    return changed;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
