name: HumanEval_25_factorize
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long counter = 1;\n    long lastFactor = 1;\n\
    \    long lastCounter = 1;\n    \n    while(factor <= n)\n    {\n        factors[counter]\
    \ = factor;\n        factorization *= factor;\n        counter++;\n        \n\
    \        while(factorization % factor == 0)\n        {\n            factorization\
    \ *= factor;\n            factor++;\n        }\n    }\n    \n    factors[counter]\
    \ = factor;\n    factorization *= factor;\n    \n    for(int i = counter - 1;\
    \ i >= 0; i--)\n    {\n        if(factors[i] == lastFactor)\n        {\n     \
    \       factors[i]++;\n            lastCounter++;\n        }\n        else\n \
    \       {\n            lastFactor = factors[i];\n            lastCounter = 1;\n\
    \        }\n    }\n    \n    for(int i = 0; i < counter; i++)\n    {\n       \
    \ if(factors[i] == lastFactor)\n        {\n            factors[i]++;\n       \
    \     lastCounter++;\n        }\n        else\n        {\n            lastFactor\
    \ = factors[i];\n            lastCounter = 1;\n        }\n    }\n    \n    return\
    \ factors;\n}\n</code>\n<|/ a tags=math,algorithm,primes |>\n<| c |>\nThe first\
    \ part of this answer is wrong. `factorize(8L)` returns `[2L, 2L, 2L]` but `factorize(25L)`\
    \ returns `[1L, 2L, 3L]`.\n<|/ c |>\n<| c |>\nI fixed the bug in the first part\
    \ and added a second part that fixes the bug in the second part.\n<|/ c |>\n<|\
    \ c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| a tags=math,algorithm,primes |>\nThe first part of this answer is wrong. factorize(8L)\
    \ returns [2L, 2L, 2L] but factorize(25L) returns [1L, 2L, 3L].\nThe second part\
    \ of this answer is wrong. factorize(8L) returns [2L, 2L, 2L] but factorize(25L)\
    \ returns [1L, 2L, 3L].\nThe third part of this answer is wrong. factorize(8L)\
    \ returns [2L, 2L, 2L] but factorize(25L) returns [1L, \nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppo728n4h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmppo728n4h.d(70): Error: declaration expected, not `<`\\n/tmp/tmppo728n4h.d(95):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmppo728n4h.d(96): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmppo728n4h.d(97): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmppo728n4h.d(98): Error: declaration expected, not `assert`\\\
    n/tmp/tmppo728n4h.d(99): Error: declaration expected, not `assert`\\n/tmp/tmppo728n4h.d(100):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmppo728n4h.d(101): Error:\
    \ declaration expected, not `assert`\\n/tmp/tmppo728n4h.d(102): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmppo728n4h.d(103): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo728n4h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[factorCount] = i;\n        \
    \    factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,factorization,c#\
    \ |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ipb211c.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp2ipb211c.d(20): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp2ipb211c.d(30): Error: declaration expected, not `<`\\n/tmp/tmp2ipb211c.d(35):\
    \ Error: semicolon expected, not `.`\\n/tmp/tmp2ipb211c.d(35): Error: no identifier\
    \ for declarator `.Collections.Generic`\\n/tmp/tmp2ipb211c.d(36): Error: semicolon\
    \ expected, not `.`\\n/tmp/tmp2ipb211c.d(36): Error: no identifier for declarator\
    \ `.Linq`\\n/tmp/tmp2ipb211c.d(37): Error: semicolon expected, not `.`\\n/tmp/tmp2ipb211c.d(37):\
    \ Error: no identifier for declarator `.Text`\\n/tmp/tmp2ipb211c.d(38): Error:\
    \ semicolon expected, not `.`\\n/tmp/tmp2ipb211c.d(38): Error: no identifier for\
    \ declarator `.Threading.Tasks`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2ipb211c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 1;\n        while(n % i == 0) {\n            n /= i;\n   \
    \         factorCount++;\n        }\n        factors[factorCount] = i;\n     \
    \   factor++;\n    }\n    return factors;\n}\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        factorCount = 1;\n        while(n % i == 0) {\n            n\
    \ /= i;\n            factorCount++;\n        }\n        factors[factorCount] =\
    \ i;\n        factor++;\n    }\n    return factors;\n}\n/*\n Return array of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n, int factorizationSize, bool isPrime) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        factorCount = 1;\n        while(n % i == 0) {\n            n\
    \ /= i;\n            factorCount++;\n        }\n        if(isPrime) {\n      \
    \      if(factorCount == factorizationSize) {\n                factors[factorCount]\
    \ = i;\n                factor++;\n                factorCount = 0;\n        \
    \    }\n        } else {\n            if(factorCount == factorizationSize) {\n\
    \                factors[factorCount] = i;\n                factor++;\n      \
    \          factorCount = 0;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return array of \nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpssj1tcww.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpssj1tcww.d(20): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpssj1tcww.d(48): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpssj1tcww.d(76): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpssj1tcww.d(98): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpssj1tcww.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = n;\n    long factorization = 1;\n    long factorizationCount = 0;\n\
    \    long factorizationCount2 = 0;\n    long factorizationCount3 = 0;\n    long\
    \ factorizationCount4 = 0;\n    long factorizationCount5 = 0;\n    long factorizationCount6\
    \ = 0;\n    long factorizationCount7 = 0;\n    long factorizationCount8 = 0;\n\
    \    long factorizationCount9 = 0;\n    long factorizationCount10 = 0;\n    long\
    \ factorizationCount11 = 0;\n    long factorizationCount12 = 0;\n    long factorizationCount13\
    \ = 0;\n    long factorizationCount14 = 0;\n    long factorizationCount15 = 0;\n\
    \    long factorizationCount16 = 0;\n    long factorizationCount17 = 0;\n    long\
    \ factorizationCount18 = 0;\n    long factorizationCount19 = 0;\n    long factorizationCount20\
    \ = 0;\n    long factorizationCount21 = 0;\n    long factorizationCount22 = 0;\n\
    \    long factorizationCount23 = 0;\n    long factorizationCount24 = 0;\n    long\
    \ factorizationCount25 = 0;\n    long factorizationCount26 = 0;\n    long factorizationCount27\
    \ = 0;\n    long factorizationCount28 = 0;\n    long factorizationCount29 = 0;\n\
    \    long factorizationCount30 = 0;\n    long factorizationCount31 = 0;\n    long\
    \ factorizationCount32 = 0;\n    long factorizationCount33 = 0;\n    long factorizationCount34\
    \ = 0;\n    long factorizationCount35 = 0;\n    long factorizationCount36 = 0;\n\
    \    long factorizationCount37 = 0;\n    long factorizationCount38 = 0;\n    long\
    \ factorizationCount39 = 0;\n    long factorizationCount40 = 0;\n    long factorizationCount41\
    \ = 0;\n    long factorizationCount42 = 0;\n    long factorizationCount43 = 0;\n\
    \    long factorizationCount44 = 0;\n    long factorizationCount45 = 0;\n    long\
    \ factorizationCount46 = 0;\n    long factorizationCount47 = 0;\n    long factorizationCount48\
    \ = 0;\n    long factorizationCount49 = 0;\n    long factorizationCount50 = 0;\n\
    \    long factorizationCount51 = 0;\n    long factorizationCount52 = 0;\n    long\
    \ factorizationCount53 = 0;\n    long factorizationCount54 = 0;\n    long factorizationCount55\
    \ = 0;\n    long factorizationCount56 = 0;\n    long factorizationCount57 = 0;\n\
    \    long factorizationCount58 = 0;\n    long factorizationCount59 = 0;\n    long\
    \ factorizationCount60 = 0;\n    long factorizationCount61\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoyye9n5o.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpoyye9n5o.d(82): Error: semicolon expected, not `unittest`\\n/tmp/tmpoyye9n5o.d(82):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpoyye9n5o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n %\
    \ i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdtxel_x2.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpdtxel_x2.d(46): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpdtxel_x2.d(75): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpdtxel_x2.d(90): Error: unterminated /* */ comment\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtxel_x2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long currentFactor = 1;\n    long currentCount\
    \ = 0;\n    long currentCount2 = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        currentFactor = factor;\n        currentCount = 1;\n  \
    \      for(int j = i; j <= (int)Math.sqrt(n); j++)\n        {\n            if(n\
    \ % j == 0)\n            {\n                currentCount++;\n                currentFactor\
    \ *= j;\n            }\n        }\n        if(currentCount > factorCount)\n  \
    \      {\n            factors[factorCount] = currentFactor;\n            factorCount\
    \ = currentCount;\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    long currentFactor = 1;\n    long currentCount = 0;\n    long currentCount2\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        currentFactor\
    \ = factor;\n        currentCount = 1;\n        for(int j = i; j <= (int)Math.sqrt(n);\
    \ j++)\n        {\n            if(n % j == 0)\n            {\n               \
    \ currentCount++;\n                currentFactor *= j;\n            }\n      \
    \  }\n        if(currentCount > factorCount)\n        {\n            factors[factorCount]\
    \ = currentFactor;\n            factorCount = currentCount;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return array of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorizationSize, int\
    \ factorizationMax) \n{\n\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3o20z9gu.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp3o20z9gu.d(23): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp3o20z9gu.d(27): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp3o20z9gu.d(63): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp3o20z9gu.d(67): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp3o20z9gu.d(98): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3o20z9gu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(p % i == 0) {\n            factors[factorCount] = i;\n\
    \            factorCount++;\n            p /= i;\n        }\n    }\n    factors[factorCount]\
    \ = p;\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ucn8e0j.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp_ucn8e0j.d(21): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ucn8e0j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*i < n)\n        {\n          \
    \  if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                n /= factor*i;\n            }\n            else\n\
    \            {\n                break;\n            }\n        }\n        if(factorCount\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n        }\n\
    \        factor = factors[factorCount-1];\n    }\n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*i < n)\n        {\n          \
    \  if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                n /= factor*i;\n            }\n            else\n\
    \            {\n                break;\n            }\n        }\n        if(factorCount\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n        }\n\
    \        factor = factors[factorCount-1];\n    }\n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i = start; i < factors.length;\
    \ i++)\n    {\n        factorCount = 0;\n        while(factor*i < n)\n       \
    \ {\n            if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb9fs_rqc.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpb9fs_rqc.d(107): Error: found `unittest` instead of statement\\n/tmp/tmpb9fs_rqc.d(120):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmpb9fs_rqc.d(120): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmpb9fs_rqc.d(120): Error: found `End of File` when\
    \ expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpb9fs_rqc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = 1;\n    long q = n;\n    long r = n;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfbpdwta8.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpfbpdwta8.d(118): Error: no identifier for declarator `long`\\n/tmp/tmpfbpdwta8.d(118):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpfbpdwta8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 0;\n        while(n % factor == 0) {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor = factors[factorCount-1];\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c#,primes,math |>\n\
    <| c |>\nThis is not the fastest solution, since it requires division operations.\
    \ A better solution would be to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| a tags=algorithm,c#,primes,math |>\n<code>\npublic static bool IsPrime(long\
    \ n)\n{\n    if (n < 2)\n        return false;\n    if (n == 2)\n        return\
    \ true;\n    if (n % 2 == 0)\n        return false;\n    long limit = (long)Math.Sqrt(n)\
    \ + 1;\n    long counter = 2;\n    while (counter <= limit)\n    {\n        if\
    \ (n % counter == 0)\n            return false;\n        counter++;\n    }\n \
    \   return true;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is not the fastest\
    \ solution, since it requires division operations. A better solution would be\
    \ to generate all primes up to sqrt(n), then filter out those that are not divisible\
    \ by all numbers from 2 to sqrt(n).\n<|/ c |>\n<| c |>\n: I agree, it is better\
    \ to generate all primes up to sqrt(n), then filter out those that are not divisible\
    \ by \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnkq3l7b0.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpnkq3l7b0.d(20): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpnkq3l7b0.d(30): Error: declaration expected, not `<`\\n/tmp/tmpnkq3l7b0.d(53):\
    \ Error: declaration expected, not `if`\\n/tmp/tmpnkq3l7b0.d(55): Error: declaration\
    \ expected, not `if`\\n/tmp/tmpnkq3l7b0.d(57): Error: C style cast illegal, use\
    \ `cast(long)Math.Sqrt(n)`\\n/tmp/tmpnkq3l7b0.d(59): Error: declaration expected,\
    \ not `while`\\n/tmp/tmpnkq3l7b0.d(63): Error: no identifier for declarator `counter`\\\
    n/tmp/tmpnkq3l7b0.d(63): Error: declaration expected, not `++`\\n/tmp/tmpnkq3l7b0.d(64):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpnkq3l7b0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[counter] = i;\n            n\
    \ /= i;\n            counter++;\n        }\n    }\n    factors[counter] = n;\n\
    \    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,java |>\n<| c |>\n\
    This code does not work for large numbers. Try factorize(100000000000L).\n<|/\
    \ c |>\n<| c |>\nYes, it works only for small numbers. But it can be easily modified\
    \ to work with large numbers. Just use BigInteger instead of long.\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| a tags=algorithm,primes,java |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdba2evaj.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpdba2evaj.d(20): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpdba2evaj.d(30): Error: declaration expected, not `<`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdba2evaj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n) + 1L];\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    \n    for(long i = 2; i <= n; i++)\n  \
    \  {\n        while(n % i == 0)\n        {\n            factors[factorCount] =\
    \ i;\n            factor++;\n            factorCount++;\n            n /= i;\n\
    \        }\n    }\n    \n    if(n > 1)\n    {\n        factors[factorCount] =\
    \ n;\n        factor++;\n        factorCount++;\n    }\n    \n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code doesn't work. `factorize(8L)`\
    \ returns `[2, 2, 2]` instead of `[2, 2, 2, 2, 2]`.\n<|/ c |>\n<| c |>\nI tested\
    \ it on `8L` which returns `[2, 2, 2, 2, 2]` as expected. Are you sure you tested\
    \ it correctly?\n<|/ c |>\n<| c |>\nYes, I tested it on `8L` which returns `[2,\
    \ 2, 2, 2, 2]` as expected. Are you sure you tested it correctly?\n<|/ c |>\n\
    <| c |>\nI tested it on `8L` which returns `[2, 2, 2, 2, 2]` as expected. Are\
    \ you sure you tested it correctly?\n<|/ c |>\n<| c |>\nI tested it on `8L` which\
    \ returns `[2, 2, 2, 2, 2]` as expected. Are you sure you tested it correctly?\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp3c46pcn.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\\\
    n/tmp/tmpp3c46pcn.d(41): Error: declaration expected, not `<`\\n/tmp/tmpp3c46pcn.d(44):\
    \ Error: unterminated character constant\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpp3c46pcn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  for(int i = 0; i < factors.length; i++)\n    {\n        while(p % 2 == 0)\n\
    \        {\n            p /= 2;\n            factors[i] = 2;\n        }\n    \
    \    while(p % 3 == 0)\n        {\n            p /= 3;\n            factors[i]\
    \ = 3;\n        }\n        while(p % 5 == 0)\n        {\n            p /= 5;\n\
    \            factors[i] = 5;\n        }\n        while(p % 7 == 0)\n        {\n\
    \            p /= 7;\n            factors[i] = 7;\n        }\n        while(p\
    \ % 11 == 0)\n        {\n            p /= 11;\n            factors[i] = 11;\n\
    \        }\n        while(p % 13 == 0)\n        {\n            p /= 13;\n    \
    \        factors[i] = 13;\n        }\n        while(p % 17 == 0)\n        {\n\
    \            p /= 17;\n            factors[i] = 17;\n        }\n        while(p\
    \ % 19 == 0)\n        {\n            p /= 19;\n            factors[i] = 19;\n\
    \        }\n        while(p % 23 == 0)\n        {\n            p /= 23;\n    \
    \        factors[i] = 23;\n        }\n        while(p % 29 == 0)\n        {\n\
    \            p /= 29;\n            factors[i] = 29;\n        }\n        while(p\
    \ % 31 == 0)\n        {\n            p /= 31;\n            factors[i] = 31;\n\
    \        }\n        while(p % 37 == 0)\n        {\n            p /= 37;\n    \
    \        factors[i] = 37;\n        }\n        while(p % 41 == 0)\n        {\n\
    \            p /= 41;\n            factors[i] = 41;\n        }\n        while(p\
    \ % 43 == 0)\n        {\n            p /= 43;\n            factors[i] = 43;\n\
    \        }\n        while(p % 47 == 0)\n        {\n            p /= 47;\n    \
    \        factors[i] = 47;\n        }\n        while(p % 53 == 0)\n        {\n\
    \            p /= 53;\n            factors[i] = 53;\n        }\n        while(p\
    \ % 59 == 0)\n        {\n            p /= 59;\n            factors[i] = 59;\n\
    \        }\n        while(p % 61 == 0)\n        {\n            p /= 61;\n    \
    \        factors[i] = 61;\n        }\n        while(p % 67 == 0)\n        {\n\
    \            p /= 67;\n            factors[i] = 67;\n        }\n        while(p\
    \ % 71 == 0)\n        {\n            p /= 71;\n            factors[i] = 71;\n\
    \        }\n        while(p % 73 == 0)\n        {\n            p /= 73;\n    \
    \        factors[i] = \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp21og71li.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmp21og71li.d(125): Error: expression expected, not `unittest`\\n/tmp/tmp21og71li.d(126):\
    \ Error: found `{` when expecting `;` following statement\\n/tmp/tmp21og71li.d(138):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmp21og71li.d(138): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp21og71li.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factor_count = 1;\n    long factor_index = 0;\n    for(int i =\
    \ 1; i <= (int)Math.sqrt(n); i++) {\n        factors[factor_index] = i;\n    \
    \    factor_index++;\n        if(n % i == 0) {\n            factor_count++;\n\
    \            factor /= i;\n        }\n    }\n    factors[factor_index] = factor;\n\
    \    factor_index++;\n    factors[factor_index] = factor_count;\n    return factors;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprqpph_sg.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmprqpph_sg.d(21): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmprqpph_sg.d(34): Error: declaration expected, not `<`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqpph_sg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = 1;\n    long r = n;\n    while(p != 1) {\n        while(p % q == 0) {\n\
    \            factors[(int)q] = p;\n            p /= q;\n        }\n        q *=\
    \ 2;\n    }\n    for(int i = factors.length-1; i >= 0; i--) {\n        while(n\
    \ % factors[i] == 0) {\n            n /= factors[i];\n            factors[i]++;\n\
    \        }\n    }\n    factors[(int)n] = 1;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp387k98l2.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmp387k98l2.d(23): Error: C style cast illegal, use `cast(int)q`\\n/tmp/tmp387k98l2.d(34):\
    \ Error: C style cast illegal, use `cast(int)n`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp387k98l2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n        while(n\
    \ % i == 0) {\n            factors[count] = i;\n            n /= i;\n        \
    \    count++;\n        }\n    }\n    factors[count] = n;\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp26jhnw2i.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmp26jhnw2i.d(20): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmp26jhnw2i.d(30): Error: declaration expected, not `<`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp26jhnw2i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu8fa1y57.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpu8fa1y57.d(118): Error: no identifier for declarator `long`\\n/tmp/tmpu8fa1y57.d(118):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpu8fa1y57.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqaupcre.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\\\
    n/tmp/tmpyqaupcre.d(118): Error: no identifier for declarator `long`\\n/tmp/tmpyqaupcre.d(118):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpyqaupcre.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorsCount = 0;\n    long factorsCount2\
    \ = 0;\n    long factorsCount3 = 0;\n    long factorsCount4 = 0;\n    long factorsCount5\
    \ = 0;\n    long factorsCount6 = 0;\n    long factorsCount7 = 0;\n    long factorsCount8\
    \ = 0;\n    long factorsCount9 = 0;\n    long factorsCount10 = 0;\n    long factorsCount11\
    \ = 0;\n    long factorsCount12 = 0;\n    long factorsCount13 = 0;\n    long factorsCount14\
    \ = 0;\n    long factorsCount15 = 0;\n    long factorsCount16 = 0;\n    long factorsCount17\
    \ = 0;\n    long factorsCount18 = 0;\n    long factorsCount19 = 0;\n    long factorsCount20\
    \ = 0;\n    long factorsCount21 = 0;\n    long factorsCount22 = 0;\n    long factorsCount23\
    \ = 0;\n    long factorsCount24 = 0;\n    long factorsCount25 = 0;\n    long factorsCount26\
    \ = 0;\n    long factorsCount27 = 0;\n    long factorsCount28 = 0;\n    long factorsCount29\
    \ = 0;\n    long factorsCount30 = 0;\n    long factorsCount31 = 0;\n    long factorsCount32\
    \ = 0;\n    long factorsCount33 = 0;\n    long factorsCount34 = 0;\n    long factorsCount35\
    \ = 0;\n    long factorsCount36 = 0;\n    long factorsCount37 = 0;\n    long factorsCount38\
    \ = 0;\n    long factorsCount39 = 0;\n    long factorsCount40 = 0;\n    long factorsCount41\
    \ = 0;\n    long factorsCount42 = 0;\n    long factorsCount43 = 0;\n    long factorsCount44\
    \ = 0;\n    long factorsCount45 = 0;\n    long factorsCount46 = 0;\n    long factorsCount47\
    \ = 0;\n    long factorsCount48 = 0;\n    long factorsCount49 = 0;\n    long factorsCount50\
    \ = 0;\n    long factorsCount51 = 0;\n    long factorsCount52 = 0;\n    long factorsCount53\
    \ = 0;\n    long factorsCount54 = 0;\n    long factorsCount55 = 0;\n    long factorsCount56\
    \ = 0;\n    long factorsCount57 = 0;\n    long factorsCount58 = 0;\n    long factorsCount59\
    \ = 0;\n    long factorsCount60 = 0;\n    long factorsCount61 = 0;\n    long factor\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkghnu_3x.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpkghnu_3x.d(82): Error: semicolon expected, not `unittest`\\n/tmp/tmpkghnu_3x.d(82):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkghnu_3x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxnfdhgge.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\\\
    n/tmp/tmpxnfdhgge.d(89): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnfdhgge.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
