language: d
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long counter = 1;\n    long lastFactor = 1;\n\
    \    long lastCounter = 1;\n    \n    while(factor <= n)\n    {\n        factors[counter]\
    \ = factor;\n        factorization *= factor;\n        counter++;\n        \n\
    \        while(factorization % factor == 0)\n        {\n            factorization\
    \ *= factor;\n            factor++;\n        }\n    }\n    \n    factors[counter]\
    \ = factor;\n    factorization *= factor;\n    \n    for(int i = counter - 1;\
    \ i >= 0; i--)\n    {\n        if(factors[i] == lastFactor)\n        {\n     \
    \       factors[i]++;\n            lastCounter++;\n        }\n        else\n \
    \       {\n            lastFactor = factors[i];\n            lastCounter = 1;\n\
    \        }\n    }\n    \n    for(int i = 0; i < counter; i++)\n    {\n       \
    \ if(factors[i] == lastFactor)\n        {\n            factors[i]++;\n       \
    \     lastCounter++;\n        }\n        else\n        {\n            lastFactor\
    \ = factors[i];\n            lastCounter = 1;\n        }\n    }\n    \n    return\
    \ factors;\n}\n</code>\n<|/ a tags=math,algorithm,primes |>\n<| c |>\nThe first\
    \ part of this answer is wrong. `factorize(8L)` returns `[2L, 2L, 2L]` but `factorize(25L)`\
    \ returns `[1L, 2L, 3L]`.\n<|/ c |>\n<| c |>\nI fixed the bug in the first part\
    \ and added a second part that fixes the bug in the second part.\n<|/ c |>\n<|\
    \ c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| c |>\nI added a second part that fixes the bug in the second part.\n<|/ c |>\n\
    <| a tags=math,algorithm,primes |>\nThe first part of this answer is wrong. factorize(8L)\
    \ returns [2L, 2L, 2L] but factorize(25L) returns [1L, 2L, 3L].\nThe second part\
    \ of this answer is wrong. factorize(8L) returns [2L, 2L, 2L] but factorize(25L)\
    \ returns [1L, 2L, 3L].\nThe third part of this answer is wrong. factorize(8L)\
    \ returns [2L, 2L, 2L] but factorize(25L) returns [1L, \nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppo728n4h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmppo728n4h.d(70):
    Error: declaration expected, not `<`\n/tmp/tmppo728n4h.d(95): Error: declaration
    expected, not `assert`\n/tmp/tmppo728n4h.d(96): Error: declaration expected, not
    `assert`\n/tmp/tmppo728n4h.d(97): Error: declaration expected, not `assert`\n/tmp/tmppo728n4h.d(98):
    Error: declaration expected, not `assert`\n/tmp/tmppo728n4h.d(99): Error: declaration
    expected, not `assert`\n/tmp/tmppo728n4h.d(100): Error: declaration expected,
    not `assert`\n/tmp/tmppo728n4h.d(101): Error: declaration expected, not `assert`\n/tmp/tmppo728n4h.d(102):
    Error: declaration expected, not `assert`\n/tmp/tmppo728n4h.d(103): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppo728n4h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[factorCount] = i;\n        \
    \    factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,factorization,c#\
    \ |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2ipb211c.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2ipb211c.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2ipb211c.d(30):
    Error: declaration expected, not `<`\n/tmp/tmp2ipb211c.d(35): Error: semicolon
    expected, not `.`\n/tmp/tmp2ipb211c.d(35): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmp2ipb211c.d(36): Error: semicolon expected, not
    `.`\n/tmp/tmp2ipb211c.d(36): Error: no identifier for declarator `.Linq`\n/tmp/tmp2ipb211c.d(37):
    Error: semicolon expected, not `.`\n/tmp/tmp2ipb211c.d(37): Error: no identifier
    for declarator `.Text`\n/tmp/tmp2ipb211c.d(38): Error: semicolon expected, not
    `.`\n/tmp/tmp2ipb211c.d(38): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ipb211c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 1;\n        while(n % i == 0) {\n            n /= i;\n   \
    \         factorCount++;\n        }\n        factors[factorCount] = i;\n     \
    \   factor++;\n    }\n    return factors;\n}\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        factorCount = 1;\n        while(n % i == 0) {\n            n\
    \ /= i;\n            factorCount++;\n        }\n        factors[factorCount] =\
    \ i;\n        factor++;\n    }\n    return factors;\n}\n/*\n Return array of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n, int factorizationSize, bool isPrime) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        factorCount = 1;\n        while(n % i == 0) {\n            n\
    \ /= i;\n            factorCount++;\n        }\n        if(isPrime) {\n      \
    \      if(factorCount == factorizationSize) {\n                factors[factorCount]\
    \ = i;\n                factor++;\n                factorCount = 0;\n        \
    \    }\n        } else {\n            if(factorCount == factorizationSize) {\n\
    \                factors[factorCount] = i;\n                factor++;\n      \
    \          factorCount = 0;\n            }\n        }\n    }\n    return factors;\n\
    }\n/*\n Return array of \nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpssj1tcww.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpssj1tcww.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpssj1tcww.d(48): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpssj1tcww.d(76): Error: C
    style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpssj1tcww.d(98): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpssj1tcww.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = n;\n    long factorization = 1;\n    long factorizationCount = 0;\n\
    \    long factorizationCount2 = 0;\n    long factorizationCount3 = 0;\n    long\
    \ factorizationCount4 = 0;\n    long factorizationCount5 = 0;\n    long factorizationCount6\
    \ = 0;\n    long factorizationCount7 = 0;\n    long factorizationCount8 = 0;\n\
    \    long factorizationCount9 = 0;\n    long factorizationCount10 = 0;\n    long\
    \ factorizationCount11 = 0;\n    long factorizationCount12 = 0;\n    long factorizationCount13\
    \ = 0;\n    long factorizationCount14 = 0;\n    long factorizationCount15 = 0;\n\
    \    long factorizationCount16 = 0;\n    long factorizationCount17 = 0;\n    long\
    \ factorizationCount18 = 0;\n    long factorizationCount19 = 0;\n    long factorizationCount20\
    \ = 0;\n    long factorizationCount21 = 0;\n    long factorizationCount22 = 0;\n\
    \    long factorizationCount23 = 0;\n    long factorizationCount24 = 0;\n    long\
    \ factorizationCount25 = 0;\n    long factorizationCount26 = 0;\n    long factorizationCount27\
    \ = 0;\n    long factorizationCount28 = 0;\n    long factorizationCount29 = 0;\n\
    \    long factorizationCount30 = 0;\n    long factorizationCount31 = 0;\n    long\
    \ factorizationCount32 = 0;\n    long factorizationCount33 = 0;\n    long factorizationCount34\
    \ = 0;\n    long factorizationCount35 = 0;\n    long factorizationCount36 = 0;\n\
    \    long factorizationCount37 = 0;\n    long factorizationCount38 = 0;\n    long\
    \ factorizationCount39 = 0;\n    long factorizationCount40 = 0;\n    long factorizationCount41\
    \ = 0;\n    long factorizationCount42 = 0;\n    long factorizationCount43 = 0;\n\
    \    long factorizationCount44 = 0;\n    long factorizationCount45 = 0;\n    long\
    \ factorizationCount46 = 0;\n    long factorizationCount47 = 0;\n    long factorizationCount48\
    \ = 0;\n    long factorizationCount49 = 0;\n    long factorizationCount50 = 0;\n\
    \    long factorizationCount51 = 0;\n    long factorizationCount52 = 0;\n    long\
    \ factorizationCount53 = 0;\n    long factorizationCount54 = 0;\n    long factorizationCount55\
    \ = 0;\n    long factorizationCount56 = 0;\n    long factorizationCount57 = 0;\n\
    \    long factorizationCount58 = 0;\n    long factorizationCount59 = 0;\n    long\
    \ factorizationCount60 = 0;\n    long factorizationCount61\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoyye9n5o.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpoyye9n5o.d(82):
    Error: semicolon expected, not `unittest`\n/tmp/tmpoyye9n5o.d(82): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyye9n5o.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n %\
    \ i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdtxel_x2.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdtxel_x2.d(46):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdtxel_x2.d(75):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdtxel_x2.d(90):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdtxel_x2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long currentFactor = 1;\n    long currentCount\
    \ = 0;\n    long currentCount2 = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        currentFactor = factor;\n        currentCount = 1;\n  \
    \      for(int j = i; j <= (int)Math.sqrt(n); j++)\n        {\n            if(n\
    \ % j == 0)\n            {\n                currentCount++;\n                currentFactor\
    \ *= j;\n            }\n        }\n        if(currentCount > factorCount)\n  \
    \      {\n            factors[factorCount] = currentFactor;\n            factorCount\
    \ = currentCount;\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long factor = 1;\n    long factorCount =\
    \ 0;\n    long currentFactor = 1;\n    long currentCount = 0;\n    long currentCount2\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        currentFactor\
    \ = factor;\n        currentCount = 1;\n        for(int j = i; j <= (int)Math.sqrt(n);\
    \ j++)\n        {\n            if(n % j == 0)\n            {\n               \
    \ currentCount++;\n                currentFactor *= j;\n            }\n      \
    \  }\n        if(currentCount > factorCount)\n        {\n            factors[factorCount]\
    \ = currentFactor;\n            factorCount = currentCount;\n        }\n    }\n\
    \    return factors;\n}\n/*\n Return array of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorizationSize, int\
    \ factorizationMax) \n{\n\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3o20z9gu.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3o20z9gu.d(23):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3o20z9gu.d(27):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3o20z9gu.d(63):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3o20z9gu.d(67):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3o20z9gu.d(98):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp3o20z9gu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++) {\n        while(p % i == 0) {\n            factors[factorCount] = i;\n\
    \            factorCount++;\n            p /= i;\n        }\n    }\n    factors[factorCount]\
    \ = p;\n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ucn8e0j.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_ucn8e0j.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_ucn8e0j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*i < n)\n        {\n          \
    \  if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                n /= factor*i;\n            }\n            else\n\
    \            {\n                break;\n            }\n        }\n        if(factorCount\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n        }\n\
    \        factor = factors[factorCount-1];\n    }\n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(factor*i < n)\n        {\n          \
    \  if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                n /= factor*i;\n            }\n            else\n\
    \            {\n                break;\n            }\n        }\n        if(factorCount\
    \ == 0)\n        {\n            factors[factorCount++] = factor;\n        }\n\
    \        factor = factors[factorCount-1];\n    }\n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i = start; i < factors.length;\
    \ i++)\n    {\n        factorCount = 0;\n        while(factor*i < n)\n       \
    \ {\n            if(n % factor*i == 0)\n            {\n                factors[factorCount++]\
    \ = factor*i;\n                \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb9fs_rqc.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpb9fs_rqc.d(107):
    Error: found `unittest` instead of statement\n/tmp/tmpb9fs_rqc.d(120): Error:
    found `End of File` when expecting `}` following compound statement\n/tmp/tmpb9fs_rqc.d(120):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpb9fs_rqc.d(120):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9fs_rqc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = 1;\n    long q = n;\n    long r = n;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfbpdwta8.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpfbpdwta8.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpfbpdwta8.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbpdwta8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 0;\n        while(n % factor == 0) {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor = factors[factorCount-1];\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c#,primes,math |>\n\
    <| c |>\nThis is not the fastest solution, since it requires division operations.\
    \ A better solution would be to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| c |>\n: I agree, it is better to generate all primes up to sqrt(n), then filter\
    \ out those that are not divisible by all numbers from 2 to sqrt(n).\n<|/ c |>\n\
    <| a tags=algorithm,c#,primes,math |>\n<code>\npublic static bool IsPrime(long\
    \ n)\n{\n    if (n < 2)\n        return false;\n    if (n == 2)\n        return\
    \ true;\n    if (n % 2 == 0)\n        return false;\n    long limit = (long)Math.Sqrt(n)\
    \ + 1;\n    long counter = 2;\n    while (counter <= limit)\n    {\n        if\
    \ (n % counter == 0)\n            return false;\n        counter++;\n    }\n \
    \   return true;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is not the fastest\
    \ solution, since it requires division operations. A better solution would be\
    \ to generate all primes up to sqrt(n), then filter out those that are not divisible\
    \ by all numbers from 2 to sqrt(n).\n<|/ c |>\n<| c |>\n: I agree, it is better\
    \ to generate all primes up to sqrt(n), then filter out those that are not divisible\
    \ by \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnkq3l7b0.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpnkq3l7b0.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpnkq3l7b0.d(30): Error:
    declaration expected, not `<`\n/tmp/tmpnkq3l7b0.d(53): Error: declaration expected,
    not `if`\n/tmp/tmpnkq3l7b0.d(55): Error: declaration expected, not `if`\n/tmp/tmpnkq3l7b0.d(57):
    Error: C style cast illegal, use `cast(long)Math.Sqrt(n)`\n/tmp/tmpnkq3l7b0.d(59):
    Error: declaration expected, not `while`\n/tmp/tmpnkq3l7b0.d(63): Error: no identifier
    for declarator `counter`\n/tmp/tmpnkq3l7b0.d(63): Error: declaration expected,
    not `++`\n/tmp/tmpnkq3l7b0.d(64): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnkq3l7b0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[counter] = i;\n            n\
    \ /= i;\n            counter++;\n        }\n    }\n    factors[counter] = n;\n\
    \    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,java |>\n<| c |>\n\
    This code does not work for large numbers. Try factorize(100000000000L).\n<|/\
    \ c |>\n<| c |>\nYes, it works only for small numbers. But it can be easily modified\
    \ to work with large numbers. Just use BigInteger instead of long.\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| c |>\nIt works with large numbers. Try factorize(100000000000L).\n<|/ c |>\n\
    <| a tags=algorithm,primes,java |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdba2evaj.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdba2evaj.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdba2evaj.d(30):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpdba2evaj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n) + 1L];\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    \n    for(long i = 2; i <= n; i++)\n  \
    \  {\n        while(n % i == 0)\n        {\n            factors[factorCount] =\
    \ i;\n            factor++;\n            factorCount++;\n            n /= i;\n\
    \        }\n    }\n    \n    if(n > 1)\n    {\n        factors[factorCount] =\
    \ n;\n        factor++;\n        factorCount++;\n    }\n    \n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code doesn't work. `factorize(8L)`\
    \ returns `[2, 2, 2]` instead of `[2, 2, 2, 2, 2]`.\n<|/ c |>\n<| c |>\nI tested\
    \ it on `8L` which returns `[2, 2, 2, 2, 2]` as expected. Are you sure you tested\
    \ it correctly?\n<|/ c |>\n<| c |>\nYes, I tested it on `8L` which returns `[2,\
    \ 2, 2, 2, 2]` as expected. Are you sure you tested it correctly?\n<|/ c |>\n\
    <| c |>\nI tested it on `8L` which returns `[2, 2, 2, 2, 2]` as expected. Are\
    \ you sure you tested it correctly?\n<|/ c |>\n<| c |>\nI tested it on `8L` which\
    \ returns `[2, 2, 2, 2, 2]` as expected. Are you sure you tested it correctly?\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp3c46pcn.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpp3c46pcn.d(41):
    Error: declaration expected, not `<`\n/tmp/tmpp3c46pcn.d(44): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3c46pcn.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  for(int i = 0; i < factors.length; i++)\n    {\n        while(p % 2 == 0)\n\
    \        {\n            p /= 2;\n            factors[i] = 2;\n        }\n    \
    \    while(p % 3 == 0)\n        {\n            p /= 3;\n            factors[i]\
    \ = 3;\n        }\n        while(p % 5 == 0)\n        {\n            p /= 5;\n\
    \            factors[i] = 5;\n        }\n        while(p % 7 == 0)\n        {\n\
    \            p /= 7;\n            factors[i] = 7;\n        }\n        while(p\
    \ % 11 == 0)\n        {\n            p /= 11;\n            factors[i] = 11;\n\
    \        }\n        while(p % 13 == 0)\n        {\n            p /= 13;\n    \
    \        factors[i] = 13;\n        }\n        while(p % 17 == 0)\n        {\n\
    \            p /= 17;\n            factors[i] = 17;\n        }\n        while(p\
    \ % 19 == 0)\n        {\n            p /= 19;\n            factors[i] = 19;\n\
    \        }\n        while(p % 23 == 0)\n        {\n            p /= 23;\n    \
    \        factors[i] = 23;\n        }\n        while(p % 29 == 0)\n        {\n\
    \            p /= 29;\n            factors[i] = 29;\n        }\n        while(p\
    \ % 31 == 0)\n        {\n            p /= 31;\n            factors[i] = 31;\n\
    \        }\n        while(p % 37 == 0)\n        {\n            p /= 37;\n    \
    \        factors[i] = 37;\n        }\n        while(p % 41 == 0)\n        {\n\
    \            p /= 41;\n            factors[i] = 41;\n        }\n        while(p\
    \ % 43 == 0)\n        {\n            p /= 43;\n            factors[i] = 43;\n\
    \        }\n        while(p % 47 == 0)\n        {\n            p /= 47;\n    \
    \        factors[i] = 47;\n        }\n        while(p % 53 == 0)\n        {\n\
    \            p /= 53;\n            factors[i] = 53;\n        }\n        while(p\
    \ % 59 == 0)\n        {\n            p /= 59;\n            factors[i] = 59;\n\
    \        }\n        while(p % 61 == 0)\n        {\n            p /= 61;\n    \
    \        factors[i] = 61;\n        }\n        while(p % 67 == 0)\n        {\n\
    \            p /= 67;\n            factors[i] = 67;\n        }\n        while(p\
    \ % 71 == 0)\n        {\n            p /= 71;\n            factors[i] = 71;\n\
    \        }\n        while(p % 73 == 0)\n        {\n            p /= 73;\n    \
    \        factors[i] = \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp21og71li.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp21og71li.d(125):
    Error: expression expected, not `unittest`\n/tmp/tmp21og71li.d(126): Error: found
    `{` when expecting `;` following statement\n/tmp/tmp21og71li.d(138): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmp21og71li.d(138):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21og71li.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factor_count = 1;\n    long factor_index = 0;\n    for(int i =\
    \ 1; i <= (int)Math.sqrt(n); i++) {\n        factors[factor_index] = i;\n    \
    \    factor_index++;\n        if(n % i == 0) {\n            factor_count++;\n\
    \            factor /= i;\n        }\n    }\n    factors[factor_index] = factor;\n\
    \    factor_index++;\n    factors[factor_index] = factor_count;\n    return factors;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprqpph_sg.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmprqpph_sg.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmprqpph_sg.d(34):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmprqpph_sg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = 1;\n    long r = n;\n    while(p != 1) {\n        while(p % q == 0) {\n\
    \            factors[(int)q] = p;\n            p /= q;\n        }\n        q *=\
    \ 2;\n    }\n    for(int i = factors.length-1; i >= 0; i--) {\n        while(n\
    \ % factors[i] == 0) {\n            n /= factors[i];\n            factors[i]++;\n\
    \        }\n    }\n    factors[(int)n] = 1;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp387k98l2.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp387k98l2.d(23):
    Error: C style cast illegal, use `cast(int)q`\n/tmp/tmp387k98l2.d(34): Error:
    C style cast illegal, use `cast(int)n`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp387k98l2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n        while(n\
    \ % i == 0) {\n            factors[count] = i;\n            n /= i;\n        \
    \    count++;\n        }\n    }\n    factors[count] = n;\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp26jhnw2i.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp26jhnw2i.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp26jhnw2i.d(30): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26jhnw2i.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu8fa1y57.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpu8fa1y57.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpu8fa1y57.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8fa1y57.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyqaupcre.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpyqaupcre.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpyqaupcre.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyqaupcre.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorsCount = 0;\n    long factorsCount2\
    \ = 0;\n    long factorsCount3 = 0;\n    long factorsCount4 = 0;\n    long factorsCount5\
    \ = 0;\n    long factorsCount6 = 0;\n    long factorsCount7 = 0;\n    long factorsCount8\
    \ = 0;\n    long factorsCount9 = 0;\n    long factorsCount10 = 0;\n    long factorsCount11\
    \ = 0;\n    long factorsCount12 = 0;\n    long factorsCount13 = 0;\n    long factorsCount14\
    \ = 0;\n    long factorsCount15 = 0;\n    long factorsCount16 = 0;\n    long factorsCount17\
    \ = 0;\n    long factorsCount18 = 0;\n    long factorsCount19 = 0;\n    long factorsCount20\
    \ = 0;\n    long factorsCount21 = 0;\n    long factorsCount22 = 0;\n    long factorsCount23\
    \ = 0;\n    long factorsCount24 = 0;\n    long factorsCount25 = 0;\n    long factorsCount26\
    \ = 0;\n    long factorsCount27 = 0;\n    long factorsCount28 = 0;\n    long factorsCount29\
    \ = 0;\n    long factorsCount30 = 0;\n    long factorsCount31 = 0;\n    long factorsCount32\
    \ = 0;\n    long factorsCount33 = 0;\n    long factorsCount34 = 0;\n    long factorsCount35\
    \ = 0;\n    long factorsCount36 = 0;\n    long factorsCount37 = 0;\n    long factorsCount38\
    \ = 0;\n    long factorsCount39 = 0;\n    long factorsCount40 = 0;\n    long factorsCount41\
    \ = 0;\n    long factorsCount42 = 0;\n    long factorsCount43 = 0;\n    long factorsCount44\
    \ = 0;\n    long factorsCount45 = 0;\n    long factorsCount46 = 0;\n    long factorsCount47\
    \ = 0;\n    long factorsCount48 = 0;\n    long factorsCount49 = 0;\n    long factorsCount50\
    \ = 0;\n    long factorsCount51 = 0;\n    long factorsCount52 = 0;\n    long factorsCount53\
    \ = 0;\n    long factorsCount54 = 0;\n    long factorsCount55 = 0;\n    long factorsCount56\
    \ = 0;\n    long factorsCount57 = 0;\n    long factorsCount58 = 0;\n    long factorsCount59\
    \ = 0;\n    long factorsCount60 = 0;\n    long factorsCount61 = 0;\n    long factor\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkghnu_3x.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpkghnu_3x.d(82):
    Error: semicolon expected, not `unittest`\n/tmp/tmpkghnu_3x.d(82): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkghnu_3x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxnfdhgge.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpxnfdhgge.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxnfdhgge.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3\
    \ = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4g7ahcb_.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp4g7ahcb_.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4g7ahcb_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount] =\
    \ factor;\n            factorCount++;\n            n /= factor;\n        }\n \
    \       factor++;\n    }\n    factors[factorCount] = n;\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpntzw77h5.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntzw77h5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        factorization *= i;\n        factors[(int)i-1] = factorization;\n\
    \    }\n    for(int i = 2; i <= (int)sqrt(n); i++) {\n        while(counter <=\
    \ factors[(int)i-1]) {\n            factors[(int)i-1] /= counter;\n          \
    \  factors[(int)i-1] *= factor;\n            counter += 1;\n        }\n      \
    \  counter -= 1;\n        factor *= i;\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,primes,java |>\n<| c |>\nThe first for loop can be replaced\
    \ with `for(int i = 0; i <= (int)sqrt(n); i++) { factors[(int)i-1] = factorization;\
    \ }`\n<|/ c |>\n<| c |>\nThe second for loop can be replaced with `for(int i =\
    \ 2; i <= (int)sqrt(n); i++) { factors[(int)i-1] /= counter; factors[(int)i-1]\
    \ *= factor; counter += 1;}`\n<|/ c |>\n<| c |>\nThe first for loop can be replaced\
    \ with `for(int i = 0; i <= (int)sqrt(n); i++) { factors[(int)i-1] = factorization;\
    \ }`\n<|/ c |>\n<| c |>\nThe second for loop can be replaced with `for(int i =\
    \ 2; i <= (int)sqrt(n); i++) { factors[(int)i-1] /= counter; factors[(int)i-1]\
    \ *= factor; counter += 1;}`\n<|/ c |>\n<| c |>\nThe first for loop can be replaced\
    \ with `for(int i = 0; i <= (int)sqrt(n); i++) { factors[(int)i-1] = factorization;\
    \ }`\n<|/ c |>\n<| a dscore=5 |>\nThe most efficient way is to use Sieve of Eratosthenes\
    \ algorithm. \nThe algorithm is very simple and easy to implement. \nThe algorithm\
    \ is very efficient and can be implemented in O(n log n) time.\nThe algorithm\
    \ is very simple and easy to implement.\nThe algorithm is very efficient and can\
    \ be implemented in O(n log n) time.\nThe algorithm is very simple and easy to\
    \ implement.\nThe algorithm is very efficient and can be implemented in O(n log\
    \ n) time.\nThe algorithm is very simple and easy to implement.\nThe algorithm\
    \ is very efficient and can be implemented in O(n log n) time.\nThe algorithm\
    \ is very simple and easy to implement.\nThe algorithm is very efficient and can\
    \ be implemented in O\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxken8nsf.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxken8nsf.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxken8nsf.d(23): Error:
    C style cast illegal, use `cast(int)i`\n/tmp/tmpxken8nsf.d(25): Error: C style
    cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxken8nsf.d(26): Error: C style cast
    illegal, use `cast(int)i`\n/tmp/tmpxken8nsf.d(27): Error: C style cast illegal,
    use `cast(int)i`\n/tmp/tmpxken8nsf.d(28): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpxken8nsf.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpxken8nsf.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmpxken8nsf.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmpxken8nsf.d(71): Error: declaration expected, not `assert`\n/tmp/tmpxken8nsf.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmpxken8nsf.d(73): Error: declaration
    expected, not `assert`\n/tmp/tmpxken8nsf.d(74): Error: declaration expected, not
    `assert`\n/tmp/tmpxken8nsf.d(75): Error: declaration expected, not `assert`\n/tmp/tmpxken8nsf.d(76):
    Error: declaration expected, not `assert`\n/tmp/tmpxken8nsf.d(77): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxken8nsf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    \n    while(factor\
    \ <= n)\n    {\n        factors[factor_index] = factor;\n        factor_index++;\n\
    \        factor *= factor;\n        factor_count++;\n    }\n    \n    factors[factor_index]\
    \ = n;\n    \n    for(int i = factor_index; i >= 0; i--)\n    {\n        if(factors[i]\
    \ == 1)\n        {\n            factor_count--;\n        }\n        else\n   \
    \     {\n            factor_count++;\n        }\n        \n        if(factor_count\
    \ > factors[i])\n        {\n            factors[i] = factor_count;\n        }\n\
    \    }\n    \n    return factors;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdvsy7chx.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpdvsy7chx.d(51):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpdvsy7chx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\
    \ {\n        if(n%i == 0) {\n            factors[factorCount] = i;\n         \
    \   factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    factorCount++;\n    return factors;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The question was about a specific language, C#, that doesn't have `long[]` as\
    \ an array type. Your answer doesn't really answer the question.\n<|/ c |>\n<|\
    \ c |>\nI didn't say that C# doesn't have long[] as array type. I said that C#\
    \ doesn't have generic arrays. C# has generic lists. And C# has generic dictionaries.\
    \ And C# has generic sets. And C# has generic functions. And C# has generic delegates.\
    \ And C# has generic interfaces. And C# has generic delegates. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# has generic interfaces. And\
    \ C# has generic interfaces. And C# has generic interfaces. And C# has generic\
    \ interfaces. And C# has generic interfaces. And C# \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqt38lfh9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqt38lfh9.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqt38lfh9.d(31):
    Error: declaration expected, not `<`\n/tmp/tmpqt38lfh9.d(34): Error: unterminated
    character constant\n/tmp/tmpqt38lfh9.d(34): Error: unterminated character constant\n/tmp/tmpqt38lfh9.d(37):
    Error: unterminated character constant\n/tmp/tmpqt38lfh9.d(37): Error: unterminated
    character constant\n/tmp/tmpqt38lfh9.d(37): Error: unterminated character constant\n/tmp/tmpqt38lfh9.d(42):
    Error: declaration expected, not `assert`\n/tmp/tmpqt38lfh9.d(43): Error: declaration
    expected, not `assert`\n/tmp/tmpqt38lfh9.d(44): Error: declaration expected, not
    `assert`\n/tmp/tmpqt38lfh9.d(45): Error: declaration expected, not `assert`\n/tmp/tmpqt38lfh9.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmpqt38lfh9.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpqt38lfh9.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpqt38lfh9.d(49): Error: declaration expected, not `assert`\n/tmp/tmpqt38lfh9.d(50):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqt38lfh9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\
    \ {\n        factorCount = 0;\n        while(factor <= n && n % factor == 0) {\n\
    \            factors[factorCount++] = factor;\n            n /= factor;\n    \
    \    }\n        if(n != 1) {\n            factors[factorCount++] = n;\n      \
    \  }\n        factor = factors[factorCount-1];\n    }\n    return factors;\n}\n\
    </code>\n<|/ a tags=java,algorithm,primes |>\n<| c |>\nThis is not an answer,\
    \ but a comment to the question. Maybe you can add some explanation why this works?\n\
    <|/ c |>\n<| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is very inefficient for large numbers. A better algorithm is described here:\
    \ https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-c\n\
    <|/ c |>\n<| c |>\nThe algorithm is inefficient, but it is also very simple. There\
    \ are many ways to improve the efficiency of the algorithm. One of them is to\
    \ use Sieve of Eratosthenes algorithm. Another one is to use sieve of Atkin.\n\
    <|/ c |>\n<| c |>\nThe algorithm is inefficient, but it is also very simple. There\
    \ are many ways to improve the efficiency of the algorithm. One of them is to\
    \ use Sieve of Eratosthenes algorithm. Another one is to use sieve of Atkin.\n\
    <|/ c |>\n<| a dscore=5 |>\nThe simplest way to find prime numbers is to generate\
    \ them all and check whether they are divisible by any number other than 1 and\
    \ themselves.\n<code>\npublic static void main(String[] args) {\n    long n =\
    \ 1000;\n    boolean isPrime = true;\n    for(int i = 0; i <= n; i++) {\n    \
    \    if(isPrime) {\n            for(int j = 2; j < i; j++) {\n               \
    \ if(i % j == 0) {\n                    isPrime = false;\n                   \
    \ break;\n                }\n            }\n        }\n    }\n    System.out.println(isPrime);\n\
    }\n</code>\n<|/ a tags=java,algorithm,primes |>\n<| c |>\nThis algorithm is very\
    \ inefficient for large numbers. A better algorithm is described here: https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-c\n\
    <|/ c |>\n<| c |>\nThe algorithm is inefficient, but it is also \nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpujawpvp3.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpujawpvp3.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpujawpvp3.d(33):
    Error: declaration expected, not `<`\n/tmp/tmpujawpvp3.d(56): Error: declaration
    expected, not `for`\n/tmp/tmpujawpvp3.d(56): Error: no identifier for declarator
    `i`\n/tmp/tmpujawpvp3.d(56): Error: declaration expected, not `<=`\n/tmp/tmpujawpvp3.d(56):
    Error: no identifier for declarator `i`\n/tmp/tmpujawpvp3.d(56): Error: declaration
    expected, not `++`\n/tmp/tmpujawpvp3.d(58): Error: no identifier for declarator
    `j`\n/tmp/tmpujawpvp3.d(58): Error: declaration expected, not `<`\n/tmp/tmpujawpvp3.d(58):
    Error: no identifier for declarator `j`\n/tmp/tmpujawpvp3.d(58): Error: declaration
    expected, not `++`\n/tmp/tmpujawpvp3.d(61): Error: declaration expected, not `break`\n/tmp/tmpujawpvp3.d(62):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpujawpvp3.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long factorization2 =\
    \ 1;\n    long factorization3 = 1;\n    long factorization4 = 1;\n    long factorization5\
    \ = 1;\n    long factorization6 = 1;\n    long factorization7 = 1;\n    long factorization8\
    \ = 1;\n    long factorization9 = 1;\n    long factorization10 = 1;\n    long\
    \ factorization11 = 1;\n    long factorization12 = 1;\n    long factorization13\
    \ = 1;\n    long factorization14 = 1;\n    long factorization15 = 1;\n    long\
    \ factorization16 = 1;\n    long factorization17 = 1;\n    long factorization18\
    \ = 1;\n    long factorization19 = 1;\n    long factorization20 = 1;\n    long\
    \ factorization21 = 1;\n    long factorization22 = 1;\n    long factorization23\
    \ = 1;\n    long factorization24 = 1;\n    long factorization25 = 1;\n    long\
    \ factorization26 = 1;\n    long factorization27 = 1;\n    long factorization28\
    \ = 1;\n    long factorization29 = 1;\n    long factorization30 = 1;\n    long\
    \ factorization31 = 1;\n    long factorization32 = 1;\n    long factorization33\
    \ = 1;\n    long factorization34 = 1;\n    long factorization35 = 1;\n    long\
    \ factorization36 = 1;\n    long factorization37 = 1;\n    long factorization38\
    \ = 1;\n    long factorization39 = 1;\n    long factorization40 = 1;\n    long\
    \ factorization41 = 1;\n    long factorization42 = 1;\n    long factorization43\
    \ = 1;\n    long factorization44 = 1;\n    long factorization45 = 1;\n    long\
    \ factorization46 = 1;\n    long factorization47 = 1;\n    long factorization48\
    \ = 1;\n    long factorization49 = 1;\n    long factorization50 = 1;\n    long\
    \ factorization51 = 1;\n    long factorization52 = 1;\n    long factorization53\
    \ = 1;\n    long factorization54 = 1;\n    long factorization55 = 1;\n    long\
    \ factorization56 = 1;\n    long factorization57 = 1;\n    long factorization58\
    \ = 1;\n    long factorization59 = 1;\n    long factorization60 = 1;\n    long\
    \ factorization61 = 1;\n    long factorization62 = 1;\n    long factorization63\
    \ = 1;\n    long factorization64 = 1;\n    long factorization65 = 1;\n    long\
    \ factorization66 = 1;\n    long factorization67 = 1;\n    long factorization68\
    \ = 1;\n    long factorization69 = 1;\n    \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxiei8q7y.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxiei8q7y.d(90):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxiei8q7y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx6fckmi5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpx6fckmi5.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpx6fckmi5.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6fckmi5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjn14s7h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpyjn14s7h.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyjn14s7h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factors[factorCount] = i;\n        factorCount++;\n        while(n % i ==\
    \ 0) {\n            n /= i;\n            factors[factorCount] = i;\n         \
    \   factorCount++;\n        }\n    }\n    factors[factorCount] = n;\n    factorCount++;\n\
    \    for(int i = factorCount; i >= 0; i--) {\n        factor *= factors[i];\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c++,primes |>\n\
    <| c |>\nI believe this algorithm is wrong. For example, factorize(25) returns\
    \ [5, 5]. Factorizing 25 is (25/5)*5 + 5\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ My algorithm is wrong. I've fixed it.\n<|/ c |>\n<| c |>\nThe algorithm is still\
    \ wrong. factorize(25) returns [5, 5]. Factorizing 25 is (25/5)*5 + 5\n<|/ c |>\n\
    <| c |>\nYes, you are right. My algorithm is wrong. I've fixed it.\n<|/ c |>\n\
    <| c |>\nThe algorithm is still wrong. factorize(25) returns [5, 5]. Factorizing\
    \ 25 is (25/5)*5 + 5\n<|/ c |>\n<| a tags=algorithm,c++,primes |>\n<code>\n#include\
    \ <iostream>\n#include <math.h>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptyjfeeft.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmptyjfeeft.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmptyjfeeft.d(36): Error:
    declaration expected, not `<`\n/tmp/tmptyjfeeft.d(42): Error: unterminated character
    constant\n/tmp/tmptyjfeeft.d(48): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyjfeeft.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt6j_alqa.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpt6j_alqa.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpt6j_alqa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i ==\
    \ 0)\n        {\n            factor *= i;\n            factors[i-1] = factor;\n\
    \        }\n    }\n    return factors;\n}\n</code>\n<|/ a tags=java,algorithm,primes\
    \ |>\n<| a tags=java,algorithm,primes |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy3ant_3n.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpy3ant_3n.d(19):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpy3ant_3n.d(29):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpy3ant_3n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    for(int i = 0; i < factors.length; i++)\n  \
    \  {\n        factors[i] = factorization;\n        factorization *= factor;\n\
    \        factor /= 2;\n    }\n    factors[factors.length - 1] = n;\n    for(int\
    \ i = factors.length - 2; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n \
    \       {\n            factors[i] = factors[i - 1];\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorization) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n   \
    \ for(int i = 0; i < factors.length; i++)\n    {\n        factors[i] = factorization;\n\
    \        factor *= factor;\n        factor /= 2;\n    }\n    factors[factors.length\
    \ - 1] = n;\n    for(int i = factors.length - 2; i >= 0; i--)\n    {\n       \
    \ if(factors[i] == 1)\n        {\n            factors[i] = factors[i - 1];\n \
    \       }\n    }\n    return factors;\n}\n/*\n Return array of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int factorization, int factor) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n\
    \    for(int i = 0; i < factors.length; i++)\n    {\n        factors[i] = factorization;\n\
    \        factor *= factor;\n        factor /= 2;\n    }\n    factors[factors.length\
    \ - 1] = n;\n    for(int i = factors.length - 2; i >= 0; i--)\n    {\n       \
    \ if(factors[i] == 1)\n        {\n            factors[i] = factors[i - 1];\n \
    \       }\n    }\n    return \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpek2okza9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpek2okza9.d(50):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpek2okza9.d(82):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpek2okza9.d(98):
    Error: expression expected, not `unittest`\n/tmp/tmpek2okza9.d(99): Error: found
    `{` when expecting `;` following `return` statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpek2okza9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long factorizationCount\
    \ = 0;\n    long factorizationSum = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        factors[i] = factor;\n        factorizationSum += factor;\n\
    \        factorizationCount += 1;\n        while(factorizationCount > 1) {\n \
    \           factorizationCount -= 1;\n            factorizationSum += factor;\n\
    \            factorizationCount += 1;\n        }\n        factor += 2;\n    }\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        factors[i] = factor;\n\
    \        factorizationSum += factor;\n        factorizationCount += 1;\n     \
    \   while(factorizationCount > 1) {\n            factorizationCount -= 1;\n  \
    \          factorizationSum += factor;\n            factorizationCount += 1;\n\
    \        }\n        factor += 2;\n    }\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        factors[i] = factor;\n        factorizationSum += factor;\n\
    \        factorizationCount += 1;\n        while(factorizationCount > 1) {\n \
    \           factorizationCount -= 1;\n            factorizationSum += factor;\n\
    \            factorizationCount += 1;\n        }\n        factor += 2;\n    }\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        factors[i] = factor;\n\
    \        factorizationSum += factor;\n        factorizationCount += 1;\n     \
    \   while(factorizationCount > 1) {\n            factorizationCount -= 1;\n  \
    \          factorizationSum += factor;\n            factorizationCount += 1;\n\
    \        }\n        factor += 2;\n    }\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        factors[i] = factor;\n        factorizationSum += factor;\n\
    \        factorizationCount += 1;\n        while(factorizationCount > 1) {\n \
    \           factorizationCount -= 1;\n            factorizationSum += factor;\n\
    \            factorizationCount += 1;\n        }\n        factor += 2;\n    }\n\
    \    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        factors[i] = factor;\n\
    \        factorizationSum += factor;\n        factorizationCount += 1;\n     \
    \   while(factorizationCount > 1) {\n            factorizationCount -= 1;\n  \
    \          factorizationSum += factor;\n            factorizationCount += 1;\n\
    \        }\n        factor += 2;\n    }\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        factors[i] = factor;\n        factorizationSum \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe136bnlt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(23):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(34):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(45):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(56):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(67):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(78):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(89):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe136bnlt.d(92):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpe136bnlt.d(105):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpe136bnlt.d(105):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe136bnlt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long i = 2;\n    while(i <= n)\n    {\n        while(n % i == 0)\n      \
    \  {\n            factors[(int)(i-1)/factor] = factor;\n            n /= i;\n\
    \            factor++;\n        }\n        i++;\n    }\n    return factors;\n\
    }\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) ==\
    \ [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) ==\
    \ [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7zuoiqn5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp7zuoiqn5.d(24):
    Error: C style cast illegal, use `cast(int)(i - 1)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7zuoiqn5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long p = n;\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n);\
    \ i++)\n    {\n        while(p % factor == 0)\n        {\n            factors[factorCount]\
    \ = factor;\n            factorCount++;\n            p /= factor;\n        }\n\
    \        factor++;\n    }\n    return factors;\n}\n</code>\n<|/ a tags=c++,primes,algorithm\
    \ |>\n<| c |>\nThis code doesn't work for large numbers. Try factorize(10000000000L).\n\
    <|/ c |>\n<| c |>\nI tested it on 10000000000L and it returned [2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_p0jhdle.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp_p0jhdle.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp_p0jhdle.d(33): Error:
    declaration expected, not `<`\n/tmp/tmp_p0jhdle.d(36): Error: unterminated character
    constant\n/tmp/tmp_p0jhdle.d(44): Error: declaration expected, not `assert`\n/tmp/tmp_p0jhdle.d(45):
    Error: declaration expected, not `assert`\n/tmp/tmp_p0jhdle.d(46): Error: declaration
    expected, not `assert`\n/tmp/tmp_p0jhdle.d(47): Error: declaration expected, not
    `assert`\n/tmp/tmp_p0jhdle.d(48): Error: declaration expected, not `assert`\n/tmp/tmp_p0jhdle.d(49):
    Error: declaration expected, not `assert`\n/tmp/tmp_p0jhdle.d(50): Error: declaration
    expected, not `assert`\n/tmp/tmp_p0jhdle.d(51): Error: declaration expected, not
    `assert`\n/tmp/tmp_p0jhdle.d(52): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_p0jhdle.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n\
    \    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long\
    \ z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n\
    \    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long\
    \ i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n\
    \    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long\
    \ r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n\
    \    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long\
    \ j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n\
    \    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long\
    \ s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n\
    \    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long\
    \ b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n\
    \    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long\
    \ k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqryolzav.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpqryolzav.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqryolzav.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqryolzav.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long maxFactor = n;\n    long factorCount = 0;\n    for(long i = 2; i <=\
    \ maxFactor; i++)\n    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            n /= i;\n            factorCount++;\n        }\n    }\n  \
    \  factors[factorCount] = n;\n    return factors;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport\
    \ java.io.*;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9fnu79fo.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp9fnu79fo.d(33):
    Error: declaration expected, not `<`\n/tmp/tmp9fnu79fo.d(38): Error: identifier
    expected following `package`\n/tmp/tmp9fnu79fo.d(38): Error: `;` expected\n/tmp/tmp9fnu79fo.d(39):
    Error: identifier expected following `package`\n/tmp/tmp9fnu79fo.d(39): Error:
    `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9fnu79fo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long i = 1;\n    \n    while(factor <= n && i <= factors.length)\n    {\n\
    \        if(n % factor == 0)\n        {\n            factors[(int)i] = factor;\n\
    \            n /= factor;\n            i++;\n        }\n        else\n       \
    \ {\n            factor = 1;\n        }\n    }\n    \n    if(n > 1)\n    {\n \
    \       factors[(int)i] = n;\n    }\n    \n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_9ekjctq.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_9ekjctq.d(25):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp_9ekjctq.d(37): Error:
    C style cast illegal, use `cast(int)i`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp_9ekjctq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n    }\n  \
    \  factors[factorCount] = n;\n    factorCount++;\n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,primes,factorization,math |>\n<| a tags=algorithm,primes,factorization,math\
    \ |>\nI wrote a program to find prime factors of a number in Java. Hope it helps.\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphh98bzfx.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphh98bzfx.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphh98bzfx.d(33):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphh98bzfx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,java\
    \ |>\n<| c |>\nThis code doesn't work for large numbers. Try factorize(10000000000L).\n\
    <|/ c |>\n<| c |>\nI tested it on large numbers and it works fine. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI tested it on large numbers and it works fine. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI tested it on large numbers and it works fine. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI tested it on large numbers and it works fine. Try it yourself.\n\
    <|/ c |>\n<| a dscore=5 |>\nI wrote a Java program to find prime numbers in less\
    \ than 1 second. \n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzfmw2_a6.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzfmw2_a6.d(32):
    Error: declaration expected, not `<`\n/tmp/tmpzfmw2_a6.d(35): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzfmw2_a6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3\
    \ = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp64p2rhpx.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp64p2rhpx.d(90):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp64p2rhpx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentCount = 1;\n    long currentCount2\
    \ = 0;\n    long currentCount3 = 0;\n    long currentCount4 = 0;\n    long currentCount5\
    \ = 0;\n    long currentCount6 = 0;\n    long currentCount7 = 0;\n    long currentCount8\
    \ = 0;\n    long currentCount9 = 0;\n    long currentCount10 = 0;\n    long currentCount11\
    \ = 0;\n    long currentCount12 = 0;\n    long currentCount13 = 0;\n    long currentCount14\
    \ = 0;\n    long currentCount15 = 0;\n    long currentCount16 = 0;\n    long currentCount17\
    \ = 0;\n    long currentCount18 = 0;\n    long currentCount19 = 0;\n    long currentCount20\
    \ = 0;\n    long currentCount21 = 0;\n    long currentCount22 = 0;\n    long currentCount23\
    \ = 0;\n    long currentCount24 = 0;\n    long currentCount25 = 0;\n    long currentCount26\
    \ = 0;\n    long currentCount27 = 0;\n    long currentCount28 = 0;\n    long currentCount29\
    \ = 0;\n    long currentCount30 = 0;\n    long currentCount31 = 0;\n    long currentCount32\
    \ = 0;\n    long currentCount33 = 0;\n    long currentCount34 = 0;\n    long currentCount35\
    \ = 0;\n    long currentCount36 = 0;\n    long currentCount37 = 0;\n    long currentCount38\
    \ = 0;\n    long currentCount39 = 0;\n    long currentCount40 = 0;\n    long currentCount41\
    \ = 0;\n    long currentCount42 = 0;\n    long currentCount43 = 0;\n    long currentCount44\
    \ = 0;\n    long currentCount45 = 0;\n    long currentCount46 = 0;\n    long currentCount47\
    \ = 0;\n    long currentCount48 = 0;\n    long currentCount49 = 0;\n    long currentCount50\
    \ = 0;\n    long currentCount51 = 0;\n    long currentCount52 = 0;\n    long currentCount53\
    \ = 0;\n    long currentCount54 = 0;\n    long currentCount55 = 0;\n    long currentCount56\
    \ = 0;\n    long currentCount57 = 0;\n    long currentCount58 = 0;\n    long currentCount59\
    \ = 0;\n    long currentCount60 = 0;\n    long currentCount61 = 0;\n    long currentCount62\
    \ = 0;\n    long currentCount63 = 0;\n    long currentCount64 = 0;\n    long currentCount65\
    \ = 0;\n    long currentCount66 = 0;\n    long currentCount67 = 0;\n    long currentCount68\
    \ = 0;\n    long currentCount69 = 0;\n    long currentCount70 = 0;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi80go1re.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpi80go1re.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpi80go1re.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\n    long factorCount = 1;\n    long factorIndex\
    \ = 0;\n    long factorCount = 1;\n    long factorIndex = 0;\n    long factorCount\
    \ = 1;\n    long factorIndex = 0;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpavgylznz.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpavgylznz.d(101):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpavgylznz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n \
    \       if(n%i == 0)\n        {\n            factors[factorCount] = i;\n     \
    \       factor++;\n            factorCount++;\n            if(factorCount >= maxFactors)\n\
    \                break;\n        }\n    }\n    factors[factorCount] = n;\n   \
    \ return factors;\n}\n/*\n Return array of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factor++;\n            factorCount++;\n            if(factorCount\
    \ >= maxFactors)\n                break;\n            if(factorCount >= maxFactorsCount)\n\
    \                break;\n        }\n    }\n    factors[factorCount] = n;\n   \
    \ return factors;\n}\n/*\n Return array of prime factors of given integer in the\
    \ order from \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2438q96z.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(46):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(49):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(77):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(80):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2438q96z.d(96):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2438q96z.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u\
    \ = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n \
    \   long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d\
    \ = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n \
    \   long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m\
    \ = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n \
    \   long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v\
    \ = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n \
    \   long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e\
    \ = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n \
    \   long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n\
    \ = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n \
    \   long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w\
    \ = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n \
    \   long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f\
    \ = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n \
    \   long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o\
    \ = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n \
    \   long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x\
    \ = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n \
    \   long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g\
    \ = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpotxkyc18.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpotxkyc18.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpotxkyc18.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpotxkyc18.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n    }\n  \
    \  factors[factorCount] = n;\n    return factors;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=algorithm,math,primes,java |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdf18r_xt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdf18r_xt.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdf18r_xt.d(32):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpdf18r_xt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    \n    while(p != q) {\n        while(p != q && q != r) {\n            while(p\
    \ != q && q != r && r != s) {\n                while(p != q && q != r && r !=\
    \ s && s != t) {\n                    while(p != q && q != r && r != s && s !=\
    \ t && t != u) {\n                        while(p != q && q != r && r != s &&\
    \ s != t && t != u && u != v) {\n                            while(p != q && q\
    \ != r && r != s && s != t && t != u && u != v && v != w) {\n                \
    \                while(p != q && q != r && r != s && s != t && t != u && u !=\
    \ v && v != w && w != x) {\n                                    while(p != q &&\
    \ q != r && r != s && s != t && t != u && u != v && v != w && w != x && x != y)\
    \ {\n                                        while(p != q && q != r && r != s\
    \ && s != t && t != u && u != v && v != w && w != x && x != y && y != z) {\n \
    \                                           while(p != q && q != r && r != s &&\
    \ s != t && t != u && u != v && v != w && w != x && x != y && y != z && z != a)\
    \ {\n                                                while(p != q && q != r &&\
    \ r != s && s != t && t != u && u != v && v != w && w != x && x != y && y != z\
    \ && z != a && a != b) {\n                                                   \
    \ while(p != q && q != r && r != s && s != t && t != u && u != v && v != w &&\
    \ w != x && x != y && y != z && z != a && a != b && b != c) {\n              \
    \                                          while(p != q && q != r && r != s &&\
    \ s != t && t != u && u != v && v != w && w != x && x != y && y != z && z != a\
    \ && a != b && b != c && c != d) {\n                                         \
    \                   while(p != q && q != r && r != s && s != t && t != u && u\
    \ != v && v != w && w != x && x != y \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa5qe0y9j.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpa5qe0y9j.d(40):
    Error: found `unittest` when expecting `)`\n/tmp/tmpa5qe0y9j.d(53): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa5qe0y9j.d(53):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa5qe0y9j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp43j_a15m.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp43j_a15m.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp43j_a15m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjn14s7h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpyjn14s7h.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyjn14s7h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    for(int i = 0; i <= (int)Math.Sqrt(n);\
    \ i++){\n        temp = factor;\n        while(temp <= n){\n            if(n %\
    \ temp == 0){\n                factors[counter] = temp;\n                n /=\
    \ temp;\n                counter++;\n            }\n            temp++;\n    \
    \    }\n        factor++;\n    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,java\
    \ |>\n<| c |>\nThe question was about finding prime factors, not prime numbers.\n\
    <|/ c |>\n<| c |>\nYes, but this algorithm is very fast and easy to understand.\n\
    <|/ c |>\n<| c |>\nThis algorithm is very fast and easy to understand.\n<|/ c\
    \ |>\n<| c |>\nI believe this algorithm is very fast and easy to understand.\n\
    <|/ c |>\n<| c |>\nThis algorithm is very fast and easy to understand.\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnf3t2bch.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpnf3t2bch.d(21):
    Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpnf3t2bch.d(35):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnf3t2bch.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    factors[0] = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n    \
    \    long q = n/i;\n        if(q > 1) {\n            factors[i] = factors[i-1]\
    \ * q;\n            p /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = p;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int max) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n    factors[0] =\
    \ 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        long q = n/i;\n\
    \        if(q > 1) {\n            factors[i] = factors[i-1] * q;\n           \
    \ p /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)] = p;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int max, int factorization) \n{\n    long[]\
    \ factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n    factors[0] =\
    \ 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        long q = n/i;\n\
    \        if(q > 1) {\n            factors[i] = factors[i-1] * q;\n           \
    \ p /= i;\n        }\n    }\n    factors[(int)Math.sqrt(n)] = p;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factor\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphtp_950y.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(27):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(44):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(47):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(54):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(71):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(74):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(81):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtp_950y.d(84):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphtp_950y.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(n % factor == 0)\n        {\n       \
    \     factors[factorCount++] = factor;\n            n /= factor;\n        }\n\
    \        factor = factors[factorCount-1];\n    }\n    factors[factorCount] = n;\n\
    \    return factors;\n}\n/*\n Return array of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n     \
    \   factorCount = 0;\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor = factors[factorCount-1];\n\
    \        if(factorCount >= maxFactors)\n            break;\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(n % factor == 0)\n        {\n       \
    \     factors[factorCount++] = factor;\n            n /= factor;\n        }\n\
    \        factor = factors[factorCount-1];\n        if(factorCount >= maxFactors)\n\
    \            break;\n        if(factorCount >= maxFactorsCount)\n            break;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi4klvq7j.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpi4klvq7j.d(47):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpi4klvq7j.d(79): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpi4klvq7j.d(95): Error: found
    `unittest` instead of statement\n/tmp/tmpi4klvq7j.d(108): Error: found `End of
    File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpi4klvq7j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpigv94ood.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpigv94ood.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpigv94ood.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigv94ood.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n    for(int i = 1;\
    \ i <= (int)Math.sqrt(n); i++) {\n        factors[factorIndex] = i;\n        factorCount++;\n\
    \        factorIndex++;\n        if(n % i == 0) {\n            factors[factorIndex]\
    \ = i;\n            factorCount++;\n            factorIndex++;\n        }\n  \
    \  }\n    factors[factorIndex] = n;\n    factorCount++;\n    factorIndex++;\n\
    \    for(int i = factorIndex; i < factors.length; i++) {\n        factors[i] *=\
    \ factors[factorIndex];\n        factorCount++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6h0848o4.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp6h0848o4.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp6h0848o4.d(40):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp6h0848o4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long count = 0;\n    long i = 1;\n    long j = 0;\n    while(i < n)\n   \
    \ {\n        while(n % i == 0)\n        {\n            factors[count] = i;\n \
    \           n = n / i;\n            count++;\n        }\n        i++;\n    }\n\
    \    factors[count] = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,java\
    \ |>\n<| c |>\nThis doesn't work for large numbers. Try factorize(1000000000000L).\n\
    <|/ c |>\n<| c |>\nI tested it on 1000000000000L and it returned [2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplrsyzz63.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplrsyzz63.d(35):
    Error: declaration expected, not `<`\n/tmp/tmplrsyzz63.d(38): Error: unterminated
    character constant\n/tmp/tmplrsyzz63.d(46): Error: declaration expected, not `assert`\n/tmp/tmplrsyzz63.d(47):
    Error: declaration expected, not `assert`\n/tmp/tmplrsyzz63.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmplrsyzz63.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmplrsyzz63.d(50): Error: declaration expected, not `assert`\n/tmp/tmplrsyzz63.d(51):
    Error: declaration expected, not `assert`\n/tmp/tmplrsyzz63.d(52): Error: declaration
    expected, not `assert`\n/tmp/tmplrsyzz63.d(53): Error: declaration expected, not
    `assert`\n/tmp/tmplrsyzz63.d(54): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmplrsyzz63.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    \n    while(p <= q) {\n        while(p <= q && q > 0) {\n\
    \            while(p <= q && q > 0) {\n                while(p <= q && q > 0)\
    \ {\n                    while(p <= q && q > 0) {\n                        while(p\
    \ <= q && q > 0) {\n                            while(p <= q && q > 0) {\n   \
    \                             while(p <= q && q > 0) {\n                     \
    \               while(p <= q && q > 0) {\n                                   \
    \     while(p <= q && q > 0) {\n                                            while(p\
    \ <= q && q > 0) {\n                                                while(p <=\
    \ q && q > 0) {\n                                                    while(p <=\
    \ q && q > 0) {\n                                                        while(p\
    \ <= q && q > 0) {\n                                                         \
    \   while(p <= q && q > 0) {\n                                               \
    \                 while(p <= q && q > 0) {\n                                 \
    \                                   while(p <= q && q > 0) {\n               \
    \                                                         while(p <= q && q >\
    \ 0) {\n                                                                     \
    \       while(p <= q && q > 0) {\n                                           \
    \                                     while(p <= q && q > 0) {\n             \
    \                                                                       while(p\
    \ <= q && q > 0) {\n                                                         \
    \                               while(p <= q && q > 0) {\n                   \
    \                                                                         while(p\
    \ <= q && q > 0) {\n                                                         \
    \                                       while(p <= q && q > 0) {\n           \
    \                                                                            \
    \             while(p <= q && q > 0) {\n                                     \
    \                                                                   while(p <=\
    \ q && q > 0) {\n                                                            \
    \                                                while(p <= q && q > 0) {\n  \
    \                                                                            \
    \                                  while(p <= q && q > 0) {\n                \
    \                                                                            \
    \                        while(p <= q && q > 0) {\n                          \
    \                                                                            \
    \                  while(p <= q && q > 0) {\n                                \
    \                                                                            \
    \                while(p <= q && q > 0) {\n                                  \
    \                                                                            \
    \                  while(p <= q && q > 0) {\n                                \
    \                                                                            \
    \                        while(p <= q && q > 0) {\n                          \
    \                                                                            \
    \                                  while(p <= q && q > 0) {\n                \
    \                                                                            \
    \                                                while(p <= q && q > 0) {\n  \
    \                                                                            \
    \                                                                  while(p <=\
    \ q && q > 0) {\n                                                            \
    \                                                                            \
    \            while(p <= q && q > 0) {\n                                      \
    \                                                                            \
    \                                      while(p <= q && q > 0) {\n            \
    \                                                                            \
    \                                                                    while(p <=\
    \ q && q > 0) {\n                                                            \
    \                                                                            \
    \                        while(p <= q && q > 0) {\n                          \
    \                                                                            \
    \                                                              while(p <= q &&\
    \ q > 0) {\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfbae9f93.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfbae9f93.d(71):
    Error: found `unittest` instead of statement\n/tmp/tmpfbae9f93.d(84): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfbae9f93.d(84):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbae9f93.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp74i5m5_q.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp74i5m5_q.d(89):
    Error: semicolon expected, not `unittest`\n/tmp/tmp74i5m5_q.d(89): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp74i5m5_q.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u\
    \ = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n \
    \   long z = 0;\n    \n    while(p > 1) {\n        while(p % 2 == 0) {\n     \
    \       p = p / 2;\n            factors[(int)Math.ceil(p)]++;\n        }\n   \
    \     while(p % 3 == 0) {\n            p = p / 3;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 5 == 0) {\n            p = p / 5;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 7 == 0) {\n            p = p / 7;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 11 == 0) {\n            p = p / 11;\n          \
    \  factors[(int)Math.ceil(p)]++;\n        }\n        while(p % 13 == 0) {\n  \
    \          p = p / 13;\n            factors[(int)Math.ceil(p)]++;\n        }\n\
    \        while(p % 17 == 0) {\n            p = p / 17;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 19 == 0) {\n            p = p / 19;\n          \
    \  factors[(int)Math.ceil(p)]++;\n        }\n        while(p % 23 == 0) {\n  \
    \          p = p / 23;\n            factors[(int)Math.ceil(p)]++;\n        }\n\
    \        while(p % 29 == 0) {\n            p = p / 29;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 31 == 0) {\n            p = p / 31;\n          \
    \  factors[(int)Math.ceil(p)]++;\n        }\n        while(p % 37 == 0) {\n  \
    \          p = p / 37;\n            factors[(int)Math.ceil(p)]++;\n        }\n\
    \        while(p % 41 == 0) {\n            p = p / 41;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 43 == 0) {\n            p = p / 43;\n          \
    \  factors[(int)Math.ceil(p)]++;\n        }\n        while(p % 47 == 0) {\n  \
    \          p = p / 47;\n            factors[(int)Math.ceil(p)]++;\n        }\n\
    \        while(p % 53 == 0) {\n            p = p / 53;\n            factors[(int)Math.ceil(p)]++;\n\
    \        }\n        while(p % 59 == 0) {\n            p = p / 59;\n          \
    \  factors[(int)Math.ceil(p)]++;\n        }\n        while(p % 61 == 0) {\n  \
    \          p = p / 61;\n            factors[\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqyhqmbif.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqyhqmbif.d(33):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(37):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(41):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(45):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(49):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(53):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(57):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(61):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(65):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(69):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(73):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(77):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(81):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(85):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(89):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(93):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(97):
    Error: C style cast illegal, use `cast(int)Math.ceil(p)`\n/tmp/tmpqyhqmbif.d(102):
    Error: expression expected, not `unittest`\n/tmp/tmpqyhqmbif.d(103): Error: found
    `{` when expecting `,`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqyhqmbif.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjn14s7h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpyjn14s7h.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyjn14s7h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for large numbers. `factorize(1000000007)` returns `[2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate = factorize;\n\n\
    \    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmrdqd2ip.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmrdqd2ip.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmrdqd2ip.d(32):
    Error: declaration expected, not `<`\n/tmp/tmpmrdqd2ip.d(35): Error: unterminated
    character constant\n/tmp/tmpmrdqd2ip.d(35): Error: unterminated string constant
    starting at /tmp/tmpmrdqd2ip.d(35)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmrdqd2ip.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    \n    for(int i = 1; i < factors.Length; i++)\n\
    \    {\n        factorCount = 0;\n        while(n % factor == 0)\n        {\n\
    \            factors[factorCount] = factor;\n            factorCount++;\n    \
    \        n /= factor;\n        }\n        factor = factors[factorCount];\n   \
    \ }\n    \n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c#,primes |>\n\
    <| c |>\nThis code does not work for large numbers. I tested it for 1000000000\
    \ and it returned the wrong result. Also it takes too long to compute.\n<|/ c\
    \ |>\n<| c |>\nThis code does not work for large numbers. I tested it for 1000000000\
    \ and it returned the wrong result. Also it takes too long to compute.\n<|/ c\
    \ |>\n<| c |>\nThe code does not work for large numbers. I tested it for 1000000000\
    \ and it returned the wrong result. Also it takes too long to compute.\n<|/ c\
    \ |>\n<| c |>\nThe code does not work for large numbers. I tested it for 1000000000\
    \ and it returned the wrong result. Also it takes too long to compute.\n<|/ c\
    \ |>\n<| c |>\nThe code does not work for large numbers. I tested it for 1000000000\
    \ and it returned the wrong result. Also it takes too long to compute.\n<|/ c\
    \ |>\n<| a dscore=4 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_wityag1.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmp_wityag1.d(35):
    Error: declaration expected, not `<`\n/tmp/tmp_wityag1.d(55): Error: semicolon
    expected, not `.`\n/tmp/tmp_wityag1.d(55): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmp_wityag1.d(56): Error: semicolon expected, not
    `.`\n/tmp/tmp_wityag1.d(56): Error: no identifier for declarator `.Linq`\n/tmp/tmp_wityag1.d(57):
    Error: semicolon expected, not `.`\n/tmp/tmp_wityag1.d(57): Error: no identifier
    for declarator `.Text`\n/tmp/tmp_wityag1.d(58): Error: semicolon expected, not
    `.`\n/tmp/tmp_wityag1.d(58): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wityag1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[i] = factor;\n  \
    \          n /= i;\n            counter = 1;\n        }\n        else\n      \
    \  {\n            factors[i] = factor;\n            factor++;\n            counter++;\n\
    \        }\n    }\n    factors[(int)Math.sqrt(n)] = factor;\n    return factors;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is not an answer to the question. Instead\
    \ of providing code as an answer, it should be a comment to the question.\n<|/\
    \ c |>\n<| c |>\nI agree, however I do not have enough reputation to comment on\
    \ the question so I posted an answer. Thanks for the feedback.\n<|/ c |>\n<| c\
    \ |>\nThis is not an answer to the question. Instead of providing code as an answer,\
    \ it should be a comment to the question.\n<|/ c |>\n<| c |>\nI agree, however\
    \ I do not have enough reputation to comment on the question so I posted an answer.\
    \ Thanks for the feedback.\n<|/ c |>\n<| c |>\nThis is not an answer to the question.\
    \ Instead of providing code as an answer, it should be a comment to the question.\n\
    <|/ c |>\n<| a tags=algorithm,primes,java |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8edx471l.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp8edx471l.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp8edx471l.d(35):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp8edx471l.d(38):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8edx471l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentFactor = 1;\n    long currentCount\
    \ = 0;\n    long currentFactorCount = 0;\n    long factorization = 1;\n    long\
    \ factorizationCount = 0;\n    \n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        factors[i] = factor;\n        factorCount++;\n        factor *=\
    \ i;\n    }\n    \n    for(int i = factors.length - 1; i >= 0; i--)\n    {\n \
    \       currentFactor = factors[i];\n        currentCount = 1;\n        \n   \
    \     for(int j = i; j < factors.length; j++)\n        {\n            currentFactor\
    \ *= factors[j];\n            currentCount++;\n        }\n        \n        if(currentCount\
    \ > factorCount)\n        {\n            factorizationCount += currentCount;\n\
    \            factorization *= currentFactor;\n        }\n    }\n    \n    factors[factors.length\
    \ - 1] = factorization;\n    factors[factors.length - 2] = factorizationCount;\n\
    \    \n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorizationSize)\n\
    {\n    long[] factors = new long[factorizationSize];\n    long factor = 1;\n \
    \   long factorCount = 0;\n    long currentFactor = 1;\n    long currentCount\
    \ = 0;\n    long currentFactorCount = 0;\n    long factorization = 1;\n    long\
    \ factorizationCount = 0;\n    \n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        factors[i] = factor;\n        factorCount++;\n        factor *=\
    \ i;\n    }\n    \n    for(int i = factors.length - 1; i >= 0; i--)\n    {\n \
    \       currentFactor = factors[i];\n        currentCount = 1;\n        \n   \
    \     for(int j = i; j < factors.length; j++)\n        {\n            currentFactor\
    \ *= factors[j];\n            currentCount++;\n        }\n        \n        if(currentCount\
    \ > factorCount)\n        {\n            factorizationCount += currentCount;\n\
    \            factorization *= currentFactor;\n        }\n    }\n    \n    factors[factors.length\
    \ - 1] = factorization;\n    factors[factors.length - \nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoh0ovik2.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpoh0ovik2.d(106):
    Error: expression expected, not `unittest`\n/tmp/tmpoh0ovik2.d(107): Error: found
    `{` when expecting `,`\n/tmp/tmpoh0ovik2.d(108): Error: expression expected, not
    `alias`\n/tmp/tmpoh0ovik2.d(108): Error: found `candidate` when expecting `,`\n/tmp/tmpoh0ovik2.d(108):
    Error: expression expected, not `=`\n/tmp/tmpoh0ovik2.d(108): Error: found `factorize`
    when expecting `,`\n/tmp/tmpoh0ovik2.d(108): Error: expression expected, not `;`\n/tmp/tmpoh0ovik2.d(110):
    Error: found `assert` when expecting `,`\n/tmp/tmpoh0ovik2.d(110): Error: found
    `;` when expecting `,`\n/tmp/tmpoh0ovik2.d(111): Error: found `;` when expecting
    `,`\n/tmp/tmpoh0ovik2.d(112): Error: found `;` when expecting `,`\n/tmp/tmpoh0ovik2.d(113):
    Error: found `;` when expecting `,`\n/tmp/tmpoh0ovik2.d(114): Error: found `;`
    when expecting `,`\n/tmp/tmpoh0ovik2.d(115): Error: found `;` when expecting `,`\n/tmp/tmpoh0ovik2.d(116):
    Error: found `;` when expecting `,`\n/tmp/tmpoh0ovik2.d(117): Error: found `;`
    when expecting `,`\n/tmp/tmpoh0ovik2.d(118): Error: expression expected, not `}`\n/tmp/tmpoh0ovik2.d(119):
    Error: found `void` when expecting `,`\n/tmp/tmpoh0ovik2.d(119): Error: found
    `{` when expecting `,`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoh0ovik2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factor_count = 1;\n    long factor_index = 0;\n    for(int i =\
    \ 1; i <= (int)Math.sqrt(n); i++) {\n        factors[factor_index] = factor;\n\
    \        factor_index++;\n        factor *= i;\n        factor_count++;\n    }\n\
    \    factors[factor_index] = factor;\n    factor_index++;\n    factors[factor_index]\
    \ = factor_count;\n    for(int i = 1; i <= factor_index; i++) {\n        factors[factor_index]\
    \ = factors[factor_index] * factors[i];\n        factor_index++;\n    }\n    return\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0mavhyd8.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0mavhyd8.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0mavhyd8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        temp = factor;\n        factor *= i;\n        while(temp < n)\
    \ {\n            if(n % temp == 0) {\n                factors[counter] = temp;\n\
    \                n /= temp;\n                counter++;\n                break;\n\
    \            }\n            temp++;\n        }\n    }\n    return factors;\n}\n\
    </code>\n<|/ a tags=algorithm,c#,primes,math |>\n<| c |>\nThe algorithm is wrong.\
    \ Try factorize(8L). You'll get [2, 2, 2] instead of [2, 2, 3]\n<|/ c |>\n<| c\
    \ |>\nThe algorithm is wrong. Try factorize(8L). You'll get [2, 2, 2] instead\
    \ of [2, 2, 3]\n<|/ c |>\n<| c |>\nThe algorithm is wrong. Try factorize(8L).\
    \ You'll get [2, 2, 2] instead of [2, 2, 3]\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is wrong. Try factorize(8L). You'll get [2, 2, 2] instead of [2, 2, 3]\n<|/\
    \ c |>\n<| c |>\nThe algorithm is wrong. Try factorize(8L). You'll get [2, 2,\
    \ 2] instead of [2, 2, 3]\n<|/ c |>\n<| a tags=algorithm,c#,primes,math |>\n<code>\n\
    public static bool IsPrime(long number)\n{\n    if (number == 1)\n    {\n    \
    \    return false;\n    }\n    if (number == 2)\n    {\n        return true;\n\
    \    }\n    if (number % 2 == 0)\n    {\n        return false;\n    }\n    long\
    \ limit = (long)Math.Sqrt(number);\n    for (int i = 3; i <= limit; i += 2)\n\
    \    {\n        if (number % i == 0)\n        {\n            return false;\n \
    \       }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzv9h9lua.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzv9h9lua.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpzv9h9lua.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpzv9h9lua.d(39): Error: unterminated
    character constant\n/tmp/tmpzv9h9lua.d(42): Error: unterminated character constant\n/tmp/tmpzv9h9lua.d(45):
    Error: unterminated character constant\n/tmp/tmpzv9h9lua.d(48): Error: unterminated
    character constant\n/tmp/tmpzv9h9lua.d(51): Error: unterminated character constant\n/tmp/tmpzv9h9lua.d(60):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzv9h9lua.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        temp = factor;\n        while(temp * factor <= n)\n   \
    \     {\n            if(n % temp == 0)\n            {\n                factors[i]\
    \ = temp;\n                n /= temp;\n                break;\n            }\n\
    \            factor++;\n        }\n        if(temp == 1)\n        {\n        \
    \    factors[i] = n;\n            break;\n        }\n    }\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long factor = 1;\n    long counter = 1;\n\
    \    long temp;\n    for(int i = 0; i < factors.length; i++)\n    {\n        temp\
    \ = factor;\n        while(temp * factor <= n)\n        {\n            if(n %\
    \ temp == 0)\n            {\n                factors[i] = temp;\n            \
    \    n /= temp;\n                break;\n            }\n            factor++;\n\
    \        }\n        if(temp == 1)\n        {\n            factors[i] = n;\n  \
    \          break;\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorizationSize, bool isPrime)\n{\n   \
    \ long[] factors = new long[factorizationSize];\n    long factor = 1;\n    long\
    \ counter = 1;\n    long temp;\n    for(int i = 0; i < factors.length; i++)\n\
    \    {\n        temp = factor;\n        while(temp * factor <= n)\n        {\n\
    \            if(n % temp == 0)\n            {\n                factors[i] = temp;\n\
    \                n /= temp;\n                break;\n            }\n         \
    \   factor\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzi3ybzy.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpvzi3ybzy.d(111):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpvzi3ybzy.d(124):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpvzi3ybzy.d(124):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpvzi3ybzy.d(124):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzi3ybzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long factorization2 =\
    \ 1;\n    long factorization3 = 1;\n    long factorization4 = 1;\n    long factorization5\
    \ = 1;\n    long factorization6 = 1;\n    long factorization7 = 1;\n    long factorization8\
    \ = 1;\n    long factorization9 = 1;\n    long factorization10 = 1;\n    long\
    \ factorization11 = 1;\n    long factorization12 = 1;\n    long factorization13\
    \ = 1;\n    long factorization14 = 1;\n    long factorization15 = 1;\n    long\
    \ factorization16 = 1;\n    long factorization17 = 1;\n    long factorization18\
    \ = 1;\n    long factorization19 = 1;\n    long factorization20 = 1;\n    long\
    \ factorization21 = 1;\n    long factorization22 = 1;\n    long factorization23\
    \ = 1;\n    long factorization24 = 1;\n    long factorization25 = 1;\n    long\
    \ factorization26 = 1;\n    long factorization27 = 1;\n    long factorization28\
    \ = 1;\n    long factorization29 = 1;\n    long factorization30 = 1;\n    long\
    \ factorization31 = 1;\n    long factorization32 = 1;\n    long factorization33\
    \ = 1;\n    long factorization34 = 1;\n    long factorization35 = 1;\n    long\
    \ factorization36 = 1;\n    long factorization37 = 1;\n    long factorization38\
    \ = 1;\n    long factorization39 = 1;\n    long factorization40 = 1;\n    long\
    \ factorization41 = 1;\n    long factorization42 = 1;\n    long factorization43\
    \ = 1;\n    long factorization44 = 1;\n    long factorization45 = 1;\n    long\
    \ factorization46 = 1;\n    long factorization47 = 1;\n    long factorization48\
    \ = 1;\n    long factorization49 = 1;\n    long factorization50 = 1;\n    long\
    \ factorization51 = 1;\n    long factorization52 = 1;\n    long factorization53\
    \ = 1;\n    long factorization54 = 1;\n    long factorization55 = 1;\n    long\
    \ factorization56 = 1;\n    long factorization57 = 1;\n    long factorization58\
    \ = 1;\n    long factorization59 = 1;\n    long factorization60 = 1;\n    long\
    \ factorization61 = 1;\n    long factorization62 = 1;\n    long factorization63\
    \ = 1;\n    long factorization64 = 1;\n    long factorization65 = 1;\n    long\
    \ factorization66 = 1;\n    long factorization67 = 1;\n    long factorization68\
    \ = 1;\n    long factorization69 = 1;\n    \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5tq28mlt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp5tq28mlt.d(90):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp5tq28mlt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  for(int i = 0; i < factors.length; i++)\n    {\n        while(p % 2 == 0)\n\
    \        {\n            factors[i] = 2;\n            p /= 2;\n        }\n    \
    \    while(p % 3 == 0)\n        {\n            factors[i] = 3;\n            p\
    \ /= 3;\n        }\n        while(p % 5 == 0)\n        {\n            factors[i]\
    \ = 5;\n            p /= 5;\n        }\n        while(p % 7 == 0)\n        {\n\
    \            factors[i] = 7;\n            p /= 7;\n        }\n        while(p\
    \ % 11 == 0)\n        {\n            factors[i] = 11;\n            p /= 11;\n\
    \        }\n        while(p % 13 == 0)\n        {\n            factors[i] = 13;\n\
    \            p /= 13;\n        }\n        while(p % 17 == 0)\n        {\n    \
    \        factors[i] = 17;\n            p /= 17;\n        }\n        while(p %\
    \ 19 == 0)\n        {\n            factors[i] = 19;\n            p /= 19;\n  \
    \      }\n        while(p % 23 == 0)\n        {\n            factors[i] = 23;\n\
    \            p /= 23;\n        }\n        while(p % 29 == 0)\n        {\n    \
    \        factors[i] = 29;\n            p /= 29;\n        }\n        while(p %\
    \ 31 == 0)\n        {\n            factors[i] = 31;\n            p /= 31;\n  \
    \      }\n        while(p % 37 == 0)\n        {\n            factors[i] = 37;\n\
    \            p /= 37;\n        }\n        while(p % 41 == 0)\n        {\n    \
    \        factors[i] = 41;\n            p /= 41;\n        }\n        while(p %\
    \ 43 == 0)\n        {\n            factors[i] = 43;\n            p /= 43;\n  \
    \      }\n        while(p % 47 == 0)\n        {\n            factors[i] = 47;\n\
    \            p /= 47;\n        }\n        while(p % 53 == 0)\n        {\n    \
    \        factors[i] = 53;\n            p /= 53;\n        }\n        while(p %\
    \ 59 == 0)\n        {\n            factors[i] = 59;\n            p /= 59;\n  \
    \      }\n        while(p % 61 == 0)\n        {\n            factors[i] = 61;\n\
    \            p /= 61;\n        }\n        while(p % 67 == 0)\n        {\n    \
    \        factors[i] = 67;\n            p /= 67;\n        }\n        while(p %\
    \ 71 == 0)\n        {\n            factors[i] = 71;\n            p /= 71;\n  \
    \      }\n        while(p % 73 == 0)\n        {\n            factors[i] = 73;\n\
    \            p /= \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpruqf99ei.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpruqf99ei.d(125):
    Error: expression expected, not `unittest`\n/tmp/tmpruqf99ei.d(126): Error: found
    `{` when expecting `;` following statement\n/tmp/tmpruqf99ei.d(138): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmpruqf99ei.d(138):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpruqf99ei.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ factor = 1;\n    for(int i = 0; i <= (int)sqrt(n); i++)\n    {\n        while(p\
    \ % i == 0)\n        {\n            factor *= i;\n            p /= i;\n      \
    \  }\n        factors[i] = factor;\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,primes |>\n<| c |>\nThe question was about\
    \ C#, not Java.\n<|/ c |>\n<| c |>\nThe question was about C#, not Java.\n<|/\
    \ c |>\n<| c |>\nThe question was about C#, not Java.\n<|/ c |>\n<| c |>\nThe\
    \ question was about C#, not Java.\n<|/ c |>\n<| c |>\nThe question was about\
    \ C#, not Java.\n<|/ c |>\n<| a tags=c#,algorithm,primes |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8mahsgi.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpc8mahsgi.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpc8mahsgi.d(32): Error:
    declaration expected, not `<`\n/tmp/tmpc8mahsgi.d(52): Error: semicolon expected,
    not `.`\n/tmp/tmpc8mahsgi.d(52): Error: no identifier for declarator `.Collections.Generic`\n/tmp/tmpc8mahsgi.d(53):
    Error: semicolon expected, not `.`\n/tmp/tmpc8mahsgi.d(53): Error: no identifier
    for declarator `.Linq`\n/tmp/tmpc8mahsgi.d(54): Error: semicolon expected, not
    `.`\n/tmp/tmpc8mahsgi.d(54): Error: no identifier for declarator `.Text`\n/tmp/tmpc8mahsgi.d(55):
    Error: semicolon expected, not `.`\n/tmp/tmpc8mahsgi.d(55): Error: no identifier
    for declarator `.Threading.Tasks`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8mahsgi.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyjn14s7h.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpyjn14s7h.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpyjn14s7h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        factors[(int)i] = 1;\n        while(p <= n && n % p == 0)\n        {\n\
    \            factors[(int)i] += factor;\n            n /= p;\n            factor++;\n\
    \        }\n        p++;\n    }\n    return factors;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe question is about finding prime factors, not factorizing a\
    \ number.\n<|/ c |>\n<| c |>\nI believe that factorization is also a prime factorization\
    \ problem. Factorization is just finding prime factors of a number. Factorization\
    \ is also a prime factorization problem because factorization is also a prime\
    \ factorization problem. Factorization is also a prime factorization problem because\
    \ factorization is also a prime factorization problem. Factorization is also a\
    \ prime factorization problem because factorization is also a prime factorization\
    \ problem.\n<|/ c |>\n<| c |>\nFactorization is also a prime factorization problem\
    \ because factorization is also a prime factorization problem. Factorization is\
    \ also a prime factorization problem because factorization is also a prime factorization\
    \ problem. Factorization is also a prime factorization problem because factorization\
    \ is also a prime factorization problem.\n<|/ c |>\n<| c |>\nFactorization is\
    \ also a prime factorization problem because factorization is also a prime factorization\
    \ problem. Factorization is also a prime factorization problem because factorization\
    \ is also a prime factorization problem. Factorization is also a prime factorization\
    \ problem because factorization is also a prime factorization problem. Factorization\
    \ is also a prime factorization problem because factorization is also a prime\
    \ factorization problem.\n<|/ c |>\n<| c |>\nFactorization is also a prime factorization\
    \ problem because factorization is also a prime factorization problem. Factorization\
    \ is also a prime factorization problem because factorization is also a prime\
    \ factorization problem. Factorization is also a prime factorization problem because\
    \ factorization is also a prime factorization problem. Factorization is also a\
    \ prime factorization problem because factorization is also a prime factorization\
    \ problem. Factorization is also a prime factorization problem because factorization\
    \ is also a prime factorization problem.\n<|/ c |>\n<| a tags=java,algorithm,primes\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport\
    \ java.util.\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw7y8mdo5.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpw7y8mdo5.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpw7y8mdo5.d(22):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpw7y8mdo5.d(25): Error:
    C style cast illegal, use `cast(int)i`\n/tmp/tmpw7y8mdo5.d(33): Error: declaration
    expected, not `<`\n/tmp/tmpw7y8mdo5.d(55): Error: identifier expected following
    `package`\n/tmp/tmpw7y8mdo5.d(55): Error: `;` expected\n/tmp/tmpw7y8mdo5.d(56):
    Error: declaration expected, not `{`\n/tmp/tmpw7y8mdo5.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpw7y8mdo5.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpw7y8mdo5.d(61): Error: declaration expected, not `assert`\n/tmp/tmpw7y8mdo5.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpw7y8mdo5.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpw7y8mdo5.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpw7y8mdo5.d(65): Error: declaration expected, not `assert`\n/tmp/tmpw7y8mdo5.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmpw7y8mdo5.d(67): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7y8mdo5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2ukkpkxj.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2ukkpkxj.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmp2ukkpkxj.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ukkpkxj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 2;\n    long t = 2;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7qdueary.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp7qdueary.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmp7qdueary.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7qdueary.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    long factor_count2\
    \ = 0;\n    long factor_index2 = 0;\n    long factor_count3 = 0;\n    long factor_index3\
    \ = 0;\n    long factor_count4 = 0;\n    long factor_index4 = 0;\n    long factor_count5\
    \ = 0;\n    long factor_index5 = 0;\n    long factor_count6 = 0;\n    long factor_index6\
    \ = 0;\n    long factor_count7 = 0;\n    long factor_index7 = 0;\n    long factor_count8\
    \ = 0;\n    long factor_index8 = 0;\n    long factor_count9 = 0;\n    long factor_index9\
    \ = 0;\n    long factor_count10 = 0;\n    long factor_index10 = 0;\n    long factor_count11\
    \ = 0;\n    long factor_index11 = 0;\n    long factor_count12 = 0;\n    long factor_index12\
    \ = 0;\n    long factor_count13 = 0;\n    long factor_index13 = 0;\n    long factor_count14\
    \ = 0;\n    long factor_index14 = 0;\n    long factor_count15 = 0;\n    long factor_index15\
    \ = 0;\n    long factor_count16 = 0;\n    long factor_index16 = 0;\n    long factor_count17\
    \ = 0;\n    long factor_index17 = 0;\n    long factor_count18 = 0;\n    long factor_index18\
    \ = 0;\n    long factor_count19 = 0;\n    long factor_index19 = 0;\n    long factor_count20\
    \ = 0;\n    long factor_index20 = 0;\n    long factor_count21 = 0;\n    long factor_index21\
    \ = 0;\n    long factor_count22 = 0;\n    long factor_index22 = 0;\n    long factor_count23\
    \ = 0;\n    long factor_index23 = 0;\n    long factor_count24 = 0;\n    long factor_index24\
    \ = 0;\n    long factor_count25 = 0;\n    long factor_index25 = 0;\n    long factor_count26\
    \ = 0;\n    long factor_index26 = 0;\n    long factor_count27 = 0;\n    long factor_index27\
    \ = 0;\n    long factor_count28 = 0;\n    long factor_index28 = 0;\n    long factor_count29\
    \ = 0;\n    long factor_index29 = 0;\n    long factor_count30 = 0;\n    long factor_index30\
    \ = 0;\n    long factor_count31 = 0;\n    long factor_index31 = 0;\n    long factor_count32\
    \ = 0;\n    long factor_index32 = 0;\n    long factor_count33 = 0;\n    long factor_index33\
    \ = 0;\n    long factor_count34 = 0;\n    long factor_index34 = 0;\n    long factor_count35\
    \ = 0;\n    long factor_index35 = 0;\n    long factor_count36 = 0;\n    long factor_index36\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa_77blu_.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpa_77blu_.d(91):
    Error: semicolon expected, not `unittest`\n/tmp/tmpa_77blu_.d(91): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_77blu_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorIndex = 0;\n    \n    while(factor\
    \ <= n) {\n        factors[factorIndex] = factor;\n        factorCount++;\n  \
    \      factorIndex++;\n        \n        factor++;\n        \n        while(factor\
    \ <= n && factorCount > 0) {\n            factors[factorIndex] = factor;\n   \
    \         factorCount--;\n            factorIndex++;\n            factor++;\n\
    \        }\n    }\n    \n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfk8kkyji.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfk8kkyji.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu8fa1y57.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpu8fa1y57.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpu8fa1y57.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8fa1y57.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long k = n;\n    long\
    \ l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxm8nvo19.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxm8nvo19.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpxm8nvo19.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxm8nvo19.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long i = 2;\n    while(p > 1) {\n        while(p %\
    \ i == 0) {\n            factors[(int)i]++;\n            p /= i;\n        }\n\
    \        i++;\n    }\n    factors[(int)i]++;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn8lgvxwn.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpn8lgvxwn.d(23):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpn8lgvxwn.d(28): Error:
    C style cast illegal, use `cast(int)i`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpn8lgvxwn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    for(int i = 1; i < factors.length; i++)\n   \
    \ {\n        while(n % factor == 0)\n        {\n            factors[counter] =\
    \ factor;\n            n /= factor;\n            counter++;\n        }\n     \
    \   factor++;\n    }\n    factors[counter] = n;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2qa4_54q.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2qa4_54q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long counter = 1;\n    long i = 2;\n    while(i <= n)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[counter] = i;\n            n /= i;\n\
    \            counter++;\n        }\n        i++;\n    }\n    factors[counter]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c++,factorization\
    \ |>\n<| c |>\nThis code does not work for large numbers. For example, factorize(1000000007L)\
    \ returns [1000000007L, 1000000007L]\n<|/ c |>\n<| c |>\nIt works for me on `1000000007L`\
    \ - it returns `[1000000007L, 1000000007L]`\n<|/ c |>\n<| c |>\nIt works for me\
    \ on `1000000007L` - it returns `[1000000007L, 1000000007L]`\n<|/ c |>\n<| c |>\n\
    It works for me on `1000000007L` - it returns `[1000000007L, 1000000007L]`\n<|/\
    \ c |>\n<| c |>\nIt works for me on `1000000007L` - it returns `[1000000007L,\
    \ 1000000007L]`\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution using recursion:\n\
    <code>\n#include <iostream>\n#include <vector>\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2od2iwlw.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp2od2iwlw.d(34):
    Error: declaration expected, not `<`\n/tmp/tmp2od2iwlw.d(52): Error: unterminated
    character constant\n/tmp/tmp2od2iwlw.d(60): Error: declaration expected, not `assert`\n/tmp/tmp2od2iwlw.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmp2od2iwlw.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmp2od2iwlw.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmp2od2iwlw.d(64): Error: declaration expected, not `assert`\n/tmp/tmp2od2iwlw.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmp2od2iwlw.d(66): Error: declaration
    expected, not `assert`\n/tmp/tmp2od2iwlw.d(67): Error: declaration expected, not
    `assert`\n/tmp/tmp2od2iwlw.d(68): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2od2iwlw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long i = 1;\n    long j = 0;\n    \n    while(i\
    \ < n)\n    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n        i++;\n\
    \    }\n    \n    for(int k = 0; k < factorCount; k++)\n    {\n        factors[k]\
    \ = factors[k] * factorCount;\n    }\n    \n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppw_0fux6.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppw_0fux6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    \n    for(int i = 1; i <= (int)sqrt(n);\
    \ i++) {\n        temp = factor;\n        while(temp * factor <= n) {\n      \
    \      factors[counter] = temp;\n            counter++;\n            temp *= factor;\n\
    \        }\n        factors[counter] = temp;\n        counter++;\n    }\n    \n\
    \    factors[counter] = n;\n    \n    return factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,java\
    \ |>\n<| c |>\nThis code is not correct. `factorize(8L)` returns `[2, 2, 2]` instead\
    \ of `[2, 2, 2, 2, 2]`.\n<|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing\
    \ it out\n<|/ c |>\n<| c |>\nThis code is not correct. `factorize(8L)` returns\
    \ `[2, 2, 2]` instead of `[2, 2, 2, 2, 2]`.\n<|/ c |>\n<| c |>\nI fixed the bug.\
    \ Thanks for pointing it out\n<|/ c |>\n<| c |>\nThis code is not correct. `factorize(8L)`\
    \ returns `[2, 2, 2]` instead of `[2, 2, 2, 2, 2]`.\n<|/ c |>\n<| a tags=algorithm,math,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnxjaw4cl.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpnxjaw4cl.d(22):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpnxjaw4cl.d(37): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxjaw4cl.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 0;\n        for(int j = 1; j <= i; j++) {\n            if(n%i\
    \ == 0) {\n                factors[factorCount] = i;\n                factorCount++;\n\
    \            }\n        }\n        if(factorCount == 0) {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n        }\n        factor++;\n    }\n    return\
    \ factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code doesn't work. For\
    \ example, factorize(8L) returns [2, 2, 2], not [2, 2, 2, 2]\n<|/ c |>\n<| c |>\n\
    This code doesn't work. For example, factorize(8L) returns [2, 2, 2], not [2,\
    \ 2, 2, 2]\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Sorry\
    \ for the confusion.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6jogrit_.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp6jogrit_.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp6jogrit_.d(36): Error:
    declaration expected, not `<`\n/tmp/tmp6jogrit_.d(39): Error: unterminated character
    constant\n/tmp/tmp6jogrit_.d(42): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jogrit_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentCount = 0;\n    for(int i = 0; i <=\
    \ (int)sqrt(n); i++) {\n        factors[i] = factor;\n        factorCount += factor;\n\
    \        factor *= i;\n        currentCount += factor;\n        if(currentCount\
    \ > n) {\n            factors[(int)sqrt(n)] = currentCount - n;\n            factorCount--;\n\
    \            currentCount -= n;\n        }\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpej9ctmn2.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpej9ctmn2.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpej9ctmn2.d(27): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpej9ctmn2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long i = 2;\n    while(i <= n)\n    {\n     \
    \   while(n % i == 0)\n        {\n            factors[counter] = i;\n        \
    \    n /= i;\n            counter++;\n        }\n        i++;\n    }\n    factors[counter]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxjhsn1wb.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpxjhsn1wb.d(34):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxjhsn1wb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqjmn5043.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqjmn5043.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqjmn5043.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjmn5043.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        factorCount = 0;\n        while(n % factor == 0)\n        {\n       \
    \     factors[factorCount] = factor;\n            factorCount++;\n           \
    \ n /= factor;\n        }\n        factor = factors[factorCount];\n    }\n   \
    \ return factors;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbvr04gpa.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpbvr04gpa.d(33):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbvr04gpa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    \n    for(int i = 1; i < factors.length; i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor = factor * i;\n\
    \    }\n    factors[factorCount++] = factor;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoa8m08uy.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa8m08uy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long temp;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        temp = factor;\n        while(temp != 1) {\n            counter++;\n\
    \            temp = temp * factor;\n        }\n        factors[i] = counter;\n\
    \        factor *= i;\n    }\n    \n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpldcnpzpu.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpldcnpzpu.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpldcnpzpu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++) {\n        temp = factor;\n        factor *= i;\n        while(temp <=\
    \ n) {\n            if(n % temp == 0) {\n                factors[counter] = temp;\n\
    \                n /= temp;\n                break;\n            }\n         \
    \   temp++;\n        }\n        counter++;\n    }\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzf3rt3u.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpvzf3rt3u.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpvzf3rt3u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long factorization = 1;\n    for(int i = 1; i\
    \ <= (int)Math.sqrt(n); i++) {\n        factors[(int)i] = 1;\n        factorization\
    \ *= i;\n        while(factorization % i == 0) {\n            factors[(int)i]\
    \ += 1;\n            factorization /= i;\n        }\n    }\n    for(int i = 1;\
    \ i <= (int)Math.sqrt(n); i++) {\n        if(factors[(int)i] > 1) {\n        \
    \    factors[(int)i] /= factors[(int)i-1];\n            counter += factors[(int)i];\n\
    \        }\n    }\n    return factors;\n}\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ long[] factorization) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long factor = 1;\n    long counter = 1;\n    long factorization = 1;\n  \
    \  for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        factors[(int)i] = 1;\n\
    \        factorization *= i;\n        while(factorization % i == 0) {\n      \
    \      factors[(int)i] += 1;\n            factorization /= i;\n        }\n   \
    \ }\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        if(factors[(int)i]\
    \ > 1) {\n            factors[(int)i] /= factors[(int)i-1];\n            counter\
    \ += factors[(int)i];\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factorization, long[] factors) \n{\n \
    \   long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor = 1;\n  \
    \  long counter = 1;\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0fci8uhw.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(21):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(22):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(25): Error:
    C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(29): Error: C style
    cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(30): Error: C style
    cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(31): Error: C style cast illegal,
    use `cast(int)i`\n/tmp/tmp0fci8uhw.d(31): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(32):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(51): Error:
    C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(55): Error:
    C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(56): Error:
    C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(59): Error: C style
    cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(63): Error: C style cast illegal,
    use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(64): Error: C style cast illegal,
    use `cast(int)i`\n/tmp/tmp0fci8uhw.d(65): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(65):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(66): Error:
    C style cast illegal, use `cast(int)i`\n/tmp/tmp0fci8uhw.d(85): Error: C style
    cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0fci8uhw.d(89): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fci8uhw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    \n    for(int i = 0; i <= (int)sqrt(n);\
    \ i++)\n    {\n        if(n%i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n    }\n  \
    \  \n    for(int i = 0; i <= factorCount; i++)\n    {\n        factors[i] = factor;\n\
    \        factor += factors[i];\n    }\n    \n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,math,primes,c# |>\n<| c |>\nI believe this algorithm is wrong.\
    \ Try factorize(8L). You will get [2, 2, 2]. 8 is divisible by 2 3 times. So the\
    \ algorithm should return [2, 2, 2]. Your algorithm returns [2, 2, 2, 2]. 8 is\
    \ divisible by 2 3 times. So the algorithm should return [2, 2, 2, 2]. 8 is divisible\
    \ by 2 3 times. So the algorithm should return [2, 2, 2, 2]. 8 is divisible by\
    \ 2 3 times. So the algorithm should return [2, 2, 2, 2]. 8 is divisible by 2\
    \ 3 times. So the algorithm should return [2, 2, 2, 2]. 8 is divisible by 2 3\
    \ times. So the algorithm should return [2, 2, 2, 2]. 8 is divisible by 2 3 times.\
    \ So the algorithm should return [2, 2, 2, 2]. 8 is divisible by 2 3 times. So\
    \ the algorithm should return [2, 2, 2, 2]. 8 is divisible by 2 3 times. So the\
    \ algorithm should return [2, 2, 2, 2]. 8 is divisible by 2 3 times. So the algorithm\
    \ should return [2, 2, 2, 2]. 8 is divisible by 2 3 times. So the algorithm should\
    \ return [2, 2, 2, 2]. 8 is divisible by 2 3 times. So the algorithm should return\
    \ [2, 2, 2, 2]. 8 is divisible by 2 3 times. So the algorithm should return [2,\
    \ 2, 2, 2]. 8 is divisible by 2 3 times. So the algorithm should return [2, 2,\
    \ 2, 2]. 8 is divisible by 2 3 times. So the algorithm should return [2, 2, 2,\
    \ 2]. 8 is divisible by 2 3 times. So the algorithm should return [2, 2, 2, 2].\
    \ 8 is divisible by 2 3 times. So the algorithm should return [2, 2, 2, 2]. 8\
    \ is divisible by 2 3 times. So the algorithm should return [2, 2, 2, 2]. 8 is\
    \ divisible by 2 3 times. So the \nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo2n42xsm.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpo2n42xsm.d(22):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpo2n42xsm.d(40): Error:
    declaration expected, not `<`\n/tmp/tmpo2n42xsm.d(48): Error: declaration expected,
    not `assert`\n/tmp/tmpo2n42xsm.d(49): Error: declaration expected, not `assert`\n/tmp/tmpo2n42xsm.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpo2n42xsm.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpo2n42xsm.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpo2n42xsm.d(53): Error: declaration expected, not `assert`\n/tmp/tmpo2n42xsm.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpo2n42xsm.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpo2n42xsm.d(56): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo2n42xsm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentFactor = 1;\n    for(int i = 1; i\
    \ <= (int)sqrt(n); i++) {\n        factors[factorCount] = i;\n        factorCount++;\n\
    \        while(n % i == 0) {\n            n /= i;\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n        }\n    }\n    for(int i = factorCount;\
    \ i > 0; i--) {\n        if(n % factors[i - 1] == 0) {\n            n /= factors[i\
    \ - 1];\n            factors[i - 1] = 1;\n            factors[factorCount - 1]\
    \ = 1;\n            factorCount--;\n        }\n    }\n    return factors;\n}\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0qx13ud3.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0qx13ud3.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp0qx13ud3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu8fa1y57.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpu8fa1y57.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpu8fa1y57.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8fa1y57.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = n;\n\
    \    long s = 1;\n    long t = 0;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = n;\n    long s = 1;\n\
    \    long t = 0;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqozuqj13.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqozuqj13.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpqozuqj13.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu8fa1y57.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpu8fa1y57.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpu8fa1y57.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8fa1y57.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        while(n % i ==\
    \ 0) {\n            factors[factor++] = i;\n            n /= i;\n        }\n \
    \   }\n    factors[factor++] = n;\n    return factors;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not an answer to the question. He asked for a solution in Java,\
    \ not C#.\n<|/ c |>\n<| c |>\nThe question was tagged with both Java and C#, so\
    \ I thought this was a good answer for both languages. I agree that C# is more\
    \ readable than Java, but I thought this was a good solution for both languages.\n\
    <|/ c |>\n<| c |>\nThe question was tagged with both Java and C#, so I thought\
    \ this was a good answer for both languages. I agree that C# is more readable\
    \ than Java, but I thought this was a good solution for both languages.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but this is not a good solution for both languages.\
    \ Java is more readable than C#, but this is not a good solution for both languages.\n\
    <|/ c |>\n<| c |>\nI agree with you, but this is not a good solution for both\
    \ languages. Java is more readable than C#, but this is not a good solution for\
    \ both languages.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqll14z44.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqll14z44.d(19):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqll14z44.d(28):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpqll14z44.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long p = n;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1t391f3x.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp1t391f3x.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmp1t391f3x.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1t391f3x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long factor = 1;\n    long counter = 1;\n    \n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factor;\n        \n        while(n % p ==\
    \ 0)\n        {\n            factor++;\n            n /= p;\n        }\n     \
    \   \n        p++;\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(factors[i] == 1)\n        {\n            factors[i] = counter;\n\
    \            counter++;\n        }\n    }\n    \n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest to\
    \ largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int max) \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n\
    \    long p = 1;\n    long factor = 1;\n    long counter = 1;\n    \n    for(int\
    \ i = 1; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factor;\n \
    \       \n        while(n % p == 0)\n        {\n            factor++;\n      \
    \      n /= p;\n        }\n        \n        p++;\n    }\n    \n    for(int i\
    \ = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(factors[i] == 1)\n    \
    \    {\n            factors[i] = counter;\n            counter++;\n        }\n\
    \    }\n    \n    return factors;\n}\n/*\n Return array of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be arrayed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int max, int min) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n    long\
    \ factor = 1;\n    long counter = 1;\n    \n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcy5cgchr.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(35):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(60):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(65):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(78):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(103):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(108):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcy5cgchr.d(111):
    Error: found `unittest` instead of statement\n/tmp/tmpcy5cgchr.d(124): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcy5cgchr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n\
    \    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = factor;\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n \
    \   long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = factor;\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long factorCount = 0;\n    for(int i = start; i < factors.length;\
    \ i++)\n    {\n        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = factor;\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa01_nwml.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpa01_nwml.d(88):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa01_nwml.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long k = n;\n    long\
    \ l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxm8nvo19.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpxm8nvo19.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpxm8nvo19.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxm8nvo19.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\
    \ {\n        if(n % i == 0) {\n            factors[factorCount] = i;\n       \
    \     factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] factors) \n{\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n);\
    \ i++) {\n        if(n % i == 0) {\n            factors[factorCount] = i;\n  \
    \          factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] factors, int factorCount)\
    \ \n{\n    long factor = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n\
    \        if(n % i == 0) {\n            factors[factorCount] = i;\n           \
    \ factor++;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt91dlm7t.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpt91dlm7t.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpt91dlm7t.d(46):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpt91dlm7t.d(71):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpt91dlm7t.d(94):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpt91dlm7t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCount2 = 0;\n    for(int i = factors.length\
    \ - 1; i >= 0; i--) \n    {\n        factorCount = 0;\n        factorCount2 =\
    \ 0;\n        for(int j = factors.length - 1; j >= 0; j--) \n        {\n     \
    \       if(factors[j] == i) \n            {\n                factorCount++;\n\
    \                factorCount2++;\n            }\n        }\n        if(factorCount\
    \ > 1) \n        {\n            factors[i] = factor;\n            factorCount++;\n\
    \        }\n        factor = factor * i;\n        factorCount2 = factorCount2;\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8p1s255v.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp8p1s255v.d(43):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8p1s255v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3\
    \ = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0t6iyimc.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0t6iyimc.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0t6iyimc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     while(n % i == 0) {\n            factors[factorCount] = i;\n           \
    \ n /= i;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq4_lwq5x.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpq4_lwq5x.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpq4_lwq5x.d(30): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4_lwq5x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long counter = 1;\n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        while(p % factor == 0)\n        {\n            factors[counter]\
    \ = factor;\n            counter++;\n            p /= factor;\n        }\n   \
    \     factors[counter] = factor;\n        counter++;\n        factor *= i;\n \
    \   }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,math,java\
    \ |>\n<| c |>\nThis code doesn't work for large numbers. For example, factorize(8L)\
    \ returns [2, 2, 2] instead of [2, 2, 2, 2, 2]\n<|/ c |>\n<| c |>\nI tested it\
    \ on Java 8 and it worked fine. Can you please give me an example where it fails?\n\
    <|/ c |>\n<| c |>\nI tested it on Java 8 and it worked fine. Can you please give\
    \ me an example where it fails?\n<|/ c |>\n<| c |>\nI tested it on Java 8 and\
    \ it worked fine. Can you please give me an example where it fails?\n<|/ c |>\n\
    <| c |>\nI tested it on Java 8 and it worked fine. Can you please give me an example\
    \ where it fails?\n<|/ c |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8uoz84tc.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp8uoz84tc.d(35):
    Error: declaration expected, not `<`\n/tmp/tmp8uoz84tc.d(38): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8uoz84tc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 2; i <= n; i++)\n    {\n    \
    \    factorCount = 0;\n        while(factor <= n && n % factor == 0)\n       \
    \ {\n            factors[factorCount++] = factor;\n            n /= factor;\n\
    \            factor++;\n        }\n        if(factor > n)\n        {\n       \
    \     factors[factorCount++] = n;\n        }\n    }\n    return factors;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.Arrays;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_i3ca_lj.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_i3ca_lj.d(36):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp_i3ca_lj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    \n    while(p <= q)\n    {\n        while(p <= q)\n        {\n \
    \           while(p <= q)\n            {\n                while(p <= q)\n    \
    \            {\n                    while(p <= q)\n                    {\n   \
    \                     while(p <= q)\n                        {\n             \
    \               while(p <= q)\n                            {\n               \
    \                 while(p <= q)\n                                {\n         \
    \                           while(p <= q)\n                                  \
    \  {\n                                        while(p <= q)\n                \
    \                        {\n                                            while(p\
    \ <= q)\n                                            {\n                     \
    \                           while(p <= q)\n                                  \
    \              {\n                                                    while(p\
    \ <= q)\n                                                    {\n             \
    \                                           while(p <= q)\n                  \
    \                                      {\n                                   \
    \                         while(p <= q)\n                                    \
    \                        {\n                                                 \
    \               while(p <= q)\n                                              \
    \                  {\n                                                       \
    \             while(p <= q)\n                                                \
    \                    {\n                                                     \
    \                   while(p <= q)\n                                          \
    \                              {\n                                           \
    \                                 while(p <= q)\n                            \
    \                                                {\n                         \
    \                                                       while(p <= q)\n      \
    \                                                                          {\n\
    \                                                                            \
    \        while(p <= q)\n                                                     \
    \                               {\n                                          \
    \                                              while(p <= q)\n               \
    \                                                                         {\n\
    \                                                                            \
    \                while(p <= q)\n                                             \
    \                                               {\n                          \
    \                                                                      while(p\
    \ <= q)\n                                                                    \
    \                            {\n                                             \
    \                                                       while(p <= q)\n      \
    \                                                                            \
    \                  {\n                                                       \
    \                                                 while(p <= q)\n            \
    \                                                                            \
    \                {\n                                                         \
    \                                                   while(p <= q)\n          \
    \                                                                            \
    \                      {\n                                                   \
    \                                                             while(p <= q)\n\
    \                                                                            \
    \                                    {\n                                     \
    \                                                                            \
    \   while(p <= q)\n                                                          \
    \                                                          {\n               \
    \                                                                            \
    \                             while(p <= q)\n                                \
    \                                                                            \
    \            {\n                                                             \
    \                                                               while(p <= q)\n\
    \                                                                            \
    \                                                {\n                         \
    \                                                                            \
    \                           while(p <= q)\n                                  \
    \                                                                            \
    \                  {\n                                                       \
    \                                                                            \
    \ while(p <= q)\n                                                            \
    \                                                                        {\n \
    \                                                                            \
    \                                                           while(p <= q)\n  \
    \                                                                            \
    \                                                          {\n               \
    \                                                                            \
    \                                                 while(p <= q)\n            \
    \                                                                            \
    \                                                    {\n                     \
    \                                                                            \
    \                                               while(p <= q)\n              \
    \                                                                            \
    \                                                      {\n                   \
    \                                                                            \
    \                                                     while(p <= q)\n        \
    \                                                                            \
    \                                                                {\n         \
    \                                                                            \
    \                                                                   while(p <=\
    \ q)\n                                                                       \
    \                                                                            \
    \     {\n                                                                    \
    \                                                                            \
    \            while(p <= q)\n                                                 \
    \                                                                            \
    \                               {\n                                          \
    \                                                                            \
    \                                          while(p <= q)\n                   \
    \                                                                            \
    \                                                                 {\n        \
    \                                                                            \
    \                                                                            \
    \    while(p <= q)\n                                                         \
    \                                                                            \
    \                               {\n                                          \
    \                                                                            \
    \                                                  while(p <= q)\n           \
    \                                                                            \
    \                                                                            \
    \     {\n                                                                \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpirh3kpfp.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpirh3kpfp.d(115):
    Error: found `unittest` instead of statement\n/tmp/tmpirh3kpfp.d(128): Error:
    found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpirh3kpfp.d(128):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpirh3kpfp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1gg5oluw.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp1gg5oluw.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1gg5oluw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnk41jsjq.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpnk41jsjq.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnk41jsjq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = 1;\n\
    \    long factor = 1;\n    long factor_count = 1;\n    long i = 2;\n    while(i\
    \ <= n)\n    {\n        factor_count++;\n        while(n % i == 0)\n        {\n\
    \            factors[factor_count] = i;\n            n /= i;\n            factor_count++;\n\
    \        }\n        i++;\n    }\n    factors[factor_count] = n;\n    return factors;\n\
    }\n</code>\n<|/ a tags=algorithm,primes,java |>\n<| a dscore=0 |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9zd5qyc9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp9zd5qyc9.d(36):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp9zd5qyc9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long counter = 1;\n    while(p > 1)\n    {\n        factors[(int)counter]\
    \ = p;\n        counter++;\n        factor *= p;\n        p /= factor;\n    }\n\
    \    factors[(int)counter] = p;\n    return factors;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnydnz1wm.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpnydnz1wm.d(23):
    Error: C style cast illegal, use `cast(int)counter`\n/tmp/tmpnydnz1wm.d(28): Error:
    C style cast illegal, use `cast(int)counter`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnydnz1wm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    for(int i = 0; i < factors.length; i++)\n    {\n    \
    \    while(p % factor == 0)\n        {\n            factors[(int)i]++;\n     \
    \       p /= factor;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpusjdvjln.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpusjdvjln.d(24):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpusjdvjln.d(31): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpusjdvjln.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    for(int i = 1; i < factors.length; i++)\n    {\n        while(n % factor\
    \ == 0)\n        {\n            factors[factors.length-i-1] = factor;\n      \
    \      n /= factor;\n            factor++;\n        }\n    }\n    factors[factors.length-1]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=math,algorithm,primes |>\n\
    <| a dscore=2 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsj5wdt3n.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpsj5wdt3n.d(31):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpsj5wdt3n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long factorization2 =\
    \ 1;\n    long factorization3 = 1;\n    long factorization4 = 1;\n    long factorization5\
    \ = 1;\n    long factorization6 = 1;\n    long factorization7 = 1;\n    long factorization8\
    \ = 1;\n    long factorization9 = 1;\n    long factorization10 = 1;\n    long\
    \ factorization11 = 1;\n    long factorization12 = 1;\n    long factorization13\
    \ = 1;\n    long factorization14 = 1;\n    long factorization15 = 1;\n    long\
    \ factorization16 = 1;\n    long factorization17 = 1;\n    long factorization18\
    \ = 1;\n    long factorization19 = 1;\n    long factorization20 = 1;\n    long\
    \ factorization21 = 1;\n    long factorization22 = 1;\n    long factorization23\
    \ = 1;\n    long factorization24 = 1;\n    long factorization25 = 1;\n    long\
    \ factorization26 = 1;\n    long factorization27 = 1;\n    long factorization28\
    \ = 1;\n    long factorization29 = 1;\n    long factorization30 = 1;\n    long\
    \ factorization31 = 1;\n    long factorization32 = 1;\n    long factorization33\
    \ = 1;\n    long factorization34 = 1;\n    long factorization35 = 1;\n    long\
    \ factorization36 = 1;\n    long factorization37 = 1;\n    long factorization38\
    \ = 1;\n    long factorization39 = 1;\n    long factorization40 = 1;\n    long\
    \ factorization41 = 1;\n    long factorization42 = 1;\n    long factorization43\
    \ = 1;\n    long factorization44 = 1;\n    long factorization45 = 1;\n    long\
    \ factorization46 = 1;\n    long factorization47 = 1;\n    long factorization48\
    \ = 1;\n    long factorization49 = 1;\n    long factorization50 = 1;\n    long\
    \ factorization51 = 1;\n    long factorization52 = 1;\n    long factorization53\
    \ = 1;\n    long factorization54 = 1;\n    long factorization55 = 1;\n    long\
    \ factorization56 = 1;\n    long factorization57 = 1;\n    long factorization58\
    \ = 1;\n    long factorization59 = 1;\n    long factorization60 = 1;\n    long\
    \ factorization61 = 1;\n    long factorization62 = 1;\n    long factorization63\
    \ = 1;\n    long factorization64 = 1;\n    long factorization65 = 1;\n    long\
    \ factorization66 = 1;\n    long factorization67 = 1;\n    long factorization68\
    \ = 1;\n    long factorization69 = 1;\n    \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5tq28mlt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp5tq28mlt.d(90):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp5tq28mlt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcpv3rufm.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcpv3rufm.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpcpv3rufm.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcpv3rufm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++)\n    {\n\
    \        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n    \
    \        factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c++,primes |>\n\
    <| a tags=algorithm,c++,primes |>\n<code>\n#include <iostream>\n#include <cmath>\n\
    using namespace std;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv3o6itrr.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpv3o6itrr.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpv3o6itrr.d(32): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3o6itrr.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n\
    \    {\n        factorCount = 0;\n        while(n % factor == 0)\n        {\n\
    \            factors[factorCount++] = factor;\n            n /= factor;\n    \
    \    }\n        factor = factors[factorCount-1];\n    }\n    factors[factorCount++]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,primes,math,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw9tbnh5f.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpw9tbnh5f.d(33):
    Error: declaration expected, not `<`\n/tmp/tmpw9tbnh5f.d(38): Error: semicolon
    expected, not `.`\n/tmp/tmpw9tbnh5f.d(38): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmpw9tbnh5f.d(39): Error: semicolon expected, not
    `.`\n/tmp/tmpw9tbnh5f.d(39): Error: no identifier for declarator `.Linq`\n/tmp/tmpw9tbnh5f.d(40):
    Error: semicolon expected, not `.`\n/tmp/tmpw9tbnh5f.d(40): Error: no identifier
    for declarator `.Text`\n/tmp/tmpw9tbnh5f.d(41): Error: semicolon expected, not
    `.`\n/tmp/tmpw9tbnh5f.d(41): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw9tbnh5f.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorization = 1;\n    for(int i = 0; i <= (int)sqrt(n); i++) {\n \
    \       factors[i] = factorization;\n        factorization *= i;\n    }\n    for(int\
    \ i = 0; i <= (int)sqrt(n); i++) {\n        factor *= i;\n        factorization\
    \ *= i;\n        for(int j = i; j <= (int)sqrt(n); j++) {\n            if(factorization%j\
    \ == 0) {\n                factors[j] = factorization/j;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return array of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n, int max) \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor\
    \ = 1;\n    long factorization = 1;\n    for(int i = 0; i <= (int)sqrt(n); i++)\
    \ {\n        factors[i] = factorization;\n        factorization *= i;\n    }\n\
    \    for(int i = 0; i <= (int)sqrt(n); i++) {\n        factor *= i;\n        factorization\
    \ *= i;\n        for(int j = i; j <= (int)sqrt(n); j++) {\n            if(factorization%j\
    \ == 0) {\n                factors[j] = factorization/j;\n                break;\n\
    \            }\n        }\n    }\n    return factors;\n}\n/*\n Return array of\
    \ prime factors of given integer in the order from smallest to largest.\n    Each\
    \ of the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n, int max, int factorization) \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n\
    \    long factor = 1;\n    long factorization = 1;\n    for(int i = 0; i <= (int)sqrt(n);\
    \ i++) {\n        factors[i] = factorization;\n        factorization *= i;\n \
    \   }\n    for(int i = 0; i <= (int)sqrt(n); \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm7qd7dz_.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(24): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(27): Error: C
    style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(50): Error: C style
    cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(53): Error: C style cast
    illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(57): Error: C style cast illegal,
    use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(60): Error: C style cast illegal, use
    `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(83): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(86):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(90): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpm7qd7dz_.d(91): Error: expression
    expected, not `unittest`\n/tmp/tmpm7qd7dz_.d(92): Error: found `{` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm7qd7dz_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    if(n > 1)\n    {\n        factors[factorCount++] = n;\n    }\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes,c# |>\n<| c |>\nThis\
    \ is not an answer to the question. He asked for C#, not Java.\n<|/ c |>\n<| c\
    \ |>\nI wrote this in C#. He didn't ask for Java.\n<|/ c |>\n<| c |>\nI wrote\
    \ this in C#. He didn't ask for Java.\n<|/ c |>\n<| c |>\nI wrote this in C#.\
    \ He didn't ask for Java.\n<|/ c |>\n<| c |>\nI wrote this in C#. He didn't ask\
    \ for Java.\n<|/ c |>\n<| a tags=algorithm,math,primes,c# |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsn85x8sm.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpsn85x8sm.d(35):
    Error: declaration expected, not `<`\n/tmp/tmpsn85x8sm.d(41): Error: unterminated
    character constant\n/tmp/tmpsn85x8sm.d(44): Error: unterminated character constant\n/tmp/tmpsn85x8sm.d(47):
    Error: unterminated character constant\n/tmp/tmpsn85x8sm.d(50): Error: unterminated
    character constant\n/tmp/tmpsn85x8sm.d(55): Error: semicolon expected, not `.`\n/tmp/tmpsn85x8sm.d(55):
    Error: no identifier for declarator `.Collections.Generic`\n/tmp/tmpsn85x8sm.d(56):
    Error: semicolon expected, not `.`\n/tmp/tmpsn85x8sm.d(56): Error: no identifier
    for declarator `.Linq`\n/tmp/tmpsn85x8sm.d(57): Error: semicolon expected, not
    `.`\n/tmp/tmpsn85x8sm.d(57): Error: no identifier for declarator `.Text`\n/tmp/tmpsn85x8sm.d(58):
    Error: semicolon expected, not `.`\n/tmp/tmpsn85x8sm.d(58): Error: no identifier
    for declarator `.Threading.Tasks`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn85x8sm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factorCount = 0;\n        while(n % i == 0) {\n            n /= i;\n   \
    \         factorCount++;\n        }\n        factors[factorCount] = i;\n     \
    \   factor++;\n    }\n    factors[factorCount] = n;\n    return factors;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,primes,c# |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Threading.Tasks;\nunittest\n{\n    alias candidate = factorize;\n\n \
    \   assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n \
    \   assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprorzlm9g.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmprorzlm9g.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmprorzlm9g.d(32): Error:
    declaration expected, not `<`\n/tmp/tmprorzlm9g.d(37): Error: semicolon expected,
    not `.`\n/tmp/tmprorzlm9g.d(37): Error: no identifier for declarator `.Collections.Generic`\n/tmp/tmprorzlm9g.d(38):
    Error: semicolon expected, not `.`\n/tmp/tmprorzlm9g.d(38): Error: no identifier
    for declarator `.Linq`\n/tmp/tmprorzlm9g.d(39): Error: semicolon expected, not
    `.`\n/tmp/tmprorzlm9g.d(39): Error: no identifier for declarator `.Text`\n/tmp/tmprorzlm9g.d(40):
    Error: semicolon expected, not `.`\n/tmp/tmprorzlm9g.d(40): Error: no identifier
    for declarator `.Threading.Tasks`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprorzlm9g.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long counter = 1;\n    while(p > 1) {\n        while(p\
    \ % factor == 0) {\n            factors[counter] = factor;\n            p /= factor;\n\
    \            counter++;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long p = n;\n    long factor = 1;\n    long\
    \ counter = 1;\n    while(p > 1) {\n        while(p % factor == 0) {\n       \
    \     factors[counter] = factor;\n            p /= factor;\n            counter++;\n\
    \        }\n        factor++;\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorizationSize, int factorizationMaxSize)\
    \ \n{\n    long[] factors = new long[factorizationMaxSize];\n    long p = n;\n\
    \    long factor = 1;\n    long counter = 1;\n    while(p > 1) {\n        while(p\
    \ % factor == 0) {\n            factors[counter] = factor;\n            p /= factor;\n\
    \            counter++;\n        }\n        factor++;\n    }\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpamovt92n.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpamovt92n.d(87):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpamovt92n.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long factor = 1;\n  \
    \  long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = factor;\n    return factors;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\
    import java.util.List;\nimport java.util.Scanner;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2zptypx5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp2zptypx5.d(32):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp2zptypx5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.Sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factorCount++;\n            n = n/i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,c#,primes |>\n<|\
    \ a tags=algorithm,c#,primes |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf_0ouyz4.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpf_0ouyz4.d(20):
    Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpf_0ouyz4.d(32):
    Error: declaration expected, not `<`\n/tmp/tmpf_0ouyz4.d(37): Error: semicolon
    expected, not `.`\n/tmp/tmpf_0ouyz4.d(37): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmpf_0ouyz4.d(38): Error: semicolon expected, not
    `.`\n/tmp/tmpf_0ouyz4.d(38): Error: no identifier for declarator `.Linq`\n/tmp/tmpf_0ouyz4.d(39):
    Error: semicolon expected, not `.`\n/tmp/tmpf_0ouyz4.d(39): Error: no identifier
    for declarator `.Text`\n/tmp/tmpf_0ouyz4.d(40): Error: semicolon expected, not
    `.`\n/tmp/tmpf_0ouyz4.d(40): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_0ouyz4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorIndex = 0;\n    for(int i = 1; i <=\
    \ (int)sqrt(n); i++) {\n        if(n % i == 0) {\n            factors[factorIndex]\
    \ = i;\n            factorCount++;\n            while(n % i == 0) {\n        \
    \        n /= i;\n                factors[factorIndex] = i;\n                factorCount++;\n\
    \            }\n            factorIndex++;\n        }\n    }\n    factors[factorIndex]\
    \ = n;\n    factorCount++;\n    factorIndex++;\n    for(int i = factorIndex; i\
    \ >= 0; i--) {\n        factors[i] *= factorCount;\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=algorithm,primes,math,c# |>\n<| c |>\nThis code doesn't\
    \ work for large numbers. I tested it with numbers like 1000000000000 and it returns\
    \ only 2 factors.\n<|/ c |>\n<| c |>\nI tested it with numbers like 1000000000000\
    \ and it returns only 2 factors.\n<|/ c |>\n<| c |>\nIt returns only 2 factors\
    \ for me too. Maybe it's because I used the wrong number. Try with 1000000000000L\n\
    <|/ c |>\n<| c |>\nYes, it works now. Thanks. I tested it with 1000000000000L\
    \ and it returned only 2 factors.\n<|/ c |>\n<| c |>\nIt returns only 2 factors\
    \ for me too. Maybe it's because I used the wrong number. Try with 1000000000000L\n\
    <|/ c |>\n<| a tags=algorithm,primes,math,c# |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1w7cxtzg.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp1w7cxtzg.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp1w7cxtzg.d(41): Error:
    declaration expected, not `<`\n/tmp/tmp1w7cxtzg.d(44): Error: unterminated character
    constant\n/tmp/tmp1w7cxtzg.d(50): Error: unterminated character constant\n/tmp/tmp1w7cxtzg.d(56):
    Error: unterminated character constant\n/tmp/tmp1w7cxtzg.d(61): Error: semicolon
    expected, not `.`\n/tmp/tmp1w7cxtzg.d(61): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmp1w7cxtzg.d(62): Error: semicolon expected, not
    `.`\n/tmp/tmp1w7cxtzg.d(62): Error: no identifier for declarator `.Linq`\n/tmp/tmp1w7cxtzg.d(63):
    Error: semicolon expected, not `.`\n/tmp/tmp1w7cxtzg.d(63): Error: no identifier
    for declarator `.Text`\n/tmp/tmp1w7cxtzg.d(64): Error: semicolon expected, not
    `.`\n/tmp/tmp1w7cxtzg.d(64): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1w7cxtzg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long lastFactor = 1;\n    long lastFactorCount\
    \ = 1;\n    long lastFactorIndex = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++)\
    \ {\n        if(n % i == 0) {\n            factors[factorCount] = i;\n       \
    \     factorCount++;\n            while(n % i == 0) {\n                n /= i;\n\
    \                factors[factorCount] = i;\n                factorCount++;\n \
    \           }\n            if(lastFactorIndex == factorCount-1) {\n          \
    \      lastFactor = i;\n                lastFactorCount = factorCount;\n     \
    \       }\n            lastFactorIndex = factorCount-1;\n        }\n    }\n  \
    \  factors[factorCount] = n;\n    factorCount++;\n    while(lastFactorIndex !=\
    \ factorCount-1) {\n        factors[factorCount] = lastFactor;\n        factorCount++;\n\
    \        lastFactor = lastFactors[lastFactorIndex];\n        lastFactorCount =\
    \ lastFactorIndex+1;\n        lastFactorIndex = lastFactorCount-1;\n    }\n  \
    \  return factors;\n}\n/*\n Return array of prime factors of given integer in\
    \ the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] factorization) \n\
    {\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    long lastFactor = 1;\n    long lastFactorCount = 1;\n\
    \    long lastFactorIndex = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n\
    \        if(n % i == 0) {\n            factors[factorCount] = i;\n           \
    \ factorCount++;\n            while(n % i == 0) {\n                n /= i;\n \
    \               factors[factorCount] = i;\n                factorCount++;\n  \
    \          }\n            if(lastFactorIndex == factorCount-1) {\n           \
    \     lastFactor = i;\n                lastFactorCount = factorCount;\n      \
    \      }\n            lastFactorIndex = factorCount-1;\n        }\n    }\n   \
    \ factors[factorCount] = n;\n    factorCount++;\n    while(lastFactorIndex !=\
    \ factorCount-1) {\n        factors[factorCount] = lastFactor;\n        factorCount++;\n\
    \        lastFactor = lastFactors[lastFactorIndex];\n        lastFactorCount =\
    \ lastFactorIndex+1;\n        lastFactorIndex = \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy1wjvvvc.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpy1wjvvvc.d(23):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpy1wjvvvc.d(64): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpy1wjvvvc.d(70): Error: C
    style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpy1wjvvvc.d(94): Error: expression
    expected, not `unittest`\n/tmp/tmpy1wjvvvc.d(95): Error: found `{` when expecting
    `;` following statement\n/tmp/tmpy1wjvvvc.d(107): Error: found `End of File` when
    expecting `}` following compound statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpy1wjvvvc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factor++;\n            n /= i;\n            factorCount++;\n    \
    \    }\n    }\n    factors[factorCount] = n;\n    return factors;\n}\n/*\n Return\
    \ array of prime factors of given integer in the order from smallest to largest.\n\
    \    Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors = new\
    \ long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long factorCount = 0;\n\
    \    for(int i = 1; i < factors.length; i++)\n    {\n        while(n % i == 0)\n\
    \        {\n            factors[factorCount] = i;\n            factor++;\n   \
    \         n /= i;\n            factorCount++;\n            if(factorCount >= maxFactors)\n\
    \                break;\n        }\n    }\n    factors[factorCount] = n;\n   \
    \ return factors;\n}\n/*\n Return array of prime factors of given integer in the\
    \ order from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factor++;\n            n /= i;\n            factorCount++;\n    \
    \        if(factorCount >= maxFactors)\n                break;\n            if(factorCount\
    \ >= maxFactorsCount)\n                break;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factor\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmyrobqmb.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmyrobqmb.d(47):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmyrobqmb.d(79):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmyrobqmb.d(99):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmyrobqmb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 0;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    \n    while(p <= r)\n    {\n        while(p <= r)\n        {\n \
    \           while(p <= r)\n            {\n                while(p <= r)\n    \
    \            {\n                    while(p <= r)\n                    {\n   \
    \                     while(p <= r)\n                        {\n             \
    \               while(p <= r)\n                            {\n               \
    \                 while(p <= r)\n                                {\n         \
    \                           while(p <= r)\n                                  \
    \  {\n                                        while(p <= r)\n                \
    \                        {\n                                            while(p\
    \ <= r)\n                                            {\n                     \
    \                           while(p <= r)\n                                  \
    \              {\n                                                    while(p\
    \ <= r)\n                                                    {\n             \
    \                                           while(p <= r)\n                  \
    \                                      {\n                                   \
    \                         while(p <= r)\n                                    \
    \                        {\n                                                 \
    \               while(p <= r)\n                                              \
    \                  {\n                                                       \
    \             while(p <= r)\n                                                \
    \                    {\n                                                     \
    \                   while(p <= r)\n                                          \
    \                              {\n                                           \
    \                                 while(p <= r)\n                            \
    \                                                {\n                         \
    \                                                       while(p <= r)\n      \
    \                                                                          {\n\
    \                                                                            \
    \        while(p <= r)\n                                                     \
    \                               {\n                                          \
    \                                              while(p <= r)\n               \
    \                                                                         {\n\
    \                                                                            \
    \                while(p <= r)\n                                             \
    \                                               {\n                          \
    \                                                                      while(p\
    \ <= r)\n                                                                    \
    \                            {\n                                             \
    \                                                       while(p <= r)\n      \
    \                                                                            \
    \                  {\n                                                       \
    \                                                 while(p <= r)\n            \
    \                                                                            \
    \                {\n                                                         \
    \                                                   while(p <= r)\n          \
    \                                                                            \
    \                      {\n                                                   \
    \                                                             while(p <= r)\n\
    \                                                                            \
    \                                    {\n                                     \
    \                                                                            \
    \   while(p <= r)\n                                                          \
    \                                                          {\n               \
    \                                                                            \
    \                             while(p <= r)\n                                \
    \                                                                            \
    \            {\n                                                             \
    \                                                               while(p <= r)\n\
    \                                                                            \
    \                                                {\n                         \
    \                                                                            \
    \                           while(p <= r)\n                                  \
    \                                                                            \
    \                  {\n                                                       \
    \                                                                            \
    \ while(p <= r)\n                                                            \
    \                                                                        {\n \
    \                                                                            \
    \                                                           while(p <= r)\n  \
    \                                                                            \
    \                                                          {\n               \
    \                                                                            \
    \                                                 while(p <= r)\n            \
    \                                                                            \
    \                                                    {\n                     \
    \                                                                            \
    \                                               while(p <= r)\n              \
    \                                                                            \
    \                                                      {\n                   \
    \                                                                            \
    \                                                     while(p <= r)\n        \
    \                                                                            \
    \                                                                {\n         \
    \                                                                            \
    \                                                                   while(p <=\
    \ r)\n                                                                       \
    \                                                                            \
    \     {\n                                                                    \
    \                                                                            \
    \            while(p <= r)\n                                                 \
    \                                                                            \
    \                               {\n                                          \
    \                                                                            \
    \                                          while(p <= r)\n                   \
    \                                                                            \
    \                                                                 {\n        \
    \                                                                            \
    \                                                                            \
    \    while(p <= r)\n                                                         \
    \                                                                            \
    \                               {\n                                          \
    \                                                                            \
    \                                                  while(p <= r)\n           \
    \                                                                            \
    \                                                                            \
    \     {\n                                                                \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzl19sv2u.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpzl19sv2u.d(115):
    Error: found `unittest` instead of statement\n/tmp/tmpzl19sv2u.d(128): Error:
    found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpzl19sv2u.d(128):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzl19sv2u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplcjoycrc.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmplcjoycrc.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmplcjoycrc.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplcjoycrc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n\
    \        while(n % i == 0)\n        {\n            factors[i] = factor;\n    \
    \        n /= i;\n            counter++;\n        }\n        factor++;\n    }\n\
    \    factors[(int)Math.sqrt(n)] = factor;\n    return factors;\n}\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2puopsqx.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2puopsqx.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp2puopsqx.d(30):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2puopsqx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long factorCount = 0;\n    long factorIndex = 0;\n\
    \    while(p > 1)\n    {\n        factors[factorIndex] = p;\n        factorIndex++;\n\
    \        factorCount++;\n        while(p % factor == 0)\n        {\n         \
    \   p /= factor;\n            factorCount++;\n        }\n        factor++;\n \
    \   }\n    factors[factorIndex] = p;\n    factorIndex++;\n    factors[factorIndex]\
    \ = factorCount;\n    return factors;\n}\n/*\n Return array of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int factorizationSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long p = n;\n    long factor = 1;\n    long factorCount = 0;\n    long factorIndex\
    \ = 0;\n    while(p > 1)\n    {\n        factors[factorIndex] = p;\n        factorIndex++;\n\
    \        factorCount++;\n        while(p % factor == 0)\n        {\n         \
    \   p /= factor;\n            factorCount++;\n        }\n        factor++;\n \
    \   }\n    factors[factorIndex] = p;\n    factorIndex++;\n    factors[factorIndex]\
    \ = factorCount;\n    return factors;\n}\n/*\n Return array of prime factors of\
    \ given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int factorizationSize, int factorizationCount)\n{\n    long[] factors = new\
    \ long[factorizationSize];\n    long p = n;\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    long factorIndex = 0;\n    while(p > 1)\n    {\n        factors[factorIndex]\
    \ = p;\n\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_m7assly.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_m7assly.d(98):
    Error: found `unittest` instead of statement\n/tmp/tmp_m7assly.d(111): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_m7assly.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long factor = 1;\n  \
    \  long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3 =\
    \ 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvk21bwq4.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpvk21bwq4.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvk21bwq4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++)\n    {\n\
    \        factorCount = 0;\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n        if(n\
    \ > 1)\n        {\n            factors[factorCount] = n;\n            factorCount++;\n\
    \        }\n    }\n    factors[factorCount] = 1;\n    return factors;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcm0ujefx.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpcm0ujefx.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpcm0ujefx.d(38): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcm0ujefx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n  \
    \  long[] factors = new long[maxFactors];\n    long factor = 1;\n    long factorCount\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i\
    \ == 0)\n        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int maxFactors, int minFactors)\
    \ \n{\n    long[] factors = new long[maxFactors];\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n \
    \       if(n%i == 0)\n        {\n            factors[factorCount] = i;\n     \
    \       factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjay_2c_y.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpjay_2c_y.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpjay_2c_y.d(49):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpjay_2c_y.d(78):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpjay_2c_y.d(90):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjay_2c_y.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long count = 0;\n    long i = 1;\n    \n    while(factor <= n)\n    {\n \
    \       while(n % factor == 0)\n        {\n            factors[count++] = factor;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    \n    factors[count++]\
    \ = n;\n    \n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ doesn't work. Try factorize(8L).\n<|/ c |>\n<| c |>\nIt works. I tested it before\
    \ posting it. The output was `[2L, 2L, 2L]`\n<|/ c |>\n<| c |>\nI tested it again\
    \ and I got `[2L, 2L, 2L]` as output. Are you sure you tested it correctly?\n\
    <|/ c |>\n<| c |>\nYes, I tested it again. My mistake. Sorry.\n<|/ c |>\n<| c\
    \ |>\nI tested it again and I got `[2L, 2L, 2L]` as output. Are you sure you tested\
    \ it correctly?\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic static void main(String[]\
    \ args) {\n    long n = 8L;\n    long[] factors = new long[(int) Math.sqrt(n)];\n\
    \    long factor = 1;\n    long count = 0;\n    long i = 1;\n    while (factor\
    \ <= n) {\n        while (n % factor == 0) {\n            factors[count++] = factor;\n\
    \            n /= factor;\n        }\n        factor++;\n    }\n    factors[count++]\
    \ = n;\n    System.out.println(Arrays.toString(factors));\n}\n</code>\n<|/ a tags=java,algorithm,primes\
    \ |>\n<| a tags=java,algorithm,primes |>\n<code>\nimport java.util.Arrays;\nimport\
    \ java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqxa9itja.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqxa9itja.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpqxa9itja.d(39): Error: unterminated
    character constant\n/tmp/tmpqxa9itja.d(57): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqxa9itja.d(61):
    Error: declaration expected, not `while`\n/tmp/tmpqxa9itja.d(64): Error: no identifier
    for declarator `n`\n/tmp/tmpqxa9itja.d(64): Error: declaration expected, not `/=`\n/tmp/tmpqxa9itja.d(65):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqxa9itja.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorizationCount = 0;\n    for(int i\
    \ = factors.length - 1; i >= 0; i--)\n    {\n        factorization *= factors[i];\n\
    \        factorizationCount += factors[i];\n        while(factorizationCount >\
    \ n)\n        {\n            factorizationCount -= factors[i];\n            factors[i]\
    \ = factor;\n            factor++;\n        }\n    }\n    return factors;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxhxa8ra1.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpxhxa8ra1.d(34):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxhxa8ra1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcpv3rufm.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcpv3rufm.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpcpv3rufm.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcpv3rufm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)sqrt(n); i++) {\n   \
    \     if(n%i == 0) {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \            n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return\
    \ factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,c++,primes |>\n\
    <code>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\
    using namespace std;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdi6038a4.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpdi6038a4.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpdi6038a4.d(30): Error:
    declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdi6038a4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    for(int i = 0; i < factors.Length; i++)\n    {\n    \
    \    while(p % factor == 0)\n        {\n            factors[(int)i] = factor;\n\
    \            p /= factor;\n            factor++;\n        }\n    }\n    return\
    \ factors;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpedb5e88b.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpedb5e88b.d(24):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpedb5e88b.d(31): Error:
    declaration expected, not `<`\n/tmp/tmpedb5e88b.d(36): Error: identifier expected
    following `package`\n/tmp/tmpedb5e88b.d(36): Error: `;` expected\n/tmp/tmpedb5e88b.d(37):
    Error: identifier expected following `package`\n/tmp/tmpedb5e88b.d(37): Error:
    `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedb5e88b.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long factorization = 1;\n    \n    for(int i\
    \ = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factorization;\n\
    \        factorization *= i;\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n   \
    \         factors[i] = factorization;\n            factorization *= i;\n     \
    \       counter++;\n        }\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factors[i];\n    }\n    \n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    \n    for(int i = 0;\
    \ i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i] = factorization;\n \
    \       factorization *= i;\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        while(n % i == 0)\n        {\n            n /= i;\n   \
    \         factors[i] = factorization;\n            factorization *= i;\n     \
    \       counter++;\n        }\n    }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        factors[i] = factors[i];\n    }\n    \n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors, long[] factorization) \n{\n\
    \    long factor = 1;\n    long counter = 1;\n    long factorization = 1;\n  \
    \  \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplr8fqhzz.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(28):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(39):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(64):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(70):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(81):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplr8fqhzz.d(106):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplr8fqhzz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[factorCount] = i;\n        \
    \    factor++;\n            n /= i;\n            factorCount++;\n        }\n \
    \   }\n    factors[factorCount] = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport\
    \ java.io.*;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3j6wcpra.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3j6wcpra.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp3j6wcpra.d(31):
    Error: declaration expected, not `<`\n/tmp/tmp3j6wcpra.d(36): Error: identifier
    expected following `package`\n/tmp/tmp3j6wcpra.d(36): Error: `;` expected\n/tmp/tmp3j6wcpra.d(37):
    Error: identifier expected following `package`\n/tmp/tmp3j6wcpra.d(37): Error:
    `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3j6wcpra.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    factors[0]\
    \ = 1;\n    for(int i=1; i<factors.length; i++)\n    {\n        while(p % i ==\
    \ 0)\n        {\n            factors[i] = factors[i-1] * i;\n            p /=\
    \ i;\n        }\n    }\n    return factors;\n}\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph6tvwmcd.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6tvwmcd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentCount = 0;\n    for(int i = 0; i <=\
    \ (int)sqrt(n); ++i)\n    {\n        factors[i] = factor;\n        factor += i;\n\
    \    }\n    for(int i = 0; i <= (int)sqrt(n); ++i)\n    {\n        currentCount\
    \ = factorCount;\n        factorCount = factors[i];\n        while(currentCount\
    \ != factorCount)\n        {\n            factors[++i] = factor;\n           \
    \ factor += i;\n            currentCount = factorCount;\n            factorCount\
    \ = factors[i];\n        }\n    }\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,java\
    \ |>\n<| c |>\nThis doesn't work for large numbers. I tested with n = 1000000000\
    \ and it returned [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzyd2_7b7.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpzyd2_7b7.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpzyd2_7b7.d(26): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpzyd2_7b7.d(40): Error: declaration
    expected, not `<`\n/tmp/tmpzyd2_7b7.d(43): Error: unterminated character constant\n/tmp/tmpzyd2_7b7.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpzyd2_7b7.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpzyd2_7b7.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpzyd2_7b7.d(51): Error: declaration expected, not `assert`\n/tmp/tmpzyd2_7b7.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmpzyd2_7b7.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpzyd2_7b7.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpzyd2_7b7.d(55): Error: declaration expected, not `assert`\n/tmp/tmpzyd2_7b7.d(56):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzyd2_7b7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorIndex = 0;\n    for(int i = 1; i <\
    \ factors.length; i++)\n    {\n        factorCount = 0;\n        while(factor\
    \ <= n)\n        {\n            if(n % factor == 0)\n            {\n         \
    \       factors[factorIndex++] = factor;\n                factorCount++;\n   \
    \             n /= factor;\n            }\n            else\n            {\n \
    \               break;\n            }\n        }\n        if(factorCount > 1)\n\
    \        {\n            factors[factorIndex++] = factor;\n            factorCount++;\n\
    \        }\n        factor = factor * i;\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,c#,primes |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoukboo57.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpoukboo57.d(46):
    Error: declaration expected, not `<`\n/tmp/tmpoukboo57.d(51): Error: semicolon
    expected, not `.`\n/tmp/tmpoukboo57.d(51): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmpoukboo57.d(52): Error: semicolon expected, not
    `.`\n/tmp/tmpoukboo57.d(52): Error: no identifier for declarator `.Linq`\n/tmp/tmpoukboo57.d(53):
    Error: semicolon expected, not `.`\n/tmp/tmpoukboo57.d(53): Error: no identifier
    for declarator `.Text`\n/tmp/tmpoukboo57.d(54): Error: semicolon expected, not
    `.`\n/tmp/tmpoukboo57.d(54): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoukboo57.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = 1;\n    long r = 1;\n    long s = 2;\n    long t = 3;\n    long u\
    \ = 3;\n    long v = 3;\n    long w = 3;\n    long x = 2;\n    long y = 2;\n \
    \   long z = 2;\n    long wx = 2;\n    long wy = 2;\n    long wz = 2;\n    long\
    \ xx = 2;\n    long yy = 2;\n    long zz = 2;\n    long xy = 2;\n    long yz =\
    \ 2;\n    long zzz = 2;\n    long xw = 2;\n    long yw = 2;\n    long zw = 2;\n\
    \    long ww = 2;\n    long xx = 2;\n    long yy = 2;\n    long zz = 2;\n    long\
    \ xy = 2;\n    long yz = 2;\n    long zzz = 2;\n    long xw = 2;\n    long yw\
    \ = 2;\n    long zw = 2;\n    long ww = 2;\n    long xx = 2;\n    long yy = 2;\n\
    \    long zz = 2;\n    long xy = 2;\n    long yz = 2;\n    long zzz = 2;\n   \
    \ long xw = 2;\n    long yw = 2;\n    long zw = 2;\n    long ww = 2;\n    long\
    \ xx = 2;\n    long yy = 2;\n    long zz = 2;\n    long xy = 2;\n    long yz =\
    \ 2;\n    long zzz = 2;\n    long xw = 2;\n    long yw = 2;\n    long zw = 2;\n\
    \    long ww = 2;\n    long xx = 2;\n    long yy = 2;\n    long zz = 2;\n    long\
    \ xy = 2;\n    long yz = 2;\n    long zzz = 2;\n    long xw = 2;\n    long yw\
    \ = 2;\n    long zw = 2;\n    long ww = 2;\n    long xx = 2;\n    long yy = 2;\n\
    \    long zz = 2;\n    long xy = 2;\n    long yz = 2;\n    long zzz = 2;\n   \
    \ long xw = 2;\n    long yw = 2;\n    long zw = 2;\n    long ww = 2;\n    long\
    \ xx = 2;\n    long yy = 2;\n    long zz = 2;\n    long xy = 2;\n    long yz =\
    \ 2;\n    long zzz = 2;\n    long xw = 2;\n    long yw = 2;\n    long zw = 2;\n\
    \    long ww = 2;\n    long xx = 2;\n    long yy = 2;\n    long zz = 2;\n    \n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplb8podcb.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplb8podcb.d(106):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmplb8podcb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long factorization = 1;\n    long factorizationCounter\
    \ = 1;\n    long factorizationCounter2 = 1;\n    long factorizationCounter3 =\
    \ 1;\n    long factorizationCounter4 = 1;\n    long factorizationCounter5 = 1;\n\
    \    long factorizationCounter6 = 1;\n    long factorizationCounter7 = 1;\n  \
    \  long factorizationCounter8 = 1;\n    long factorizationCounter9 = 1;\n    long\
    \ factorizationCounter10 = 1;\n    long factorizationCounter11 = 1;\n    long\
    \ factorizationCounter12 = 1;\n    long factorizationCounter13 = 1;\n    long\
    \ factorizationCounter14 = 1;\n    long factorizationCounter15 = 1;\n    long\
    \ factorizationCounter16 = 1;\n    long factorizationCounter17 = 1;\n    long\
    \ factorizationCounter18 = 1;\n    long factorizationCounter19 = 1;\n    long\
    \ factorizationCounter20 = 1;\n    long factorizationCounter21 = 1;\n    long\
    \ factorizationCounter22 = 1;\n    long factorizationCounter23 = 1;\n    long\
    \ factorizationCounter24 = 1;\n    long factorizationCounter25 = 1;\n    long\
    \ factorizationCounter26 = 1;\n    long factorizationCounter27 = 1;\n    long\
    \ factorizationCounter28 = 1;\n    long factorizationCounter29 = 1;\n    long\
    \ factorizationCounter30 = 1;\n    long factorizationCounter31 = 1;\n    long\
    \ factorizationCounter32 = 1;\n    long factorizationCounter33 = 1;\n    long\
    \ factorizationCounter34 = 1;\n    long factorizationCounter35 = 1;\n    long\
    \ factorizationCounter36 = 1;\n    long factorizationCounter37 = 1;\n    long\
    \ factorizationCounter38 = 1;\n    long factorizationCounter39 = 1;\n    long\
    \ factorizationCounter40 = 1;\n    long factorizationCounter41 = 1;\n    long\
    \ factorizationCounter42 = 1;\n    long factorizationCounter43 = 1;\n    long\
    \ factorizationCounter44 = 1;\n    long factorizationCounter45 = 1;\n    long\
    \ factorizationCounter46 = 1;\n    long factorizationCounter47 = 1;\n    long\
    \ factorizationCounter48 = 1;\n    long factorizationCounter49 = 1;\n    long\
    \ factorizationCounter50 = 1;\n    long factorizationCounter51 = 1;\n    long\
    \ factorizationCounter52 = 1;\n    long factorizationCounter53 = 1;\n    long\
    \ factorizationCounter54 = 1;\n    long factorizationCounter55 = 1;\n    long\
    \ factorizationCounter56 = 1;\n    long factorizationCounter57 = 1;\n    long\
    \ factorizationCounter58 = 1;\n    long factorizationCounter59 = 1;\n    long\
    \ factorizationCounter60 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps9c831nt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmps9c831nt.d(81):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmps9c831nt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long count = 0;\n    long p = n;\n    long q = n;\n    \n    while(p != 1)\n\
    \    {\n        while(p % factor == 0)\n        {\n            factors[count++]\
    \ = factor;\n            p /= factor;\n        }\n        factor = 1;\n      \
    \  while(p % factor == 0)\n        {\n            factor *= factor;\n        \
    \    p /= factor;\n        }\n        factors[count++] = factor;\n        factor\
    \ = 1;\n    }\n    \n    while(p != 1)\n    {\n        while(p % factor == 0)\n\
    \        {\n            factors[count++] = factor;\n            p /= factor;\n\
    \        }\n        factor = 1;\n        while(p % factor == 0)\n        {\n \
    \           factor *= factor;\n            p /= factor;\n        }\n        factors[count++]\
    \ = factor;\n        factor = 1;\n    }\n    \n    for(int i = 0; i < count; i++)\n\
    \    {\n        factors[i] = factors[i];\n    }\n    \n    return factors;\n}\n\
    /*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int maxFactors) \n{\n    long[] factors =\
    \ new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long count = 0;\n  \
    \  long p = n;\n    long q = n;\n    \n    while(p != 1)\n    {\n        while(p\
    \ % factor == 0)\n        {\n            factors[count++] = factor;\n        \
    \    p /= factor;\n        }\n        factor = 1;\n        while(p % factor ==\
    \ 0)\n        {\n            factor *= factor;\n            p /= factor;\n   \
    \     }\n        factors[count++] = factor;\n        factor = 1;\n    }\n    \n\
    \    while(p != 1)\n    {\n        while(p % factor == 0)\n        {\n       \
    \     factors[count++] = factor;\n            p /= factor;\n        }\n      \
    \  factor = 1;\n        while(p % factor == 0)\n        {\n            factor\
    \ *= factor;\n            p /= factor;\n        }\n        factors[count++] =\
    \ factor;\n        factor = 1;\n    }\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe1h31zif.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe1h31zif.d(78):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe1h31zif.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpe1h31zif.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 2;\n    factors[0]\
    \ = 1;\n    factors[1] = 1;\n    for(int i = 2; i <= (int)sqrt(n); i++)\n    {\n\
    \        if(n % i == 0)\n        {\n            factors[p] = i;\n            factors[p+1]\
    \ = factors[p] * factors[p];\n            p += 2;\n        }\n    }\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] factors) \n{\n  \
    \  long p = 2;\n    factors[0] = 1;\n    factors[1] = 1;\n    for(int i = 2; i\
    \ <= (int)sqrt(n); i++)\n    {\n        if(n % i == 0)\n        {\n          \
    \  factors[p] = i;\n            factors[p+1] = factors[p] * factors[p];\n    \
    \        p += 2;\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long p =\
    \ 2;\n    factors[start] = 1;\n    factors[start+1] = 1;\n    for(int i = 2; i\
    \ <= (int)sqrt(n); i++)\n    {\n        if(n % i == 0)\n        {\n          \
    \  factors[p] = i;\n            factors[p+1] = factors[p] * factors[p];\n    \
    \        p += 2;\n        }\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2\nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5ev1kvki.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp5ev1kvki.d(21):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp5ev1kvki.d(49): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp5ev1kvki.d(77): Error: C
    style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp5ev1kvki.d(88): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ev1kvki.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long i = 2;\n    while(i <= n)\n    {\n        while(n % i == 0)\n      \
    \  {\n            factors[(int)(i-1)]++;\n            n /= i;\n        }\n   \
    \     i++;\n    }\n    return factors;\n}\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n,\
    \ int maxFactors) \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n   \
    \ long factor = 1;\n    long i = 2;\n    while(i <= n)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[(int)(i-1)]++;\n            n /= i;\n\
    \        }\n        i++;\n    }\n    if(maxFactors == 0)\n        return factors;\n\
    \    long[] factorsCopy = new long[factors.length];\n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        if(factors[i] > maxFactors)\n        {\n            factorsCopy[i]\
    \ = factors[i];\n            factors[i] = maxFactors;\n        }\n        else\n\
    \            factorsCopy[i] = factors[i];\n    }\n    return factorsCopy;\n}\n\
    /*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int maxFactors, int maxFactorsCount) \n{\n\
    \    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n   \
    \ long i = 2;\n    while(i <= n)\n    {\n        while(n % i == 0)\n        {\n\
    \            factors[(int)(i-1)]++;\n            n /= i;\n        }\n        i++;\n\
    \    }\n    if(maxFactors == 0)\n        return factors;\n    long[] factorsCopy\
    \ = new long[factors.length];\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphtd0i27b.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtd0i27b.d(24):
    Error: C style cast illegal, use `cast(int)(i - 1)`\n/tmp/tmphtd0i27b.d(45): Error:
    C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtd0i27b.d(52): Error:
    C style cast illegal, use `cast(int)(i - 1)`\n/tmp/tmphtd0i27b.d(86): Error: C
    style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmphtd0i27b.d(93): Error:
    C style cast illegal, use `cast(int)(i - 1)`\n/tmp/tmphtd0i27b.d(102): Error:
    found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphtd0i27b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long count = 0;\n    long factorization = 1;\n    long factorization2 = 1;\n\
    \    long factorization3 = 1;\n    long factorization4 = 1;\n    long factorization5\
    \ = 1;\n    long factorization6 = 1;\n    long factorization7 = 1;\n    long factorization8\
    \ = 1;\n    long factorization9 = 1;\n    long factorization10 = 1;\n    long\
    \ factorization11 = 1;\n    long factorization12 = 1;\n    long factorization13\
    \ = 1;\n    long factorization14 = 1;\n    long factorization15 = 1;\n    long\
    \ factorization16 = 1;\n    long factorization17 = 1;\n    long factorization18\
    \ = 1;\n    long factorization19 = 1;\n    long factorization20 = 1;\n    long\
    \ factorization21 = 1;\n    long factorization22 = 1;\n    long factorization23\
    \ = 1;\n    long factorization24 = 1;\n    long factorization25 = 1;\n    long\
    \ factorization26 = 1;\n    long factorization27 = 1;\n    long factorization28\
    \ = 1;\n    long factorization29 = 1;\n    long factorization30 = 1;\n    long\
    \ factorization31 = 1;\n    long factorization32 = 1;\n    long factorization33\
    \ = 1;\n    long factorization34 = 1;\n    long factorization35 = 1;\n    long\
    \ factorization36 = 1;\n    long factorization37 = 1;\n    long factorization38\
    \ = 1;\n    long factorization39 = 1;\n    long factorization40 = 1;\n    long\
    \ factorization41 = 1;\n    long factorization42 = 1;\n    long factorization43\
    \ = 1;\n    long factorization44 = 1;\n    long factorization45 = 1;\n    long\
    \ factorization46 = 1;\n    long factorization47 = 1;\n    long factorization48\
    \ = 1;\n    long factorization49 = 1;\n    long factorization50 = 1;\n    long\
    \ factorization51 = 1;\n    long factorization52 = 1;\n    long factorization53\
    \ = 1;\n    long factorization54 = 1;\n    long factorization55 = 1;\n    long\
    \ factorization56 = 1;\n    long factorization57 = 1;\n    long factorization58\
    \ = 1;\n    long factorization59 = 1;\n    long factorization60 = 1;\n    long\
    \ factorization61 = 1;\n    long factorization62 = 1;\n    long factorization63\
    \ = 1;\n    long factorization64 = 1;\n    long factorization65 = 1;\n    long\
    \ factorization66 = 1;\n    long factorization67 = 1;\n    long factorization68\
    \ = 1;\n    long factorization69 = 1;\n    long \nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1lctts8e.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp1lctts8e.d(90):
    Error: no identifier for declarator `long`\n/tmp/tmp1lctts8e.d(90): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lctts8e.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = 1;\n  \
    \  long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u\
    \ = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n \
    \   long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d\
    \ = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n \
    \   long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m\
    \ = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n \
    \   long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v\
    \ = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n \
    \   long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e\
    \ = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n \
    \   long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n\
    \ = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n \
    \   long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w\
    \ = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n \
    \   long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f\
    \ = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n \
    \   long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o\
    \ = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n \
    \   long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x\
    \ = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n \
    \   long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g\
    \ = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprzmg1bbx.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmprzmg1bbx.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmprzmg1bbx.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzmg1bbx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n\
    \    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long\
    \ z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n\
    \    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long\
    \ i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n\
    \    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long\
    \ r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n\
    \    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long\
    \ j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n\
    \    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long\
    \ s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n\
    \    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long\
    \ b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n\
    \    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long\
    \ k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqryolzav.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpqryolzav.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqryolzav.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqryolzav.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long i = 1;\n    \n    while(factorCount < factors.length)\n\
    \    {\n        while(n % i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n        i++;\n\
    \    }\n    \n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_aexf6vo.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_aexf6vo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long limit = n;\n    while(limit > 1)\n    {\n   \
    \     while(n % factor == 0)\n        {\n            factors[counter] = factor;\n\
    \            n /= factor;\n            counter++;\n        }\n        factor++;\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a tags=primes,algorithm,c#,factorization\
    \ |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppe4ymu3o.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmppe4ymu3o.d(33):
    Error: declaration expected, not `<`\n/tmp/tmppe4ymu3o.d(38): Error: semicolon
    expected, not `.`\n/tmp/tmppe4ymu3o.d(38): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmppe4ymu3o.d(39): Error: semicolon expected, not
    `.`\n/tmp/tmppe4ymu3o.d(39): Error: no identifier for declarator `.Linq`\n/tmp/tmppe4ymu3o.d(40):
    Error: semicolon expected, not `.`\n/tmp/tmppe4ymu3o.d(40): Error: no identifier
    for declarator `.Text`\n/tmp/tmppe4ymu3o.d(41): Error: semicolon expected, not
    `.`\n/tmp/tmppe4ymu3o.d(41): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppe4ymu3o.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long i = 2;\n    while(i < n)\n    {\n        while(n % i == 0)\n       \
    \ {\n            factors[(int)(i/factor)] = factor;\n            n /= i;\n   \
    \     }\n        i++;\n        factor++;\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,primes,factorization,c# |>\n<| a tags=algorithm,primes,factorization,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn7z0jg9_.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpn7z0jg9_.d(24):
    Error: C style cast illegal, use `cast(int)(i / factor)`\n/tmp/tmpn7z0jg9_.d(32):
    Error: declaration expected, not `<`\n/tmp/tmpn7z0jg9_.d(37): Error: semicolon
    expected, not `.`\n/tmp/tmpn7z0jg9_.d(37): Error: no identifier for declarator
    `.Collections.Generic`\n/tmp/tmpn7z0jg9_.d(38): Error: semicolon expected, not
    `.`\n/tmp/tmpn7z0jg9_.d(38): Error: no identifier for declarator `.Linq`\n/tmp/tmpn7z0jg9_.d(39):
    Error: semicolon expected, not `.`\n/tmp/tmpn7z0jg9_.d(39): Error: no identifier
    for declarator `.Text`\n/tmp/tmpn7z0jg9_.d(40): Error: semicolon expected, not
    `.`\n/tmp/tmpn7z0jg9_.d(40): Error: no identifier for declarator `.Threading.Tasks`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7z0jg9_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i<factors.length;\
    \ i++)\n    {\n        while(p % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            p /= factor;\n        }\n        factor *= i;\n    }\n\
    \    return factors;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,primes,math,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe4u_1dc1.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpe4u_1dc1.d(32):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpe4u_1dc1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx6fckmi5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpx6fckmi5.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpx6fckmi5.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6fckmi5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    long temp;\n    \n    while(factor <= n)\n  \
    \  {\n        temp = factor;\n        while(temp % factor == 0)\n        {\n \
    \           factors[counter] = factor;\n            temp /= factor;\n        \
    \    counter++;\n        }\n        factor++;\n    }\n    \n    return factors;\n\
    }\n</code>\n<|/ a tags=algorithm,primes,math,c# |>\n<| c |>\nThis code does not\
    \ work for large numbers. I tested it with n = 1000000000 and it returned [2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n    alias candidate =\
    \ factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) ==\
    \ [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmi8xio_3.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpmi8xio_3.d(36):
    Error: declaration expected, not `<`\n/tmp/tmpmi8xio_3.d(44): Error: declaration
    expected, not `assert`\n/tmp/tmpmi8xio_3.d(45): Error: declaration expected, not
    `assert`\n/tmp/tmpmi8xio_3.d(46): Error: declaration expected, not `assert`\n/tmp/tmpmi8xio_3.d(47):
    Error: declaration expected, not `assert`\n/tmp/tmpmi8xio_3.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmpmi8xio_3.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmpmi8xio_3.d(50): Error: declaration expected, not `assert`\n/tmp/tmpmi8xio_3.d(51):
    Error: declaration expected, not `assert`\n/tmp/tmpmi8xio_3.d(52): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmi8xio_3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 2;\n    long\
    \ factor = 1;\n    long factorCount = 0;\n    while(p <= n)\n    {\n        factors[factorCount++]\
    \ = p;\n        factor *= p;\n        while(p <= n && n % p == 0)\n        {\n\
    \            n /= p;\n            factor++;\n        }\n        p++;\n    }\n\
    \    factors[factorCount] = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp75cfshdl.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp75cfshdl.d(35):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp75cfshdl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt6j_alqa.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpt6j_alqa.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpt6j_alqa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        factorCount = 0;\n        while(factor <= n && n % factor == 0)\n\
    \        {\n            factors[factorCount++] = factor;\n            n /= factor;\n\
    \        }\n        if(n > 1)\n        {\n            factors[factorCount++] =\
    \ n;\n        }\n        factor = factors[factorCount-1];\n    }\n    return factors;\n\
    }\n</code>\n<|/ a tags=math,algorithm,primes,java |>\n<| c |>\nThis code does\
    \ not work. Try factorize(8L).\n<|/ c |>\n<| c |>\nI tested it and it works. I\
    \ used the example you provided. What do you mean by \"does not work\"?\n<|/ c\
    \ |>\n<| c |>\nI mean it returns wrong results. Try factorize(8L).\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I used the example you provided. What do you\
    \ mean by \"does not work\"?\n<|/ c |>\n<| c |>\nI mean it returns wrong results.\
    \ Try factorize(8L).\n<|/ c |>\n<| a tags=math,algorithm,primes,java |>\n<code>\n\
    import java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp73_9u0r_.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp73_9u0r_.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp73_9u0r_.d(36):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp73_9u0r_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    long currentCount = 1;\n    long currentFactor\
    \ = 1;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++) {\n        factors[factorCount]\
    \ = i;\n        factorCount++;\n    }\n    for(int i = factorCount; i >= 0; i--)\
    \ {\n        currentCount = 1;\n        currentFactor = factors[i];\n        for(int\
    \ j = factorCount; j >= i; j--) {\n            if(currentFactor*factors[j] ==\
    \ n) {\n                currentCount++;\n            }\n        }\n        factors[i]\
    \ = currentCount;\n    }\n    return factors;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI believe this algorithm is O(n^2) because of the nested for loops.\n\
    <|/ c |>\n<| c |>\nYes, it is O(n^2). But the nested for loops are only executed\
    \ once per outer loop. So, it is O(n).\n<|/ c |>\n<| c |>\nI believe this algorithm\
    \ is O(n^2) because of the nested for loops.\n<|/ c |>\n<| c |>\nThe nested for\
    \ loops are only executed once per outer loop. So, it is O(n).\n<|/ c |>\n<| c\
    \ |>\nI believe this algorithm is O(n^2) because of the nested for loops.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>\npublic class PrimeFactors\n{\n    public static\
    \ void main(String[] args)\n    {\n        long n = Integer.parseInt(args[0]);\n\
    \        long factor = 1;\n        long factorCount = 0;\n        long currentCount\
    \ = 1;\n        long currentFactor = 1;\n        for(int i = 1; i <= n; i++)\n\
    \        {\n            factors[factorCount] = i;\n            factorCount++;\n\
    \        }\n        for(int i = factorCount; i >= 0; i--)\n        {\n       \
    \     currentCount = 1;\n            currentFactor = factors[i];\n           \
    \ for(int j = factorCount; j >= i; j--)\n            {\n                if(currentFactor*factors[j]\
    \ == n)\n                {\n                    currentCount++;\n            \
    \    }\n            }\n            factors[i] = currentCount;\n        }\n   \
    \     System.out.println(Arrays.toString(factors));\n    }\n}\n</code>\n<|/ a\
    \ tags=algorithm,java,primes |>\n<| a tags=algorithm,java,primes |>\n<code>\n\
    import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx3lo9lbe.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpx3lo9lbe.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpx3lo9lbe.d(38):
    Error: declaration expected, not `<`\n/tmp/tmpx3lo9lbe.d(66): Error: declaration
    expected, not `for`\n/tmp/tmpx3lo9lbe.d(66): Error: no identifier for declarator
    `i`\n/tmp/tmpx3lo9lbe.d(66): Error: declaration expected, not `<=`\n/tmp/tmpx3lo9lbe.d(66):
    Error: no identifier for declarator `i`\n/tmp/tmpx3lo9lbe.d(66): Error: declaration
    expected, not `++`\n/tmp/tmpx3lo9lbe.d(69): Error: no identifier for declarator
    `factorCount`\n/tmp/tmpx3lo9lbe.d(69): Error: declaration expected, not `++`\n/tmp/tmpx3lo9lbe.d(70):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx3lo9lbe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n\
    \    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long\
    \ z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n\
    \    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long\
    \ i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n\
    \    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long\
    \ r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n\
    \    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long\
    \ j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n\
    \    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long\
    \ s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n\
    \    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long\
    \ b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n\
    \    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long\
    \ k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqryolzav.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpqryolzav.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqryolzav.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqryolzav.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long factor = 1;\n    long i = 1;\n    while(p > 1) {\n        while(p %\
    \ i == 0) {\n            factors[i] = factor;\n            p /= i;\n         \
    \   i++;\n        }\n        factor++;\n    }\n    factors[(int)Math.sqrt(n)]\
    \ = factor;\n    return factors;\n}\n</code>\n<|/ a |>\n<| a tags=math,algorithm,primes,java\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4tc9m_zx.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp4tc9m_zx.d(29):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp4tc9m_zx.d(32):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4tc9m_zx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n\
    \    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long\
    \ z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n\
    \    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long\
    \ i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n\
    \    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long\
    \ r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n\
    \    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long\
    \ j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n\
    \    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long\
    \ s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n\
    \    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long\
    \ b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n\
    \    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long\
    \ k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long k = \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0qp1tfiw.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0qp1tfiw.d(118):
    Error: expression expected, not `unittest`\n/tmp/tmp0qp1tfiw.d(119): Error: semicolon
    expected, not `{`\n/tmp/tmp0qp1tfiw.d(131): Error: found `End of File` when expecting
    `}` following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qp1tfiw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqiy2nrke.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpqiy2nrke.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqiy2nrke.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqiy2nrke.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 1; i <= (int)Math.sqrt(n); i++)\
    \ {\n        while(n % i == 0) {\n            factors[factorCount] = i;\n    \
    \        n /= i;\n            factorCount++;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcrw30s_i.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcrw30s_i.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpcrw30s_i.d(30):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpcrw30s_i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3\
    \ = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0t6iyimc.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0t6iyimc.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0t6iyimc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx6fckmi5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpx6fckmi5.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpx6fckmi5.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6fckmi5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorizationCount = 0;\n    long factorizationSum\
    \ = 0;\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        factors[i]\
    \ = factor;\n        factorizationSum += factor;\n        factorizationCount +=\
    \ 1;\n        \n        while(factorizationCount != i) {\n            factorization\
    \ *= factor;\n            factorizationSum += factor;\n            factorizationCount\
    \ += 1;\n        }\n        \n        factorization = factorizationSum / factorizationCount;\n\
    \        \n        while(n % factor == 0) {\n            factorizationSum += factor;\n\
    \            factorizationCount += 1;\n            n /= factor;\n        }\n \
    \   }\n    \n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n        factors[i]\
    \ = factor;\n        factorizationSum += factor;\n        factorizationCount +=\
    \ 1;\n        \n        while(factorizationCount != i) {\n            factorization\
    \ *= factor;\n            factorizationSum += factor;\n            factorizationCount\
    \ += 1;\n        }\n        \n        factorization = factorizationSum / factorizationCount;\n\
    \        \n        while(n % factor == 0) {\n            factorizationSum += factor;\n\
    \            factorizationCount += 1;\n            n /= factor;\n        }\n \
    \   }\n    \n    return factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvf5jq4id.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpvf5jq4id.d(23):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpvf5jq4id.d(43):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpvf5jq4id.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long p = n;\n  \
    \  long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u\
    \ = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n \
    \   long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d\
    \ = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n \
    \   long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m\
    \ = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n \
    \   long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v\
    \ = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n \
    \   long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e\
    \ = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n \
    \   long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n\
    \ = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n \
    \   long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w\
    \ = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n \
    \   long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f\
    \ = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n \
    \   long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o\
    \ = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n \
    \   long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x\
    \ = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n \
    \   long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g\
    \ = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5nux63jm.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmp5nux63jm.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp5nux63jm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = n;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx6fckmi5.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpx6fckmi5.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpx6fckmi5.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx6fckmi5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  for(int i = 0; i < factors.length; i++)\n    {\n        while(p % 2 == 0)\n\
    \        {\n            p /= 2;\n            factors[i] = 2;\n        }\n    \
    \    while(p % 3 == 0)\n        {\n            p /= 3;\n            factors[i]\
    \ = 3;\n        }\n        while(p % 5 == 0)\n        {\n            p /= 5;\n\
    \            factors[i] = 5;\n        }\n        while(p % 7 == 0)\n        {\n\
    \            p /= 7;\n            factors[i] = 7;\n        }\n        while(p\
    \ % 11 == 0)\n        {\n            p /= 11;\n            factors[i] = 11;\n\
    \        }\n        while(p % 13 == 0)\n        {\n            p /= 13;\n    \
    \        factors[i] = 13;\n        }\n        while(p % 17 == 0)\n        {\n\
    \            p /= 17;\n            factors[i] = 17;\n        }\n        while(p\
    \ % 19 == 0)\n        {\n            p /= 19;\n            factors[i] = 19;\n\
    \        }\n        while(p % 23 == 0)\n        {\n            p /= 23;\n    \
    \        factors[i] = 23;\n        }\n        while(p % 29 == 0)\n        {\n\
    \            p /= 29;\n            factors[i] = 29;\n        }\n        while(p\
    \ % 31 == 0)\n        {\n            p /= 31;\n            factors[i] = 31;\n\
    \        }\n        while(p % 37 == 0)\n        {\n            p /= 37;\n    \
    \        factors[i] = 37;\n        }\n        while(p % 41 == 0)\n        {\n\
    \            p /= 41;\n            factors[i] = 41;\n        }\n        while(p\
    \ % 43 == 0)\n        {\n            p /= 43;\n            factors[i] = 43;\n\
    \        }\n        while(p % 47 == 0)\n        {\n            p /= 47;\n    \
    \        factors[i] = 47;\n        }\n        while(p % 53 == 0)\n        {\n\
    \            p /= 53;\n            factors[i] = 53;\n        }\n        while(p\
    \ % 59 == 0)\n        {\n            p /= 59;\n            factors[i] = 59;\n\
    \        }\n        while(p % 61 == 0)\n        {\n            p /= 61;\n    \
    \        factors[i] = 61;\n        }\n        while(p % 67 == 0)\n        {\n\
    \            p /= 67;\n            factors[i] = 67;\n        }\n        while(p\
    \ % 71 == 0)\n        {\n            p /= 71;\n            factors[i] = 71;\n\
    \        }\n        while(p % 73 == 0)\n        {\n            p /= 73;\n    \
    \        factors[i] = \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp21og71li.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp21og71li.d(125):
    Error: expression expected, not `unittest`\n/tmp/tmp21og71li.d(126): Error: found
    `{` when expecting `;` following statement\n/tmp/tmp21og71li.d(138): Error: found
    `End of File` when expecting `}` following compound statement\n/tmp/tmp21og71li.d(138):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21og71li.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    \n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        while(p % factor == 0)\n        {\n            factors[factorCount]\
    \ = factor;\n            factorCount++;\n            p /= factor;\n          \
    \  factor++;\n        }\n    }\n    \n    return factors;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy5fq2dlf.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpy5fq2dlf.d(35):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpy5fq2dlf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = 1;\n    long r = n;\n    long m = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbtfqox98.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpbtfqox98.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpbtfqox98.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtfqox98.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            factors[factorCount] = i;\n\
    \            factorCount++;\n            n /= i;\n        }\n    }\n    factors[factorCount]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] factors) \n{\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n);\
    \ i++)\n    {\n        if(n%i == 0)\n        {\n            factors[factorCount]\
    \ = i;\n            factorCount++;\n            n /= i;\n        }\n    }\n  \
    \  factors[factorCount] = n;\n    return factors;\n}\n/*\n Return array of prime\
    \ factors of given integer in the order from smallest to largest.\n    Each of\
    \ the factors should be arrayed number of times corresponding to how many times\
    \ it appeares in factorization.\n    Input number should be equal to the product\
    \ of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n\
    \    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long\
    \ n, long[] factors, int factorCount) \n{\n    long factor = 1;\n    for(int i\
    \ = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        if(n%i == 0)\n        {\n\
    \            factors[factorCount] = i;\n            factorCount++;\n         \
    \   n /= i;\n        }\n    }\n    factors[factorCount] = n;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplvrlmjuz.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplvrlmjuz.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplvrlmjuz.d(48):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplvrlmjuz.d(75):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmplvrlmjuz.d(87):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvrlmjuz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorization2 = 1;\n    long factorization3\
    \ = 1;\n    long factorization4 = 1;\n    long factorization5 = 1;\n    long factorization6\
    \ = 1;\n    long factorization7 = 1;\n    long factorization8 = 1;\n    long factorization9\
    \ = 1;\n    long factorization10 = 1;\n    long factorization11 = 1;\n    long\
    \ factorization12 = 1;\n    long factorization13 = 1;\n    long factorization14\
    \ = 1;\n    long factorization15 = 1;\n    long factorization16 = 1;\n    long\
    \ factorization17 = 1;\n    long factorization18 = 1;\n    long factorization19\
    \ = 1;\n    long factorization20 = 1;\n    long factorization21 = 1;\n    long\
    \ factorization22 = 1;\n    long factorization23 = 1;\n    long factorization24\
    \ = 1;\n    long factorization25 = 1;\n    long factorization26 = 1;\n    long\
    \ factorization27 = 1;\n    long factorization28 = 1;\n    long factorization29\
    \ = 1;\n    long factorization30 = 1;\n    long factorization31 = 1;\n    long\
    \ factorization32 = 1;\n    long factorization33 = 1;\n    long factorization34\
    \ = 1;\n    long factorization35 = 1;\n    long factorization36 = 1;\n    long\
    \ factorization37 = 1;\n    long factorization38 = 1;\n    long factorization39\
    \ = 1;\n    long factorization40 = 1;\n    long factorization41 = 1;\n    long\
    \ factorization42 = 1;\n    long factorization43 = 1;\n    long factorization44\
    \ = 1;\n    long factorization45 = 1;\n    long factorization46 = 1;\n    long\
    \ factorization47 = 1;\n    long factorization48 = 1;\n    long factorization49\
    \ = 1;\n    long factorization50 = 1;\n    long factorization51 = 1;\n    long\
    \ factorization52 = 1;\n    long factorization53 = 1;\n    long factorization54\
    \ = 1;\n    long factorization55 = 1;\n    long factorization56 = 1;\n    long\
    \ factorization57 = 1;\n    long factorization58 = 1;\n    long factorization59\
    \ = 1;\n    long factorization60 = 1;\n    long factorization61 = 1;\n    long\
    \ factorization62 = 1;\n    long factorization63 = 1;\n    long factorization64\
    \ = 1;\n    long factorization65 = 1;\n    long factorization66 = 1;\n    long\
    \ factorization67 = 1;\n    long factorization68 = 1;\n    long factorization69\
    \ = 1;\n    long factorization70 = 1;\nunittest\n{\n    alias candidate = factorize;\n\
    \n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n\
    \    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L,\
    \ 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxnfdhgge.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpxnfdhgge.d(89):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxnfdhgge.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n        while(n\
    \ % i == 0) {\n            factors[count] = i;\n            n /= i;\n        \
    \    count++;\n        }\n    }\n    factors[count] = n;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors) \n{\n    long factor = 1;\n\
    \    long count = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n        while(n\
    \ % i == 0) {\n            factors[count] = i;\n            n /= i;\n        \
    \    count++;\n        }\n    }\n    factors[count] = n;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, long[] factors, int start) \n{\n    long factor\
    \ = 1;\n    long count = 0;\n    for(int i = start; i <= (int)sqrt(n); i++) {\n\
    \        while(n % i == 0) {\n            factors[count] = i;\n            n /=\
    \ i;\n            count++;\n        }\n    }\n    factors[count] = n;\n    return\
    \ factors;\n}\n/*\n Return array of prime factors of given integer in the order\
    \ from smallest to largest.\n    Each of the factors should be arrayed number\
    \ of times corresponding to how many times it appeares in factorization.\n   \
    \ Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, long[] \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0y984ts1.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0y984ts1.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0y984ts1.d(46): Error:
    C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0y984ts1.d(72): Error: C
    style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp0y984ts1.d(95): Error: found
    `unittest` when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0y984ts1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long i = 2;\n    long j = 0;\n    while(i <=\
    \ n)\n    {\n        while(n % i == 0)\n        {\n            factors[factor_count]\
    \ = i;\n            n /= i;\n            factor_count++;\n        }\n        i++;\n\
    \    }\n    factors[factor_count] = n;\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorization_size)\n{\n    long[] factors\
    \ = new long[factorization_size];\n    long factor = 1;\n    long factor_count\
    \ = 1;\n    long i = 2;\n    long j = 0;\n    while(i <= n)\n    {\n        while(n\
    \ % i == 0)\n        {\n            factors[factor_count] = i;\n            n\
    \ /= i;\n            factor_count++;\n        }\n        i++;\n    }\n    factors[factor_count]\
    \ = n;\n    return factors;\n}\n/*\n Return array of prime factors of given integer\
    \ in the order from smallest to largest.\n    Each of the factors should be arrayed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L,\
    \ 2)\n    [2L, 2L, 2L]\n    >>> factorize(25L, 2)\n    [5L, 5L]\n    >>> factorize(70L,\
    \ 2)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorization_size,\
    \ int max_factorization_size)\n{\n    long[] factors = new long[max_factorization_size];\n\
    \    long factor = 1;\n    long factor_count = 1;\n    long i = 2;\n    long j\
    \ = 0;\n    while(i <= n)\n    {\n        while(n % i == 0)\n        {\n     \
    \       factors[factor_count] = i;\n            n /= i;\n            factor_count++;\n\
    \        }\n        i++;\n    }\n    factors[factor_count] = n;\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp653ho92w.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp653ho92w.d(99):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp653ho92w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCountMax = factors.Length;\n    long\
    \ factorCountMin = factorCountMax;\n    long factorCountMin2 = factorCountMax;\n\
    \    long factorCountMin3 = factorCountMax;\n    long factorCountMin4 = factorCountMax;\n\
    \    long factorCountMin5 = factorCountMax;\n    long factorCountMin6 = factorCountMax;\n\
    \    long factorCountMin7 = factorCountMax;\n    long factorCountMin8 = factorCountMax;\n\
    \    long factorCountMin9 = factorCountMax;\n    long factorCountMin10 = factorCountMax;\n\
    \    long factorCountMin11 = factorCountMax;\n    long factorCountMin12 = factorCountMax;\n\
    \    long factorCountMin13 = factorCountMax;\n    long factorCountMin14 = factorCountMax;\n\
    \    long factorCountMin15 = factorCountMax;\n    long factorCountMin16 = factorCountMax;\n\
    \    long factorCountMin17 = factorCountMax;\n    long factorCountMin18 = factorCountMax;\n\
    \    long factorCountMin19 = factorCountMax;\n    long factorCountMin20 = factorCountMax;\n\
    \    long factorCountMin21 = factorCountMax;\n    long factorCountMin22 = factorCountMax;\n\
    \    long factorCountMin23 = factorCountMax;\n    long factorCountMin24 = factorCountMax;\n\
    \    long factorCountMin25 = factorCountMax;\n    long factorCountMin26 = factorCountMax;\n\
    \    long factorCountMin27 = factorCountMax;\n    long factorCountMin28 = factorCountMax;\n\
    \    long factorCountMin29 = factorCountMax;\n    long factorCountMin30 = factorCountMax;\n\
    \    long factorCountMin31 = factorCountMax;\n    long factorCountMin32 = factorCountMax;\n\
    \    long factorCountMin33 = factorCountMax;\n    long factorCountMin34 = factorCountMax;\n\
    \    long factorCountMin35 = factorCountMax;\n    long factorCountMin36 = factorCountMax;\n\
    \    long factorCountMin37 = factorCountMax;\n    long factorCountMin38 = factorCountMax;\n\
    \    long factorCountMin39 = factorCountMax;\n    long factorCountMin40 = factorCountMax;\n\
    \    long factorCountMin\nunittest\n{\n    alias candidate = factorize;\n\n  \
    \  assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n  \
    \  assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5ompqinq.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmp5ompqinq.d(62):
    Error: semicolon expected, not `unittest`\n/tmp/tmp5ompqinq.d(62): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ompqinq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++) {\n\
    \        factorCount = 0;\n        while(n % factor == 0) {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor = factors[factorCount-1];\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a tags=c#,algorithm,primes |>\n<|\
    \ c |>\nThis code doesn't work for large numbers. For example, factorize(8L) returns\
    \ [2, 2, 2] instead of [2, 2, 2, 2, 2].\n<|/ c |>\n<| c |>\nYes, I tested it with\
    \ 8L and it returned [2, 2, 2, 2, 2]. I'll update the answer to include a more\
    \ efficient solution.\n<|/ c |>\n<| c |>\nI tested it with 8L and it returned\
    \ [2, 2, 2, 2, 2]. I'll update the answer to include a more efficient solution.\n\
    <|/ c |>\n<| c |>\nI tested it with 8L and it returned [2, 2, 2, 2, 2]. I'll update\
    \ the answer to include a more efficient solution.\n<|/ c |>\n<| c |>\nI tested\
    \ it with 8L and it returned [2, 2, 2, 2, 2]. I'll update the answer to include\
    \ a more efficient solution.\n<|/ c |>\n<| a |>\n<code>\npublic static bool IsPrime(long\
    \ n)\n{\n    if (n == 1)\n    {\n        return false;\n    }\n    if (n == 2)\n\
    \    {\n        return true;\n    }\n    if (n % 2 == 0)\n    {\n        return\
    \ false;\n    }\n    long limit = (long)Math.Sqrt(n) + 1;\n    for (int i = 3;\
    \ i <= limit; i = i + 2)\n    {\n        if (n % i == 0)\n        {\n        \
    \    return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfbmry66p.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfbmry66p.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfbmry66p.d(30):
    Error: declaration expected, not `<`\n/tmp/tmpfbmry66p.d(33): Error: unterminated
    character constant\n/tmp/tmpfbmry66p.d(36): Error: unterminated character constant\n/tmp/tmpfbmry66p.d(39):
    Error: unterminated character constant\n/tmp/tmpfbmry66p.d(42): Error: unterminated
    character constant\n/tmp/tmpfbmry66p.d(45): Error: unterminated character constant\n/tmp/tmpfbmry66p.d(54):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbmry66p.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    \n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        temp = factor;\n        while(temp * factor <= n)\n   \
    \     {\n            counter++;\n            temp *= factor;\n        }\n    \
    \    factors[i] = counter;\n        factor *= n;\n    }\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it appeares in factorization.\n    Input number should be\
    \ equal to the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n\
    \    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n\
    \    \n*/\nlong[] factorize(long n, int factorizationOrder) \n{\n    long[] factors\
    \ = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n    long counter = 1;\n\
    \    long temp;\n    \n    for(int i = 0; i < factors.length; i++)\n    {\n  \
    \      temp = factor;\n        while(temp * factor <= n)\n        {\n        \
    \    counter++;\n            temp *= factor;\n        }\n        factors[i] =\
    \ counter;\n        factor *= n;\n    }\n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L, 2)\n    [2L, 2L, 2L]\n   \
    \ >>> factorize(25L, 2)\n    [5L, 5L]\n    >>> factorize(70L, 2)\n    [2L, 5L,\
    \ 7L]\n    \n*/\nlong[] factorize(long n, int factorizationOrder, int factorizationOrderLimit)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long counter = 1;\n    long temp;\n    \n    for(int i = 0; i < factors.length;\
    \ i++)\n    {\n        temp = factor;\n        while(temp * factor <= n)\n   \
    \     {\n            counter++;\n            temp *= factor;\n        }\n    \
    \    factors[i] = counter;\n        factor *= n;\n    }\n    return factors;\n\
    }\n/*\n Return array of prime factors of given integer in the order from smallest\
    \ to largest.\n    Each of the factors should be arrayed number of times corresponding\
    \ to how many times it \nunittest\n{\n    alias candidate = factorize;\n\n   \
    \ assert(candidate(2L) == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n   \
    \ assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n\
    \    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz4n78v0r.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpz4n78v0r.d(49):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpz4n78v0r.d(81):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpz4n78v0r.d(99):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz4n78v0r.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = 1;\n    long\
    \ q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv6fb96mu.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpv6fb96mu.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpv6fb96mu.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6fb96mu.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorization = 1;\n    long factorizationCount = 0;\n    \n    for(long\
    \ i = 1; i <= n; i++)\n    {\n        factorizationCount += factorization;\n \
    \       factorization *= i;\n        \n        for(long j = 1; j <= factorizationCount;\
    \ j++)\n        {\n            if(factorization%j == 0)\n            {\n     \
    \           factors[factorizationCount] = j;\n                factorizationCount\
    \ += 1;\n                break;\n            }\n        }\n    }\n    \n    return\
    \ factors;\n}\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6sj_0emo.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sj_0emo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\
    \ {\n        factors[i] = factor;\n        factor *= i;\n        factorCount++;\n\
    \    }\n    for(int i = factorCount; i > 0; i--) {\n        while(n % factors[i]\
    \ == 0) {\n            n /= factors[i];\n            factorCount--;\n        }\n\
    \    }\n    return factors;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nunittest\n{\n   \
    \ alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_72500ki.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_72500ki.d(20):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp_72500ki.d(33):
    Error: declaration expected, not `<`\n/tmp/tmp_72500ki.d(38): Error: identifier
    expected following `package`\n/tmp/tmp_72500ki.d(38): Error: `;` expected\n/tmp/tmp_72500ki.d(39):
    Error: identifier expected following `package`\n/tmp/tmp_72500ki.d(39): Error:
    `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_72500ki.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i <= (int)sqrt(n); i++) {\n   \
    \     factors[factorCount] = i;\n        factorCount++;\n        factor *= i;\n\
    \    }\n    factors[factorCount] = n;\n    factorCount++;\n    for(int i = 0;\
    \ i <= factorCount; i++) {\n        factors[factorCount] = factor;\n        factorCount++;\n\
    \        factor *= factors[i];\n    }\n    return factors;\n}\n</code>\n<|/ a\
    \ tags=c#,algorithm,primes,math |>\n<| c |>\nThis code doesn't work for large\
    \ numbers. I tested it on `factorize(1000000007)` and it returned `[2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \nunittest\n{\n\
    \    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp555ia4r2.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp555ia4r2.d(20):
    Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmp555ia4r2.d(34): Error:
    declaration expected, not `<`\n/tmp/tmp555ia4r2.d(37): Error: unterminated character
    constant\n/tmp/tmp555ia4r2.d(37): Error: unterminated string constant starting
    at /tmp/tmp555ia4r2.d(37)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp555ia4r2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long lastFactor = 1;\n    long lastFactorCount\
    \ = 0;\n    for(int i = 0; i <= (int)Math.sqrt(n); i++)\n    {\n        factors[i]\
    \ = factor;\n        factorCount += 1;\n        factor *= i;\n        while(factor\
    \ > 1 && factorCount > 0)\n        {\n            factorCount -= 1;\n        \
    \    factor /= i;\n        }\n        if(factor == 1)\n        {\n           \
    \ factors[(int)Math.sqrt(n)] = factor;\n            factorCount += 1;\n      \
    \  }\n    }\n    for(int i = factorCount - 1; i >= 0; i--)\n    {\n        if(factors[i]\
    \ == 1)\n        {\n            factors[(int)Math.sqrt(n)] = factors[i];\n   \
    \         factorCount += 1;\n        }\n    }\n    for(int i = factorCount - 1;\
    \ i >= 0; i--)\n    {\n        if(factors[i] == 1)\n        {\n            factors[(int)Math.sqrt(n)]\
    \ = factors[i];\n            factorCount += 1;\n        }\n    }\n    for(int\
    \ i = factorCount - 1; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n    \
    \    {\n            factors[(int)Math.sqrt(n)] = factors[i];\n            factorCount\
    \ += 1;\n        }\n    }\n    for(int i = factorCount - 1; i >= 0; i--)\n   \
    \ {\n        if(factors[i] == 1)\n        {\n            factors[(int)Math.sqrt(n)]\
    \ = factors[i];\n            factorCount += 1;\n        }\n    }\n    for(int\
    \ i = factorCount - 1; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n    \
    \    {\n            factors[(int)Math.sqrt(n)] = factors[i];\n            factorCount\
    \ += 1;\n        }\n    }\n    for(int i = factorCount - 1; i >= 0; i--)\n   \
    \ {\n        if(factors[i] == 1)\n        {\n            factors[(int)Math.sqrt(n)]\
    \ = factors[i];\n            factorCount += 1;\n        }\n    }\n    for(int\
    \ i = factorCount - 1; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n    \
    \    {\n            factors[(int)Math.sqrt(n)] = factors[i];\n            factorCount\
    \ += 1;\n        }\n    }\n    for(int i = factorCount - 1; i >= 0; i--)\n   \
    \ {\n        if(factors[i] == 1)\n        {\n            factors[(int)Math.sqrt(n)]\
    \ = factors[i];\n            factorCount += 1;\n        }\n    }\n    for(int\
    \ i = factorCount - 1; i >= 0; i--)\n    {\n        if(factors[i] == 1)\n    \
    \    {\n            factors[(int)Math.sqrt(n)] = factors[i];\n            factorCount\
    \ \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfm_ivdxr.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(22):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(34):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(42):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(50):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(58):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(66):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(74):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(82):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(90):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(98):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(106):
    Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpfm_ivdxr.d(108):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpfm_ivdxr.d(121):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfm_ivdxr.d(121):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpfm_ivdxr.d(121):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfm_ivdxr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u\
    \ = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n \
    \   long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d\
    \ = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n \
    \   long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m\
    \ = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n \
    \   long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v\
    \ = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n \
    \   long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e\
    \ = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n \
    \   long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n\
    \ = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n \
    \   long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w\
    \ = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n \
    \   long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f\
    \ = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n \
    \   long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o\
    \ = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n \
    \   long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x\
    \ = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n \
    \   long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g\
    \ = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpotxkyc18.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpotxkyc18.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpotxkyc18.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpotxkyc18.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long p = n;\n\
    \    long q = 1;\n    long r = n;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n\
    \    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long\
    \ d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n\
    \    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long\
    \ m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n\
    \    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long\
    \ v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n\
    \    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long\
    \ e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n\
    \    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long\
    \ n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n\
    \    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long\
    \ w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    \nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnk41jsjq.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpnk41jsjq.d(118):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnk41jsjq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 1; i < factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    factors[factorCount++] = n;\n    return factors;\n}\n</code>\n<|/ a tags=algorithm,primes,java\
    \ |>\n<| c |>\nThis code doesn't work. Try factorize(8L).\n<|/ c |>\n<| c |>\n\
    It works. I tested it before posting. 8 is prime and it's factors are [2,2]. 8\
    \ is also a factor of 8^2, so 8^2 is also a factor of 8^3, and so on. 8^2 has\
    \ 3 factors, 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors,\
    \ 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2\
    \ factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2 factors,\
    \ 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2 factors, 8^4 has 1\
    \ factor, and so on. 8^2 has 3 factors, 8^3 has 2 factors, 8^4 has 1 factor, and\
    \ so on. 8^2 has 3 factors, 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2\
    \ has 3 factors, 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors,\
    \ 8^3 has 2 factors, 8^4 has 1 factor, and so on.\n<|/ c |>\n<| c |>\n8^2 has\
    \ 3 factors, 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors,\
    \ 8^3 has 2 factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2\
    \ factors, 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2 factors,\
    \ 8^4 has 1 factor, and so on. 8^2 has 3 factors, 8^3 has 2 factors, 8^4 has 1\
    \ factor, and so \nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9ej8c6s9.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp9ej8c6s9.d(32):
    Error: declaration expected, not `<`\n/tmp/tmp9ej8c6s9.d(35): Error: unterminated
    character constant\n/tmp/tmp9ej8c6s9.d(38): Error: unterminated character constant\n/tmp/tmp9ej8c6s9.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmp9ej8c6s9.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmp9ej8c6s9.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmp9ej8c6s9.d(49): Error: declaration expected, not `assert`\n/tmp/tmp9ej8c6s9.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmp9ej8c6s9.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmp9ej8c6s9.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmp9ej8c6s9.d(53): Error: declaration expected, not `assert`\n/tmp/tmp9ej8c6s9.d(54):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ej8c6s9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long factor = 1;\n\
    \    long factor_count = 1;\n    long factor_index = 0;\n    \n    while(factor\
    \ <= n)\n    {\n        if(n % factor == 0)\n        {\n            factors[factor_index]\
    \ = factor;\n            factor_count++;\n        }\n        factor++;\n    }\n\
    \    \n    for(int i = 1; i < factor_count; i++)\n    {\n        factors[factor_index]\
    \ = factors[factor_index] * i;\n    }\n    \n    return factors;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,math,primes,java |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.List;\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmr9s84_k.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpmr9s84_k.d(39):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmr9s84_k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)sqrt(n)+1];\n    long p = n;\n    long\
    \ q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n\
    \    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long\
    \ z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n\
    \    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long\
    \ i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n\
    \    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long\
    \ r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n\
    \    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long\
    \ j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n\
    \    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long\
    \ s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n\
    \    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long\
    \ b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n\
    \    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long\
    \ k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n\
    \    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long \nunittest\n{\n \
    \   alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqryolzav.d(17): Error: C style cast illegal, use `cast(int)sqrt(n)`\n/tmp/tmpqryolzav.d(118):
    Error: no identifier for declarator `long`\n/tmp/tmpqryolzav.d(118): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqryolzav.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long factorCount = 0;\n    \n    for(int i = 1; i < factors.length;\
    \ i++)\n    {\n        factorCount = 0;\n        while(n % factor == 0)\n    \
    \    {\n            factors[factorCount++] = factor;\n            n /= factor;\n\
    \        }\n        factor = factors[factorCount-1];\n    }\n    \n    return\
    \ factors;\n}\n</code>\n<|/ a tags=algorithm,primes,c# |>\n<| c |>\nThis code\
    \ does not work for large numbers. For example, factorize(10000000000L) returns\
    \ [10000000000L, 10000000000L]\n<|/ c |>\n<| c |>\nI tested it on 10000000000L\
    \ and it returned [10000000000L, 10000000000L]\n<|/ c |>\n<| c |>\nI tested it\
    \ on 10000000000L and it returned [10000000000L, 10000000000L]\n<|/ c |>\n<| c\
    \ |>\nI tested it on 10000000000L and it returned [10000000000L, 10000000000L]\n\
    <|/ c |>\n<| c |>\nI tested it on 10000000000L and it returned [10000000000L,\
    \ 10000000000L]\n<|/ c |>\n<| a dscore=5 |>\nThe best algorithm for finding prime\
    \ factors is to start with the Sieve of Eratosthenes and to eliminate all the\
    \ factors less than or equal to sqrt(n).\nThe Sieve of Eratosthenes is very easy\
    \ to implement. Here is a C# implementation:\n<code>\npublic static IEnumerable<int>\
    \ Sieve(int n)\n{\n    bool[] isPrime = new bool[n + 1];\n    for (int i = 2;\
    \ i <= n; i++)\n    {\n        if (isPrime[i])\n        {\n            for (int\
    \ j = i * i; j < n; j += i)\n            {\n                isPrime[j] = false;\n\
    \            }\n        }\n    }\n    for (int i = 2; i <= n; i++)\n    {\n  \
    \      if (isPrime[i])\n        {\n            yield return i;\n        }\n  \
    \  }\n}\n</code>\n<|/ a tags=algorithm,primes,c# |>\n<| c |>\nThe Sieve of Eratosthenes\
    \ is very easy to implement. Here is a C# implementation:\nunittest\n{\n    alias\
    \ candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqdeivx5m.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpqdeivx5m.d(34):
    Error: declaration expected, not `<`\n/tmp/tmpqdeivx5m.d(58): Error: declaration
    expected, not `for`\n/tmp/tmpqdeivx5m.d(58): Error: no identifier for declarator
    `i`\n/tmp/tmpqdeivx5m.d(58): Error: declaration expected, not `<=`\n/tmp/tmpqdeivx5m.d(58):
    Error: no identifier for declarator `i`\n/tmp/tmpqdeivx5m.d(58): Error: declaration
    expected, not `++`\n/tmp/tmpqdeivx5m.d(62): Error: no identifier for declarator
    `j`\n/tmp/tmpqdeivx5m.d(62): Error: declaration expected, not `<`\n/tmp/tmpqdeivx5m.d(62):
    Error: no identifier for declarator `j`\n/tmp/tmpqdeivx5m.d(62): Error: declaration
    expected, not `+=`\n/tmp/tmpqdeivx5m.d(65): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqdeivx5m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long factorCount = 0;\n    \n    while(p > 1)\n    {\n\
    \        factorCount++;\n        factors[factorCount] = p;\n        \n       \
    \ long r = p / factor;\n        p = factor;\n        factor *= r;\n    }\n   \
    \ \n    factors[factorCount] = p;\n    \n    return factors;\n}\n/*\n Return array\
    \ of prime factors of given integer in the order from smallest to largest.\n \
    \   Each of the factors should be arrayed number of times corresponding to how\
    \ many times it appeares in factorization.\n    Input number should be equal to\
    \ the product of all factors\n    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>>\
    \ factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n    [2L, 5L, 7L]\n   \
    \ \n*/\nlong[] factorize(long n, int factorizationSize) \n{\n    long[] factors\
    \ = new long[factorizationSize];\n    long p = n;\n    long factor = 1;\n    long\
    \ factorCount = 0;\n    \n    while(p > 1)\n    {\n        factorCount++;\n  \
    \      factors[factorCount] = p;\n        \n        long r = p / factor;\n   \
    \     p = factor;\n        factor *= r;\n    }\n    \n    factors[factorCount]\
    \ = p;\n    \n    return factors;\n}\n/*\n Return array of prime factors of given\
    \ integer in the order from smallest to largest.\n    Each of the factors should\
    \ be arrayed number of times corresponding to how many times it appeares in factorization.\n\
    \    Input number should be equal to the product of all factors\n    >>> factorize(8L)\n\
    \    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n    >>> factorize(70L)\n\
    \    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n, int factorizationSize, int\
    \ factorizationMaxSize) \n{\n    long[] factors = new long[factorizationSize];\n\
    \    long p = n;\n    long factor = 1;\n    long factorCount = 0;\n    \n    while(p\
    \ > 1)\n    {\n        factorCount++;\n        factors[factorCount] = p;\n   \
    \     \n        long r = p / factor;\n        p = factor;\n        factor *= r;\n\
    \    }\n    \n    factors[factorCount] = p;\n    \n    return factors;\n}\n/*\n\
    \ Return array of prime factors of given integer in the order from smallest \n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps53k3wmh.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmps53k3wmh.d(102):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps53k3wmh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)+1];\n    long factor =\
    \ 1;\n    long counter = 1;\n    for(int i = 1; i < factors.length; i++)\n   \
    \ {\n        while(n % factor == 0)\n        {\n            factors[counter++]\
    \ = factor;\n            n /= factor;\n        }\n        factors[counter++] =\
    \ factor;\n        factor *= i;\n    }\n    factors[counter] = n;\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=algorithm,math,primes |>\n<| c |>\nI like your\
    \ solution, but I believe it can be optimized a bit. For example, you can stop\
    \ checking after you found a factor of sqrt(n), because you know that no other\
    \ factors exist below sqrt(n).\n<|/ c |>\n<| c |>\nYes, you are right. I just\
    \ wanted to show the idea of prime factorization. Thanks for your comment!\n<|/\
    \ c |>\n<| c |>\nThis algorithm is O(n^2) in time and space. There are better\
    \ algorithms such as [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).\n\
    <|/ c |>\n<| c |>\nI agree with you. Sieve of Eratosthenes is much better than\
    \ my solution. Thanks for your comment!\n<|/ c |>\n<| c |>\nI believe that your\
    \ algorithm is O(n^2) in time and space, but it is O(n) in space. Your algorithm\
    \ is O(n^2) in time and space, but it is O(n) in space. Your algorithm is O(n^2)\
    \ in time and space, but it is O(n) in space. Your algorithm is O(n^2) in time\
    \ and space, but it is O(n) in space. Your algorithm is O(n^2) in time and space,\
    \ but it is O(n) in space. Your algorithm is O(n^2) in time and space, but it\
    \ is O(n) in space. Your algorithm is O(n^2) in time and space, but it is O(n)\
    \ in space.\n<|/ c |>\n<| a tags=algorithm,math,primes |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdbqihsov.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpdbqihsov.d(33):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpdbqihsov.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    for(int i = 0; i<factors.length; i++)\n    {\n\
    \        while(n % factor == 0)\n        {\n            factors[factorCount++]\
    \ = factor;\n            n /= factor;\n        }\n        factor *= i;\n    }\n\
    \    if(n > 1)\n    {\n        factors[factorCount++] = n;\n    }\n    return\
    \ factors;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work for large\
    \ numbers. `factorize(10000000000L)` returns `[10000000000L, 10000000000L]` instead\
    \ of `[10000000000L, 10000000000L, 10000000000L, 10000000000L]`.\n<|/ c |>\n<|\
    \ c |>\nYes, I forgot about that case. I've fixed my answer. Thanks.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n\
    \    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L,\
    \ 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpodzinmgt.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmpodzinmgt.d(35):
    Error: declaration expected, not `<`\n/tmp/tmpodzinmgt.d(38): Error: unterminated
    character constant\n/tmp/tmpodzinmgt.d(41): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpodzinmgt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long factorCount2 = 0;\n    long factorCount3\
    \ = 0;\n    long factorCount4 = 0;\n    long factorCount5 = 0;\n    long factorCount6\
    \ = 0;\n    long factorCount7 = 0;\n    long factorCount8 = 0;\n    long factorCount9\
    \ = 0;\n    long factorCount10 = 0;\n    long factorCount11 = 0;\n    long factorCount12\
    \ = 0;\n    long factorCount13 = 0;\n    long factorCount14 = 0;\n    long factorCount15\
    \ = 0;\n    long factorCount16 = 0;\n    long factorCount17 = 0;\n    long factorCount18\
    \ = 0;\n    long factorCount19 = 0;\n    long factorCount20 = 0;\n    long factorCount21\
    \ = 0;\n    long factorCount22 = 0;\n    long factorCount23 = 0;\n    long factorCount24\
    \ = 0;\n    long factorCount25 = 0;\n    long factorCount26 = 0;\n    long factorCount27\
    \ = 0;\n    long factorCount28 = 0;\n    long factorCount29 = 0;\n    long factorCount30\
    \ = 0;\n    long factorCount31 = 0;\n    long factorCount32 = 0;\n    long factorCount33\
    \ = 0;\n    long factorCount34 = 0;\n    long factorCount35 = 0;\n    long factorCount36\
    \ = 0;\n    long factorCount37 = 0;\n    long factorCount38 = 0;\n    long factorCount39\
    \ = 0;\n    long factorCount40 = 0;\n    long factorCount41 = 0;\n    long factorCount42\
    \ = 0;\n    long factorCount43 = 0;\n    long factorCount44 = 0;\n    long factorCount45\
    \ = 0;\n    long factorCount46 = 0;\n    long factorCount47 = 0;\n    long factorCount48\
    \ = 0;\n    long factorCount49 = 0;\n    long factorCount50 = 0;\n    long factorCount51\
    \ = 0;\n    long factorCount52 = 0;\n    long factorCount53 = 0;\n    long factorCount54\
    \ = 0;\n    long factorCount55 = 0;\n    long factorCount56 = 0;\n    long factorCount57\
    \ = 0;\n    long factorCount58 = 0;\n    long factorCount59 = 0;\n    long factorCount60\
    \ = 0;\n    long factorCount61 = 0;\n    long factorCount62 = 0;\n    long factorCount63\
    \ = 0;\n    long factorCount64 = 0;\n    long factorCount65 = 0;\n    long factorCount66\
    \ = 0;\n    long factorCount67 = 0;\n    long factorCount68 = 0;\n    long factorCount69\
    \ = 0;\n    long factorCount70 = 0;\n    long factorCount71 = 0;\n\nunittest\n\
    {\n    alias candidate = factorize;\n\n    assert(candidate(2L) == [2L]);\n  \
    \  assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n\
    \    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L) == [3L,\
    \ 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L, 19L, 19L]);\n\
    \    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0t6iyimc.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp0t6iyimc.d(91):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0t6iyimc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.Sqrt(n)];\n    long factor = 1;\n\
    \    long factorCount = 0;\n    long currentCount = 0;\n    long currentFactor\
    \ = 1;\n    for(int i = 0; i <= (int)Math.Sqrt(n); i++)\n    {\n        factors[i]\
    \ = factor;\n        factorCount = 1;\n        for(int j = i; j < n; j++)\n  \
    \      {\n            if(n % j == 0)\n            {\n                factorCount++;\n\
    \                currentCount++;\n            }\n        }\n        if(currentCount\
    \ > factorCount)\n        {\n            factor = currentFactor;\n           \
    \ currentCount = factorCount;\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=algorithm,math,primes,c# |>\n<code>\npublic static\
    \ bool IsPrime(long n)\n{\n    if (n < 2)\n        return false;\n    if (n ==\
    \ 2)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    long\
    \ limit = (long)Math.Sqrt(n);\n    for (long i = 4; i <= limit; i += 2)\n    {\n\
    \        if (n % i == 0)\n            return false;\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\npublic static bool IsPrime(long\
    \ n)\n{\n    if (n < 2)\n        return false;\n    if (n == 2)\n        return\
    \ true;\n    if (n % 2 == 0)\n        return false;\n    long limit = (long)Math.Sqrt(n);\n\
    \    for (long i = 4; i <= limit; i += 2)\n    {\n        if (n % i == 0)\n  \
    \          return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=algorithm,math,primes,c#\
    \ |>\n<| a |>\n<code>\npublic bool IsPrime(int n)\n{\n    if (n == 2)\n      \
    \  return true;\n    if (n % 2 == 0)\n        return false;\n    int limit = (int)Math.Sqrt(n);\n\
    \    for (int i = 2; i <= limit; i++)\n    {\n        if (n % i == 0)\n      \
    \      return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=algorithm,math,primes,c#\
    \ dscore=1 |>\n<| a tags=algorithm,math,primes,c# |>\n<code>\npublic static bool\
    \ IsPrime(long n)\n{\n    if (n < 2)\n        return false;\n    if (n == 2)\n\
    \        return true;\n    if (n % 2 == 0)\n        return false;\n    long limit\
    \ = (long)Math.Sqrt(n);\n    for (long i = 4; i <= limit; i += 2)\n    {\n   \
    \     if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nunittest\n{\n    alias candidate\
    \ = factorize;\n\n    assert(candidate(2L) == [2L]);\n    assert(candidate(4L)\
    \ == [2L, 2L]);\n    assert(candidate(8L) == [2L, 2L, 2L]);\n    assert(candidate(57L)\
    \ == [3L, 19L]);\n    assert(candidate(3249L) == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L)\
    \ == [3L, 3L, 3L, 19L, 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(18L) == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpttqhm2n0.d(17): Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpttqhm2n0.d(22):
    Error: C style cast illegal, use `cast(int)Math.Sqrt(n)`\n/tmp/tmpttqhm2n0.d(42):
    Error: declaration expected, not `<`\n/tmp/tmpttqhm2n0.d(50): Error: declaration
    expected, not `if`\n/tmp/tmpttqhm2n0.d(52): Error: declaration expected, not `if`\n/tmp/tmpttqhm2n0.d(54):
    Error: C style cast illegal, use `cast(long)Math.Sqrt(n)`\n/tmp/tmpttqhm2n0.d(55):
    Error: declaration expected, not `for`\n/tmp/tmpttqhm2n0.d(55): Error: no identifier
    for declarator `i`\n/tmp/tmpttqhm2n0.d(55): Error: declaration expected, not `<=`\n/tmp/tmpttqhm2n0.d(55):
    Error: no identifier for declarator `i`\n/tmp/tmpttqhm2n0.d(55): Error: declaration
    expected, not `+=`\n/tmp/tmpttqhm2n0.d(59): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttqhm2n0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Return array of prime factors\
    \ of given integer in the order from smallest to largest.\n    Each of the factors\
    \ should be arrayed number of times corresponding to how many times it appeares\
    \ in factorization.\n    Input number should be equal to the product of all factors\n\
    \    >>> factorize(8L)\n    [2L, 2L, 2L]\n    >>> factorize(25L)\n    [5L, 5L]\n\
    \    >>> factorize(70L)\n    [2L, 5L, 7L]\n    \n*/\nlong[] factorize(long n)\
    \ \n{\n    long[] factors = new long[(int)Math.sqrt(n)];\n    long p = n;\n  \
    \  long factor = 1;\n    long counter = 1;\n    long factorization = 1;\n    while(p\
    \ > 1) {\n        factorization *= p;\n        factors[counter] = factorization;\n\
    \        p /= factorization;\n        counter++;\n    }\n    factors[counter]\
    \ = factorization;\n    factors[counter] = 1;\n    factors[counter] = 1;\n   \
    \ return factors;\n}\n</code>\n<|/ a |>\n<| c |>\nI appreciate your efforts, but\
    \ this doesn't answer the question. OP asked for \"a solution that doesn't require\
    \ any external libraries\". Your solution requires external libraries.\n<|/ c\
    \ |>\n<| c |>\nI appreciate your efforts, but this doesn't answer the question.\
    \ OP asked for \"a solution that doesn't require any external libraries\". Your\
    \ solution requires external libraries.\n<|/ c |>\n<| c |>\nI appreciate your\
    \ efforts, but this doesn't answer the question. OP asked for \"a solution that\
    \ doesn't require any external libraries\". Your solution requires external libraries.\n\
    <|/ c |>\n<| c |>\nI appreciate your efforts, but this doesn't answer the question.\
    \ OP asked for \"a solution that doesn't require any external libraries\". Your\
    \ solution requires external libraries.\n<|/ c |>\n<| c |>\nI appreciate your\
    \ efforts, but this doesn't answer the question. OP asked for \"a solution that\
    \ doesn't require any external libraries\". Your solution requires external libraries.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = factorize;\n\n    assert(candidate(2L)\
    \ == [2L]);\n    assert(candidate(4L) == [2L, 2L]);\n    assert(candidate(8L)\
    \ == [2L, 2L, 2L]);\n    assert(candidate(57L) == [3L, 19L]);\n    assert(candidate(3249L)\
    \ == [3L, 3L, 19L, 19L]);\n    assert(candidate(185193L) == [3L, 3L, 3L, 19L,\
    \ 19L, 19L]);\n    assert(candidate(20577L) == [3L, 19L, 19L, 19L]);\n    assert(candidate(18L)\
    \ == [2L, 3L, 3L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp82_5ou_n.d(17): Error: C style cast illegal, use `cast(int)Math.sqrt(n)`\n/tmp/tmp82_5ou_n.d(33):
    Error: declaration expected, not `<`\n/tmp/tmp82_5ou_n.d(36): Error: unterminated
    character constant\n/tmp/tmp82_5ou_n.d(39): Error: unterminated character constant\n/tmp/tmp82_5ou_n.d(42):
    Error: unterminated character constant\n/tmp/tmp82_5ou_n.d(45): Error: unterminated
    character constant\n/tmp/tmp82_5ou_n.d(48): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp82_5ou_n.d", "-I/tmp"]\n'''
  stdout: b''
