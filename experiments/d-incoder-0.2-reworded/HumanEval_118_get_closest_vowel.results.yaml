name: HumanEval_118_get_closest_vowel
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end) {\n        string vowel = word.substr(start, 1);\n        \n        if(vowels.find(vowel)\
    \ != string::npos) {\n            int index = vowels.find(vowel);\n          \
    \  \n            if(index != string::npos) {\n                if(index > start)\
    \ {\n                    start = index;\n                } else {\n          \
    \          end = index;\n                }\n            }\n        }\n    }\n\
    \    \n    return word.substr(start, 1);\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptf42urzu.d(33): Error: found `:` when expecting `)`\\n/tmp/tmptf42urzu.d(33):\
    \ Error: found `:` instead of statement\\n/tmp/tmptf42urzu.d(36): Error: found\
    \ `:` when expecting `)`\\n/tmp/tmptf42urzu.d(36): Error: found `:` instead of\
    \ statement\\n/tmp/tmptf42urzu.d(39): Error: found `else` without a corresponding\
    \ `if`, `version` or `debug` statement\\n/tmp/tmptf42urzu.d(42): Error: unrecognized\
    \ declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptf42urzu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ <= end) {\n        int mid = (start + end) / 2;\n        \n        if (word.startsWith(vowels,\
    \ mid)) {\n            end = mid - 1;\n        } else if (word.endsWith(vowels,\
    \ mid)) {\n            start = mid + 1;\n        } else {\n            start =\
    \ mid + 1;\n            end = mid - 1;\n        }\n    }\n    \n    return word.substring(start,\
    \ end + 1);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg9a35xba.d(28): Error: no property `length` for type `string`\\\
    n/tmp/tmpg9a35xba.d(33): Error: no property `startsWith` for type `string`\\n/tmp/tmpg9a35xba.d(35):\
    \ Error: no property `endsWith` for type `string`\\n/tmp/tmpg9a35xba.d(43): Error:\
    \ no property `substring` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg9a35xba.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    int len = word.length();\n    int start = 0;\n    int end = 0;\n    \n  \
    \  for(int i = 0; i < len; i++)\n    {\n        if(word[i] == consonants[len -\
    \ 1])\n        {\n            end = len - 1;\n            break;\n        }\n\
    \        else if(word[i] == consonants[0])\n        {\n            start = len\
    \ - 1;\n            break;\n        }\n    }\n    \n    if(start == end)\n   \
    \ {\n        return \"\";\n    }\n    \n    string result = \"\";\n    \n    for(int\
    \ i = start; i <= end; i++)\n    {\n        if(vowels.find(word[i]) != string::npos)\n\
    \        {\n            result = word[i];\n            break;\n        }\n   \
    \ }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp15bg3x6h.d(55): Error: found `:` when expecting `)`\\n/tmp/tmp15bg3x6h.d(55):\
    \ Error: found `:` instead of statement\\n/tmp/tmp15bg3x6h.d(62): Error: declaration\
    \ expected, not `return`\\n/tmp/tmp15bg3x6h.d(63): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp15bg3x6h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\") - 1])\n        {\n            return\
    \ word[i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzkr6ekey.d(27): Error: no property `length` for type `string`\\\
    n/tmp/tmpzkr6ekey.d(29): Error: no property `find_last_of` for type `string`\\\
    n/tmp/tmpzkr6ekey.d(31): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpzkr6ekey.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n \
    \   {\n        if(it->second==1)\n        {\n            vowel=it->first;\n  \
    \          break;\n        }\n    }\n    if(vowel.length()==0)\n    {\n      \
    \  return \"\";\n    }\n    string vowel_before;\n    string vowel_after;\n  \
    \  for(int i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n   \
    \     {\n            if(word[i]==vowel)\n            {\n                vowel_before=word.substr(0,i);\n\
    \                vowel_after=word.substr(i+1,word.length());\n               \
    \ break;\n            }\n        }\n    }\n    if(vowel_before.length()==0)\n\
    \    {\n        return \"\";\n    }\n    if(vowel_after.length()==0)\n    {\n\
    \        return \"\";\n    }\n    string vowel_before2=get_closest_vowel(vowel_before);\n\
    \    string vowel_after2=get_closest_vowel(vowel_after);\n    if(vowel_before2.length()==0)\n\
    \    {\n        return vowel;\n    }\n    if(vowel_after2.length()==0)\n    {\n\
    \        return vowel;\n    }\n    if(vowel_before2==vowel)\n    {\n        return\
    \ vowel_after2;\n    }\n    if(vowel_after2==vowel)\n    {\n        return vowel_before2;\n\
    \    }\n    if(vowel_before2<vowel)\n    {\n        return vowel_before2;\n  \
    \  }\n    return vowel_after2;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxh_acfwd.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpxh_acfwd.d(33): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpxh_acfwd.d(33): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmpxh_acfwd.d(33): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmpxh_acfwd.d(37): Error: use `.` for member lookup, not `->`\\\
    n/tmp/tmpxh_acfwd.d(39): Error: use `.` for member lookup, not `->`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxh_acfwd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n\
    \    {\n        if(it->second > 0)\n        {\n            string vowel = it->first;\n\
    \            int count = it->second;\n            int index = word.length() -\
    \ 1;\n            while(index >= 0)\n            {\n                if(isVowel(word[index]))\n\
    \                {\n                    if(word[index] == vowel)\n           \
    \         {\n                        count++;\n                    }\n       \
    \             else\n                    {\n                        break;\n  \
    \                  }\n                }\n                index--;\n          \
    \  }\n            if(count > 0)\n            {\n                return vowel;\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc0suzckd.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpc0suzckd.d(34): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpc0suzckd.d(34): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmpc0suzckd.d(34): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmpc0suzckd.d(37): Error: use `.` for member lookup, not `->`\\\
    n/tmp/tmpc0suzckd.d(39): Error: use `.` for member lookup, not `->`\\n/tmp/tmpc0suzckd.d(40):\
    \ Error: use `.` for member lookup, not `->`\\n/tmp/tmpc0suzckd.d(65): Error:\
    \ declaration expected, not `<`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc0suzckd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    for(int i =\
    \ word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] == vowels_right[i])\n\
    \        {\n            return word[i];\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfzk4mx9y.d(26): Error: no property `right` for type `string`\\\
    n/tmp/tmpfzk4mx9y.d(28): Error: no property `length` for type `string`\\n/tmp/tmpfzk4mx9y.d(32):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfzk4mx9y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    int start = 0;\n    int end = len - 1;\n    string\
    \ result = \"\";\n    while(start < end) {\n        string s = word.substr(start,\
    \ 1);\n        if(vowels.find(s) == string::npos) {\n            start = start\
    \ + 1;\n        } else {\n            end = end - 1;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n/*\nYou are\
    \ given a word. Your task is to find the closest vowel that stands between \n\
    \    two consonants from the right side of the word (case sensitive).\n    \n\
    \    Vowels in the beginning and ending doesn't count. Return empty string if\
    \ you didn't\n    find any vowel met the above condition. \nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoa_2jgnz.d(32): Error: found `:` when expecting `)`\\n/tmp/tmpoa_2jgnz.d(32):\
    \ Error: found `:` instead of statement\\n/tmp/tmpoa_2jgnz.d(34): Error: found\
    \ `else` without a corresponding `if`, `version` or `debug` statement\\n/tmp/tmpoa_2jgnz.d(37):\
    \ Error: unrecognized declaration\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpoa_2jgnz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=vowels[word[i]]+1;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==0)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if the word is \"ab\". It returns \"a\" instead of \"\".\n<|/ c |>\n<|\
    \ c |>\nYes, I missed that case. Thanks for pointing it out. Updated the code.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm04_chr8.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpm04_chr8.d(33): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpm04_chr8.d(33): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmpm04_chr8.d(33): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmpm04_chr8.d(36): Error: use `.` for member lookup, not `->`\\\
    n/tmp/tmpm04_chr8.d(38): Error: use `.` for member lookup, not `->`\\n/tmp/tmpm04_chr8.d(43):\
    \ Error: declaration expected, not `<`\\n/tmp/tmpm04_chr8.d(46): Error: unterminated\
    \ character constant\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm04_chr8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string, int> vowel_map;\n    for(int i = 0; i < word.length(); i++)\n \
    \   {\n        string vowel = word.substr(i, 1);\n        vowel_map[vowel] = vowel_map[vowel]\
    \ + 1;\n    }\n    map<string, int>::iterator it;\n    for(it = vowel_map.begin();\
    \ it != vowel_map.end(); ++it)\n    {\n        if(it->second == 1)\n        {\n\
    \            return it->first;\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=c++,string |>\n<| c |>\nI didn't downvote you, but I suspect it's because\
    \ you didn't explain what your code does, and how it does it.\n<|/ c |>\n<| c\
    \ |>\nI added some explanation to the code. Hope it helps.\n<|/ c |>\n<| c |>\n\
    I didn't downvote you, but I suspect it's because you didn't explain what your\
    \ code does, and how it does it.\n<|/ c |>\n<| c |>\nI added some explanation\
    \ to the code. Hope it helps.\n<|/ c |>\n<| c |>\nI didn't downvote you, but I\
    \ suspect it's because you didn't explain what your code does, and how it does\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_2lqfpqs.d(26): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp_2lqfpqs.d(32): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp_2lqfpqs.d(32): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp_2lqfpqs.d(32): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp_2lqfpqs.d(35): Error: use `.` for member lookup, not `->`\\\
    n/tmp/tmp_2lqfpqs.d(37): Error: use `.` for member lookup, not `->`\\n/tmp/tmp_2lqfpqs.d(42):\
    \ Error: declaration expected, not `<`\\n/tmp/tmp_2lqfpqs.d(45): Error: unterminated\
    \ character constant\\n/tmp/tmp_2lqfpqs.d(45): Error: unterminated character constant\\\
    n/tmp/tmp_2lqfpqs.d(45): Error: unterminated character constant\\n/tmp/tmp_2lqfpqs.d(51):\
    \ Error: unterminated character constant\\n/tmp/tmp_2lqfpqs.d(51): Error: unterminated\
    \ character constant\\n/tmp/tmp_2lqfpqs.d(51): Error: unterminated character constant\\\
    n/tmp/tmp_2lqfpqs.d(57): Error: unterminated character constant\\n/tmp/tmp_2lqfpqs.d(57):\
    \ Error: unterminated character constant\\n/tmp/tmp_2lqfpqs.d(57): Error: unterminated\
    \ character constant\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_2lqfpqs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at\
    \ /tmp/tmpk57yzw2t.d(114)\\n/tmp/tmpk57yzw2t.d(102): Error: found `yogurt` when\
    \ expecting `,`\\n/tmp/tmpk57yzw2t.d(102): Error: found `u` when expecting `,`\\\
    n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting `,`\\n/tmp/tmpk57yzw2t.d(103):\
    \ Error: found `u` when expecting `,`\\n/tmp/tmpk57yzw2t.d(104): Error: found\
    \ `easy` when expecting `,`\\n/tmp/tmpk57yzw2t.d(104): Error: Implicit string\
    \ concatenation is deprecated, use \") == \" ~ \");\\\\x0a    assert(candidate(\"\
    \ instead\\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\\\
    n/tmp/tmpk57yzw2t.d(105): Error: Implicit string concatenation is deprecated,\
    \ use \") == \" ~ \");\\\\x0a    assert(candidate(\" instead\\n/tmp/tmpk57yzw2t.d(106):\
    \ Error: found `ali` when expecting `,`\\n/tmp/tmpk57yzw2t.d(106): Error: Implicit\
    \ string concatenation is deprecated, use \") == \" ~ \");\\\\x0a    assert(candidate(\"\
    \ instead\\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\\n/tmp/tmpk57yzw2t.d(107):\
    \ Error: found `a` when expecting `,`\\n/tmp/tmpk57yzw2t.d(108): Error: found\
    \ `most` when expecting `,`\\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting\
    \ `,`\\n/tmp/tmpk57yzw2t.d(109): Error: found `ab` when expecting `,`\\n/tmp/tmpk57yzw2t.d(109):\
    \ Error: Implicit string concatenation is deprecated, use \") == \" ~ \");\\\\\
    x0a    assert(candidate(\" instead\\n/tmp/tmpk57yzw2t.d(110): Error: found `ba`\
    \ when expecting `,`\\n/tmp/tmpk57yzw2t.d(110): Error: Implicit string concatenation\
    \ is deprecated, use \") == \" ~ \");\\\\x0a    assert(candidate(\" instead\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk57yzw2t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.substr(vowels.rfind('e') + 1);\n    string vowels_left\
    \ = vowels.substr(0, vowels.rfind('e'));\n    string vowels_mid = vowels.substr(vowels.rfind('e')\
    \ + 1, vowels.rfind('e') - vowels.rfind('e') - 1);\n    \n    string vowels_right_lower\
    \ = vowels_right.substr(0, vowels_right.rfind('e'));\n    string vowels_right_upper\
    \ = vowels_right.substr(vowels_right.rfind('e') + 1, vowels_right.rfind('e') -\
    \ vowels_right.rfind('e') - 1);\n    string vowels_left_lower = vowels_left.substr(0,\
    \ vowels_left.rfind('e'));\n    string vowels_left_upper = vowels_left.substr(vowels_left.rfind('e')\
    \ + 1, vowels_left.rfind('e') - vowels_left.rfind('e') - 1);\n    string vowels_mid_lower\
    \ = vowels_mid.substr(0, vowels_mid.rfind('e'));\n    string vowels_mid_upper\
    \ = vowels_mid.substr(vowels_mid.rfind('e') + 1, vowels_mid.rfind('e') - vowels_mid.rfind('e')\
    \ - 1);\n    \n    string vowels_right_lower = vowels_right.substr(0, vowels_right.rfind('e'));\n\
    \    string vowels_right_upper = vowels_right.substr(vowels_right.rfind('e') +\
    \ 1, vowels_right.rfind('e') - vowels_right.rfind('e') - 1);\n    string vowels_left_lower\
    \ = vowels_left.substr(0, vowels_left.rfind('e'));\n    string vowels_left_upper\
    \ = vowels_left.substr(vowels_left.rfind('e') + 1, vowels_left.rfind('e') - vowels_left.rfind('e')\
    \ - 1);\n    string vowels_mid_lower = vowels_mid.substr(0, vowels_mid.rfind('e'));\n\
    \    string vowels_mid_upper = vowels_mid.substr(vowels_mid.rfind('e') + 1, vowels_mid.rfind('e')\
    \ - vowels_mid.rfind('e') - 1);\n    \n    string vowels_right_lower = vowels_right.substr(0,\
    \ vowels_right.rfind('e'));\n    string vowels_right_upper = vowels_right.substr(vowels_right.rfind('e')\
    \ + 1, vowels_right.rfind('e') - vowels_right.rfind('e') - 1);\n    string vowels_left_lower\
    \ = vowels_left.substr(0, vowels_left.rfind('e\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4c5_gq47.d(46): Error: unterminated character constant\\n/tmp/tmp4c5_gq47.d(47):\
    \ Error: found `unittest` when expecting `,`\\n/tmp/tmp4c5_gq47.d(65): Error:\
    \ found `void` when expecting `,`\\n/tmp/tmp4c5_gq47.d(65): Error: found `{` when\
    \ expecting `,`\\n/tmp/tmp4c5_gq47.d(65): Error: expression expected, not `}`\\\
    n/tmp/tmp4c5_gq47.d(65): Error: found `End of File` when expecting `,`\\n/tmp/tmp4c5_gq47.d(65):\
    \ Error: found `End of File` when expecting `)`\\n/tmp/tmp4c5_gq47.d(65): Error:\
    \ found `End of File` when expecting `,`\\n/tmp/tmp4c5_gq47.d(65): Error: found\
    \ `End of File` when expecting `)`\\n/tmp/tmp4c5_gq47.d(65): Error: semicolon\
    \ expected, not `End of File`\\n/tmp/tmp4c5_gq47.d(65): Error: found `End of File`\
    \ when expecting `}` following compound statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4c5_gq47.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(isVowel(word[i]))\n        {\n            for(int j=word.length()-1;j>=0;j--)\n\
    \            {\n                if(isConsonant(word[j]))\n                {\n\
    \                    if(word[j]==word[i])\n                    {\n           \
    \             if(word[j+1]==word[i])\n                        {\n            \
    \                if(word[j+2]==word[i])\n                            {\n     \
    \                           return word[i];\n                            }\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprrgt4n35.d(26): Error: no property `length` for type `string`\\\
    n/tmp/tmprrgt4n35.d(28): Error: undefined identifier `isVowel`\\n/tmp/tmprrgt4n35.d(30):\
    \ Error: no property `length` for type `string`\\n/tmp/tmprrgt4n35.d(32): Error:\
    \ undefined identifier `isConsonant`\\n/tmp/tmprrgt4n35.d(40): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprrgt4n35.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int left = 0;\n    int right = word.length()\
    \ - 1;\n    while(left < right) {\n        int mid = (left + right) / 2;\n   \
    \     if(word[mid] >= 'a' && word[mid] <= 'z') {\n            left = mid;\n  \
    \      } else {\n            right = mid;\n        }\n    }\n    if(word[left]\
    \ >= 'a' && word[left] <= 'z') {\n        return word[left];\n    } else {\n \
    \       return \"\";\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,algorithm,c++,c\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoxmdiv_q.d(41): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoxmdiv_q.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    map<string, int>::iterator it;\n    string vowel;\n    map<string, int>::iterator\
    \ it2;\n    string vowel2;\n    map<string, int>::iterator it3;\n    string vowel3;\n\
    \    map<string, int>::iterator it4;\n    string vowel4;\n    map<string, int>::iterator\
    \ it5;\n    string vowel5;\n    map<string, int>::iterator it6;\n    string vowel6;\n\
    \    map<string, int>::iterator it7;\n    string vowel7;\n    map<string, int>::iterator\
    \ it8;\n    string vowel8;\n    map<string, int>::iterator it9;\n    string vowel9;\n\
    \    map<string, int>::iterator it10;\n    string vowel10;\n    map<string, int>::iterator\
    \ it11;\n    string vowel11;\n    map<string, int>::iterator it12;\n    string\
    \ vowel12;\n    map<string, int>::iterator it13;\n    string vowel13;\n    map<string,\
    \ int>::iterator it14;\n    string vowel14;\n    map<string, int>::iterator it15;\n\
    \    string vowel15;\n    map<string, int>::iterator it16;\n    string vowel16;\n\
    \    map<string, int>::iterator it17;\n    string vowel17;\n    map<string, int>::iterator\
    \ it18;\n    string vowel18;\n    map<string, int>::iterator it19;\n    string\
    \ vowel19;\n    map<string, int>::iterator it20;\n    string vowel20;\n    map<string,\
    \ int>::iterator it21;\n    string vowel21;\n    map<string, int>::iterator it22;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1_40qksp.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(50): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(50): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(50): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(52): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(52): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(52): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(54): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(54): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(54): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(56): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(56): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(56): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(58): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(58): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(58): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(60): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmp1_40qksp.d(60): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmp1_40qksp.d(60): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmp1_40qksp.d(62): Error: found `>` when expecting `.` following\
    \ int\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1_40qksp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.substr(vowels.rfind('A') + 1);\n    string vowels_left\
    \ = vowels.substr(0, vowels.rfind('A'));\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_right[0])\n        {\n           \
    \ int index = vowels.find(word[i]);\n            if(index != -1)\n           \
    \ {\n                string vowels_before = vowels.substr(0, index);\n       \
    \         if(vowels_before == vowels_left || vowels_before == vowels_right)\n\
    \                {\n                    return word[i];\n                }\n \
    \           }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmwjh3vde.d(26): Error: no property `substr` for type `string`\\\
    n/tmp/tmpmwjh3vde.d(27): Error: no property `substr` for type `string`\\n/tmp/tmpmwjh3vde.d(29):\
    \ Error: no property `length` for type `string`\\n/tmp/tmpmwjh3vde.d(33): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpmwjh3vde.d(36): Error: no property\
    \ `substr` for type `string`\\n/tmp/tmpmwjh3vde.d(39): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmwjh3vde.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int start = 0;\n    int end = word.length() - 1;\n    while(start < end)\n\
    \    {\n        int mid = (start + end) / 2;\n        if(word.at(mid) == vowels.at(mid))\n\
    \        {\n            end = mid - 1;\n        }\n        else if(word.at(mid)\
    \ == vowels.at(mid+1))\n        {\n            start = mid + 1;\n        }\n \
    \       else\n        {\n            start = mid + 1;\n            end = mid -\
    \ 1;\n        }\n    }\n    return word.at(start);\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9j2zszud.d(47): Error: declaration expected, not `<`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9j2zszud.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            string vowel = word[i];\n            vowels[vowel] += 1;\n \
    \       }\n    }\n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 1)\n        {\n \
    \           return it->first;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkw3on66j.d(25): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpkw3on66j.d(34): Error: found `>` when expecting `.` following\
    \ int\\n/tmp/tmpkw3on66j.d(34): Error: found `:` when expecting identifier following\
    \ `int`.\\n/tmp/tmpkw3on66j.d(34): Error: found `:` when expecting `;` following\
    \ statement\\n/tmp/tmpkw3on66j.d(37): Error: use `.` for member lookup, not `->`\\\
    n/tmp/tmpkw3on66j.d(39): Error: use `.` for member lookup, not `->`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkw3on66j.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    string vowels = \"aeiouAEIOU\"\
    ;\n    \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int j = word.length() - 1;\n            while(j >= 0 && vowels.find(word[j])\
    \ != string::npos)\n            {\n                if(index > vowels.find(word[j]))\n\
    \                {\n                    index = vowels.find(word[j]);\n      \
    \          }\n                j--;\n            }\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc1w84f3n.d(30): Error: found `:` when expecting `)`\\n/tmp/tmpc1w84f3n.d(30):\
    \ Error: found `:` instead of statement\\n/tmp/tmpc1w84f3n.d(34): Error: found\
    \ `:` when expecting `)`\\n/tmp/tmpc1w84f3n.d(34): Error: found `:` instead of\
    \ statement\\n/tmp/tmpc1w84f3n.d(42): Error: declaration expected, not `return`\\\
    n/tmp/tmpc1w84f3n.d(43): Error: unrecognized declaration\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpc1w84f3n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int vowel_start\
    \ = len - 1;\n    int vowel_end = len - 1;\n    int vowel_mid = 0;\n    \n   \
    \ for(int i = 0; i < len; i++)\n    {\n        if(word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n    \
    \        vowel_start = i;\n        }\n        else if(word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n        {\n \
    \           vowel_end = i;\n        }\n    }\n    \n    for(int i = vowel_start;\
    \ i <= vowel_end; i++)\n    {\n        vowel_mid += word[i];\n    }\n    \n  \
    \  for(int i = vowel_end; i >= vowel_start; i--)\n    {\n        vowel_mid +=\
    \ word[i];\n    }\n    \n    return vowel_mid;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7zsfqiq2.d(25): Error: no property `length` for type `string`\\\
    n/tmp/tmp7zsfqiq2.d(52): Error: cannot implicitly convert expression `vowel_mid`\
    \ of type `int` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp7zsfqiq2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
