language: d
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end) {\n        string vowel = word.substr(start, 1);\n        \n        if(vowels.find(vowel)\
    \ != string::npos) {\n            int index = vowels.find(vowel);\n          \
    \  \n            if(index != string::npos) {\n                if(index > start)\
    \ {\n                    start = index;\n                } else {\n          \
    \          end = index;\n                }\n            }\n        }\n    }\n\
    \    \n    return word.substr(start, 1);\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptf42urzu.d(33): Error: found `:` when expecting `)`\n/tmp/tmptf42urzu.d(33):
    Error: found `:` instead of statement\n/tmp/tmptf42urzu.d(36): Error: found `:`
    when expecting `)`\n/tmp/tmptf42urzu.d(36): Error: found `:` instead of statement\n/tmp/tmptf42urzu.d(39):
    Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmptf42urzu.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf42urzu.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ <= end) {\n        int mid = (start + end) / 2;\n        \n        if (word.startsWith(vowels,\
    \ mid)) {\n            end = mid - 1;\n        } else if (word.endsWith(vowels,\
    \ mid)) {\n            start = mid + 1;\n        } else {\n            start =\
    \ mid + 1;\n            end = mid - 1;\n        }\n    }\n    \n    return word.substring(start,\
    \ end + 1);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg9a35xba.d(28): Error: no property `length` for type `string`\n/tmp/tmpg9a35xba.d(33):
    Error: no property `startsWith` for type `string`\n/tmp/tmpg9a35xba.d(35): Error:
    no property `endsWith` for type `string`\n/tmp/tmpg9a35xba.d(43): Error: no property
    `substring` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9a35xba.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    int len = word.length();\n    int start = 0;\n    int end = 0;\n    \n  \
    \  for(int i = 0; i < len; i++)\n    {\n        if(word[i] == consonants[len -\
    \ 1])\n        {\n            end = len - 1;\n            break;\n        }\n\
    \        else if(word[i] == consonants[0])\n        {\n            start = len\
    \ - 1;\n            break;\n        }\n    }\n    \n    if(start == end)\n   \
    \ {\n        return \"\";\n    }\n    \n    string result = \"\";\n    \n    for(int\
    \ i = start; i <= end; i++)\n    {\n        if(vowels.find(word[i]) != string::npos)\n\
    \        {\n            result = word[i];\n            break;\n        }\n   \
    \ }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp15bg3x6h.d(55): Error: found `:` when expecting `)`\n/tmp/tmp15bg3x6h.d(55):
    Error: found `:` instead of statement\n/tmp/tmp15bg3x6h.d(62): Error: declaration
    expected, not `return`\n/tmp/tmp15bg3x6h.d(63): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15bg3x6h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\") - 1])\n        {\n            return\
    \ word[i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzkr6ekey.d(27): Error: no property `length` for type `string`\n/tmp/tmpzkr6ekey.d(29):
    Error: no property `find_last_of` for type `string`\n/tmp/tmpzkr6ekey.d(31): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzkr6ekey.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n \
    \   {\n        if(it->second==1)\n        {\n            vowel=it->first;\n  \
    \          break;\n        }\n    }\n    if(vowel.length()==0)\n    {\n      \
    \  return \"\";\n    }\n    string vowel_before;\n    string vowel_after;\n  \
    \  for(int i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n   \
    \     {\n            if(word[i]==vowel)\n            {\n                vowel_before=word.substr(0,i);\n\
    \                vowel_after=word.substr(i+1,word.length());\n               \
    \ break;\n            }\n        }\n    }\n    if(vowel_before.length()==0)\n\
    \    {\n        return \"\";\n    }\n    if(vowel_after.length()==0)\n    {\n\
    \        return \"\";\n    }\n    string vowel_before2=get_closest_vowel(vowel_before);\n\
    \    string vowel_after2=get_closest_vowel(vowel_after);\n    if(vowel_before2.length()==0)\n\
    \    {\n        return vowel;\n    }\n    if(vowel_after2.length()==0)\n    {\n\
    \        return vowel;\n    }\n    if(vowel_before2==vowel)\n    {\n        return\
    \ vowel_after2;\n    }\n    if(vowel_after2==vowel)\n    {\n        return vowel_before2;\n\
    \    }\n    if(vowel_before2<vowel)\n    {\n        return vowel_before2;\n  \
    \  }\n    return vowel_after2;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxh_acfwd.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpxh_acfwd.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpxh_acfwd.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpxh_acfwd.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpxh_acfwd.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpxh_acfwd.d(39): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxh_acfwd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n\
    \    {\n        if(it->second > 0)\n        {\n            string vowel = it->first;\n\
    \            int count = it->second;\n            int index = word.length() -\
    \ 1;\n            while(index >= 0)\n            {\n                if(isVowel(word[index]))\n\
    \                {\n                    if(word[index] == vowel)\n           \
    \         {\n                        count++;\n                    }\n       \
    \             else\n                    {\n                        break;\n  \
    \                  }\n                }\n                index--;\n          \
    \  }\n            if(count > 0)\n            {\n                return vowel;\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc0suzckd.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpc0suzckd.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpc0suzckd.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpc0suzckd.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpc0suzckd.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpc0suzckd.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpc0suzckd.d(40): Error: use `.` for member
    lookup, not `->`\n/tmp/tmpc0suzckd.d(65): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc0suzckd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    for(int i =\
    \ word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] == vowels_right[i])\n\
    \        {\n            return word[i];\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfzk4mx9y.d(26): Error: no property `right` for type `string`\n/tmp/tmpfzk4mx9y.d(28):
    Error: no property `length` for type `string`\n/tmp/tmpfzk4mx9y.d(32): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzk4mx9y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    int start = 0;\n    int end = len - 1;\n    string\
    \ result = \"\";\n    while(start < end) {\n        string s = word.substr(start,\
    \ 1);\n        if(vowels.find(s) == string::npos) {\n            start = start\
    \ + 1;\n        } else {\n            end = end - 1;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n/*\nYou are\
    \ given a word. Your task is to find the closest vowel that stands between \n\
    \    two consonants from the right side of the word (case sensitive).\n    \n\
    \    Vowels in the beginning and ending doesn't count. Return empty string if\
    \ you didn't\n    find any vowel met the above condition. \nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoa_2jgnz.d(32): Error: found `:` when expecting `)`\n/tmp/tmpoa_2jgnz.d(32):
    Error: found `:` instead of statement\n/tmp/tmpoa_2jgnz.d(34): Error: found `else`
    without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpoa_2jgnz.d(37):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa_2jgnz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=vowels[word[i]]+1;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==0)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work if the word is \"ab\". It returns \"a\" instead of \"\".\n<|/ c |>\n<|\
    \ c |>\nYes, I missed that case. Thanks for pointing it out. Updated the code.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm04_chr8.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpm04_chr8.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpm04_chr8.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpm04_chr8.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpm04_chr8.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpm04_chr8.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpm04_chr8.d(43): Error: declaration expected,
    not `<`\n/tmp/tmpm04_chr8.d(46): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm04_chr8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string, int> vowel_map;\n    for(int i = 0; i < word.length(); i++)\n \
    \   {\n        string vowel = word.substr(i, 1);\n        vowel_map[vowel] = vowel_map[vowel]\
    \ + 1;\n    }\n    map<string, int>::iterator it;\n    for(it = vowel_map.begin();\
    \ it != vowel_map.end(); ++it)\n    {\n        if(it->second == 1)\n        {\n\
    \            return it->first;\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=c++,string |>\n<| c |>\nI didn't downvote you, but I suspect it's because\
    \ you didn't explain what your code does, and how it does it.\n<|/ c |>\n<| c\
    \ |>\nI added some explanation to the code. Hope it helps.\n<|/ c |>\n<| c |>\n\
    I didn't downvote you, but I suspect it's because you didn't explain what your\
    \ code does, and how it does it.\n<|/ c |>\n<| c |>\nI added some explanation\
    \ to the code. Hope it helps.\n<|/ c |>\n<| c |>\nI didn't downvote you, but I\
    \ suspect it's because you didn't explain what your code does, and how it does\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_2lqfpqs.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmp_2lqfpqs.d(32): Error: found `>` when expecting `.` following int\n/tmp/tmp_2lqfpqs.d(32):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp_2lqfpqs.d(32):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp_2lqfpqs.d(35):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp_2lqfpqs.d(37): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp_2lqfpqs.d(42): Error: declaration expected,
    not `<`\n/tmp/tmp_2lqfpqs.d(45): Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(45):
    Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(45): Error: unterminated
    character constant\n/tmp/tmp_2lqfpqs.d(51): Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(51):
    Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(51): Error: unterminated
    character constant\n/tmp/tmp_2lqfpqs.d(57): Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(57):
    Error: unterminated character constant\n/tmp/tmp_2lqfpqs.d(57): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_2lqfpqs.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.substr(vowels.rfind('e') + 1);\n    string vowels_left\
    \ = vowels.substr(0, vowels.rfind('e'));\n    string vowels_mid = vowels.substr(vowels.rfind('e')\
    \ + 1, vowels.rfind('e') - vowels.rfind('e') - 1);\n    \n    string vowels_right_lower\
    \ = vowels_right.substr(0, vowels_right.rfind('e'));\n    string vowels_right_upper\
    \ = vowels_right.substr(vowels_right.rfind('e') + 1, vowels_right.rfind('e') -\
    \ vowels_right.rfind('e') - 1);\n    string vowels_left_lower = vowels_left.substr(0,\
    \ vowels_left.rfind('e'));\n    string vowels_left_upper = vowels_left.substr(vowels_left.rfind('e')\
    \ + 1, vowels_left.rfind('e') - vowels_left.rfind('e') - 1);\n    string vowels_mid_lower\
    \ = vowels_mid.substr(0, vowels_mid.rfind('e'));\n    string vowels_mid_upper\
    \ = vowels_mid.substr(vowels_mid.rfind('e') + 1, vowels_mid.rfind('e') - vowels_mid.rfind('e')\
    \ - 1);\n    \n    string vowels_right_lower = vowels_right.substr(0, vowels_right.rfind('e'));\n\
    \    string vowels_right_upper = vowels_right.substr(vowels_right.rfind('e') +\
    \ 1, vowels_right.rfind('e') - vowels_right.rfind('e') - 1);\n    string vowels_left_lower\
    \ = vowels_left.substr(0, vowels_left.rfind('e'));\n    string vowels_left_upper\
    \ = vowels_left.substr(vowels_left.rfind('e') + 1, vowels_left.rfind('e') - vowels_left.rfind('e')\
    \ - 1);\n    string vowels_mid_lower = vowels_mid.substr(0, vowels_mid.rfind('e'));\n\
    \    string vowels_mid_upper = vowels_mid.substr(vowels_mid.rfind('e') + 1, vowels_mid.rfind('e')\
    \ - vowels_mid.rfind('e') - 1);\n    \n    string vowels_right_lower = vowels_right.substr(0,\
    \ vowels_right.rfind('e'));\n    string vowels_right_upper = vowels_right.substr(vowels_right.rfind('e')\
    \ + 1, vowels_right.rfind('e') - vowels_right.rfind('e') - 1);\n    string vowels_left_lower\
    \ = vowels_left.substr(0, vowels_left.rfind('e\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4c5_gq47.d(46): Error: unterminated character constant\n/tmp/tmp4c5_gq47.d(47):
    Error: found `unittest` when expecting `,`\n/tmp/tmp4c5_gq47.d(65): Error: found
    `void` when expecting `,`\n/tmp/tmp4c5_gq47.d(65): Error: found `{` when expecting
    `,`\n/tmp/tmp4c5_gq47.d(65): Error: expression expected, not `}`\n/tmp/tmp4c5_gq47.d(65):
    Error: found `End of File` when expecting `,`\n/tmp/tmp4c5_gq47.d(65): Error:
    found `End of File` when expecting `)`\n/tmp/tmp4c5_gq47.d(65): Error: found `End
    of File` when expecting `,`\n/tmp/tmp4c5_gq47.d(65): Error: found `End of File`
    when expecting `)`\n/tmp/tmp4c5_gq47.d(65): Error: semicolon expected, not `End
    of File`\n/tmp/tmp4c5_gq47.d(65): Error: found `End of File` when expecting `}`
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4c5_gq47.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(isVowel(word[i]))\n        {\n            for(int j=word.length()-1;j>=0;j--)\n\
    \            {\n                if(isConsonant(word[j]))\n                {\n\
    \                    if(word[j]==word[i])\n                    {\n           \
    \             if(word[j+1]==word[i])\n                        {\n            \
    \                if(word[j+2]==word[i])\n                            {\n     \
    \                           return word[i];\n                            }\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprrgt4n35.d(26): Error: no property `length` for type `string`\n/tmp/tmprrgt4n35.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmprrgt4n35.d(30): Error: no property
    `length` for type `string`\n/tmp/tmprrgt4n35.d(32): Error: undefined identifier
    `isConsonant`\n/tmp/tmprrgt4n35.d(40): Error: cannot implicitly convert expression
    `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprrgt4n35.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int left = 0;\n    int right = word.length()\
    \ - 1;\n    while(left < right) {\n        int mid = (left + right) / 2;\n   \
    \     if(word[mid] >= 'a' && word[mid] <= 'z') {\n            left = mid;\n  \
    \      } else {\n            right = mid;\n        }\n    }\n    if(word[left]\
    \ >= 'a' && word[left] <= 'z') {\n        return word[left];\n    } else {\n \
    \       return \"\";\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,algorithm,c++,c\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoxmdiv_q.d(41): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxmdiv_q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    map<string, int>::iterator it;\n    string vowel;\n    map<string, int>::iterator\
    \ it2;\n    string vowel2;\n    map<string, int>::iterator it3;\n    string vowel3;\n\
    \    map<string, int>::iterator it4;\n    string vowel4;\n    map<string, int>::iterator\
    \ it5;\n    string vowel5;\n    map<string, int>::iterator it6;\n    string vowel6;\n\
    \    map<string, int>::iterator it7;\n    string vowel7;\n    map<string, int>::iterator\
    \ it8;\n    string vowel8;\n    map<string, int>::iterator it9;\n    string vowel9;\n\
    \    map<string, int>::iterator it10;\n    string vowel10;\n    map<string, int>::iterator\
    \ it11;\n    string vowel11;\n    map<string, int>::iterator it12;\n    string\
    \ vowel12;\n    map<string, int>::iterator it13;\n    string vowel13;\n    map<string,\
    \ int>::iterator it14;\n    string vowel14;\n    map<string, int>::iterator it15;\n\
    \    string vowel15;\n    map<string, int>::iterator it16;\n    string vowel16;\n\
    \    map<string, int>::iterator it17;\n    string vowel17;\n    map<string, int>::iterator\
    \ it18;\n    string vowel18;\n    map<string, int>::iterator it19;\n    string\
    \ vowel19;\n    map<string, int>::iterator it20;\n    string vowel20;\n    map<string,\
    \ int>::iterator it21;\n    string vowel21;\n    map<string, int>::iterator it22;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1_40qksp.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp1_40qksp.d(50): Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(50):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(50):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(52):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(52): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(52):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(54):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(54): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(54):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(56):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(56): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(56):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(58):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(58): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(58):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(60):
    Error: found `>` when expecting `.` following int\n/tmp/tmp1_40qksp.d(60): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp1_40qksp.d(60):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1_40qksp.d(62):
    Error: found `>` when expecting `.` following int\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1_40qksp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.substr(vowels.rfind('A') + 1);\n    string vowels_left\
    \ = vowels.substr(0, vowels.rfind('A'));\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_right[0])\n        {\n           \
    \ int index = vowels.find(word[i]);\n            if(index != -1)\n           \
    \ {\n                string vowels_before = vowels.substr(0, index);\n       \
    \         if(vowels_before == vowels_left || vowels_before == vowels_right)\n\
    \                {\n                    return word[i];\n                }\n \
    \           }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmwjh3vde.d(26): Error: no property `substr` for type `string`\n/tmp/tmpmwjh3vde.d(27):
    Error: no property `substr` for type `string`\n/tmp/tmpmwjh3vde.d(29): Error:
    no property `length` for type `string`\n/tmp/tmpmwjh3vde.d(33): Error: no property
    `find` for type `string`\n/tmp/tmpmwjh3vde.d(36): Error: no property `substr`
    for type `string`\n/tmp/tmpmwjh3vde.d(39): Error: cannot implicitly convert expression
    `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpmwjh3vde.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int start = 0;\n    int end = word.length() - 1;\n    while(start < end)\n\
    \    {\n        int mid = (start + end) / 2;\n        if(word.at(mid) == vowels.at(mid))\n\
    \        {\n            end = mid - 1;\n        }\n        else if(word.at(mid)\
    \ == vowels.at(mid+1))\n        {\n            start = mid + 1;\n        }\n \
    \       else\n        {\n            start = mid + 1;\n            end = mid -\
    \ 1;\n        }\n    }\n    return word.at(start);\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9j2zszud.d(47): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9j2zszud.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            string vowel = word[i];\n            vowels[vowel] += 1;\n \
    \       }\n    }\n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 1)\n        {\n \
    \           return it->first;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkw3on66j.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpkw3on66j.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpkw3on66j.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpkw3on66j.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpkw3on66j.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpkw3on66j.d(39): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkw3on66j.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    string vowels = \"aeiouAEIOU\"\
    ;\n    \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int j = word.length() - 1;\n            while(j >= 0 && vowels.find(word[j])\
    \ != string::npos)\n            {\n                if(index > vowels.find(word[j]))\n\
    \                {\n                    index = vowels.find(word[j]);\n      \
    \          }\n                j--;\n            }\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc1w84f3n.d(30): Error: found `:` when expecting `)`\n/tmp/tmpc1w84f3n.d(30):
    Error: found `:` instead of statement\n/tmp/tmpc1w84f3n.d(34): Error: found `:`
    when expecting `)`\n/tmp/tmpc1w84f3n.d(34): Error: found `:` instead of statement\n/tmp/tmpc1w84f3n.d(42):
    Error: declaration expected, not `return`\n/tmp/tmpc1w84f3n.d(43): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc1w84f3n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int vowel_start\
    \ = len - 1;\n    int vowel_end = len - 1;\n    int vowel_mid = 0;\n    \n   \
    \ for(int i = 0; i < len; i++)\n    {\n        if(word[i] == 'a' || word[i] ==\
    \ 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n    \
    \        vowel_start = i;\n        }\n        else if(word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n        {\n \
    \           vowel_end = i;\n        }\n    }\n    \n    for(int i = vowel_start;\
    \ i <= vowel_end; i++)\n    {\n        vowel_mid += word[i];\n    }\n    \n  \
    \  for(int i = vowel_end; i >= vowel_start; i--)\n    {\n        vowel_mid +=\
    \ word[i];\n    }\n    \n    return vowel_mid;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7zsfqiq2.d(25): Error: no property `length` for type `string`\n/tmp/tmp7zsfqiq2.d(52):
    Error: cannot implicitly convert expression `vowel_mid` of type `int` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zsfqiq2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]++;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    string ans=\"\";\n \
    \   for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second==1)\n\
    \        {\n            ans=it->first;\n            break;\n        }\n    }\n\
    \    return ans;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis\
    \ doesn't work if you have a word like \"aba\" where there are two vowels in the\
    \ middle.\n<|/ c |>\n<| c |>\nYeah, I missed that case. Thanks for pointing it\
    \ out. I'll edit my answer.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ a word like \"aba\" where there are two vowels in the middle.\n<|/ c |>\n<|\
    \ c |>\nYeah, I missed that case. Thanks for pointing it out. I'll edit my answer.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkfmf25xs.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpkfmf25xs.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpkfmf25xs.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpkfmf25xs.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpkfmf25xs.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpkfmf25xs.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpkfmf25xs.d(45): Error: declaration expected,
    not `<`\n/tmp/tmpkfmf25xs.d(48): Error: unterminated character constant\n/tmp/tmpkfmf25xs.d(51):
    Error: unterminated character constant\n/tmp/tmpkfmf25xs.d(54): Error: unterminated
    character constant\n/tmp/tmpkfmf25xs.d(57): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkfmf25xs.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]++;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==0)\n        {\n            vowel=it->first;\n \
    \           break;\n        }\n    }\n    return vowel;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp458l5hum.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp458l5hum.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp458l5hum.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp458l5hum.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp458l5hum.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp458l5hum.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp458l5hum.d(45): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp458l5hum.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int i\
    \ = 0;\n    int j = 0;\n    string vowel = \"\";\n    \n    while(i < len && j<len)\
    \ \n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n        {\n            vowel = word[i];\n       \
    \     i = i + 1;\n        }\n        else if(word[j] == 'a' || word[j] == 'e'\
    \ || word[j] == 'i' || word[j] == 'o' || word[j] == 'u')\n        {\n        \
    \    vowel = word[j];\n            j = j + 1;\n        }\n        else if(word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U')\n\
    \        {\n            vowel = word[i];\n            i = i + 1;\n        }\n\
    \        else if(word[j] == 'A' || word[j] == 'E' || word[j] == 'I' || word[j]\
    \ == 'O' || word[j] == 'U')\n        {\n            vowel = word[j];\n       \
    \     j = j + 1;\n        }\n    }\n    return vowel;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8iwlnpdz.d(55): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8iwlnpdz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    vowels[\"\
    a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n  \
    \  vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"\
    e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n  \
    \  vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"\
    i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n  \
    \  vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"\
    o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n  \
    \  vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"\
    u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n  \
    \  vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"\
    y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n  \
    \  vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"\
    a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n  \
    \  vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"\
    e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n  \
    \  vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"\
    i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n  \
    \  vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpokrkigvj.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpokrkigvj.d(89): Error: found `unittest` when expecting `;` following
    statement\n/tmp/tmpokrkigvj.d(107): Error: found `End of File` when expecting
    `}` following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpokrkigvj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            string temp = consonants.substr(index+1,1);\n            string temp2\
    \ = consonants.substr(0,index);\n            if(temp == temp2)\n            {\n\
    \                return word[i];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqd6g0qqa.d(30): Error: found `:` when expecting `)`\n/tmp/tmpqd6g0qqa.d(30):
    Error: found `:` instead of statement\n/tmp/tmpqd6g0qqa.d(41): Error: declaration
    expected, not `return`\n/tmp/tmpqd6g0qqa.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqd6g0qqa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string,int> vowel_count;\n    for(int i=0;i<word.length();i++)\n    {\n\
    \        if(vowels.find(word[i]) != string::npos)\n        {\n            vowel_count[word[i]]++;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    for(it=vowel_count.begin();it!=vowel_count.end();it++)\n\
    \    {\n        if(it->second > 1)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if there are multiple vowels within the word.\
    \ For example, `get_closest_vowel(\"abacus\")` returns `\"a\"` instead of `\"\
    u\"`.\n<|/ c |>\n<| c |>\nI guess I missed that case. Thanks for pointing it out.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <algorithm>\n#include <cctype>\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpys_ub25u.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmpys_ub25u.d(29): Error: found `:` when expecting `)`\n/tmp/tmpys_ub25u.d(29):
    Error: found `:` instead of statement\n/tmp/tmpys_ub25u.d(34): Error: no identifier
    for declarator `map`\n/tmp/tmpys_ub25u.d(34): Error: declaration expected, not
    `<`\n/tmp/tmpys_ub25u.d(35): Error: declaration expected, not `for`\n/tmp/tmpys_ub25u.d(35):
    Error: no identifier for declarator `it`\n/tmp/tmpys_ub25u.d(35): Error: declaration
    expected, not `!=`\n/tmp/tmpys_ub25u.d(35): Error: no identifier for declarator
    `it`\n/tmp/tmpys_ub25u.d(35): Error: declaration expected, not `++`\n/tmp/tmpys_ub25u.d(40):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpys_ub25u.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n\
    \            int j = word.find_last_of(\"aeiouAEIOU\", i);\n            if(j ==\
    \ -1)\n                return \"\";\n            else\n                return\
    \ word.at(j);\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpweqkqjcx.d(25): Error: no property `length` for type `string`\n/tmp/tmpweqkqjcx.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmpweqkqjcx.d(30): Error: no property
    `find_last_of` for type `string`\n/tmp/tmpweqkqjcx.d(34): Error: no property `at`
    for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpweqkqjcx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    int len = word.length();\n   \
    \ int start = 0;\n    int end = len - 1;\n    \n    while(start < end) {\n   \
    \     \n        char c = word.chars[start];\n        char d = word.chars[end];\n\
    \        \n        if(isVowel(c)) {\n            \n            int i = start;\n\
    \            int j = end;\n            \n            while(i < j) {\n        \
    \        \n                char e = word.chars[i];\n                char f = word.chars[j];\n\
    \                \n                if(isVowel(e)) {\n                    \n  \
    \                  if(isVowel(f)) {\n                        \n              \
    \          if(isVowel(c)) {\n                            \n                  \
    \          if(isVowel(d))\n                                return c;\n       \
    \                     \n                            if(isVowel(f))\n         \
    \                       return f;\n                            \n            \
    \                if(isVowel(e))\n                                return e;\n \
    \                           \n                            if(isVowel(d))\n   \
    \                             return d;\n                            \n      \
    \                      if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \                                return f;\n                            \n   \
    \                         if(isVowel(e))\n                                return\
    \ e;\n                            \n                            if(isVowel(d))\n\
    \                                return d;\n                            \n   \
    \                         if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \                                return f;\n                            \n   \
    \                         if(isVowel(e))\n                                return\
    \ e;\n                            \n                            if(isVowel(d))\n\
    \                                return d;\n                            \n   \
    \                         if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \                                return f;\n                            \n   \
    \                         if(isVowel(e))\n                                return\
    \ e;\n                            \n                            if(isVowel(d))\n\
    \                                return d;\n                            \n   \
    \                         if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \                                return f;\n                            \n   \
    \                         if(isVowel(e))\n                                return\
    \ e;\n                            \n                            if(isVowel(d))\n\
    \                                return d;\n                            \n   \
    \                         if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \                                return f;\n                            \n   \
    \                         if(isVowel(e))\n                                return\
    \ e;\n                            \n                            if(isVowel(d))\n\
    \                                return d;\n                            \n   \
    \                         if(isVowel(c))\n                                return\
    \ c;\n                            \n                            if(isVowel(f))\n\
    \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnueeef70.d(128): Error: found `unittest` instead of statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpnueeef70.d(146):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnueeef70.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    map<string,\
    \ int> vowels2;\n    map<string, int> vowels3;\n    map<string, int> vowels4;\n\
    \    map<string, int> vowels5;\n    map<string, int> vowels6;\n    map<string,\
    \ int> vowels7;\n    map<string, int> vowels8;\n    map<string, int> vowels9;\n\
    \    map<string, int> vowels10;\n    map<string, int> vowels11;\n    map<string,\
    \ int> vowels12;\n    map<string, int> vowels13;\n    map<string, int> vowels14;\n\
    \    map<string, int> vowels15;\n    map<string, int> vowels16;\n    map<string,\
    \ int> vowels17;\n    map<string, int> vowels18;\n    map<string, int> vowels19;\n\
    \    map<string, int> vowels20;\n    map<string, int> vowels21;\n    map<string,\
    \ int> vowels22;\n    map<string, int> vowels23;\n    map<string, int> vowels24;\n\
    \    map<string, int> vowels25;\n    map<string, int> vowels26;\n    map<string,\
    \ int> vowels27;\n    map<string, int> vowels28;\n    map<string, int> vowels29;\n\
    \    map<string, int> vowels30;\n    map<string, int> vowels31;\n    map<string,\
    \ int> vowels32;\n    map<string, int> vowels33;\n    map<string, int> vowels34;\n\
    \    map<string, int> vowels35;\n    map<string, int> vowels36;\n    map<string,\
    \ int> vowels37;\n    map<string, int> vowels38;\n    map<string, int> vowels39;\n\
    \    map<string, int> vowels40;\n    map<string, int> vowels41;\n    map<string,\
    \ int> vowels42;\n    map<string, int> vowels43;\n    map<string, int> vowels44;\n\
    \    map<string, int> vowels45;\n    map<string, int> vowels46;\n    map<string,\
    \ int> vowels47;\n    map<string, int> vowels48;\n    map<string, int\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj6a4f42w.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(26): Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(27):
    Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(28): Error:
    found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(29): Error: found
    `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(30): Error: found `>`
    when expecting `.` following int\n/tmp/tmpj6a4f42w.d(31): Error: found `>` when
    expecting `.` following int\n/tmp/tmpj6a4f42w.d(32): Error: found `>` when expecting
    `.` following int\n/tmp/tmpj6a4f42w.d(33): Error: found `>` when expecting `.`
    following int\n/tmp/tmpj6a4f42w.d(34): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(35): Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(36):
    Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(37): Error:
    found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(38): Error: found
    `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(39): Error: found `>`
    when expecting `.` following int\n/tmp/tmpj6a4f42w.d(40): Error: found `>` when
    expecting `.` following int\n/tmp/tmpj6a4f42w.d(41): Error: found `>` when expecting
    `.` following int\n/tmp/tmpj6a4f42w.d(42): Error: found `>` when expecting `.`
    following int\n/tmp/tmpj6a4f42w.d(43): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(44): Error: found `>` when expecting `.` following int\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6a4f42w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9l9xnw3e.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9l9xnw3e.d(97): Error: unterminated string constant starting at /tmp/tmp9l9xnw3e.d(114)\n/tmp/tmp9l9xnw3e.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmp9l9xnw3e.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(106): Error: found `ali` when expecting `,`\n/tmp/tmp9l9xnw3e.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(107): Error: found `bad` when expecting `,`\n/tmp/tmp9l9xnw3e.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `o` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(110): Error: found `ba` when expecting `,`\n/tmp/tmp9l9xnw3e.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l9xnw3e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    int start = 0;\n    int end = len - 1;\n\
    \    \n    while (start < end) {\n        int mid = (start + end) / 2;\n     \
    \   \n        if (word.charAt(mid) == vowels.at(mid)) {\n            end = mid\
    \ - 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n   \
    \ \n    return word.substr(start, 1);\n}\n</code>\n<|/ a tags=c++,string,algorithm\
    \ |>\n<| c |>\nThe code doesn't compile. `word.substr(start, 1)` should be `word.substr(start,\
    \ 1)`\n<|/ c |>\n<| a tags=c++,string,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcyq5x3v7.d(43): Error: declaration expected, not `<`\n/tmp/tmpcyq5x3v7.d(46):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpcyq5x3v7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            vowels[word[i]]++;\n\
    \        }\n    }\n    \n    for(int i = word.length() - 1; i >= 0; i--)\n   \
    \ {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n        {\n            if(vowels[word[i]] > 0)\n\
    \            {\n                if(vowels[word[i]] > vowels[word[i - 1]])\n  \
    \              {\n                    return word[i];\n                }\n   \
    \         }\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqfz1plk9.d(25): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfz1plk9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int left = 0;\n    int right = word.length() - 1;\n    \n    while (left\
    \ < right) {\n        int mid = (left + right) / 2;\n        \n        if (word.charAt(mid)\
    \ == vowels.at(mid)) {\n            left = mid;\n        } else {\n          \
    \  right = mid;\n        }\n    }\n    \n    return word.substr(right + 1, 1);\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpomomgrwd.d(28): Error: no property `length` for type `string`\n/tmp/tmpomomgrwd.d(33):
    Error: no property `charAt` for type `string`\n/tmp/tmpomomgrwd.d(33): Error:
    no property `at` for type `string`\n/tmp/tmpomomgrwd.d(40): Error: no property
    `substr` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomomgrwd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    \n    map<string, int> consonants;\n    consonants[\"a\"] = 1;\n   \
    \ consonants[\"b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] =\
    \ 1;\n    consonants[\"e\"] = 1;\n    consonants[\"f\"] = 1;\n    consonants[\"\
    g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"i\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"o\"] = 1;\n    consonants[\"\
    p\"] = 1;\n    consonants[\"q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"\
    s\"] = 1;\n    consonants[\"t\"] = 1;\n    consonants[\"u\"] = 1;\n    consonants[\"\
    v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"x\"] = 1;\n    consonants[\"\
    y\"] = 1;\n    consonants[\"z\"] = 1;\n    consonants[\"A\"] = 1;\n    consonants[\"\
    B\"] = 1;\n    consonants[\"C\"] = 1;\n    consonants[\"D\"] = 1;\n    consonants[\"\
    E\"] = 1;\n    consonants[\"F\"] = 1;\n    consonants[\"G\"] = 1;\n    consonants[\"\
    H\"] = 1;\n    consonants[\"I\"] = 1;\n    consonants[\"J\"] = 1;\n    consonants[\"\
    K\"] = 1;\n    consonants[\"L\"] = 1;\n    consonants[\"M\"] = 1;\n    consonants[\"\
    N\"] = 1;\n    con\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsrix4wj_.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsrix4wj_.d(51): Error: found `>` when expecting `.` following int\n/tmp/tmpsrix4wj_.d(93):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpsrix4wj_.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsrix4wj_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        string temp\
    \ = word.substr(i, 1);\n        if(vowels.find(temp) != string::npos)\n      \
    \  {\n            int index = vowels.find(temp);\n            string a = word.substr(0,\
    \ i);\n            string b = word.substr(i, word.length());\n            string\
    \ c = word.substr(index + 1, word.length());\n            string d = word.substr(index\
    \ + 2, word.length());\n            string e = word.substr(index + 3, word.length());\n\
    \            string f = word.substr(index + 4, word.length());\n            string\
    \ g = word.substr(index + 5, word.length());\n            string h = word.substr(index\
    \ + 6, word.length());\n            string i = word.substr(index + 7, word.length());\n\
    \            string j = word.substr(index + 8, word.length());\n            string\
    \ k = word.substr(index + 9, word.length());\n            string l = word.substr(index\
    \ + 10, word.length());\n            string m = word.substr(index + 11, word.length());\n\
    \            string n = word.substr(index + 12, word.length());\n            string\
    \ o = word.substr(index + 13, word.length());\n            string p = word.substr(index\
    \ + 14, word.length());\n            string q = word.substr(index + 15, word.length());\n\
    \            string r = word.substr(index + 16, word.length());\n            string\
    \ s = word.substr(index + 17, word.length());\n            string t = word.substr(index\
    \ + 18, word.length());\n            string u = word.substr(index + 19, word.length());\n\
    \            string v = word.substr(index + 20, word.length());\n            string\
    \ w = word.substr(index + 21, word.length());\n            string x = word.substr(index\
    \ + 22, word.length());\n            string y = word.substr(index + 23, word.length());\n\
    \            string z = word.substr(index + 24, word.length());\n            string\
    \ A = word.substr(index + 25, word.length());\n            string B = word.substr(index\
    \ + 26, word.length());\n            string C = word.substr(index + 27, word.length());\n\
    \            string D = word.substr(index + 28, word.length());\n            string\
    \ E = word.substr(index + 29, word.length());\n            string F = word.substr(index\
    \ + 30, word.length());\n            string G = word.substr(index + 31, word.length());\n\
    \            string H = word.substr(index + 32, word.length());\n            string\
    \ I = word.substr(index + 33, word.length());\n            string J = word.substr(index\
    \ + 34, word.length());\n            string K = word.substr(index + 35, word.length());\n\
    \            string L = word.substr(index + 36, word.length());\n            string\
    \ M = word.substr(index + 37, word.length());\n            string N = word.substr(index\
    \ + 38, word.length());\n            string O = word.substr(index + 39, word.length());\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprct5_ygt.d(30): Error: found `:` when expecting `)`\n/tmp/tmprct5_ygt.d(30):
    Error: found `:` instead of statement\n/tmp/tmprct5_ygt.d(74): Error: found `unittest`
    instead of statement\n/tmp/tmprct5_ygt.d(92): Error: found `End of File` when
    expecting `}` following compound statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprct5_ygt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    map<string, int>::iterator\
    \ it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n    {\n       \
    \ if(it->second > 0)\n        {\n            string vowel = it->first;\n     \
    \       int count = it->second;\n            int index = word.length() - 1;\n\
    \            while(index >= 0)\n            {\n                if(isVowel(word[index]))\n\
    \                {\n                    if(word[index] == vowel)\n           \
    \         {\n                        count--;\n                    }\n       \
    \             if(count == 0)\n                    {\n                        break;\n\
    \                    }\n                }\n                index--;\n        \
    \    }\n            if(count > 0)\n            {\n                return vowel;\n\
    \            }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph_wtesxa.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmph_wtesxa.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmph_wtesxa.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmph_wtesxa.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmph_wtesxa.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmph_wtesxa.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmph_wtesxa.d(39): Error: use `.` for member
    lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph_wtesxa.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ < end)\n    {\n        int mid = (start + end) / 2;\n        \n        if (word.charAt(mid)\
    \ == vowels.at(mid))\n        {\n            end = mid - 1;\n        }\n     \
    \   else\n        {\n            start = mid + 1;\n        }\n    }\n    \n  \
    \  return word.substr(start, 1);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpifcwhunc.d(28): Error: no property `length` for type `string`\n/tmp/tmpifcwhunc.d(34):
    Error: no property `charAt` for type `string`\n/tmp/tmpifcwhunc.d(34): Error:
    no property `at` for type `string`\n/tmp/tmpifcwhunc.d(44): Error: no property
    `substr` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpifcwhunc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1; i>=0; i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n   \
    \         int j = word.find_last_of(\"aeiou\", i);\n            if(j != -1)\n\
    \            {\n                return word.substr(i, j);\n            }\n   \
    \     }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm717vkeb.d(25): Error: no property `length` for type `string`\n/tmp/tmpm717vkeb.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmpm717vkeb.d(30): Error: no property
    `find_last_of` for type `string`\n/tmp/tmpm717vkeb.d(33): Error: no property `substr`
    for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm717vkeb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reversed = vowels.rbegin();\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_reversed[i])\n        {\n        \
    \    int j = word.find_last_of(vowels_reversed[i]);\n            int k = word.find_last_of(vowels_reversed[j]);\n\
    \            int l = word.find_last_of(vowels_reversed[k]);\n            int m\
    \ = word.find_last_of(vowels_reversed[l]);\n            int n = word.find_last_of(vowels_reversed[m]);\n\
    \            int o = word.find_last_of(vowels_reversed[n]);\n            int p\
    \ = word.find_last_of(vowels_reversed[o]);\n            int q = word.find_last_of(vowels_reversed[p]);\n\
    \            int r = word.find_last_of(vowels_reversed[q]);\n            int s\
    \ = word.find_last_of(vowels_reversed[r]);\n            int t = word.find_last_of(vowels_reversed[s]);\n\
    \            int u = word.find_last_of(vowels_reversed[t]);\n            int v\
    \ = word.find_last_of(vowels_reversed[u]);\n            int w = word.find_last_of(vowels_reversed[v]);\n\
    \            int x = word.find_last_of(vowels_reversed[w]);\n            int y\
    \ = word.find_last_of(vowels_reversed[x]);\n            int z = word.find_last_of(vowels_reversed[y]);\n\
    \            \n            if(j > -1 && j == k)\n            {\n             \
    \   return word[j];\n            }\n            else if(j > -1 && j == l)\n  \
    \          {\n                return word[j];\n            }\n            else\
    \ if(j > -1 && j == m)\n            {\n                return word[j];\n     \
    \       }\n            else if(j > -1 && j == n)\n            {\n            \
    \    return word[j];\n            }\n            else if(j > -1 && j == o)\n \
    \           {\n                return word[j];\n            }\n            else\
    \ if(j > -1 && j == p)\n            {\n                return word[j];\n     \
    \       }\n            else if(j > -1 && j == q)\n            {\n            \
    \    return word[j];\n            }\n            else if(j > -1 && j == r)\n \
    \           {\n                return word[j];\n            }\n            else\
    \ if(j > -1 && j == s)\n            {\n                return word[j];\n     \
    \       }\n            else if(j > -1 && j == t)\n            {\n            \
    \    return word[j];\n            }\n            else if(j > -1 && j == u)\n \
    \           {\n                return word[j];\n            }\n            else\
    \ if(j > -1 && j == v)\n            {\n                return word[j];\n\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbchfdf87.d(98): Error: found `unittest` instead of statement\n/tmp/tmpbchfdf87.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbchfdf87.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpbchfdf87.d(116):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbchfdf87.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=1;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==1)\n        {\n            vowel=it->first;\n \
    \           break;\n        }\n    }\n    return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try \"ab\".\n<|/ c |>\n<| c |>\nI didn't test\
    \ it but I think it works. I tested it on \"ab\" and the result is \"u\"\n<|/\
    \ c |>\n<| c |>\nIt doesn't work. Try \"ab\".\n<|/ c |>\n<| c |>\nI tested it\
    \ on \"ab\" and the result is \"u\"\n<|/ c |>\n<| c |>\nI tested it on \"ab\"\
    \ and the result is \"u\"\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9z2a8ozl.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9z2a8ozl.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp9z2a8ozl.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp9z2a8ozl.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp9z2a8ozl.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp9z2a8ozl.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp9z2a8ozl.d(45): Error: declaration expected,
    not `<`\n/tmp/tmp9z2a8ozl.d(48): Error: unterminated character constant\n/tmp/tmp9z2a8ozl.d(51):
    Error: unterminated character constant\n/tmp/tmp9z2a8ozl.d(54): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9z2a8ozl.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            int index = vowels[word[i]];\n\
    \            if(index != -1)\n            {\n                string vowel = word.substr(0,\
    \ i);\n                if(vowel.compare(word) == 0)\n                {\n     \
    \               return vowel;\n                }\n            }\n        }\n \
    \   }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyrb9ujiv.d(25): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrb9ujiv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reversed = vowels.rbegin();\n    string vowels_reversed_reversed\
    \ = vowels_reversed.rbegin();\n    \n    for(int i = 0; i < word.length(); i++)\n\
    \    {\n        if(word[i] == vowels_reversed[i])\n        {\n            int\
    \ index = vowels_reversed.find(word[i]);\n            if(index != -1)\n      \
    \      {\n                int index2 = vowels_reversed_reversed.find(word[i]);\n\
    \                if(index2 != -1)\n                {\n                    int\
    \ index_min = min(index, index2);\n                    if(index_min == index)\n\
    \                    {\n                        return word[i];\n            \
    \        }\n                    else if(index_min == index2)\n               \
    \     {\n                        return word[i];\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis solution fails for \"ab\" because\
    \ \"ab\" contains \"a\" which is not in the vowels list. Also \"ab\" contains\
    \ \"e\" which is not in the vowels list.\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ I missed that case. Thanks for pointing out. I've updated the answer.\n<|/ c\
    \ |>\n<| c |>\nThis solution fails for \"ab\" because \"ab\" contains \"a\" which\
    \ is not in the vowels list. Also \"ab\" contains \"e\" which is not in the vowels\
    \ list.\n<|/ c |>\n<| c |>\nYes, you are right. I missed that case. Thanks for\
    \ pointing out. I've updated the answer.\n<|/ c |>\n<| c |>\nThis solution fails\
    \ for \"ab\" because \"ab\" contains \"a\" which is not in the vowels list. Also\
    \ \"ab\" contains \"e\" which is not in the vowels list.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps8jm2ctj.d(54): Error: declaration expected, not `<`\n/tmp/tmps8jm2ctj.d(60):
    Error: unterminated character constant\n/tmp/tmps8jm2ctj.d(66): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8jm2ctj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it;\n    string result = \"\";\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 2)\n        {\n \
    \           result = it->first;\n            break;\n        }\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxlbdej1m.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpxlbdej1m.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpxlbdej1m.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpxlbdej1m.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpxlbdej1m.d(38):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpxlbdej1m.d(40): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlbdej1m.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int i\
    \ = 0;\n    int j = 0;\n    int vowel_found = 0;\n    \n    while(i < len && j\
    \ < len) \n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u')\n        {\n            vowel_found = 1;\n\
    \            break;\n        }\n        i++;\n        j++;\n    }\n    if(vowel_found\
    \ == 0)\n        return \"\";\n    \n    string vowel = word[i];\n    \n    while(i\
    \ < len && j < len) \n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            vowel =\
    \ word[i];\n            break;\n        }\n        i++;\n        j++;\n    }\n\
    \    \n    return vowel;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6zh4lhe7.d(58): Error: declaration expected, not `<`\n/tmp/tmp6zh4lhe7.d(63):
    Error: identifier expected following `package`\n/tmp/tmp6zh4lhe7.d(63): Error:
    `;` expected\n/tmp/tmp6zh4lhe7.d(64): Error: identifier expected following `package`\n/tmp/tmp6zh4lhe7.d(64):
    Error: `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zh4lhe7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]] = vowels[word[i]] + 1;\n        }\n    }\n \
    \   \n    map<string, int>::iterator it;\n    for(it = vowels.begin(); it != vowels.end();\
    \ it++)\n    {\n        if(it->second > 1)\n        {\n            string vowel\
    \ = it->first;\n            int count = it->second;\n            int index = word.length()\
    \ - 1;\n            while(index >= 0)\n            {\n                if(isVowel(word[index]))\n\
    \                {\n                    if(word[index] == vowel)\n           \
    \         {\n                        if(count > 1)\n                        {\n\
    \                            string temp = word;\n                           \
    \ word = \"\";\n                            return temp;\n                   \
    \     }\n                        else\n                        {\n           \
    \                 word = \"\";\n                            return \"\";\n   \
    \                     }\n                    }\n                    else\n   \
    \                 {\n                        word = word.substr(0, index) + word.substr(index\
    \ + 1);\n                        index--;\n                    }\n           \
    \     }\n                else\n                {\n                    index--;\n\
    \                }\n            }\n        }\n    }\n    \n    return \"\";\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppaubkb8c.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmppaubkb8c.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmppaubkb8c.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmppaubkb8c.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmppaubkb8c.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmppaubkb8c.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmppaubkb8c.d(40): Error: use `.` for member
    lookup, not `->`\n/tmp/tmppaubkb8c.d(76): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppaubkb8c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\", i)]) \n        {\n            return\
    \ word[i];\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj9vswmb9.d(27): Error: no property `length` for type `string`\n/tmp/tmpj9vswmb9.d(29):
    Error: no property `find_last_of` for type `string`\n/tmp/tmpj9vswmb9.d(31): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9vswmb9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ < end) {\n        string vowel = word.substr(start, 1);\n        \n        if\
    \ (vowels.find(vowel) != string::npos) {\n            start = end + 1;\n     \
    \       end = word.length() - 1;\n        }\n        else {\n            end =\
    \ start - 1;\n        }\n    }\n    \n    return word.substr(start, 1);\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmzzew_gc.d(33): Error: found `:` when expecting `)`\n/tmp/tmpmzzew_gc.d(33):
    Error: found `:` instead of statement\n/tmp/tmpmzzew_gc.d(37): Error: found `else`
    without a corresponding `if`, `version` or `debug` statement\n/tmp/tmpmzzew_gc.d(40):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmzzew_gc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isalpha(word[i]))\n        {\n \
    \           string vowel = word[i];\n            vowels[vowel]++;\n        }\n\
    \    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==1)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ your answer. Can you please explain why you used `map<string,int> vowels;` instead\
    \ of `map<string,int> vowels;`?\n<|/ c |>\n<| c |>\nI used `map<string,int> vowels;`\
    \ because I wanted to count the number of vowels present in the word. `vowels[vowel]++;`\
    \ will increment the count of vowels present in the word and `it->second==1` will\
    \ check if the count is equal to 1. I used `map<string,int> vowels;` because I\
    \ wanted to count the number of vowels present in the word. `vowels[vowel]++;`\
    \ will increment the count of vowels present in the word and `it->second==1` will\
    \ check if the count is equal to 1. I used `map<string,int> vowels;` because I\
    \ wanted to count the number of vowels present in the word. `vowels[vowel]++;`\
    \ will increment the count of vowels present in the word and `it->second==1` will\
    \ check if the count is equal to 1.\n<|/ c |>\n<| c |>\nI used `map<string,int>\
    \ vowels;` because I wanted to count the number of vowels present in the word.\
    \ `vowels[vowel]++;` will increment the count of vowels present in the word and\
    \ `it->second==1` will check if the count is equal to 1. I used `map<string,int>\
    \ vowels;` because I wanted to count the number of vowels present in the word.\
    \ `vowels[vowel]++;` will increment the count of vowels present in the word and\
    \ `it->second==1` will check if the count is equal to 1. I used `map<string,int>\
    \ vowels;` because I wanted to count the number of vowels present in the word.\
    \ `vowels[vowel]++;` will increment the count of vowels present in the word and\
    \ `it->second==1` will check if the count is equal to 1.\n<|/ c |>\n<| c |>\n\
    I used `map<string,int> vowels;` because I wanted to count the number of vowels\
    \ present in the word. `vowels[vowel]++;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi5xah3b4.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpi5xah3b4.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpi5xah3b4.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpi5xah3b4.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpi5xah3b4.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpi5xah3b4.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpi5xah3b4.d(44): Error: declaration expected,
    not `<`\n/tmp/tmpi5xah3b4.d(56): Error: unterminated string constant starting
    at /tmp/tmpi5xah3b4.d(56)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5xah3b4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int start\
    \ = 0;\n    int end = len - 1;\n    int mid = 0;\n    string vowel = \"\";\n \
    \   \n    while(start < end) {\n        mid = (start + end) / 2;\n        \n \
    \       if(word.charAt(mid) == word.charAt(mid + 1))\n            end = mid -\
    \ 1;\n        else if(word.charAt(mid) == word.charAt(mid - 1))\n            start\
    \ = mid + 1;\n        else\n            vowel = word.charAt(mid);\n    }\n   \
    \ return vowel;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic\
    \ String getClosestVowel(String word) {\n    int len = word.length();\n    int\
    \ start = 0;\n    int end = len - 1;\n    int mid = 0;\n    char vowel;\n    \n\
    \    while(start < end) {\n        mid = (start + end) / 2;\n        \n      \
    \  if(word.charAt(mid) == word.charAt(mid + 1))\n            end = mid - 1;\n\
    \        else if(word.charAt(mid) == word.charAt(mid - 1))\n            start\
    \ = mid + 1;\n        else\n            vowel = word.charAt(mid);\n    }\n   \
    \ return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| a dscore=0\
    \ |>\n<code>\npublic String getClosestVowel(String word) {\n    int len = word.length();\n\
    \    int start = 0;\n    int end = len - 1;\n    int mid = 0;\n    char vowel;\n\
    \    \n    while(start < end) {\n        mid = (start + end) / 2;\n        \n\
    \        if(word.charAt(mid) == word.charAt(mid + 1))\n            end = mid -\
    \ 1;\n        else if(word.charAt(mid) == word.charAt(mid - 1))\n            start\
    \ = mid + 1;\n        else\n            vowel = word.charAt(mid);\n    }\n   \
    \ return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| a dscore=0\
    \ |>\n<code>\npublic String getClosestVowel(String word) {\n    int len = word.length();\n\
    \    int start = 0;\n    int end = len - 1;\n    int mid = 0;\n    char vowel;\n\
    \    \n    while(start < end) {\n        mid = (start + end) / 2;\n        \n\
    \        if(word.charAt(mid) == word.charAt(mid + 1))\n            end = mid -\
    \ 1;\n        else if(word.charAt(mid) == word.charAt(mid - 1))\n            start\
    \ = mid + 1;\n        else\n            vowel = word.charAt(mid);\n    }\n   \
    \ return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3rnz_pbi.d(43): Error: declaration expected, not `<`\n/tmp/tmp3rnz_pbi.d(54):
    Error: declaration expected, not `while`\n/tmp/tmp3rnz_pbi.d(57): Error: declaration
    expected, not `if`\n/tmp/tmp3rnz_pbi.d(59): Error: declaration expected, not `else`\n/tmp/tmp3rnz_pbi.d(61):
    Error: declaration expected, not `else`\n/tmp/tmp3rnz_pbi.d(63): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3rnz_pbi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    map<string, int>::iterator it;\n    string vowel = \"\";\n    for(it\
    \ = vowels.begin(); it != vowels.end(); ++it)\n    {\n        if(word.find(it->first)\
    \ != string::npos)\n        {\n            vowel = it->first;\n            break;\n\
    \        }\n    }\n    return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis code doesn't work if the word is \"ab\". It returns \"a\"\
    \ instead of \"b\".\n<|/ c |>\n<| c |>\nIt doesn't work because you didn't read\
    \ the question carefully. The question says \"You may assume that the given string\
    \ contains English letter only.\" The code doesn't work because \"ab\" contains\
    \ \"a\" and \"b\" which are not vowels.\n<|/ c |>\n<| c |>\nI read the question\
    \ carefully. The code doesn't work because \"ab\" contains \"a\" and \"b\" which\
    \ are not vowels.\n<|/ c |>\n<| c |>\nI read the question carefully. The code\
    \ doesn't work because \"ab\" contains \"a\" and \"b\" which are not vowels.\n\
    <|/ c |>\n<| c |>\nI read the question carefully. The code doesn't work because\
    \ \"ab\" contains \"a\" and \"b\" which are not vowels.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq9akui6j.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpq9akui6j.d(50): Error: found `>` when expecting `.` following int\n/tmp/tmpq9akui6j.d(50):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpq9akui6j.d(50):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpq9akui6j.d(54):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpq9akui6j.d(54): Error: found
    `:` when expecting `)`\n/tmp/tmpq9akui6j.d(54): Error: found `:` instead of statement\n/tmp/tmpq9akui6j.d(60):
    Error: declaration expected, not `return`\n/tmp/tmpq9akui6j.d(61): Error: unrecognized
    declaration\n/tmp/tmpq9akui6j.d(65): Error: unterminated character constant\n/tmp/tmpq9akui6j.d(68):
    Error: unterminated character constant\n/tmp/tmpq9akui6j.d(68): Error: unterminated
    character constant\n/tmp/tmpq9akui6j.d(68): Error: unterminated character constant\n/tmp/tmpq9akui6j.d(71):
    Error: unterminated character constant\n/tmp/tmpq9akui6j.d(74): Error: unterminated
    character constant\n/tmp/tmpq9akui6j.d(77): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9akui6j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    int start = 0;\n    int end = 0;\n    int vowelCount\
    \ = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            vowelCount++;\n        }\n    }\n \
    \   for(int i = len - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            vowelCount++;\n        }\n    }\n \
    \   if(vowelCount > 2)\n    {\n        start = len - vowelCount;\n        end\
    \ = len - 1;\n    }\n    else\n    {\n        start = len - 1;\n        end =\
    \ len - 1;\n    }\n    string result = \"\";\n    for(int i = start; i <= end;\
    \ i++)\n    {\n        if(vowels.find(word[i]) != string::npos)\n        {\n \
    \           result = word[i];\n            break;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c++ |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6klekhxi.d(32): Error: found `:` when expecting `)`\n/tmp/tmp6klekhxi.d(32):
    Error: found `:` instead of statement\n/tmp/tmp6klekhxi.d(37): Error: declaration
    expected, not `for`\n/tmp/tmp6klekhxi.d(37): Error: no identifier for declarator
    `i`\n/tmp/tmp6klekhxi.d(37): Error: declaration expected, not `>=`\n/tmp/tmp6klekhxi.d(37):
    Error: no identifier for declarator `i`\n/tmp/tmp6klekhxi.d(37): Error: declaration
    expected, not `--`\n/tmp/tmp6klekhxi.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6klekhxi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    for(int i = 0; i < word.length(); i++)\n    {\n        for(int j = 0; j <\
    \ vowels.length(); j++)\n        {\n            if(word[i] == vowels[j])\n   \
    \         {\n                string vowel_start = word.substr(0, i);\n       \
    \         string vowel_end = word.substr(i, word.length());\n                string\
    \ vowel_middle = word.substr(i, word.length()/2);\n                \n        \
    \        if(vowel_start.length() > vowel_middle.length())\n                {\n\
    \                    return vowel_start;\n                }\n                else\
    \ if(vowel_middle.length() > vowel_end.length())\n                {\n        \
    \            return vowel_middle;\n                }\n                else\n \
    \               {\n                    return vowel_end;\n                }\n\
    \            }\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf4tz4dhn.d(28): Error: no property `length` for type `string`\n/tmp/tmpf4tz4dhn.d(30):
    Error: no property `length` for type `string`\n/tmp/tmpf4tz4dhn.d(34): Error:
    no property `substr` for type `string`\n/tmp/tmpf4tz4dhn.d(35): Error: no property
    `substr` for type `string`\n/tmp/tmpf4tz4dhn.d(36): Error: no property `substr`
    for type `string`\n/tmp/tmpf4tz4dhn.d(38): Error: no property `length` for type
    `string`\n/tmp/tmpf4tz4dhn.d(38): Error: no property `length` for type `string`\n/tmp/tmpf4tz4dhn.d(42):
    Error: no property `length` for type `string`\n/tmp/tmpf4tz4dhn.d(42): Error:
    no property `length` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpf4tz4dhn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reverse = vowels.rbegin();\n    string vowels_reverse2 = vowels.rend();\n\
    \    \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(word[i] ==\
    \ vowels[word.length() - 1 - i])\n        {\n            return word[i];\n   \
    \     }\n    }\n    \n    for(int i = 0; i < word.length(); i++)\n    {\n    \
    \    if(word[i] == vowels_reverse[word.length() - 1 - i])\n        {\n       \
    \     return word[i];\n        }\n    }\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_reverse2[word.length() - 1 - i])\n\
    \        {\n            return word[i];\n        }\n    }\n    \n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt4yn09rf.d(26): Error: no property `rbegin` for type `string`\n/tmp/tmpt4yn09rf.d(27):
    Error: no property `rend` for type `string`\n/tmp/tmpt4yn09rf.d(29): Error: no
    property `length` for type `string`\n/tmp/tmpt4yn09rf.d(31): Error: no property
    `length` for type `string`\n/tmp/tmpt4yn09rf.d(37): Error: no property `length`
    for type `string`\n/tmp/tmpt4yn09rf.d(39): Error: no property `length` for type
    `string`\n/tmp/tmpt4yn09rf.d(45): Error: no property `length` for type `string`\n/tmp/tmpt4yn09rf.d(47):
    Error: no property `length` for type `string`\n/tmp/tmpt4yn09rf.d(33): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\n/tmp/tmpt4yn09rf.d(41): Error: cannot implicitly convert expression
    `word[cast(ulong)i]` of type `immutable(char)` to `string`\n/tmp/tmpt4yn09rf.d(49):
    Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt4yn09rf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.size()-1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int index2 = word[i] == 'a' ? 0 : 1;\n            int index3 = word[i]\
    \ == 'e' ? 2 : 3;\n            int index4 = word[i] == 'i' ? 4 : 5;\n        \
    \    int index5 = word[i] == 'o' ? 6 : 7;\n            int index6 = word[i] ==\
    \ 'u' ? 8 : 9;\n            \n            int index7 = word[i] == 'A' ? 0 : 1;\n\
    \            int index8 = word[i] == 'E' ? 2 : 3;\n            int index9 = word[i]\
    \ == 'I' ? 4 : 5;\n            int index10 = word[i] == 'O' ? 6 : 7;\n       \
    \     int index11 = word[i] == 'U' ? 8 : 9;\n            \n            int index12\
    \ = word[i] == 'a' ? 0 : 1;\n            int index13 = word[i] == 'e' ? 2 : 3;\n\
    \            int index14 = word[i] == 'i' ? 4 : 5;\n            int index15 =\
    \ word[i] == 'o' ? 6 : 7;\n            int index16 = word[i] == 'u' ? 8 : 9;\n\
    \            \n            int index17 = word[i] == 'A' ? 0 : 1;\n           \
    \ int index18 = word[i] == 'E' ? 2 : 3;\n            int index19 = word[i] ==\
    \ 'I' ? 4 : 5;\n            int index20 = word[i] == 'O' ? 6 : 7;\n          \
    \  int index21 = word[i] == 'U' ? 8 : 9;\n            \n            int index22\
    \ = word[i] == 'a' ? 0 : 1;\n            int index23 = word[i] == 'e' ? 2 : 3;\n\
    \            int index24 = word[i] == 'i' ? 4 : 5;\n            int index25 =\
    \ word[i] == 'o' ? 6 : 7;\n            int index26 = word[i] == 'u' ? 8 : 9;\n\
    \            \n            int index27 = word[i] == 'A' ? 0 : 1;\n           \
    \ int index28 = word[i] == 'E' ? 2 : 3;\n            int index29 = word[i] ==\
    \ 'I' ? 4 : 5;\n            int index30 = word[i] == 'O' ? 6 : 7;\n          \
    \  int index31 = word[i] == 'U' ? 8 : 9;\n            \n            int index32\
    \ = word[i] == 'a' ? 0 : 1;\n            int index33 = word[i] == 'e' ? 2 : 3;\n\
    \            int index34 = word[i] == 'i' ? 4 : 5;\n            int index35 =\
    \ word[i] == 'o' ? \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp68d3mrhp.d(29): Error: found `:` when expecting `)`\n/tmp/tmp68d3mrhp.d(29):
    Error: found `:` instead of statement\n/tmp/tmp68d3mrhp.d(72): Error: expression
    expected, not `unittest`\n/tmp/tmp68d3mrhp.d(73): Error: found `{` when expecting
    `:`\n/tmp/tmp68d3mrhp.d(74): Error: expression expected, not `alias`\n/tmp/tmp68d3mrhp.d(74):
    Error: semicolon expected, not `candidate`\n/tmp/tmp68d3mrhp.d(90): Error: found
    `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp68d3mrhp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isalpha(word[i]))\n      \
    \  {\n            string vowel = word[i];\n            vowels[vowel] = vowels[vowel]\
    \ + 1;\n        }\n    }\n    \n    map<string, int>::iterator it;\n    for(it\
    \ = vowels.begin(); it != vowels.end(); it++)\n    {\n        if(it->second >\
    \ 1)\n        {\n            string vowel = it->first;\n            int vowel_count\
    \ = it->second;\n            int vowel_count_right = vowel_count - 1;\n      \
    \      int vowel_count_left = vowel_count + 1;\n            string vowel_right;\n\
    \            string vowel_left;\n            string vowel_middle;\n          \
    \  \n            if(vowel_count_right == 0)\n            {\n                vowel_right\
    \ = vowel;\n            }\n            else if(vowel_count_left == 0)\n      \
    \      {\n                vowel_left = vowel;\n            }\n            else\n\
    \            {\n                vowel_middle = vowel;\n            }\n       \
    \     \n            int vowel_count_right_index = vowel.rfind(vowel_right);\n\
    \            int vowel_count_left_index = vowel.rfind(vowel_left);\n         \
    \   int vowel_count_middle_index = vowel.rfind(vowel_middle);\n            \n\
    \            int vowel_count_right_index_2 = vowel.rfind(vowel_right, vowel_count_right_index\
    \ + 1);\n            int vowel_count_left_index_2 = vowel.rfind(vowel_left, vowel_count_left_index\
    \ + 1);\n            int vowel_count_middle_index_2 = vowel.rfind(vowel_middle,\
    \ vowel_count_middle_index + 1);\n            \n            int vowel_count_right_index_3\
    \ = vowel.rfind(vowel_right, vowel_count_right_index + 2);\n            int vowel_count_left_index_3\
    \ = vowel.rfind(vowel_left, vowel_count_left_index + 2);\n            int vowel_count_middle_index_3\
    \ = vowel.rfind(vowel_middle, vowel_count_middle_index + 2);\n            \n \
    \           int vowel_count_right_index_4 = vowel.rfind(vowel_right, vowel_count_right_index\
    \ + 3);\n            int vowel_count_left_index_4 = vowel.rfind(vowel_left, vowel_count_left_index\
    \ + 3);\n            int vowel_count_middle_index_4 = vowel.rfind(vowel_middle,\
    \ vowel_count_middle_index + 3);\n            \n            int vowel_count_right_index_5\
    \ = vowel.rfind(vowel_right, vowel_count_right_index + 4);\n            int vowel_count_left_index_5\
    \ = vowel.rfind(vowel_left, vowel_count_left_index + 4);\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1ql_y694.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp1ql_y694.d(35): Error: found `>` when expecting `.` following int\n/tmp/tmp1ql_y694.d(35):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp1ql_y694.d(35):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp1ql_y694.d(38):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp1ql_y694.d(40): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp1ql_y694.d(41): Error: use `.` for member
    lookup, not `->`\n/tmp/tmp1ql_y694.d(79): Error: found `unittest` instead of statement\n/tmp/tmp1ql_y694.d(97):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp1ql_y694.d(97):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ql_y694.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isalpha(word[i]))\n        {\n \
    \           string vowel = word[i];\n            vowels[vowel]++;\n        }\n\
    \    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second<2)\n        {\n            return it->first;\n \
    \       }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string |>\n<| a\
    \ tags=c++,string |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbc40jv9i.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpbc40jv9i.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpbc40jv9i.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpbc40jv9i.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpbc40jv9i.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpbc40jv9i.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpbc40jv9i.d(44): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbc40jv9i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second==1)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThis code does not work if you\
    \ have a word like \"aardvark\" which has two vowels next to each other. Try it\
    \ out yourself and see for yourself.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I tested it on \"aardvark\" which has two vowels next to each other. it returns\
    \ \"a\".\n<|/ c |>\n<| c |>\nI tested it on \"aardvark\" which has two vowels\
    \ next to each other. it returns \"a\".\n<|/ c |>\n<| c |>\nI tested it on \"\
    aardvark\" which has two vowels next to each other. it returns \"a\".\n<|/ c |>\n\
    <| c |>\nI tested it on \"aardvark\" which has two vowels next to each other.\
    \ it returns \"a\".\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpclasmg5c.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpclasmg5c.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpclasmg5c.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpclasmg5c.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpclasmg5c.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpclasmg5c.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpclasmg5c.d(43): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpclasmg5c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second<2)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the word is \"a\"\
    . Try it out with your test cases.\n<|/ c |>\n<| c |>\nThanks for pointing out.\
    \ I've edited my answer to fix this issue.\n<|/ c |>\n<| a |>\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvdsy5mt2.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpvdsy5mt2.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpvdsy5mt2.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpvdsy5mt2.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpvdsy5mt2.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpvdsy5mt2.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpvdsy5mt2.d(43): Error: declaration expected,
    not `<`\n/tmp/tmpvdsy5mt2.d(46): Error: unterminated character constant\n/tmp/tmpvdsy5mt2.d(49):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpvdsy5mt2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    for(int i =\
    \ word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] == vowels_right[0])\n\
    \        {\n            int j = word.length - 1;\n            while(j > 0 && word[j]\
    \ == vowels_right[0])\n            {\n                j--;\n            }\n  \
    \          int k = word.length - 1;\n            while(k > 0 && word[k] == vowels_right[0])\n\
    \            {\n                k--;\n            }\n            if(j > k)\n \
    \           {\n                return word[i];\n            }\n        }\n   \
    \ }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgtv1x5wa.d(26): Error: no property `right` for type `string`\n/tmp/tmpgtv1x5wa.d(28):
    Error: no property `length` for type `string`\n/tmp/tmpgtv1x5wa.d(32): Error:
    cannot implicitly convert expression `word.length - 1LU` of type `ulong` to `int`\n/tmp/tmpgtv1x5wa.d(37):
    Error: cannot implicitly convert expression `word.length - 1LU` of type `ulong`
    to `int`\n/tmp/tmpgtv1x5wa.d(44): Error: cannot implicitly convert expression
    `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpgtv1x5wa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end) {\n        if(word[start] == vowels[start]) {\n            start = start\
    \ + 1;\n        }\n        else if(word[end] == vowels[end]) {\n            end\
    \ = end - 1;\n        }\n        else {\n            int mid = start + (end -\
    \ start) / 2;\n            if(word[mid] == vowels[mid]) {\n                end\
    \ = mid - 1;\n            }\n            else {\n                start = mid +\
    \ 1;\n            }\n        }\n    }\n    \n    return word[start];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_wud8nfb.d(28): Error: no property `length` for type `string`\n/tmp/tmp_wud8nfb.d(48):
    Error: cannot implicitly convert expression `word[cast(ulong)start]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wud8nfb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] =\
    \ 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"\
    e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n\
    \    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n\
    \    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] =\
    \ 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"\
    e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n\
    \    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n\
    \    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptgejv9lp.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmptgejv9lp.d(97): Error: unterminated string constant starting at /tmp/tmptgejv9lp.d(114)\n/tmp/tmptgejv9lp.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmptgejv9lp.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmptgejv9lp.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmptgejv9lp.d(103): Error: found `u` when expecting `,`\n/tmp/tmptgejv9lp.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmptgejv9lp.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmptgejv9lp.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmptgejv9lp.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmptgejv9lp.d(106): Error: found `ali` when expecting `,`\n/tmp/tmptgejv9lp.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmptgejv9lp.d(107): Error: found `bad` when expecting `,`\n/tmp/tmptgejv9lp.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmptgejv9lp.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmptgejv9lp.d(108): Error: found `o` when expecting `,`\n/tmp/tmptgejv9lp.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmptgejv9lp.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmptgejv9lp.d(110): Error: found `ba` when expecting `,`\n/tmp/tmptgejv9lp.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptgejv9lp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    int i = 0;\n    \n    for(int j=word.length()-1;\
    \ j>=0; j--)\n    {\n        if(word[j] == 'a' || word[j] == 'e' || word[j] ==\
    \ 'i' || word[j] == 'o' || word[j] == 'u')\n        {\n            i = j;\n  \
    \          break;\n        }\n    }\n    \n    string vowel = \"\";\n    \n  \
    \  if(i != word.length()-1)\n    {\n        for(int j=i; j<word.length()-1; j++)\n\
    \        {\n            if(word[j] == 'a' || word[j] == 'e' || word[j] == 'i'\
    \ || word[j] == 'o' || word[j] == 'u')\n            {\n                vowel =\
    \ word[j];\n                break;\n            }\n        }\n    }\n    \n  \
    \  return vowel;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code doesn't work.\
    \ Try it on \"ab\".\n<|/ c |>\n<| c |>\nIt works. I tested it on \"ab\". What\
    \ is the problem you are facing?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it on\
    \ \"ab\".\n<|/ c |>\n<| c |>\nIt works. I tested it on \"ab\". What is the problem\
    \ you are facing?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it on \"ab\".\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps09h_q4e.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmps09h_q4e.d(59): Error: declaration expected, not `<`\n/tmp/tmps09h_q4e.d(62):
    Error: unterminated character constant\n/tmp/tmps09h_q4e.d(68): Error: unterminated
    character constant\n/tmp/tmps09h_q4e.d(74): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps09h_q4e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reversed = vowels.rbegin();\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_reversed[i])\n        {\n        \
    \    return word[i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8zrnpc0.d(26): Error: no property `rbegin` for type `string`\n/tmp/tmph8zrnpc0.d(28):
    Error: no property `length` for type `string`\n/tmp/tmph8zrnpc0.d(32): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8zrnpc0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    map<string, int> vowels;\n   \
    \ vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    \n    map<string, int> consonants;\n  \
    \  consonants[\"b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] =\
    \ 1;\n    consonants[\"f\"] = 1;\n    consonants[\"g\"] = 1;\n    consonants[\"\
    h\"] = 1;\n    consonants[\"j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"\
    l\"] = 1;\n    consonants[\"m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"\
    p\"] = 1;\n    consonants[\"q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"\
    s\"] = 1;\n    consonants[\"t\"] = 1;\n    consonants[\"v\"] = 1;\n    consonants[\"\
    w\"] = 1;\n    consonants[\"x\"] = 1;\n    consonants[\"y\"] = 1;\n    consonants[\"\
    z\"] = 1;\n    \n    map<string, int> consonants_reverse;\n    consonants_reverse[\"\
    b\"] = 1;\n    consonants_reverse[\"c\"] = 1;\n    consonants_reverse[\"d\"] =\
    \ 1;\n    consonants_reverse[\"f\"] = 1;\n    consonants_reverse[\"g\"] = 1;\n\
    \    consonants_reverse[\"h\"] = 1;\n    consonants_reverse[\"j\"] = 1;\n    consonants_reverse[\"\
    k\"] = 1;\n    consonants_reverse[\"l\"] = 1;\n    consonants_reverse[\"m\"] =\
    \ 1;\n    consonants_reverse[\"n\"] = 1;\n    consonants_reverse[\"p\"] = 1;\n\
    \    consonants_reverse[\"q\"] = 1;\n    consonants_reverse[\"r\"] = 1;\n    consonants_reverse[\"\
    s\"] = 1;\n    consonants_reverse[\"t\"] = 1;\n    consonants_reverse[\"v\"] =\
    \ 1;\n    consonants_reverse[\"w\"] = 1;\n    consonants_reverse[\"x\"] = 1;\n\
    \    consonants_reverse[\"y\"] = 1;\n    consonants_reverse[\"z\"] = 1;\n    \n\
    \    map<string, int> consonants_reverse2;\n    consonants_reverse2[\"b\"] = 1;\n\
    \    consonants_reverse2[\"c\"] = 1;\n    consonants_reverse2[\"d\"] = 1;\n  \
    \  consonants_reverse2[\"f\"] = 1;\n    con\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsc47w2au.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsc47w2au.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpsc47w2au.d(56):
    Error: found `>` when expecting `.` following int\n/tmp/tmpsc47w2au.d(79): Error:
    found `>` when expecting `.` following int\n/tmp/tmpsc47w2au.d(85): Error: found
    `unittest` when expecting `;` following statement\n/tmp/tmpsc47w2au.d(103): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsc47w2au.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    int start = 0;\n    int end = len - 1;\n\
    \    \n    while (start < end) {\n        int mid = (start + end) / 2;\n     \
    \   \n        if (word[mid] == vowels[mid]) {\n            end = mid - 1;\n  \
    \      } else {\n            start = mid + 1;\n        }\n    }\n    \n    return\
    \ word[end];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n   \
    \ assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"\
    u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpap8jduiq.d(27): Error: no property `length` for type `string`\n/tmp/tmpap8jduiq.d(41):
    Error: cannot implicitly convert expression `word[cast(ulong)end]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap8jduiq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int i;\n\
    \    int j;\n    string vowels = \"aeiou\";\n    string vowels_end = \"AEIOU\"\
    ;\n    string vowels_start = \"AEIOUaeiou\";\n    string vowels_start_end = \"\
    AEIOUaeiouAEIOU\";\n    string vowels_start_end_2 = \"aeiouAEIOUaeiou\";\n   \
    \ string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOU\";\n    string vowels_start_end_4\
    \ = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n\
    \    string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    string vowels_start_end_15 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfmiy38g_.d(50): Error: semicolon expected, not `yogurt`\n/tmp/tmpfmiy38g_.d(50):
    Error: found `") == "` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(50):
    Error: found `");\\x0a    assert(candidate("` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(51):
    Error: found `") == "` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(51):
    Error: found `");\\x0a    assert(candidate("` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(52):
    Error: found `") == "` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(53):
    Error: found `eAsy` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(53):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpfmiy38g_.d(54): Error: found `ali` when expecting `;` following
    statement\n/tmp/tmpfmiy38g_.d(54): Error: Implicit string concatenation is deprecated,
    use ") == " ~ ");\\x0a    assert(candidate(" instead\n/tmp/tmpfmiy38g_.d(55):
    Error: found `bad` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(55):
    Error: found `a` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(56):
    Error: found `most` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(56):
    Error: found `o` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(57):
    Error: found `ab` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(57):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpfmiy38g_.d(58): Error: found `ba` when expecting `;` following
    statement\n/tmp/tmpfmiy38g_.d(58): Error: Implicit string concatenation is deprecated,
    use ") == " ~ ");\\x0a    assert(candidate(" instead\n/tmp/tmpfmiy38g_.d(59):
    Error: found `quick` when expecting `;` following statement\n/tmp/tmpfmiy38g_.d(59):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmiy38g_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second==0)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a tags=c++,string |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7tdz7hmx.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp7tdz7hmx.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp7tdz7hmx.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp7tdz7hmx.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp7tdz7hmx.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp7tdz7hmx.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp7tdz7hmx.d(43): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7tdz7hmx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    int consonants_count\
    \ = word.length() - vowels_right.length();\n    int vowels_count = vowels_right.length();\n\
    \    \n    if(consonants_count < vowels_count)\n        return \"\";\n    \n \
    \   int consonants_index = word.length() - consonants_count;\n    int vowels_index\
    \ = vowels_count;\n    \n    for(int i = 0; i < consonants_index; i++)\n    {\n\
    \        if(vowels_right.at(vowels_index) == word.at(consonants_index))\n    \
    \    {\n            return word.at(consonants_index);\n        }\n        \n \
    \       vowels_index--;\n    }\n    \n    return \"\";\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nstring get_closest_vowel(string word)\n{\n   \
    \ string vowels = \"aeiouAEIOU\";\n    string vowels_right = vowels.right(vowels.length());\n\
    \    \n    int consonants_count = word.length() - vowels_right.length();\n   \
    \ int vowels_count = vowels_right.length();\n    \n    if(consonants_count < vowels_count)\n\
    \        return \"\";\n    \n    int consonants_index = word.length() - consonants_count;\n\
    \    int vowels_index = vowels_count;\n    \n    for(int i = 0; i < consonants_index;\
    \ i++)\n    {\n        if(vowels_right.at(vowels_index) == word.at(consonants_index))\n\
    \        {\n            return word.at(consonants_index);\n        }\n       \
    \ \n        vowels_index--;\n    }\n    \n    return \"\";\n}\n</code>\n<|/ a\
    \ tags=string,c++,algorithm |>\n<| a tags=string,c++,algorithm |>\n<code>\nstring\
    \ get_closest_vowel(string word)\n{\n    string vowels = \"aeiouAEIOU\";\n   \
    \ string vowels_right = vowels.right(vowels.length());\n    \n    int consonants_count\
    \ = word.length() - vowels_right.length();\n    int vowels_count = vowels_right.length();\n\
    \    \n    if(consonants_count < vowels_count)\n        return \"\";\n    \n \
    \   int consonants_index = word.length() - consonants_count;\n    int vowels_index\
    \ = vowels_count;\n    \n    for(int i = 0; i < consonants_index; i++)\n    {\n\
    \        if(vowels_right.at(vowels_index) == word.at(consonants_index))\n    \
    \    {\n            return word.at(consonants_index);\n        }\n        \n\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp82wgouqv.d(49): Error: declaration expected, not `<`\n/tmp/tmp82wgouqv.d(61):
    Error: declaration expected, not `if`\n/tmp/tmp82wgouqv.d(67): Error: declaration
    expected, not `for`\n/tmp/tmp82wgouqv.d(67): Error: no identifier for declarator
    `i`\n/tmp/tmp82wgouqv.d(67): Error: declaration expected, not `<`\n/tmp/tmp82wgouqv.d(67):
    Error: no identifier for declarator `i`\n/tmp/tmp82wgouqv.d(67): Error: declaration
    expected, not `++`\n/tmp/tmp82wgouqv.d(72): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp82wgouqv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        string vowel = word.substr(i,1);\n\
    \        if(vowels.find(vowel)==vowels.end())\n        {\n            vowels[vowel]=0;\n\
    \        }\n        else\n        {\n            vowels[vowel]++;\n        }\n\
    \    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==1)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try it on \"ab\".\n<|/ c |>\n<| c |>\nIt works. I tested it\
    \ on \"ab\".\n<|/ c |>\n<| c |>\nIt doesn't work. Try it on \"ab\".\n<|/ c |>\n\
    <| c |>\nIt works. I tested it on \"ab\".\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try it on \"ab\".\n<|/ c |>\n<| a tags=c++ |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptlvgyjk6.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmptlvgyjk6.d(38): Error: found `>` when expecting `.` following int\n/tmp/tmptlvgyjk6.d(38):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmptlvgyjk6.d(38):
    Error: found `:` when expecting `;` following statement\n/tmp/tmptlvgyjk6.d(41):
    Error: use `.` for member lookup, not `->`\n/tmp/tmptlvgyjk6.d(43): Error: use
    `.` for member lookup, not `->`\n/tmp/tmptlvgyjk6.d(48): Error: declaration expected,
    not `<`\n/tmp/tmptlvgyjk6.d(51): Error: unterminated character constant\n/tmp/tmptlvgyjk6.d(57):
    Error: unterminated character constant\n/tmp/tmptlvgyjk6.d(63): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptlvgyjk6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    map<string, int> consonants;\n    consonants[\"\
    b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] = 1;\n    consonants[\"\
    f\"] = 1;\n    consonants[\"g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"p\"] = 1;\n    consonants[\"\
    q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"s\"] = 1;\n    consonants[\"\
    t\"] = 1;\n    consonants[\"v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"\
    x\"] = 1;\n    consonants[\"y\"] = 1;\n    consonants[\"z\"] = 1;\n    \n    map<string,\
    \ int> consonants2;\n    consonants2[\"b\"] = 1;\n    consonants2[\"c\"] = 1;\n\
    \    consonants2[\"d\"] = 1;\n    consonants2[\"f\"] = 1;\n    consonants2[\"\
    g\"] = 1;\n    consonants2[\"h\"] = 1;\n    consonants2[\"j\"] = 1;\n    consonants2[\"\
    k\"] = 1;\n    consonants2[\"l\"] = 1;\n    consonants2[\"m\"] = 1;\n    consonants2[\"\
    n\"] = 1;\n    consonants2[\"p\"] = 1;\n    consonants2[\"q\"] = 1;\n    consonants2[\"\
    r\"] = 1;\n    consonants2[\"s\"] = 1;\n    consonants2[\"t\"] = 1;\n    consonants2[\"\
    v\"] = 1;\n    consonants2[\"w\"] = 1;\n    consonants2[\"x\"] = 1;\n    consonants2[\"\
    y\"] = 1;\n    consonants2[\"z\"] = 1;\n    \n    map<string, int> consonants3;\n\
    \    consonants3[\"b\"] = 1;\n    consonants3[\"c\"] = 1;\n    consonants3[\"\
    d\"] = 1;\n    consonants3[\"f\"] = 1;\n    consonants3[\"g\"] = 1;\n    consonants3[\"\
    h\"] = 1;\n    consonants3[\"j\"] = 1;\n    consonants3[\"k\"] = 1;\n\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppcfc7c0j.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmppcfc7c0j.d(32): Error: found `>` when expecting `.` following int\n/tmp/tmppcfc7c0j.d(55):
    Error: found `>` when expecting `.` following int\n/tmp/tmppcfc7c0j.d(78): Error:
    found `>` when expecting `.` following int\n/tmp/tmppcfc7c0j.d(88): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppcfc7c0j.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcypli44h.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpcypli44h.d(97): Error: unterminated string constant starting at /tmp/tmpcypli44h.d(114)\n/tmp/tmpcypli44h.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpcypli44h.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpcypli44h.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpcypli44h.d(103): Error: found `u` when expecting `,`\n/tmp/tmpcypli44h.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpcypli44h.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpcypli44h.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpcypli44h.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpcypli44h.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `o` when expecting `,`\n/tmp/tmpcypli44h.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpcypli44h.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpcypli44h.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcypli44h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=1;\n\
    \        }\n    }\n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(word[i]=='a'\
    \ || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n\
    \            vowels[word[i]]=1;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n \
    \   {\n        if(it->second==1)\n        {\n            vowel=it->first;\n  \
    \          break;\n        }\n    }\n    return vowel;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with the string \"ab\".\n<|/ c |>\n<|\
    \ c |>\nIt works. I tested it with the string \"ab\". And it returned \"u\". Are\
    \ you sure you copied the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied the\
    \ code correctly. Try it with the string \"ab\".\n<|/ c |>\n<| c |>\nOh, I see.\
    \ You're right. My bad. I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited my answer.\
    \ Now it works. I tested it with the string \"ab\".\n<|/ c |>\n<| a |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppwrv4gqr.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmppwrv4gqr.d(40): Error: found `>` when expecting `.` following int\n/tmp/tmppwrv4gqr.d(40):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmppwrv4gqr.d(40):
    Error: found `:` when expecting `;` following statement\n/tmp/tmppwrv4gqr.d(44):
    Error: use `.` for member lookup, not `->`\n/tmp/tmppwrv4gqr.d(46): Error: use
    `.` for member lookup, not `->`\n/tmp/tmppwrv4gqr.d(52): Error: declaration expected,
    not `<`\n/tmp/tmppwrv4gqr.d(55): Error: unterminated character constant\n/tmp/tmppwrv4gqr.d(64):
    Error: unterminated character constant\n/tmp/tmppwrv4gqr.d(64): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwrv4gqr.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    \n    for(int i = len-1; i >= 0; i--)\n\
    \    {\n        if(vowels.find(word.at(i)) != string::npos)\n        {\n     \
    \       return word.at(i);\n        }\n    }\n    \n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjdlhm0ji.d(31): Error: found `:` when expecting `)`\n/tmp/tmpjdlhm0ji.d(31):
    Error: found `:` instead of statement\n/tmp/tmpjdlhm0ji.d(37): Error: declaration
    expected, not `return`\n/tmp/tmpjdlhm0ji.d(38): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdlhm0ji.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    int start = 0;\n    int end = len - 1;\n\
    \    int mid = 0;\n    \n    while(start < end) {\n        mid = (start + end)\
    \ / 2;\n        \n        if(word.at(mid) == vowels.at(mid)) {\n            end\
    \ = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n\
    \    \n    return word.at(end);\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp29hwbxty.d(27): Error: no property `length` for type `string`\n/tmp/tmp29hwbxty.d(35):
    Error: no property `at` for type `string`\n/tmp/tmp29hwbxty.d(35): Error: no property
    `at` for type `string`\n/tmp/tmp29hwbxty.d(42): Error: no property `at` for type
    `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp29hwbxty.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it = vowels.begin();\n    map<string, int>::iterator it2 = vowels.end();\n\
    \    \n    while(it != it2)\n    {\n        if(it->second > 1)\n        {\n  \
    \          it2 = it;\n        }\n        else\n        {\n            it = it;\n\
    \        }\n    }\n    \n    return it->first;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6oq3828k.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp6oq3828k.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmp6oq3828k.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp6oq3828k.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp6oq3828k.d(35):
    Error: found `>` when expecting `.` following int\n/tmp/tmp6oq3828k.d(35): Error:
    found `:` when expecting identifier following `int`.\n/tmp/tmp6oq3828k.d(35):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp6oq3828k.d(39):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp6oq3828k.d(49): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6oq3828k.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    map<string, int> vowel_map;\n\
    \    map<string, int> consonant_map;\n    map<string, int> consonant_map_rev;\n\
    \    map<string, int> consonant_map_rev2;\n    map<string, int> consonant_map_rev3;\n\
    \    map<string, int> consonant_map_rev4;\n    map<string, int> consonant_map_rev5;\n\
    \    map<string, int> consonant_map_rev6;\n    map<string, int> consonant_map_rev7;\n\
    \    map<string, int> consonant_map_rev8;\n    map<string, int> consonant_map_rev9;\n\
    \    map<string, int> consonant_map_rev10;\n    map<string, int> consonant_map_rev11;\n\
    \    map<string, int> consonant_map_rev12;\n    map<string, int> consonant_map_rev13;\n\
    \    map<string, int> consonant_map_rev14;\n    map<string, int> consonant_map_rev15;\n\
    \    map<string, int> consonant_map_rev16;\n    map<string, int> consonant_map_rev17;\n\
    \    map<string, int> consonant_map_rev18;\n    map<string, int> consonant_map_rev19;\n\
    \    map<string, int> consonant_map_rev20;\n    map<string, int> consonant_map_rev21;\n\
    \    map<string, int> consonant_map_rev22;\n    map<string, int> consonant_map_rev23;\n\
    \    map<string, int> consonant_map_rev24;\n    map<string, int> consonant_map_rev25;\n\
    \    map<string, int> consonant_map_rev26;\n    map<string, int> consonant_map_rev27;\n\
    \    map<string, int> consonant_map_rev28;\n    map<string, int> consonant_map_rev29;\n\
    \    map<string, int> consonant_map_rev30;\n    map<string, int> consonant_map_rev31;\n\
    \    map<string, int> consonant_map_rev32;\n    map<string, int> consonant_map_rev33;\n\
    \    map<string, int> consonant_map_rev34;\n    map<string, int> consonant_map_rev35;\n\
    \    map<string, int> consonant_map_rev36;\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp28iwbe8d.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmp28iwbe8d.d(27): Error: found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(28):
    Error: found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(29): Error:
    found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(30): Error: found
    `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(31): Error: found `>`
    when expecting `.` following int\n/tmp/tmp28iwbe8d.d(32): Error: found `>` when
    expecting `.` following int\n/tmp/tmp28iwbe8d.d(33): Error: found `>` when expecting
    `.` following int\n/tmp/tmp28iwbe8d.d(34): Error: found `>` when expecting `.`
    following int\n/tmp/tmp28iwbe8d.d(35): Error: found `>` when expecting `.` following
    int\n/tmp/tmp28iwbe8d.d(36): Error: found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(37):
    Error: found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(38): Error:
    found `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(39): Error: found
    `>` when expecting `.` following int\n/tmp/tmp28iwbe8d.d(40): Error: found `>`
    when expecting `.` following int\n/tmp/tmp28iwbe8d.d(41): Error: found `>` when
    expecting `.` following int\n/tmp/tmp28iwbe8d.d(42): Error: found `>` when expecting
    `.` following int\n/tmp/tmp28iwbe8d.d(43): Error: found `>` when expecting `.`
    following int\n/tmp/tmp28iwbe8d.d(44): Error: found `>` when expecting `.` following
    int\n/tmp/tmp28iwbe8d.d(45): Error: found `>` when expecting `.` following int\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28iwbe8d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int index2 = word.length()-i;\n            int diff = abs(index-index2);\n\
    \            if(diff == 0)\n            {\n                return word[i];\n \
    \           }\n            else if(diff > 0)\n            {\n                return\
    \ word[i];\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI appreciate your efforts, but the question was to find the closest\
    \ vowel from the right side of the word. Your code will find the closest vowel\
    \ from the left side of the word.\n<|/ c |>\n<| c |>\nI edited the answer, I hope\
    \ it helps you\n<|/ c |>\n<| c |>\nThank you so much! I appreciate your efforts.\
    \ But I cannot use any library functions. I should use only basic string functions.\n\
    <|/ c |>\n<| c |>\nI edited the answer, I hope it helps you\n<|/ c |>\n<| a tags=string,c++\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmru80r0d.d(29): Error: found `:` when expecting `)`\n/tmp/tmpmru80r0d.d(29):
    Error: found `:` instead of statement\n/tmp/tmpmru80r0d.d(44): Error: declaration
    expected, not `return`\n/tmp/tmpmru80r0d.d(45): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmru80r0d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end) {\n        int mid = start + (end - start) / 2;\n        \n        if(word[mid]\
    \ == vowels[mid]) {\n            end = mid - 1;\n        } else {\n          \
    \  start = mid + 1;\n        }\n    }\n    \n    return word[start];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyzkaj8sj.d(28): Error: no property `length` for type `string`\n/tmp/tmpyzkaj8sj.d(40):
    Error: cannot implicitly convert expression `word[cast(ulong)start]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyzkaj8sj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    map<string, int> consonants;\n    consonants[\"\
    b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] = 1;\n    consonants[\"\
    f\"] = 1;\n    consonants[\"g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"p\"] = 1;\n    consonants[\"\
    q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"s\"] = 1;\n    consonants[\"\
    t\"] = 1;\n    consonants[\"v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"\
    x\"] = 1;\n    consonants[\"y\"] = 1;\n    consonants[\"z\"] = 1;\n    \n    map<string,\
    \ int> consonants2;\n    consonants2[\"z\"] = 1;\n    consonants2[\"y\"] = 1;\n\
    \    consonants2[\"x\"] = 1;\n    consonants2[\"w\"] = 1;\n    consonants2[\"\
    v\"] = 1;\n    consonants2[\"t\"] = 1;\n    consonants2[\"s\"] = 1;\n    consonants2[\"\
    r\"] = 1;\n    consonants2[\"q\"] = 1;\n    consonants2[\"p\"] = 1;\n    consonants2[\"\
    n\"] = 1;\n    consonants2[\"m\"] = 1;\n    consonants2[\"l\"] = 1;\n    consonants2[\"\
    k\"] = 1;\n    consonants2[\"j\"] = 1;\n    consonants2[\"h\"] = 1;\n    consonants2[\"\
    g\"] = 1;\n    consonants2[\"f\"] = 1;\n    consonants2[\"d\"] = 1;\n    consonants2[\"\
    c\"] = 1;\n    consonants2[\"b\"] = 1;\n    consonants2[\"a\"] = 1;\n    \n  \
    \  map<string, int> consonants3;\n    consonants3[\"z\"] = 1;\n    consonants3[\"\
    y\"] = 1;\n    consonants3[\"x\"] = 1;\n    consonants3[\"w\"] = 1;\n    consonants3[\"\
    v\"] = 1;\n    consonants3[\"t\"] = 1;\n    consonants3[\"s\"] = 1;\n    conson\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy33p41d2.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpy33p41d2.d(32): Error: found `>` when expecting `.` following int\n/tmp/tmpy33p41d2.d(55):
    Error: found `>` when expecting `.` following int\n/tmp/tmpy33p41d2.d(79): Error:
    found `>` when expecting `.` following int\n/tmp/tmpy33p41d2.d(88): Error: found
    `unittest` when expecting `;` following statement\n/tmp/tmpy33p41d2.d(106): Error:
    found `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpy33p41d2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int vowel_pos\
    \ = len - 1;\n    int vowel_len = std.length(vowels);\n    \n    for(int i = len\
    \ - 1; i >= 0; i--)\n    {\n        if(word[i] == vowels[vowel_pos])\n       \
    \ {\n            vowel_pos--;\n            if(vowel_pos < 0)\n            {\n\
    \                vowel_pos = vowel_len - 1;\n            }\n        }\n      \
    \  else\n        {\n            vowel_pos++;\n            if(vowel_pos >= vowel_len)\n\
    \            {\n                vowel_pos = 0;\n            }\n        }\n   \
    \ }\n    return vowels[vowel_pos];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3yf91ia9.d(25): Error: no property `length` for type `string`\n/tmp/tmp3yf91ia9.d(27):
    Error: undefined identifier `length` in package `std`\n/tmp/tmp3yf91ia9.d(31):
    Error: undefined identifier `vowels`\n/tmp/tmp3yf91ia9.d(48): Error: undefined
    identifier `vowels`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yf91ia9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels + \"AEIOU\";\n    \n    int vowels_count = count(vowels,\
    \ word);\n    int vowels_right_count = count(vowels_right, word);\n    \n    int\
    \ vowels_index = distance(vowels, word);\n    int vowels_right_index = distance(vowels_right,\
    \ word);\n    \n    int vowels_index_min = min(vowels_index, vowels_right_index);\n\
    \    int vowels_right_index_min = min(vowels_right_index, vowels_index);\n   \
    \ \n    string result = \"\";\n    \n    if (vowels_index_min == vowels_right_index_min)\
    \ {\n        result = word[vowels_index_min];\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\nThis doesn't work if\
    \ you have a word like \"abacus\"\n<|/ c |>\n<| c |>\nIt works. I tested it before\
    \ posting. The only thing I changed was the variable names. I changed `vowels_right`\
    \ to `vowels_rights`. And I changed `vowels_index` to `vowels_index_min`. And\
    \ I changed `vowels_right_index` to `vowels_right_index_min`. And I changed `vowels_right_count`\
    \ to `vowels_right_index_min`. And I changed `vowels_count` to `vowels_index_min`.\
    \ And I changed `vowels_right_count` to `vowels_right_index_min`. And I changed\
    \ `vowels_count` to `vowels_index_min`. And I changed `vowels_right_count` to\
    \ `vowels_right_index_min`. And I changed `vowels_count` to `vowels_index_min`.\
    \ And I changed `vowels_right_count` to `vowels_right_index_min`. And I changed\
    \ `vowels_count` to `vowels_index_min`. And I changed `vowels_right_count` to\
    \ `vowels_right_index_min`. And I changed `vowels_count` to `vowels_index_min`.\
    \ And I changed `vowels_right_count` to `vowels_right_index_min`. And I changed\
    \ `vowels_count` to `vowels_index_min`. And I changed `vowels_right_count` to\
    \ `vowels_right_index_min`. And I changed `vowels_count` to `vowels_index_min`.\
    \ And I changed `vowels_right_count` to `vowels_right_index_min`. And I changed\
    \ `vowels_count` to `vowels_index_min`. And I changed `vowels_right_count` to\
    \ `vowels_right_index_min`. And I changed `vowels_count` to `vowels_index_min`.\
    \ And I changed \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxarn01yt.d(45): Error: declaration expected, not `<`\n/tmp/tmpxarn01yt.d(48):
    Error: unterminated character constant\n/tmp/tmpxarn01yt.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmpxarn01yt.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmpxarn01yt.d(58): Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(59):
    Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmpxarn01yt.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmpxarn01yt.d(62): Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpxarn01yt.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpxarn01yt.d(66): Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpxarn01yt.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpxarn01yt.d(69): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxarn01yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcypli44h.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpcypli44h.d(97): Error: unterminated string constant starting at /tmp/tmpcypli44h.d(114)\n/tmp/tmpcypli44h.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpcypli44h.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpcypli44h.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpcypli44h.d(103): Error: found `u` when expecting `,`\n/tmp/tmpcypli44h.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpcypli44h.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpcypli44h.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpcypli44h.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpcypli44h.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `o` when expecting `,`\n/tmp/tmpcypli44h.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpcypli44h.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpcypli44h.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcypli44h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    map<string,\
    \ int> vowels2;\n    map<string, int> vowels3;\n    map<string, int> vowels4;\n\
    \    map<string, int> vowels5;\n    map<string, int> vowels6;\n    map<string,\
    \ int> vowels7;\n    map<string, int> vowels8;\n    map<string, int> vowels9;\n\
    \    map<string, int> vowels10;\n    map<string, int> vowels11;\n    map<string,\
    \ int> vowels12;\n    map<string, int> vowels13;\n    map<string, int> vowels14;\n\
    \    map<string, int> vowels15;\n    map<string, int> vowels16;\n    map<string,\
    \ int> vowels17;\n    map<string, int> vowels18;\n    map<string, int> vowels19;\n\
    \    map<string, int> vowels20;\n    map<string, int> vowels21;\n    map<string,\
    \ int> vowels22;\n    map<string, int> vowels23;\n    map<string, int> vowels24;\n\
    \    map<string, int> vowels25;\n    map<string, int> vowels26;\n    map<string,\
    \ int> vowels27;\n    map<string, int> vowels28;\n    map<string, int> vowels29;\n\
    \    map<string, int> vowels30;\n    map<string, int> vowels31;\n    map<string,\
    \ int> vowels32;\n    map<string, int> vowels33;\n    map<string, int> vowels34;\n\
    \    map<string, int> vowels35;\n    map<string, int> vowels36;\n    map<string,\
    \ int> vowels37;\n    map<string, int> vowels38;\n    map<string, int> vowels39;\n\
    \    map<string, int> vowels40;\n    map<string, int> vowels41;\n    map<string,\
    \ int> vowels42;\n    map<string, int> vowels43;\n    map<string, int> vowels44;\n\
    \    map<string, int> vowels45;\n    map<string, int> vowels46;\n    map<string,\
    \ int> vowels47;\n    map<string, int> vowels48;\n    map<string, int\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj6a4f42w.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(26): Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(27):
    Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(28): Error:
    found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(29): Error: found
    `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(30): Error: found `>`
    when expecting `.` following int\n/tmp/tmpj6a4f42w.d(31): Error: found `>` when
    expecting `.` following int\n/tmp/tmpj6a4f42w.d(32): Error: found `>` when expecting
    `.` following int\n/tmp/tmpj6a4f42w.d(33): Error: found `>` when expecting `.`
    following int\n/tmp/tmpj6a4f42w.d(34): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(35): Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(36):
    Error: found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(37): Error:
    found `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(38): Error: found
    `>` when expecting `.` following int\n/tmp/tmpj6a4f42w.d(39): Error: found `>`
    when expecting `.` following int\n/tmp/tmpj6a4f42w.d(40): Error: found `>` when
    expecting `.` following int\n/tmp/tmpj6a4f42w.d(41): Error: found `>` when expecting
    `.` following int\n/tmp/tmpj6a4f42w.d(42): Error: found `>` when expecting `.`
    following int\n/tmp/tmpj6a4f42w.d(43): Error: found `>` when expecting `.` following
    int\n/tmp/tmpj6a4f42w.d(44): Error: found `>` when expecting `.` following int\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6a4f42w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            int index = vowels[word[i]];\n\
    \            if(index != -1)\n            {\n                string vowel = word.substr(0,\
    \ i);\n                if(vowel.compare(vowels[index - 1]) == 0)\n           \
    \         return vowel;\n            }\n        }\n    }\n    return \"\";\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsw__hzfv.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsw__hzfv.d(47): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsw__hzfv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.rbegin();\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_right[i])\n        {\n           \
    \ return word[i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfgy_yvrq.d(26): Error: no property `rbegin` for type `string`\n/tmp/tmpfgy_yvrq.d(28):
    Error: no property `length` for type `string`\n/tmp/tmpfgy_yvrq.d(32): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfgy_yvrq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        string vowel = word.substr(i,1);\n\
    \        if(vowels.find(vowel)==vowels.end())\n        {\n            vowels[vowel]=0;\n\
    \        }\n        vowels[vowel]++;\n    }\n    map<string,int>::iterator it;\n\
    \    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second==1)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\nThis code doesn't work.\
    \ Try it with `get_closest_vowel(\"ab\")`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ out. I missed that case. Updated the code.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Your code works perfectly for most of the cases. But it fails for \"\
    ab\" case. Can you please help me to fix this case?\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. Your code works perfectly for most of the cases. But it fails\
    \ for \"ab\" case. Can you please help me to fix this case?\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. Your code works perfectly for most of the cases. But it\
    \ fails for \"ab\" case. Can you please help me to fix this case?\n<|/ c |>\n\
    <| a |>\n<code>\n#include <iostream>\n#include <string>\n#include <map>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwxtzuoha.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpwxtzuoha.d(35): Error: found `>` when expecting `.` following int\n/tmp/tmpwxtzuoha.d(35):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpwxtzuoha.d(35):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpwxtzuoha.d(38):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpwxtzuoha.d(40): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpwxtzuoha.d(45): Error: declaration expected,
    not `<`\n/tmp/tmpwxtzuoha.d(48): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwxtzuoha.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int vowel_count\
    \ = 0;\n    for(int i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word.at(i)))\n\
    \        {\n            vowel_count++;\n        }\n    }\n    if(vowel_count ==\
    \ 0)\n    {\n        return \"\";\n    }\n    int consonant_count = 0;\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isConsonant(word.at(i)))\n      \
    \  {\n            consonant_count++;\n        }\n    }\n    if(consonant_count\
    \ == 0)\n    {\n        return \"\";\n    }\n    int vowel_pos = 0;\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n\
    \            vowel_pos = i;\n            break;\n        }\n    }\n    if(vowel_pos\
    \ == 0)\n    {\n        return \"\";\n    }\n    int consonant_pos = 0;\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isConsonant(word.at(i)))\n      \
    \  {\n            consonant_pos = i;\n            break;\n        }\n    }\n \
    \   if(consonant_pos == 0)\n    {\n        return \"\";\n    }\n    int vowel_len\
    \ = vowel_pos - vowel_count - 1;\n    int consonant_len = consonant_pos - consonant_count\
    \ - 1;\n    int min_len = min(vowel_len, consonant_len);\n    string vowel = \"\
    \";\n    string consonant = \"\";\n    for(int i = len-1; i >= 0; i--)\n    {\n\
    \        if(isVowel(word.at(i)))\n        {\n            vowel += word.at(i);\n\
    \        }\n        else\n        {\n            consonant += word.at(i);\n  \
    \      }\n        if(i != 0)\n        {\n            if(word.at(i) == vowel.at(vowel_len-1))\n\
    \            {\n                vowel = vowel.substr(0, vowel_len);\n        \
    \        vowel_len = vowel_pos - vowel_count - 1;\n            }\n           \
    \ else if(word.at(i) == consonant.at(consonant_len-1))\n            {\n      \
    \          consonant = consonant.substr(0, consonant_len);\n                consonant_len\
    \ = consonant_pos - consonant_count - 1;\n            }\n        }\n    }\n  \
    \  return vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4fxqmvst.d(25): Error: no property `length` for type `string`\n/tmp/tmp4fxqmvst.d(29):
    Error: undefined identifier `isVowel`\n/tmp/tmp4fxqmvst.d(41): Error: undefined
    identifier `isConsonant`\n/tmp/tmp4fxqmvst.d(53): Error: undefined identifier
    `isVowel`\n/tmp/tmp4fxqmvst.d(66): Error: undefined identifier `isConsonant`\n/tmp/tmp4fxqmvst.d(78):
    Error: undefined identifier `min`, did you mean function `main`?\n/tmp/tmp4fxqmvst.d(83):
    Error: undefined identifier `isVowel`\n/tmp/tmp4fxqmvst.d(85): Error: no property
    `at` for type `string`\n/tmp/tmp4fxqmvst.d(89): Error: no property `at` for type
    `string`\n/tmp/tmp4fxqmvst.d(93): Error: no property `at` for type `string`\n/tmp/tmp4fxqmvst.d(93):
    Error: no property `at` for type `string`\n/tmp/tmp4fxqmvst.d(95): Error: no property
    `substr` for type `string`\n/tmp/tmp4fxqmvst.d(98): Error: no property `at` for
    type `string`\n/tmp/tmp4fxqmvst.d(98): Error: no property `at` for type `string`\n/tmp/tmp4fxqmvst.d(100):
    Error: no property `substr` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4fxqmvst.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           string vowel = word[i];\n            vowels[vowel]++;\n        }\n\
    \    }\n    map<string,int>::iterator it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==1)\n        {\n            vowel=it->first;\n \
    \           break;\n        }\n    }\n    if(vowel.length()==0)\n    {\n     \
    \   return \"\";\n    }\n    for(int i=0;i<word.length();i++)\n    {\n       \
    \ if(isVowel(word[i]))\n        {\n            string vowel = word[i];\n     \
    \       if(vowel==vowels[vowel])\n            {\n                return vowel;\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThanks for your answer. Can you please explain how this works?\n\
    <|/ c |>\n<| c |>\nThis code will find all the vowels in the given string and\
    \ store them in a map with key as vowel and value as number of times it occurred.\
    \ Next it will iterate over the map and find the key with the minimum number of\
    \ occurrences. Finally it will return the key of the minimum occurrences.\n<|/\
    \ c |>\n<| c |>\nI added comments to my code. Hope it helps.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. Can you please explain how this works?\n<|/ c |>\n<| c\
    \ |>\nI added comments to my code. Hope it helps.\n<|/ c |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include\
    \ <map>\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx2dqihp2.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpx2dqihp2.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpx2dqihp2.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpx2dqihp2.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpx2dqihp2.d(38):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpx2dqihp2.d(40): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpx2dqihp2.d(61): Error: declaration expected,
    not `<`\n/tmp/tmpx2dqihp2.d(88): Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(89):
    Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(90): Error: declaration
    expected, not `assert`\n/tmp/tmpx2dqihp2.d(91): Error: declaration expected, not
    `assert`\n/tmp/tmpx2dqihp2.d(92): Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(93):
    Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(94): Error: declaration
    expected, not `assert`\n/tmp/tmpx2dqihp2.d(95): Error: declaration expected, not
    `assert`\n/tmp/tmpx2dqihp2.d(96): Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(97):
    Error: declaration expected, not `assert`\n/tmp/tmpx2dqihp2.d(98): Error: declaration
    expected, not `assert`\n/tmp/tmpx2dqihp2.d(99): Error: declaration expected, not
    `assert`\n/tmp/tmpx2dqihp2.d(100): Error: declaration expected, not `assert`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx2dqihp2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] ==\
    \ consonants[word.length() - 1 - i])\n        {\n            int index = word.length()\
    \ - 1 - i;\n            int min = index;\n            for(int j = word.length()\
    \ - 1; j >= 0; j--)\n            {\n                if(word[j] == vowels[word.length()\
    \ - 1 - j])\n                {\n                    if(j - index > min)\n    \
    \                {\n                        min = j - index;\n               \
    \     }\n                }\n            }\n            return vowels[min];\n \
    \       }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis code doesn't work for \"ab\". It returns \"a\" instead of\
    \ \"\".\n<|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing out. :)\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2rup6o11.d(49): Error: declaration expected, not `<`\n/tmp/tmp2rup6o11.d(52):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp2rup6o11.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            string vowel = word[i];\n            vowels[vowel] = vowels[vowel]\
    \ + 1;\n        }\n    }\n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second > 1)\n        {\n  \
    \          string vowel = it->first;\n            int count = it->second;\n  \
    \          int index = word.length() - 1;\n            while(index >= 0 && isVowel(word[index]))\n\
    \            {\n                string temp = word[index];\n                word[index]\
    \ = vowel;\n                word[index--] = temp;\n            }\n           \
    \ return vowel;\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcot496z0.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpcot496z0.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpcot496z0.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpcot496z0.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpcot496z0.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpcot496z0.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpcot496z0.d(40): Error: use `.` for member
    lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcot496z0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\", i)]) \n        {\n            return\
    \ word[i];\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsdighw8w.d(27): Error: no property `length` for type `string`\n/tmp/tmpsdighw8w.d(29):
    Error: no property `find_last_of` for type `string`\n/tmp/tmpsdighw8w.d(31): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsdighw8w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length()-1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ == string::npos)\n        {\n            return \"\";\n        }\n    }\n  \
    \  \n    return word[0];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7cxbpf6g.d(29): Error: found `:` when expecting `)`\n/tmp/tmp7cxbpf6g.d(29):
    Error: found `:` instead of statement\n/tmp/tmp7cxbpf6g.d(35): Error: declaration
    expected, not `return`\n/tmp/tmp7cxbpf6g.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7cxbpf6g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    map<string, int> vowels2;\n    vowels2[\"a\"] = 1;\n    vowels2[\"e\"\
    ] = 1;\n    vowels2[\"i\"] = 1;\n    vowels2[\"o\"] = 1;\n    vowels2[\"u\"] =\
    \ 1;\n    vowels2[\"y\"] = 1;\n    vowels2[\"A\"] = 1;\n    vowels2[\"E\"] = 1;\n\
    \    vowels2[\"I\"] = 1;\n    vowels2[\"O\"] = 1;\n    vowels2[\"U\"] = 1;\n \
    \   vowels2[\"Y\"] = 1;\n    map<string, int> vowels3;\n    vowels3[\"a\"] = 1;\n\
    \    vowels3[\"e\"] = 1;\n    vowels3[\"i\"] = 1;\n    vowels3[\"o\"] = 1;\n \
    \   vowels3[\"u\"] = 1;\n    vowels3[\"y\"] = 1;\n    vowels3[\"A\"] = 1;\n  \
    \  vowels3[\"E\"] = 1;\n    vowels3[\"I\"] = 1;\n    vowels3[\"O\"] = 1;\n   \
    \ vowels3[\"U\"] = 1;\n    vowels3[\"Y\"] = 1;\n    map<string, int> vowels4;\n\
    \    vowels4[\"a\"] = 1;\n    vowels4[\"e\"] = 1;\n    vowels4[\"i\"] = 1;\n \
    \   vowels4[\"o\"] = 1;\n    vowels4[\"u\"] = 1;\n    vowels4[\"y\"] = 1;\n  \
    \  vowels4[\"A\"] = 1;\n    vowels4[\"E\"] = 1;\n    vowels4[\"I\"] = 1;\n   \
    \ vowels4[\"O\"] = 1;\n    vowels4[\"U\"] = 1;\n    vowels4[\"Y\"] = 1;\n    map<string,\
    \ int> \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7_hue_vh.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp7_hue_vh.d(50): Error: found `>` when expecting `.` following int\n/tmp/tmp7_hue_vh.d(63):
    Error: found `>` when expecting `.` following int\n/tmp/tmp7_hue_vh.d(76): Error:
    found `>` when expecting `.` following int\n/tmp/tmp7_hue_vh.d(89): Error: found
    `>` when expecting `.` following int\n/tmp/tmp7_hue_vh.d(90): Error: found `unittest`
    when expecting identifier following `int`.\n/tmp/tmp7_hue_vh.d(91): Error: found
    `{` when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp7_hue_vh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels + vowels.upper();\n    \n    for(int i = 0; i\
    \ < word.length(); i++)\n    {\n        if(word[i] == vowels_right[i])\n     \
    \   {\n            int j = word.find_last_of(vowels_right[i]);\n            int\
    \ k = word.find_last_of(vowels_right[i], j);\n            int l = word.find_last_of(vowels_right[i],\
    \ k);\n            int m = word.find_last_of(vowels_right[i], l);\n          \
    \  int n = word.find_last_of(vowels_right[i], m);\n            int o = word.find_last_of(vowels_right[i],\
    \ n);\n            int p = word.find_last_of(vowels_right[i], o);\n          \
    \  int q = word.find_last_of(vowels_right[i], p);\n            int r = word.find_last_of(vowels_right[i],\
    \ q);\n            int s = word.find_last_of(vowels_right[i], r);\n          \
    \  int t = word.find_last_of(vowels_right[i], s);\n            int u = word.find_last_of(vowels_right[i],\
    \ t);\n            int v = word.find_last_of(vowels_right[i], u);\n          \
    \  int w = word.find_last_of(vowels_right[i], v);\n            int x = word.find_last_of(vowels_right[i],\
    \ w);\n            int y = word.find_last_of(vowels_right[i], x);\n          \
    \  int z = word.find_last_of(vowels_right[i], y);\n            \n            if(j\
    \ == -1)\n            {\n                return word[i];\n            }\n    \
    \        else if(k == -1)\n            {\n                return word[i];\n  \
    \          }\n            else if(l == -1)\n            {\n                return\
    \ word[i];\n            }\n            else if(m == -1)\n            {\n     \
    \           return word[i];\n            }\n            else if(n == -1)\n   \
    \         {\n                return word[i];\n            }\n            else\
    \ if(o == -1)\n            {\n                return word[i];\n            }\n\
    \            else if(p == -1)\n            {\n                return word[i];\n\
    \            }\n            else if(q == -1)\n            {\n                return\
    \ word[i];\n            }\n            else if (r == -1)\n            {\n    \
    \            return word[i];\n            }\n            else if(s == -1)\n  \
    \          {\n                return word[i];\n            }\n            else\
    \ if(t == -1)\n            {\n                return word[i];\n            }\n\
    \            else if(u == -1)\n            {\n                return word[i];\n\
    \            }\n            else if(v == -1)\n            {\n                return\
    \ word[i];\n            }\n            else if(w == -1)\n            {\n     \
    \           return word[i];\n            }\n            else if(x == -1)\n   \
    \         {\n                return word[i];\n            }\n            else\
    \ if(y == -1)\n            {\n                return word[i];\n            }\n\
    \            else if(z == -1)\n            {\n                return word[i];\n\
    \            }\n        }\n    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg97mezwi.d(120): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg97mezwi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1;i>=0;i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n     \
    \       int j=i+1;\n            while(j<len && isVowel(word.at(j)))\n        \
    \    {\n                j++;\n            }\n            if(j<len)\n         \
    \   {\n                string leftVowel = word.substr(0,i);\n                string\
    \ rightVowel = word.substr(j);\n                if(leftVowel == rightVowel)\n\
    \                {\n                    return leftVowel;\n                }\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis fails for \"ab\" because \"ab\" has length 2.\n<|/ c |>\n\
    <| c |>\nThanks for pointing out. I've fixed the code.\n<|/ c |>\n<| c |>\nThis\
    \ fails for \"ab\" because \"ab\" has length 2.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing out. I've fixed the code.\n<|/ c |>\n<| c |>\nThis fails for \"ab\"\
    \ because \"ab\" has length 2.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n\
    <code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwbn77z_5.d(48): Error: declaration expected, not `<`\n/tmp/tmpwbn77z_5.d(54):
    Error: unterminated character constant\n/tmp/tmpwbn77z_5.d(60): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbn77z_5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(vowels.find(word[i])\
    \ == string::npos)\n        {\n            return \"\";\n        }\n    }\n  \
    \  \n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n \
    \       {\n            return word[i];\n        }\n    }\n    \n    return \"\"\
    ;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the word is \"\
    ab\"\n<|/ c |>\n<| c |>\nIt works fine for me. Can you please elaborate on what\
    \ doesn't work?\n<|/ c |>\n<| c |>\nIt doesn't work for \"ab\" because \"ab\"\
    \ doesn't contain any vowels. \"ab\" contains \"a\" and \"b\" so \"ab\" should\
    \ return \"a\".\n<|/ c |>\n<| c |>\nI see. Thanks for clarifying. I updated my\
    \ answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic String getClosestVowel(String\
    \ word) {\n    char[] vowels = \"aeiouAEIOU\".toCharArray();\n    char[] consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\".toCharArray();\n    char[] vowelsAfterConsonants\
    \ = \"aeiouAEIOU\".toCharArray();\n    char[] consonantsAfterVowels = \"bcdfghjklmnpqrstvwxyz\"\
    .toCharArray();\n    char[] consonantsAfterConsonants = \"bcdfghjklmnpqrstvwxyz\"\
    .toCharArray();\n    char[] consonantsAfterVowelsAfterConsonants = \"bcdfghjklmnpqrstvwxyz\"\
    .toCharArray();\n    char[] consonantsAfterVowelsAfterConsonantsAfterVowels =\
    \ \"bcdfghjklmnpqrstvwxyz\".toCharArray();\n    char[] consonantsAfterVowelsAfterConsonantsAfterVowelsAfterConsonants\
    \ = \"bcdfghjklmnpqrstvwxyz\".toCharArray();\n    char[] consonantsAfterVowelsAfterConsonantsAfterVowelsAfterConsonantsAfterVow\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprvpgt7pt.d(29): Error: found `:` when expecting `)`\n/tmp/tmprvpgt7pt.d(29):
    Error: found `:` instead of statement\n/tmp/tmprvpgt7pt.d(35): Error: declaration
    expected, not `for`\n/tmp/tmprvpgt7pt.d(35): Error: no identifier for declarator
    `i`\n/tmp/tmprvpgt7pt.d(35): Error: declaration expected, not `>=`\n/tmp/tmprvpgt7pt.d(35):
    Error: no identifier for declarator `i`\n/tmp/tmprvpgt7pt.d(35): Error: declaration
    expected, not `--`\n/tmp/tmprvpgt7pt.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprvpgt7pt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    for(int i =\
    \ word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] == vowels_right[i])\n\
    \        {\n            return word[i];\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfzk4mx9y.d(26): Error: no property `right` for type `string`\n/tmp/tmpfzk4mx9y.d(28):
    Error: no property `length` for type `string`\n/tmp/tmpfzk4mx9y.d(32): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfzk4mx9y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word[i]==vowels_right[i])\n        {\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc6wcoib6.d(37): Error: declaration expected, not `<`\n/tmp/tmpc6wcoib6.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpc6wcoib6.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpc6wcoib6.d(51): Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpc6wcoib6.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpc6wcoib6.d(55): Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpc6wcoib6.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpc6wcoib6.d(59): Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpc6wcoib6.d(61): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc6wcoib6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1;i>=0;i--)\n    {\n        if(word[i]=='a' || word[i]=='e' || word[i]=='i'\
    \ || word[i]=='o' || word[i]=='u')\n        {\n            int j = i+1;\n    \
    \        while(j<len && word[j]!='a' && word[j]!='e' && word[j]!='i' && word[j]!='o'\
    \ && word[j]!='u')\n            {\n                j++;\n            }\n     \
    \       if(j==len)\n            {\n                return word[i];\n         \
    \   }\n            else\n            {\n                int k = j-1;\n       \
    \         while(k>0 && word[k]!='a' && word[k]!='e' && word[k]!='i' && word[k]!='o'\
    \ && word[k]!='u')\n                {\n                    k--;\n            \
    \    }\n                if(k==0)\n                {\n                    return\
    \ word[i];\n                }\n                else\n                {\n     \
    \               int m = k+1;\n                    while(j<len && word[j]!='a'\
    \ && word[j]!='e' && word[j]!='i' && word[j]!='o' && word[j]!='u')\n         \
    \           {\n                        j++;\n                    }\n         \
    \           if(j==len)\n                    {\n                        return\
    \ word[i];\n                    }\n                    else\n                \
    \    {\n                        int n = j+1;\n                        while(n<len\
    \ && word[n]!='a' && word[n]!='e' && word[n]!='i' && word[n]!='o' && word[n]!='u')\n\
    \                        {\n                            n++;\n               \
    \         }\n                        if(n==len)\n                        {\n \
    \                           return word[i];\n                        }\n     \
    \                   else\n                        {\n                        \
    \    int o = n-1;\n                            while(o>0 && word[o]!='a' && word[o]!='e'\
    \ && word[o]!='i' && word[o]!='o' && word[o]!='u')\n                         \
    \   {\n                                o--;\n                            }\n \
    \                           if(o==0)\n                            {\n        \
    \                        return word[i];\n                            }\n    \
    \                        else\n                            {\n               \
    \                 int p = o+1;\n                                while(p<len &&\
    \ word[p]!='a' && word[p]!='e' && word[p]!='i' && word[p]!='o' && word[p]!='u')\n\
    \                                {\n                                    p++;\n\
    \                                }\n                                if(p==len)\n\
    \                                {\n                                    return\
    \ word[i];\n                                }\n                              \
    \  else\n                                {\n                                 \
    \   int q = p-1;\n                                    while(q>0 && word[q]!='a'\
    \ && \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu4f38_nw.d(98): Error: expression expected, not `unittest`\n/tmp/tmpu4f38_nw.d(99):
    Error: found `{` when expecting `)`\n/tmp/tmpu4f38_nw.d(116): Error: found `End
    of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpu4f38_nw.d(116):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu4f38_nw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\", i)]) \n        {\n            return\
    \ word[i];\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj9vswmb9.d(27): Error: no property `length` for type `string`\n/tmp/tmpj9vswmb9.d(29):
    Error: no property `find_last_of` for type `string`\n/tmp/tmpj9vswmb9.d(31): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9vswmb9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    map<string,\
    \ int> consonants;\n    \n    for(int i = 0; i < word.length(); i++)\n    {\n\
    \        if(isVowel(word[i]))\n        {\n            vowels[word[i]]++;\n   \
    \     }\n        else\n        {\n            consonants[word[i]]++;\n       \
    \ }\n    }\n    \n    string vowel = \"\";\n    string consonant = \"\";\n   \
    \ \n    for(auto &i : vowels)\n    {\n        if(vowels.count(i.first) > vowels.count(i.second))\n\
    \        {\n            vowel = i.first;\n        }\n    }\n    \n    for(auto\
    \ &i : consonants)\n    {\n        if(consonants.count(i.first) > consonants.count(i.second))\n\
    \        {\n            consonant = i.first;\n        }\n    }\n    \n    if(vowel.length()\
    \ == 0 && consonant.length() == 0)\n    {\n        return \"\";\n    }\n    \n\
    \    if(vowel.length() == 0)\n    {\n        return consonant;\n    }\n    \n\
    \    if(consonant.length() == 0)\n    {\n        return vowel;\n    }\n    \n\
    \    if(vowel == consonant)\n    {\n        return vowel;\n    }\n    \n    if(vowel\
    \ < consonant)\n    {\n        return vowel;\n    }\n    \n    return consonant;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the word is \"ab\", it returns\
    \ \"a\" instead of \"\"\n<|/ c |>\n<| c |>\nI edited the answer to fix the issue.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work if the word\
    \ is \"ab\", it returns \"a\" instead of \"\"\n<|/ c |>\n<| c |>\nI edited the\
    \ answer to fix the issue. Thanks for pointing it out.\n<|/ c |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <map>\n#include\
    \ <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpig0qilur.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpig0qilur.d(26): Error: found `>` when expecting `.` following int\n/tmp/tmpig0qilur.d(43):
    Error: basic type expected, not `&`\n/tmp/tmpig0qilur.d(43): Error: no identifier
    for declarator `_error_`\n/tmp/tmpig0qilur.d(43): Error: found `:` when expecting
    `;` following `for` condition\n/tmp/tmpig0qilur.d(51): Error: basic type expected,
    not `&`\n/tmp/tmpig0qilur.d(51): Error: no identifier for declarator `_error_`\n/tmp/tmpig0qilur.d(51):
    Error: found `:` when expecting `;` following `for` condition\n/tmp/tmpig0qilur.d(86):
    Error: declaration expected, not `<`\n/tmp/tmpig0qilur.d(89): Error: unterminated
    character constant\n/tmp/tmpig0qilur.d(95): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpig0qilur.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    for(int i = len-1; i >= 0; i--)\n    {\n    \
    \    if(word.endsWith(vowels[i]))\n        {\n            int j = word.lastIndexOf(vowels[i]);\n\
    \            if(j >= 0)\n            {\n                string result = word.substr(j+1);\n\
    \                return result;\n            }\n        }\n    }\n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyyck6unn.d(26): Error: no property `length` for type `string`\n/tmp/tmpyyck6unn.d(29):
    Error: no property `endsWith` for type `string`\n/tmp/tmpyyck6unn.d(31): Error:
    no property `lastIndexOf` for type `string`\n/tmp/tmpyyck6unn.d(34): Error: no
    property `substr` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpyyck6unn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reversed = vowels.rbegin();\n    string vowels_reversed_reversed\
    \ = vowels_reversed.rbegin();\n    \n    for(int i = 0; i < word.length(); i++)\n\
    \    {\n        if(word[i] == vowels_reversed[i])\n        {\n            int\
    \ j = i;\n            while(word[j] != vowels_reversed[j])\n            {\n  \
    \              j--;\n            }\n            int k = j;\n            while(word[k]\
    \ != vowels_reversed_reversed[k])\n            {\n                k--;\n     \
    \       }\n            int l = k;\n            while(word[l] != vowels_reversed_reversed[l])\n\
    \            {\n                l--;\n            }\n            int m = l;\n\
    \            while(word[m] != vowels_reversed_reversed[m])\n            {\n  \
    \              m--;\n            }\n            int n = m;\n            while(word[n]\
    \ != vowels_reversed_reversed[n])\n            {\n                n--;\n     \
    \       }\n            int o = n;\n            while(word[o] != vowels_reversed_reversed[o])\n\
    \            {\n                o--;\n            }\n            int p = o;\n\
    \            while(word[p] != vowels_reversed_reversed[p])\n            {\n  \
    \              p--;\n            }\n            int q = p;\n            while(word[q]\
    \ != vowels_reversed_reversed[q])\n            {\n                q--;\n     \
    \       }\n            int r = q;\n            while(word[r] != vowels_reversed_reversed[r])\n\
    \            {\n                r--;\n            }\n            int s = r;\n\
    \            while(word[s] != vowels_reversed_reversed[s])\n            {\n  \
    \              s--;\n            }\n            int t = s;\n            while(word[t]\
    \ != vowels_reversed_reversed[t])\n            {\n                t--;\n     \
    \       }\n            int u = t;\n            while(word[u] != vowels_reversed_reversed[u])\n\
    \            {\n                u--;\n            }\n            int v = u;\n\
    \            while(word[v] != vowels_reversed_reversed[v])\n            {\n  \
    \              v--;\n            }\n            int w = v;\n            while(word[w]\
    \ != vowels_reversed_reversed[w])\n            {\n                w--;\n     \
    \       }\n            int x = w;\n            while(word[x] != vowels_reversed_reversed[x])\n\
    \            {\n                x--;\n            }\n            int y = x;\n\
    \            while(word[y] != vowels_reversed_reversed[y])\n            {\n  \
    \              y--;\n            }\n            int z = y;\n            while(word[z]\
    \ != vowels_reversed_reversed[z])\n            {\n\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiviszami.d(117): Error: found `unittest` instead of statement\n/tmp/tmpiviszami.d(135):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpiviszami.d(135):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpiviszami.d(135):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiviszami.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    int start = 0;\n    int end = 0;\n    \n\
    \    for(int i = 0; i < len; i++)\n    {\n        if(word[i] == vowels[len - 1\
    \ - i])\n        {\n            start = i;\n            end = len - 1 - i;\n \
    \       }\n    }\n    \n    if(start == end)\n    {\n        return \"\";\n  \
    \  }\n    \n    string result = \"\";\n    \n    for(int i = start; i <= end;\
    \ i++)\n    {\n        if(word[i] == vowels[i])\n        {\n            result\
    \ += vowels[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1girwltq.d(27): Error: no property `length` for type `string`\n/tmp/tmp1girwltq.d(51):
    Error: slice `result` is not mutable\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp1girwltq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    \n    while(i < len && j < len) {\n        if(word[i] == vowels[k]) {\n \
    \           i++;\n            j++;\n            k++;\n        }\n        else\
    \ if(word[i] == vowels[k]) {\n            i++;\n            k++;\n        }\n\
    \        else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n\
    \            k++;\n        }\n        else if(word[i] == vowels[k]) {\n      \
    \      i++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n        }\n        else if(word[i] == vowels[k]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[k])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[k]) {\n            i++;\n            j++;\n      \
    \      k++;\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa80kkuqc.d(150): Error: found `unittest` instead of statement\n/tmp/tmpa80kkuqc.d(168):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpa80kkuqc.d(168):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa80kkuqc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcypli44h.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpcypli44h.d(97): Error: unterminated string constant starting at /tmp/tmpcypli44h.d(114)\n/tmp/tmpcypli44h.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpcypli44h.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpcypli44h.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpcypli44h.d(103): Error: found `u` when expecting `,`\n/tmp/tmpcypli44h.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpcypli44h.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpcypli44h.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpcypli44h.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpcypli44h.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `o` when expecting `,`\n/tmp/tmpcypli44h.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpcypli44h.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpcypli44h.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcypli44h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int start\
    \ = 0;\n    int end = len - 1;\n    \n    while(start < end) {\n        int mid\
    \ = (start + end) / 2;\n        if(word[mid] == 'a' || word[mid] == 'e' || word[mid]\
    \ == 'i' || word[mid] == 'o' || word[mid] == 'u')\n            end = mid - 1;\n\
    \        else\n            start = mid + 1;\n    }\n    \n    return word[end];\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nimport java.util.*;\n\
    import java.lang.*;\nimport java.io.*;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_kkusi2v.d(39): Error: declaration expected, not `<`\n/tmp/tmp_kkusi2v.d(44):
    Error: identifier expected following `package`\n/tmp/tmp_kkusi2v.d(44): Error:
    `;` expected\n/tmp/tmp_kkusi2v.d(45): Error: identifier expected following `package`\n/tmp/tmp_kkusi2v.d(45):
    Error: `;` expected\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_kkusi2v.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    string vowel;\n    for(it=vowels.begin();it!=vowels.end();it++)\n \
    \   {\n        if(it->second==1)\n        {\n            vowel=it->first;\n  \
    \          break;\n        }\n    }\n    if(vowel==\"\")\n    {\n        return\
    \ \"\";\n    }\n    int count=0;\n    for(int i=0;i<word.length();i++)\n    {\n\
    \        if(isVowel(word[i]))\n        {\n            count++;\n        }\n  \
    \  }\n    int index=0;\n    for(int i=word.length()-1;i>=0;i--)\n    {\n     \
    \   if(isVowel(word[i]))\n        {\n            count--;\n        }\n       \
    \ if(count<0)\n        {\n            index=i;\n            break;\n        }\n\
    \    }\n    if(index==0)\n    {\n        return \"\";\n    }\n    string result=vowel.substr(0,index-1);\n\
    \    return result;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This is not an answer to the question. While it may answer the question, please\
    \ add some explanation as to why this solves the problem.\n<|/ c |>\n<| c |>\n\
    I agree with you. But the OP asked for the algorithm and I gave him an algorithm\
    \ to solve the problem. He didn't ask for an implementation. He asked for the\
    \ algorithm and I gave him an algorithm to solve the problem. He didn't ask for\
    \ an implementation. He asked for the algorithm and I gave him an algorithm to\
    \ solve the problem. He didn't ask for an implementation. He asked for the algorithm\
    \ and I gave him an algorithm to solve the problem. He didn't ask for an implementation.\
    \ He asked for the algorithm and I gave him an algorithm to solve the problem.\
    \ He didn't ask for an implementation. He asked for the algorithm and I gave him\
    \ an algorithm to solve the problem. He didn't ask for an implementation. He asked\
    \ for the algorithm and I gave him an algorithm to solve the problem. He didn't\
    \ ask for an implementation. He asked for the algorithm and I gave him an algorithm\
    \ to solve the problem. He didn't ask for an implementation. He asked \nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8m5puynj.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp8m5puynj.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp8m5puynj.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp8m5puynj.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp8m5puynj.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp8m5puynj.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp8m5puynj.d(75): Error: declaration expected,
    not `<`\n/tmp/tmp8m5puynj.d(81): Error: unterminated character constant\n/tmp/tmp8m5puynj.d(81):
    Error: unterminated character constant\n/tmp/tmp8m5puynj.d(81): Error: unterminated
    character constant\n/tmp/tmp8m5puynj.d(81): Error: unterminated character constant\n/tmp/tmp8m5puynj.d(81):
    Error: unterminated character constant\n/tmp/tmp8m5puynj.d(81): Error: unterminated
    character constant\n/tmp/tmp8m5puynj.d(81): Error: unterminated character constant\n/tmp/tmp8m5puynj.d(81):
    Error: unterminated character constant\n/tmp/tmp8m5puynj.d(86): Error: declaration
    expected, not `assert`\n/tmp/tmp8m5puynj.d(87): Error: declaration expected, not
    `assert`\n/tmp/tmp8m5puynj.d(88): Error: declaration expected, not `assert`\n/tmp/tmp8m5puynj.d(89):
    Error: declaration expected, not `assert`\n/tmp/tmp8m5puynj.d(90): Error: declaration
    expected, not `assert`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8m5puynj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvl2zfhy.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsvl2zfhy.d(97): Error: unterminated string constant starting at /tmp/tmpsvl2zfhy.d(114)\n/tmp/tmpsvl2zfhy.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpsvl2zfhy.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpsvl2zfhy.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpsvl2zfhy.d(103): Error: found `u` when expecting `,`\n/tmp/tmpsvl2zfhy.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpsvl2zfhy.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpsvl2zfhy.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpsvl2zfhy.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpsvl2zfhy.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpsvl2zfhy.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpsvl2zfhy.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpsvl2zfhy.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpsvl2zfhy.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpsvl2zfhy.d(108): Error: found `o` when expecting `,`\n/tmp/tmpsvl2zfhy.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpsvl2zfhy.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpsvl2zfhy.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpsvl2zfhy.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsvl2zfhy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           string vowel = word[i];\n            int index = vowels.find(vowel);\n\
    \            if(index==-1)\n            {\n                vowels[vowel]=i;\n\
    \            }\n            else\n            {\n                int min = abs(index-i);\n\
    \                if(min<vowels[vowel])\n                {\n                  \
    \  vowels[vowel]=min;\n                }\n            }\n        }\n    }\n  \
    \  string result = \"\";\n    for(auto it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second<vowels.size())\n        {\n            result =\
    \ it->first;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphnw53wai.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmphnw53wai.d(49): Error: use `.` for member lookup, not `->`\n/tmp/tmphnw53wai.d(51):
    Error: use `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmphnw53wai.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            vowels[word[i]]++;\n\
    \        }\n    }\n    \n    string vowel = \"\";\n    \n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            if(vowels[word[i]]\
    \ > 0)\n            {\n                vowel = word[i];\n                break;\n\
    \            }\n        }\n    }\n    \n    return vowel;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz59_ifn6.d(25): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz59_ifn6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reverse = vowels.rbegin();\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word[i]==vowels_reverse)\n        {\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string |>\n<|\
    \ c |>\nThe question says \"You may assume that the given string contains English\
    \ letter only.\"\n<|/ c |>\n<| c |>\nYeah, I missed that part. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8_7dy9wj.d(37): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8_7dy9wj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        auto it = vowels.find(word[i]);\n\
    \        if(it == vowels.end())\n        {\n            vowels[word[i]] = 1;\n\
    \        }\n        else\n        {\n            vowels[word[i]]++;\n        }\n\
    \    }\n    \n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 2)\n        {\n \
    \           return it->first;\n        }\n    }\n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8rd_5t49.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp8rd_5t49.d(39): Error: found `>` when expecting `.` following int\n/tmp/tmp8rd_5t49.d(39):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp8rd_5t49.d(39):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp8rd_5t49.d(42):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp8rd_5t49.d(44): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rd_5t49.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string, int> vowel_map;\n    for(int i = 0; i < vowels.length(); i++)\n\
    \    {\n        vowel_map[vowels.at(i)] = i;\n    }\n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        if(vowel_map.find(word.at(i)) != vowel_map.end())\n\
    \        {\n            int index = vowel_map[word.at(i)];\n            int j\
    \ = word.at(i) - 'a';\n            while(j >= 0 && index < vowel_map.end() &&\
    \ vowel_map[index] == j)\n            {\n                index++;\n          \
    \      j--;\n            }\n            if(index < vowel_map.end())\n        \
    \    {\n                return word.at(i) + 'u';\n            }\n        }\n \
    \   }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c\
    \ |>\nI like your solution, but I believe it would be more efficient to just iterate\
    \ through the string and check each character against the vowel map.\n<|/ c |>\n\
    <| c |>\nI agree with you. My solution is more efficient than yours. I didn't\
    \ think about it because I didn't want to change his code too much.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I believe it would be more efficient to just\
    \ iterate through the string and check each character against the vowel map.\n\
    <|/ c |>\n<| c |>\nI agree with you. My solution is more efficient than yours.\
    \ I didn't think about it because I didn't want to change his code too much.\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0tku8dre.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmp0tku8dre.d(50): Error: declaration expected, not `<`\n/tmp/tmp0tku8dre.d(56):
    Error: unterminated character constant\n/tmp/tmp0tku8dre.d(56): Error: unterminated
    character constant\n/tmp/tmp0tku8dre.d(62): Error: unterminated character constant\n/tmp/tmp0tku8dre.d(62):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp0tku8dre.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ < end) {\n        int mid = start + (end - start) / 2;\n        \n        if\
    \ (word[mid] == vowels[mid]) {\n            end = mid - 1;\n        } else {\n\
    \            start = mid + 1;\n        }\n    }\n    \n    return word[start];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvsdj9kd3.d(28): Error: no property `length` for type `string`\n/tmp/tmpvsdj9kd3.d(40):
    Error: cannot implicitly convert expression `word[cast(ulong)start]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsdj9kd3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        char c = word[i];\n        if(isalpha(c))\n\
    \        {\n            vowels[c]++;\n        }\n    }\n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        char c = word[i];\n        if(isalpha(c))\n\
    \        {\n            vowels[c]--;\n        }\n    }\n    map<string, int>::iterator\
    \ it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n    {\n       \
    \ if(it->second == 0)\n        {\n            return it->first;\n        }\n \
    \   }\n    return \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,string,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq11y9cmw.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpq11y9cmw.d(42): Error: found `>` when expecting `.` following int\n/tmp/tmpq11y9cmw.d(42):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpq11y9cmw.d(42):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpq11y9cmw.d(45):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpq11y9cmw.d(47): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpq11y9cmw.d(52): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq11y9cmw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string,int> mapVowels;\n    mapVowels[vowels] = 1;\n    mapVowels[\"a\"\
    ] = 1;\n    mapVowels[\"e\"] = 1;\n    mapVowels[\"i\"] = 1;\n    mapVowels[\"\
    o\"] = 1;\n    mapVowels[\"u\"] = 1;\n    mapVowels[\"A\"] = 1;\n    mapVowels[\"\
    E\"] = 1;\n    mapVowels[\"I\"] = 1;\n    mapVowels[\"O\"] = 1;\n    mapVowels[\"\
    U\"] = 1;\n    mapVowels[\"a\"] = 1;\n    mapVowels[\"e\"] = 1;\n    mapVowels[\"\
    i\"] = 1;\n    mapVowels[\"o\"] = 1;\n    mapVowels[\"u\"] = 1;\n    mapVowels[\"\
    A\"] = 1;\n    mapVowels[\"E\"] = 1;\n    mapVowels[\"I\"] = 1;\n    mapVowels[\"\
    O\"] = 1;\n    mapVowels[\"U\"] = 1;\n    mapVowels[\"a\"] = 1;\n    mapVowels[\"\
    e\"] = 1;\n    mapVowels[\"i\"] = 1;\n    mapVowels[\"o\"] = 1;\n    mapVowels[\"\
    u\"] = 1;\n    mapVowels[\"A\"] = 1;\n    mapVowels[\"E\"] = 1;\n    mapVowels[\"\
    I\"] = 1;\n    mapVowels[\"O\"] = 1;\n    mapVowels[\"U\"] = 1;\n    mapVowels[\"\
    a\"] = 1;\n    mapVowels[\"e\"] = 1;\n    mapVowels[\"i\"] = 1;\n    mapVowels[\"\
    o\"] = 1;\n    mapVowels[\"u\"] = 1;\n    mapVowels[\"A\"] = 1;\n    mapVowels[\"\
    E\"] = 1;\n    mapVowels[\"I\"] = 1;\n    mapVowels[\"O\"] = 1;\n    mapVowels[\"\
    U\"] = 1;\n    mapVowels[\"a\"] = 1;\n    mapVowels[\"e\"] = 1;\n    mapVowels[\"\
    i\"] = 1;\n    mapVowels[\"o\"] = 1;\n    mapVowels[\"u\"] = 1;\n    mapVowels[\"\
    A\"] = 1;\n    mapVowels[\"E\"] = 1;\n    mapVowels[\"I\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphmv75bs2.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmphmv75bs2.d(75): Error: unterminated string constant starting at /tmp/tmphmv75bs2.d(92)\n/tmp/tmphmv75bs2.d(80):
    Error: found `yogurt` when expecting `,`\n/tmp/tmphmv75bs2.d(80): Error: found
    `u` when expecting `,`\n/tmp/tmphmv75bs2.d(81): Error: found `full` when expecting
    `,`\n/tmp/tmphmv75bs2.d(81): Error: found `u` when expecting `,`\n/tmp/tmphmv75bs2.d(82):
    Error: found `easy` when expecting `,`\n/tmp/tmphmv75bs2.d(82): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmphmv75bs2.d(83): Error: found `eAsy` when expecting `,`\n/tmp/tmphmv75bs2.d(83):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmphmv75bs2.d(84): Error: found `ali` when expecting `,`\n/tmp/tmphmv75bs2.d(84):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmphmv75bs2.d(85): Error: found `bad` when expecting `,`\n/tmp/tmphmv75bs2.d(85):
    Error: found `a` when expecting `,`\n/tmp/tmphmv75bs2.d(86): Error: found `most`
    when expecting `,`\n/tmp/tmphmv75bs2.d(86): Error: found `o` when expecting `,`\n/tmp/tmphmv75bs2.d(87):
    Error: found `ab` when expecting `,`\n/tmp/tmphmv75bs2.d(87): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmphmv75bs2.d(88): Error: found `ba` when expecting `,`\n/tmp/tmphmv75bs2.d(88):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmv75bs2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1; i>=0; i--)\n    {\n        if(isVowel(word[i]))\n        {\n      \
    \      int j = i+1;\n            while(j<len && isVowel(word[j]))\n          \
    \  {\n                j++;\n            }\n            if(j-i>1)\n           \
    \ {\n                return word[i];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa1z9wedo.d(25): Error: no property `length` for type `string`\n/tmp/tmpa1z9wedo.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmpa1z9wedo.d(31): Error: undefined
    identifier `isVowel`\n/tmp/tmpa1z9wedo.d(37): Error: cannot implicitly convert
    expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1z9wedo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    o\"] = 1;\n    vowels[\"u\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcypli44h.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpcypli44h.d(97): Error: unterminated string constant starting at /tmp/tmpcypli44h.d(114)\n/tmp/tmpcypli44h.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpcypli44h.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpcypli44h.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpcypli44h.d(103): Error: found `u` when expecting `,`\n/tmp/tmpcypli44h.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpcypli44h.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpcypli44h.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpcypli44h.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpcypli44h.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpcypli44h.d(108): Error: found `o` when expecting `,`\n/tmp/tmpcypli44h.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpcypli44h.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpcypli44h.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpcypli44h.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcypli44h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    \n    for(int i = len-1; i >= 0; i--)\n\
    \    {\n        if(vowels.find(word.at(i)) != string::npos)\n        {\n     \
    \       int j = i+1;\n            while(j < len && vowels.find(word.at(j)) !=\
    \ string::npos)\n            {\n                if(word.at(j) == word.at(i))\n\
    \                {\n                    return word.at(j);\n                }\n\
    \                j++;\n            }\n        }\n    }\n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg_jbthaj.d(31): Error: found `:` when expecting `)`\n/tmp/tmpg_jbthaj.d(31):
    Error: found `:` instead of statement\n/tmp/tmpg_jbthaj.d(34): Error: found `:`
    when expecting `)`\n/tmp/tmpg_jbthaj.d(34): Error: found `:` instead of statement\n/tmp/tmpg_jbthaj.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_jbthaj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    for(int i =\
    \ word.length() - 1; i >= 0; i--)\n    {\n        if(isVowel(word[i]))\n     \
    \   {\n            int count = vowels[word[i]];\n            if(count > 0)\n \
    \           {\n                vowels[word[i]]--;\n                if(count >\
    \ 1)\n                {\n                    return word[i];\n               \
    \ }\n            }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp95wqzchf.d(25): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95wqzchf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        string vowel = word.substr(i,\
    \ 1);\n        if(vowels.find(vowel) == vowels.end())\n        {\n           \
    \ vowels[vowel] = 1;\n        }\n        else\n        {\n            vowels[vowel]++;\n\
    \        }\n    }\n    \n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 2)\n        {\n \
    \           return it->first;\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg1jc01ib.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpg1jc01ib.d(39): Error: found `>` when expecting `.` following int\n/tmp/tmpg1jc01ib.d(39):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpg1jc01ib.d(39):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpg1jc01ib.d(42):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpg1jc01ib.d(44): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpg1jc01ib.d(49): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1jc01ib.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reversed = vowels.rbegin();\n    \n    int vowels_count = vowels.size();\n\
    \    int vowels_count_reversed = vowels_reversed.size();\n    \n    int consonants_count\
    \ = word.size();\n    int consonants_count_reversed = consonants_count - vowels_count_reversed;\n\
    \    \n    int consonants_count_left = consonants_count - vowels_count;\n    \n\
    \    int consonants_count_right = consonants_count + vowels_count;\n    \n   \
    \ int consonants_count_left_reversed = consonants_count_left - vowels_count_reversed;\n\
    \    \n    int consonants_count_right_reversed = consonants_count_right + vowels_count_reversed;\n\
    \    \n    int consonants_count_left_reversed_2 = consonants_count_left_reversed\
    \ - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_2 =\
    \ consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_3\
    \ = consonants_count_left_reversed - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_3\
    \ = consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_4\
    \ = consonants_count_left_reversed - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_4\
    \ = consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_5\
    \ = consonants_count_left_reversed - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_5\
    \ = consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_6\
    \ = consonants_count_left_reversed - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_6\
    \ = consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_7\
    \ = consonants_count_left_reversed - vowels_count_reversed;\n    \n    int consonants_count_right_reversed_7\
    \ = consonants_count_right_reversed + vowels_count_reversed;\n    \n    int consonants_count_left_reversed_8\
    \ = consonants_count_left_reversed - vowel\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoxlsv4p6.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpoxlsv4p6.d(67):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpoxlsv4p6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=vowels[word[i]]+1;\n\
    \        }\n    }\n    map<string,int>::iterator it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n\
    \    {\n        if(it->second==0)\n        {\n            return it->first;\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string |>\n<|\
    \ a |>\n<code>\n#include <iostream>\n#include <string>\n#include <map>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2e87a6ya.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp2e87a6ya.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmp2e87a6ya.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp2e87a6ya.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp2e87a6ya.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp2e87a6ya.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp2e87a6ya.d(43): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2e87a6ya.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int start\
    \ = 0;\n    int end = len - 1;\n    while(start < end) {\n        int mid = (start\
    \ + end) / 2;\n        if(word[mid] == 'a' || word[mid] == 'e' || word[mid] ==\
    \ 'i' || word[mid] == 'o' || word[mid] == 'u' || word[mid] == 'y') {\n       \
    \     end = mid - 1;\n        } else {\n            start = mid + 1;\n       \
    \ }\n    }\n    return word[start];\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThanks for your answer. I tried your solution and it works fine\
    \ for most of the test cases. But it fails for some test cases. Please find the\
    \ test cases below. \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2k_cb23u.d(38): Error: declaration expected, not `<`\n/tmp/tmp2k_cb23u.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmp2k_cb23u.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmp2k_cb23u.d(49): Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmp2k_cb23u.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmp2k_cb23u.d(53): Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmp2k_cb23u.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmp2k_cb23u.d(57): Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmp2k_cb23u.d(59): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2k_cb23u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\", i)]) \n        {\n            return\
    \ word[i];\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj9vswmb9.d(27): Error: no property `length` for type `string`\n/tmp/tmpj9vswmb9.d(29):
    Error: no property `find_last_of` for type `string`\n/tmp/tmpj9vswmb9.d(31): Error:
    cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9vswmb9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(word[i]=='a' || word[i]=='e' ||\
    \ word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n            vowels[word[i]]=1;\n\
    \        }\n    }\n    for(int i=0;i<word.length();i++)\n    {\n        if(word[i]=='a'\
    \ || word[i]=='e' || word[i]=='i' || word[i]=='o' || word[i]=='u')\n        {\n\
    \            int j=i;\n            while(j<word.length() && word[j]!='a' && word[j]!='e'\
    \ && word[j]!='i' && word[j]!='o' && word[j]!='u')\n            {\n          \
    \      j++;\n            }\n            string left=word.substr(0,j);\n      \
    \      string right=word.substr(j+1);\n            if(vowels[left]>vowels[right])\n\
    \            {\n                return left;\n            }\n        }\n    }\n\
    \    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\nThis\
    \ code doesn't work if the word is \"ab\". It returns \"a\" instead of \"\".\n\
    <|/ c |>\n<| c |>\nI edited the code so that it works now. Thanks for pointing\
    \ out.\n<|/ c |>\n<| c |>\nThis code doesn't work if the word is \"ab\". It returns\
    \ \"a\" instead of \"\".\n<|/ c |>\n<| c |>\nI edited the code so that it works\
    \ now. Thanks for pointing out.\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n\
    <code>\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn9ydc8yk.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpn9ydc8yk.d(52): Error: declaration expected, not `<`\n/tmp/tmpn9ydc8yk.d(55):
    Error: unterminated character constant\n/tmp/tmpn9ydc8yk.d(61): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn9ydc8yk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end) {\n        string sub = word.substr(start, end);\n        \n        int\
    \ index = vowels.find(sub);\n        \n        if(index != -1) {\n           \
    \ return vowels[index];\n        }\n        \n        start += 1;\n        end\
    \ -= 1;\n    }\n    \n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `get_closest_vowel(\"ab\")`.\n<|/\
    \ c |>\n<| c |>\nYeah, I noticed that and fixed it. Thanks for pointing it out.\
    \ :)\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `get_closest_vowel(\"\
    ab\")`.\n<|/ c |>\n<| c |>\nYeah, I noticed that and fixed it. Thanks for pointing\
    \ it out. :)\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `get_closest_vowel(\"\
    ab\")`.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9eb_zpio.d(45): Error: declaration expected, not `<`\n/tmp/tmp9eb_zpio.d(48):
    Error: unterminated character constant\n/tmp/tmp9eb_zpio.d(54): Error: unterminated
    character constant\n/tmp/tmp9eb_zpio.d(60): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9eb_zpio.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second<2)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThis code doesn't work. Try it\
    \ with `get_closest_vowel(\"ab\")`.\n<|/ c |>\n<| c |>\nThanks for pointing out.\
    \ I've fixed the code now.\n<|/ c |>\n<| c |>\nThis code doesn't work. Try it\
    \ with `get_closest_vowel(\"ab\")`.\n<|/ c |>\n<| c |>\nThanks for pointing out.\
    \ I've fixed the code now.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmhqni17a.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpmhqni17a.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpmhqni17a.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpmhqni17a.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpmhqni17a.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpmhqni17a.d(38): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpmhqni17a.d(43): Error: declaration expected,
    not `<`\n/tmp/tmpmhqni17a.d(46): Error: unterminated character constant\n/tmp/tmpmhqni17a.d(49):
    Error: unterminated character constant\n/tmp/tmpmhqni17a.d(52): Error: unterminated
    character constant\n/tmp/tmpmhqni17a.d(55): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhqni17a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1;i>=0;i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n     \
    \       int j=i+1;\n            while(j<len && isVowel(word.at(j)))\n        \
    \    {\n                j++;\n            }\n            if(j==len)\n        \
    \    {\n                return word.at(i);\n            }\n            else\n\
    \            {\n                int k=j;\n                while(j<len && isConsonant(word.at(j)))\n\
    \                {\n                    j++;\n                }\n            \
    \    if(j==len)\n                {\n                    return word.at(i);\n \
    \               }\n                else\n                {\n                 \
    \   int l=j;\n                    while(k<len && isConsonant(word.at(k)))\n  \
    \                  {\n                        k++;\n                    }\n  \
    \                  if(k==len)\n                    {\n                       \
    \ return word.at(i);\n                    }\n                    else\n      \
    \              {\n                        int m=k;\n                        while(l<len\
    \ && isConsonant(word.at(l)))\n                        {\n                   \
    \         l++;\n                        }\n                        if(l==len)\n\
    \                        {\n                            return word.at(i);\n \
    \                       }\n                        else\n                    \
    \    {\n                            int n=l;\n                            while(m<len\
    \ && isConsonant(word.at(m)))\n                            {\n               \
    \                 m++;\n                            }\n                      \
    \      if(m==len)\n                            {\n                           \
    \     return word.at(i);\n                            }\n                    \
    \        else\n                            {\n                               \
    \ int o=m;\n                                while(n<len && isConsonant(word.at(n)))\n\
    \                                {\n                                    n++;\n\
    \                                }\n                                if(n==len)\n\
    \                                {\n                                    return\
    \ word.at(i);\n                                }\n                           \
    \     else\n                                {\n                              \
    \      int p=n;\n                                    while(o<len && isConsonant(word.at(o)))\n\
    \                                    {\n                                     \
    \   o++;\n                                    }\n                            \
    \        if(o==len)\n                                    {\n                 \
    \                       return word.at(i);\n                                 \
    \   }\n                                    else\n                            \
    \        {\n                                        int q=o;\n               \
    \                         while(p<len && isConsonant(word.at(p)))\n          \
    \                              {\n                                           \
    \ p++;\n                                        }\n                          \
    \              if(p==len)\n                                        {\n       \
    \                                     return word.at(i);\n                   \
    \                     }\n                                        else\n      \
    \                                  {\n                                       \
    \     int r=p;\n                                            while(q<len && isConsonant(word.at(q)))\n\
    \                                            {\n                             \
    \                   q++;\n                                            }\n    \
    \                                        if(q==len)\n                        \
    \                    {\n                                                return\
    \ word.at(i);\n                                            }\n               \
    \                             else\n                                         \
    \   {\n                                                int s=q;\n            \
    \                                    while(r<len\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdnpz2p8a.d(131): Error: found `unittest` when expecting `)`\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpdnpz2p8a.d(149):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdnpz2p8a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int index2 = vowels.find(word[i + 1], index + 1);\n            \n\
    \            if(index2 != string::npos)\n            {\n                return\
    \ word[i];\n            }\n        }\n    }\n    \n    return \"\";\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps6c5k83s.d(29): Error: found `:` when expecting `)`\n/tmp/tmps6c5k83s.d(29):
    Error: found `:` instead of statement\n/tmp/tmps6c5k83s.d(34): Error: found `:`
    when expecting `)`\n/tmp/tmps6c5k83s.d(34): Error: found `:` instead of statement\n/tmp/tmps6c5k83s.d(39):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6c5k83s.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        string vowel = word.substr(i,\
    \ 1);\n        if(vowels.find(vowel) == vowels.end())\n        {\n           \
    \ vowels[vowel] = 1;\n        }\n        else\n        {\n            vowels[vowel]\
    \ += 1;\n        }\n    }\n    \n    map<string, int>::iterator it;\n    for(it\
    \ = vowels.begin(); it != vowels.end(); it++)\n    {\n        if(it->second ==\
    \ 1)\n        {\n            return it->first;\n        }\n    }\n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprbsblglq.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmprbsblglq.d(39): Error: found `>` when expecting `.` following int\n/tmp/tmprbsblglq.d(39):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmprbsblglq.d(39):
    Error: found `:` when expecting `;` following statement\n/tmp/tmprbsblglq.d(42):
    Error: use `.` for member lookup, not `->`\n/tmp/tmprbsblglq.d(44): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprbsblglq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.right(vowels.length());\n    string vowels_left\
    \ = vowels.left(vowels.length());\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels_right[i])\n        {\n           \
    \ string vowel_before = word.left(i);\n            string vowel_after = word.right(i);\n\
    \            \n            if(vowel_before.length() > 0 && vowel_after.length()\
    \ > 0)\n            {\n                if(vowel_before[0] == vowels_left[0] &&\
    \ vowel_before[1] == vowels_left[1])\n                {\n                    return\
    \ vowel_before;\n                }\n                else if(vowel_after[0] ==\
    \ vowels_left[0] && vowel_after[1] == vowels_left[1])\n                {\n   \
    \                 return vowel_after;\n                }\n            }\n    \
    \    }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx7179hcu.d(26): Error: no property `right` for type `string`\n/tmp/tmpx7179hcu.d(27):
    Error: no property `left` for type `string`\n/tmp/tmpx7179hcu.d(29): Error: no
    property `length` for type `string`\n/tmp/tmpx7179hcu.d(33): Error: no property
    `left` for type `string`\n/tmp/tmpx7179hcu.d(34): Error: no property `right` for
    type `string`\n/tmp/tmpx7179hcu.d(36): Error: no property `length` for type `string`\n/tmp/tmpx7179hcu.d(36):
    Error: no property `length` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpx7179hcu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int left = 0;\n    int right = word.length() - 1;\n    \n    while(left\
    \ < right) {\n        int mid = (left + right) / 2;\n        \n        if(word[mid]\
    \ == vowels[mid]) {\n            left = mid + 1;\n        } else {\n         \
    \   right = mid - 1;\n        }\n    }\n    \n    return word[left];\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nI like your solution. However it\
    \ fails for \"ab\" which should return an empty string but returns \"a\". Any\
    \ idea why?\n<|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| c |>\nThanks for your solution. However it fails\
    \ for \"ab\" which should return an empty string but returns \"a\". Any idea why?\n\
    <|/ c |>\n<| c |>\nI edited the answer to fix the bug. Thanks for pointing it\
    \ out.\n<|/ c |>\n<| c |>\nThanks for your solution. However it fails for \"ab\"\
    \ which should return an empty string but returns \"a\". Any idea why?\n<|/ c\
    \ |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpydj0zvgl.d(42): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydj0zvgl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"o\"] = 1;\n\
    \    vowels[\"u\"] = 1;\n    vowels[\"r\"] = 1;\n    vowels[\"l\"] = 1;\n    vowels[\"\
    d\"] = 1;\n    vowels[\"c\"] = 1;\n    vowels[\"t\"] = 1;\n    vowels[\"q\"] =\
    \ 1;\n    vowels[\"p\"] = 1;\n    vowels[\"f\"] = 1;\n    vowels[\"s\"] = 1;\n\
    \    vowels[\"z\"] = 1;\n    vowels[\"k\"] = 1;\n    vowels[\"j\"] = 1;\n    vowels[\"\
    x\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"q\"] = 1;\n    vowels[\"p\"] =\
    \ 1;\n    vowels[\"f\"] = 1;\n    vowels[\"s\"] = 1;\n    vowels[\"z\"] = 1;\n\
    \    vowels[\"k\"] = 1;\n    vowels[\"j\"] = 1;\n    vowels[\"x\"] = 1;\n    vowels[\"\
    z\"] = 1;\n    vowels[\"q\"] = 1;\n    vowels[\"p\"] = 1;\n    vowels[\"f\"] =\
    \ 1;\n    vowels[\"s\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"k\"] = 1;\n\
    \    vowels[\"j\"] = 1;\n    vowels[\"x\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"\
    q\"] = 1;\n    vowels[\"p\"] = 1;\n    vowels[\"f\"] = 1;\n    vowels[\"s\"] =\
    \ 1;\n    vowels[\"z\"] = 1;\n    vowels[\"k\"] = 1;\n    vowels[\"j\"] = 1;\n\
    \    vowels[\"x\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"q\"] = 1;\n    vowels[\"\
    p\"] = 1;\n    vowels[\"f\"] = 1;\n    vowels[\"s\"] = 1;\n    vowels[\"z\"] =\
    \ 1;\n    vowels[\"k\"] = 1;\n    vowels[\"j\"] = 1;\n    vowels[\"x\"] = 1;\n\
    \    vowels[\"z\"] = 1;\n    vowels[\"q\"] = 1;\n    vowels[\"p\"] = 1;\n    vowels[\"\
    f\"] = 1;\n    vowels[\"s\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"k\"] =\
    \ 1;\n    vowels[\"j\"] = 1;\n    vowels[\"x\"] = 1;\n    vowels[\"z\"] = 1;\n\
    \    vowels[\"q\"] = 1;\n    vowels[\"p\"] = 1;\n    vowels[\"f\"] = 1;\n    vowels[\"\
    s\"] = 1;\n    vowels[\"z\"] = 1;\n    vowels[\"k\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe3fazwzp.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpe3fazwzp.d(98): Error: unterminated string constant starting at /tmp/tmpe3fazwzp.d(115)\n/tmp/tmpe3fazwzp.d(103):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpe3fazwzp.d(103): Error: found
    `u` when expecting `,`\n/tmp/tmpe3fazwzp.d(104): Error: found `full` when expecting
    `,`\n/tmp/tmpe3fazwzp.d(104): Error: found `u` when expecting `,`\n/tmp/tmpe3fazwzp.d(105):
    Error: found `easy` when expecting `,`\n/tmp/tmpe3fazwzp.d(105): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpe3fazwzp.d(106): Error: found `eAsy` when expecting `,`\n/tmp/tmpe3fazwzp.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpe3fazwzp.d(107): Error: found `ali` when expecting `,`\n/tmp/tmpe3fazwzp.d(107):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpe3fazwzp.d(108): Error: found `bad` when expecting `,`\n/tmp/tmpe3fazwzp.d(108):
    Error: found `a` when expecting `,`\n/tmp/tmpe3fazwzp.d(109): Error: found `most`
    when expecting `,`\n/tmp/tmpe3fazwzp.d(109): Error: found `o` when expecting `,`\n/tmp/tmpe3fazwzp.d(110):
    Error: found `ab` when expecting `,`\n/tmp/tmpe3fazwzp.d(110): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpe3fazwzp.d(111): Error: found `ba` when expecting `,`\n/tmp/tmpe3fazwzp.d(111):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3fazwzp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowels.find(word.substr(i,\
    \ 1)) != string::npos)\n        {\n            return word.substr(i, 1);\n   \
    \     }\n    }\n    \n    return \"\";\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphw7fz5gm.d(29): Error: found `:` when expecting `)`\n/tmp/tmphw7fz5gm.d(29):
    Error: found `:` instead of statement\n/tmp/tmphw7fz5gm.d(35): Error: declaration
    expected, not `return`\n/tmp/tmphw7fz5gm.d(36): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphw7fz5gm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int index2 = vowels.find(word[i + 1], index + 1);\n            \n\
    \            if(index2 != string::npos)\n            {\n                return\
    \ word[index2];\n            }\n        }\n    }\n    \n    return \"\";\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0dhbheer.d(29): Error: found `:` when expecting `)`\n/tmp/tmp0dhbheer.d(29):
    Error: found `:` instead of statement\n/tmp/tmp0dhbheer.d(34): Error: found `:`
    when expecting `)`\n/tmp/tmp0dhbheer.d(34): Error: found `:` instead of statement\n/tmp/tmp0dhbheer.d(39):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0dhbheer.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ <= end) {\n        int mid = start + (end - start) / 2;\n        \n        if\
    \ (word[mid] == vowels[mid]) {\n            end = mid - 1;\n        } else {\n\
    \            start = mid + 1;\n        }\n    }\n    \n    return word[start];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbam3o520.d(28): Error: no property `length` for type `string`\n/tmp/tmpbam3o520.d(40):
    Error: cannot implicitly convert expression `word[cast(ulong)start]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbam3o520.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(vowels.find(word.substr(i,1))!=string::npos)\n\
    \        {\n            return word.substr(i,1);\n        }\n    }\n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeyyejzyw.d(29): Error: found `:` when expecting `)`\n/tmp/tmpeyyejzyw.d(29):
    Error: found `:` instead of statement\n/tmp/tmpeyyejzyw.d(34): Error: declaration
    expected, not `return`\n/tmp/tmpeyyejzyw.d(35): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyyejzyw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int left = 0;\n    int right = word.length()\
    \ - 1;\n    while(left <= right) {\n        int mid = (left + right) / 2;\n  \
    \      if(word[mid] == 'a' || word[mid] == 'e' || word[mid] == 'i' || word[mid]\
    \ == 'o' || word[mid] == 'u')\n            left = mid + 1;\n        else\n   \
    \         right = mid - 1;\n    }\n    return word[left];\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp92fi8i7y.d(36): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92fi8i7y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    int len = word.length();\n    int start = 0;\n    int end = len - 1;\n  \
    \  \n    while(start < end)\n    {\n        int mid = (start + end) / 2;\n   \
    \     \n        if(word[mid] == consonants[mid])\n        {\n            end =\
    \ mid - 1;\n        }\n        else if(word[mid] == vowels[mid])\n        {\n\
    \            start = mid + 1;\n        }\n        else\n        {\n          \
    \  start = mid + 1;\n            end = mid - 1;\n        }\n    }\n    \n    if(word[start]\
    \ == consonants[start])\n    {\n        return word[start];\n    }\n    else if(word[end]\
    \ == consonants[end])\n    {\n        return word[end];\n    }\n    else\n   \
    \ {\n        return \"\";\n    }\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nI believe that `if(word[mid] == consonants[mid])` should be `if(word[mid]\
    \ == consonants[mid-1])`\n<|/ c |>\n<| c |>\n`if(word[mid] == consonants[mid])`\
    \ should be `if(word[mid] == consonants[mid-1])`\n<|/ c |>\n<| c |>\n`if(word[mid]\
    \ == consonants[mid])` should be `if(word[mid] == consonants[mid-1])`\n<|/ c |>\n\
    <| c |>\n`if(word[mid] == consonants[mid])` should be `if(word[mid] == consonants[mid-1])`\n\
    <|/ c |>\n<| c |>\n`if(word[mid] == consonants[mid])` should be `if(word[mid]\
    \ == consonants[mid-1])`\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb4wvpjmm.d(64): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4wvpjmm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i=len-1;i>=0;i--)\n    {\n        if(isVowel(word[i]))\n        {\n        \
    \    int j=i+1;\n            while(j<len && isVowel(word[j]))\n            {\n\
    \                j++;\n            }\n            if(j-i>1)\n            {\n \
    \               return word[i];\n            }\n        }\n    }\n    return \"\
    \";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwtjovify.d(25): Error: no property `length` for type `string`\n/tmp/tmpwtjovify.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmpwtjovify.d(31): Error: undefined
    identifier `isVowel`\n/tmp/tmpwtjovify.d(37): Error: cannot implicitly convert
    expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwtjovify.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    map<string, int> vowels;\n   \
    \ \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n\
    \        {\n            vowels[word[i]]++;\n        }\n    }\n    \n    for(int\
    \ i = word.length() - 1; i >= 0; i--)\n    {\n        if(isVowel(word[i]))\n \
    \       {\n            vowels[word[i]]--;\n        }\n    }\n    \n    string\
    \ vowel = \"\";\n    \n    for(auto it = vowels.begin(); it != vowels.end(); ++it)\n\
    \    {\n        if(it->second == 0)\n        {\n            vowel = it->first;\n\
    \            break;\n        }\n    }\n    \n    return vowel;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2so9v8g5.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmp2so9v8g5.d(48): Error: use `.` for member lookup, not `->`\n/tmp/tmp2so9v8g5.d(50):
    Error: use `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2so9v8g5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n\
    \    {\n        if(it->second > 1)\n        {\n            string vowel = it->first;\n\
    \            int count = it->second;\n            int index = word.length() -\
    \ 1;\n            while(index >= 0 && isVowel(word[index]))\n            {\n \
    \               if(word[index] == vowel)\n                {\n                \
    \    count--;\n                }\n                index--;\n            }\n  \
    \          if(count > 0)\n            {\n                return vowel;\n     \
    \       }\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpch85y61h.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpch85y61h.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmpch85y61h.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpch85y61h.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpch85y61h.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpch85y61h.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmpch85y61h.d(40): Error: use `.` for member
    lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpch85y61h.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isVowel(word[i]))\n        {\n \
    \           vowels[word[i]]++;\n        }\n    }\n    map<string,int>::iterator\
    \ it;\n    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second<=2)\n\
    \        {\n            return it->first;\n        }\n    }\n    return \"\";\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp_uboop0.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpp_uboop0.d(33): Error: found `>` when expecting `.` following int\n/tmp/tmpp_uboop0.d(33):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmpp_uboop0.d(33):
    Error: found `:` when expecting `;` following statement\n/tmp/tmpp_uboop0.d(36):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpp_uboop0.d(38): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp_uboop0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ < end) {\n        int mid = start + (end - start) / 2;\n        \n        if\
    \ (word.startsWith(vowels, mid)) {\n            end = mid - 1;\n        } else\
    \ if (word.endsWith(vowels, mid)) {\n            start = mid + 1;\n        } else\
    \ {\n            start = mid + 1;\n            end = mid - 1;\n        }\n   \
    \ }\n    \n    return word.substring(start, end + 1);\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp50ffdiz2.d(28): Error: no property `length` for type `string`\n/tmp/tmp50ffdiz2.d(33):
    Error: no property `startsWith` for type `string`\n/tmp/tmp50ffdiz2.d(35): Error:
    no property `endsWith` for type `string`\n/tmp/tmp50ffdiz2.d(43): Error: no property
    `substring` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp50ffdiz2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == vowels[word.find_last_of(\"aeiouAEIOU\") - 1])\n        {\n            return\
    \ word[i];\n        }\n    }\n    \n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThe question was about C++, not C. Also, the code you posted is\
    \ incorrect. `find_last_of` returns the index of the last occurrence of the specified\
    \ character in the string. `word[word.find_last_of(\"aeiouAEIOU\") - 1]` will\
    \ return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\")\
    \ - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiouAEIOU\"\
    ) - 1]` will return the character at that index. `word[word.find_last_of(\"aeiou\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8sefz53c.d(37): Error: declaration expected, not `<`\n/tmp/tmp8sefz53c.d(40):
    Error: unterminated string constant starting at /tmp/tmp8sefz53c.d(40)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8sefz53c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9l9xnw3e.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9l9xnw3e.d(97): Error: unterminated string constant starting at /tmp/tmp9l9xnw3e.d(114)\n/tmp/tmp9l9xnw3e.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmp9l9xnw3e.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(106): Error: found `ali` when expecting `,`\n/tmp/tmp9l9xnw3e.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(107): Error: found `bad` when expecting `,`\n/tmp/tmp9l9xnw3e.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `o` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(110): Error: found `ba` when expecting `,`\n/tmp/tmp9l9xnw3e.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l9xnw3e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u')\n        {\n            int j=i+1;\n            while(j<word.length()\
    \ && word[j]!='a' && word[j]!='e' && word[j]!='i' && word[j]!='o' && word[j]!='u')\n\
    \            {\n                j++;\n            }\n            if(j==word.length())\n\
    \            {\n                return word[i];\n            }\n        }\n  \
    \  }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpofbbijz2.d(26): Error: no property `length` for type `string`\n/tmp/tmpofbbijz2.d(31):
    Error: no property `length` for type `string`\n/tmp/tmpofbbijz2.d(35): Error:
    no property `length` for type `string`\n/tmp/tmpofbbijz2.d(37): Error: cannot
    implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)` to
    `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpofbbijz2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    for(int i=word.length()-1;i>=0;i--)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            int index = vowels.find(word[i]);\n\
    \            int start = index - 1;\n            int end = index + 1;\n      \
    \      \n            if(start < 0)\n                start = 0;\n            if(end\
    \ > vowels.length())\n                end = vowels.length();\n            \n \
    \           string result = \"\";\n            for(int j=start;j<end;j++)\n  \
    \          {\n                result += vowels[j];\n            }\n          \
    \  return result;\n        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3e1e9c62.d(29): Error: found `:` when expecting `)`\n/tmp/tmp3e1e9c62.d(29):
    Error: found `:` instead of statement\n/tmp/tmp3e1e9c62.d(48): Error: declaration
    expected, not `return`\n/tmp/tmp3e1e9c62.d(49): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3e1e9c62.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_reverse = \"AEIOUaeiou\";\n    string vowels_reversed = \"\"\
    ;\n    \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(vowels.find(word[i])\
    \ != string::npos)\n        {\n            vowels_reversed += word[i];\n     \
    \   }\n    }\n    \n    for(int i = 0; i < word.length(); i++)\n    {\n      \
    \  if(vowels_reverse.find(word[i]) != string::npos)\n        {\n            vowels_reversed\
    \ += word[i];\n        }\n    }\n    \n    return vowels_reversed;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpilc54z05.d(31): Error: found `:` when expecting `)`\n/tmp/tmpilc54z05.d(31):
    Error: found `:` instead of statement\n/tmp/tmpilc54z05.d(37): Error: declaration
    expected, not `for`\n/tmp/tmpilc54z05.d(37): Error: no identifier for declarator
    `i`\n/tmp/tmpilc54z05.d(37): Error: declaration expected, not `<`\n/tmp/tmpilc54z05.d(37):
    Error: no identifier for declarator `i`\n/tmp/tmpilc54z05.d(37): Error: declaration
    expected, not `++`\n/tmp/tmpilc54z05.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilc54z05.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    map<string, int> vowel_map;\n\
    \    map<string, int> consonant_map;\n    map<string, int> consonant_map_reverse;\n\
    \    \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(isalpha(word[i]))\n\
    \        {\n            string vowel = word[i];\n            vowel_map[vowel]\
    \ = vowel_map[vowel] + 1;\n        }\n    }\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(isalpha(word[i]))\n        {\n            string consonant\
    \ = word[i];\n            consonant_map[consonant] = consonant_map[consonant]\
    \ + 1;\n        }\n    }\n    \n    for(int i = 0; i < word.length(); i++)\n \
    \   {\n        if(isalpha(word[i]))\n        {\n            string consonant =\
    \ word[i];\n            consonant_map_reverse[consonant] = consonant_map_reverse[consonant]\
    \ + 1;\n        }\n    }\n    \n    for(int i = 0; i < word.length(); i++)\n \
    \   {\n        if(isalpha(word[i]))\n        {\n            string consonant =\
    \ word[i];\n            int consonant_count = consonant_map[consonant];\n    \
    \        int consonant_count_reverse = consonant_map_reverse[consonant];\n   \
    \         int vowel_count = vowel_map[consonant];\n            int vowel_count_reverse\
    \ = vowel_map_reverse[consonant];\n            \n            if(consonant_count\
    \ > vowel_count && consonant_count_reverse > vowel_count_reverse)\n          \
    \  {\n                return consonant;\n            }\n        }\n    }\n   \
    \ \n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk8kjc_nv.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk8kjc_nv.d(27): Error: found `>` when expecting `.` following int\n/tmp/tmpk8kjc_nv.d(28):
    Error: found `>` when expecting `.` following int\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpk8kjc_nv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    \n    map<string, int> consonants;\n    consonants[\"a\"] = 1;\n   \
    \ consonants[\"b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] =\
    \ 1;\n    consonants[\"e\"] = 1;\n    consonants[\"f\"] = 1;\n    consonants[\"\
    g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"i\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"o\"] = 1;\n    consonants[\"\
    p\"] = 1;\n    consonants[\"q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"\
    s\"] = 1;\n    consonants[\"t\"] = 1;\n    consonants[\"u\"] = 1;\n    consonants[\"\
    v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"x\"] = 1;\n    consonants[\"\
    y\"] = 1;\n    consonants[\"z\"] = 1;\n    consonants[\"A\"] = 1;\n    consonants[\"\
    B\"] = 1;\n    consonants[\"C\"] = 1;\n    consonants[\"D\"] = 1;\n    consonants[\"\
    E\"] = 1;\n    consonants[\"F\"] = 1;\n    consonants[\"G\"] = 1;\n    consonants[\"\
    H\"] = 1;\n    consonants[\"I\"] = 1;\n    consonants[\"J\"] = 1;\n    consonants[\"\
    K\"] = 1;\n    consonants[\"L\"] = 1;\n    consonants[\"M\"] = 1;\n    consonants[\"\
    N\"] = 1;\n    con\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsrix4wj_.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsrix4wj_.d(51): Error: found `>` when expecting `.` following int\n/tmp/tmpsrix4wj_.d(93):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpsrix4wj_.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsrix4wj_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    map<string, int> vowels;\n   \
    \ \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n\
    \        {\n            vowels[word[i]] += 1;\n        }\n    }\n    \n    string\
    \ result = \"\";\n    \n    for(auto it = vowels.rbegin(); it != vowels.rend();\
    \ ++it)\n    {\n        if(it->second > 0)\n        {\n            int vowelCount\
    \ = it->second;\n            int vowelIndex = it->first;\n            \n     \
    \       int consonantCount = word.length() - vowelIndex - 1;\n            int\
    \ consonantIndex = word.length() - vowelIndex - 2;\n            \n           \
    \ int minDistance = INT_MAX;\n            \n            for(int i = consonantIndex\
    \ - 1; i >= 0; i--)\n            {\n                if(isVowel(word[i]))\n   \
    \             {\n                    int distance = abs(vowelIndex - i);\n   \
    \                 if(distance < minDistance)\n                    {\n        \
    \                minDistance = distance;\n                        result = vowelIndex;\n\
    \                    }\n                }\n            }\n            \n     \
    \       for(int i = consonantIndex + 1; i < word.length(); i++)\n            {\n\
    \                if(isVowel(word[i]))\n                {\n                   \
    \ int distance = abs(vowelIndex - i);\n                    if(distance < minDistance)\n\
    \                    {\n                        minDistance = distance;\n    \
    \                    result = vowelIndex;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt_xemoxm.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmpt_xemoxm.d(40): Error: use `.` for member lookup, not `->`\n/tmp/tmpt_xemoxm.d(42):
    Error: use `.` for member lookup, not `->`\n/tmp/tmpt_xemoxm.d(43): Error: use
    `.` for member lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt_xemoxm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word.at(i)))\n        {\n\
    \            int j = word.find_last_of(\"aeiou\");\n            if(j == -1)\n\
    \            {\n                return word.at(0);\n            }\n          \
    \  else\n            {\n                return word.at(j);\n            }\n  \
    \      }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work if you have a word like \"abacus\" because find_last_of\
    \ will return -1 and word.at(0) will throw an exception.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I've edited my answer. Thanks.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\n#include <iostream>\n#include <string>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqt7fq2jg.d(43): Error: declaration expected, not `<`\n/tmp/tmpqt7fq2jg.d(46):
    Error: unterminated character constant\n/tmp/tmpqt7fq2jg.d(49): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqt7fq2jg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    \n    map<string, int> consonants;\n    consonants[\"b\"] = 1;\n   \
    \ consonants[\"c\"] = 1;\n    consonants[\"d\"] = 1;\n    consonants[\"f\"] =\
    \ 1;\n    consonants[\"g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"p\"] = 1;\n    consonants[\"\
    q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"s\"] = 1;\n    consonants[\"\
    t\"] = 1;\n    consonants[\"v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"\
    x\"] = 1;\n    consonants[\"y\"] = 1;\n    consonants[\"z\"] = 1;\n    consonants[\"\
    B\"] = 1;\n    consonants[\"C\"] = 1;\n    consonants[\"D\"] = 1;\n    consonants[\"\
    F\"] = 1;\n    consonants[\"G\"] = 1;\n    consonants[\"H\"] = 1;\n    consonants[\"\
    J\"] = 1;\n    consonants[\"K\"] = 1;\n    consonants[\"L\"] = 1;\n    consonants[\"\
    M\"] = 1;\n    consonants[\"N\"] = 1;\n    consonants[\"P\"] = 1;\n    consonants[\"\
    Q\"] = 1;\n    consonants[\"R\"] = 1;\n    consonants[\"S\"] = 1;\n    consonants[\"\
    T\"] = 1;\n    consonants[\"V\"] = 1;\n    consonants[\"W\"] = 1;\n    consonants[\"\
    X\"] = 1;\n    con\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpla5hy1r5.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpla5hy1r5.d(51): Error: found `>` when expecting `.` following int\n/tmp/tmpla5hy1r5.d(93):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpla5hy1r5.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla5hy1r5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    map<string,\
    \ int> vowels_count;\n    map<string, int> vowels_count_reverse;\n    map<string,\
    \ int> vowels_count_reverse_count;\n    map<string, int> vowels_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count;\n    map<string,\
    \ int> vowels_count_reverse_count_reverse_count_reverse;\n    map<string, int>\
    \ vowels_count_reverse_count_reverse_count_reverse_count;\n    map<string, int>\
    \ vowels_count_reverse_count_reverse_count_reverse_count_reverse;\n    map<string,\
    \ int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count_reverse;\n\
    \    map<string, int> vowels_count_reverse_count_\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf3t11207.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpf3t11207.d(26): Error: found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(27):
    Error: found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(28): Error:
    found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(29): Error: found
    `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(30): Error: found `>`
    when expecting `.` following int\n/tmp/tmpf3t11207.d(31): Error: found `>` when
    expecting `.` following int\n/tmp/tmpf3t11207.d(32): Error: found `>` when expecting
    `.` following int\n/tmp/tmpf3t11207.d(33): Error: found `>` when expecting `.`
    following int\n/tmp/tmpf3t11207.d(34): Error: found `>` when expecting `.` following
    int\n/tmp/tmpf3t11207.d(35): Error: found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(36):
    Error: found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(37): Error:
    found `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(38): Error: found
    `>` when expecting `.` following int\n/tmp/tmpf3t11207.d(39): Error: found `>`
    when expecting `.` following int\n/tmp/tmpf3t11207.d(40): Error: found `>` when
    expecting `.` following int\n/tmp/tmpf3t11207.d(41): Error: found `>` when expecting
    `.` following int\n/tmp/tmpf3t11207.d(42): Error: found `>` when expecting `.`
    following int\n/tmp/tmpf3t11207.d(43): Error: found `>` when expecting `.` following
    int\n/tmp/tmpf3t11207.d(44): Error: found `>` when expecting `.` following int\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3t11207.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word[i]))\n        {\n  \
    \          int j = i+1;\n            while(j < len && isVowel(word[j]))\n    \
    \        {\n                j++;\n            }\n            if(j-i == 1)\n  \
    \          {\n                return word[i];\n            }\n        }\n    }\n\
    \    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu_tthd03.d(25): Error: no property `length` for type `string`\n/tmp/tmpu_tthd03.d(28):
    Error: undefined identifier `isVowel`\n/tmp/tmpu_tthd03.d(31): Error: undefined
    identifier `isVowel`\n/tmp/tmpu_tthd03.d(37): Error: cannot implicitly convert
    expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_tthd03.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    \n\
    \    int len = word.length();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int vowel_found = 0;\n    \n    while(i < len) {\n        while(j < len)\
    \ {\n            if(consonants.find(word[j]) != string::npos) {\n            \
    \    j++;\n                continue;\n            }\n            \n          \
    \  while(k < (len - i) && vowels.find(word[i + k]) != string::npos) {\n      \
    \          k++;\n            }\n            \n            if(k == (len - i)) {\n\
    \                if(word[i + k] == vowels.at(j)) {\n                    vowel_found\
    \ = 1;\n                    break;\n                }\n            }\n       \
    \     \n            j++;\n            k = 0;\n        }\n        \n        if(vowel_found)\
    \ {\n            i += k - 1;\n            vowel_found = 0;\n        }\n      \
    \  else {\n            i++;\n        }\n    }\n    \n    return word[len - i -\
    \ 1];\n}\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nThis doesn't work for \"\
    ab\" because \"ab\" has two vowels right next to each other (a and b).\n<|/ c\
    \ |>\n<| c |>\nYes, I missed that case. Thanks for pointing out. I've updated\
    \ my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpolkljmlh.d(36): Error: found `:` when expecting `)`\n/tmp/tmpolkljmlh.d(36):
    Error: found `:` instead of statement\n/tmp/tmpolkljmlh.d(41): Error: found `:`
    when expecting `)`\n/tmp/tmpolkljmlh.d(41): Error: found `:` instead of statement\n/tmp/tmpolkljmlh.d(56):
    Error: declaration expected, not `if`\n/tmp/tmpolkljmlh.d(58): Error: no identifier
    for declarator `vowel_found`\n/tmp/tmpolkljmlh.d(58): Error: declaration expected,
    not `=`\n/tmp/tmpolkljmlh.d(59): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpolkljmlh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int i\
    \ = 0;\n    int j = 0;\n    int k = 0;\n    string vowel = \"\";\n    \n    while(i\
    \ < len && j < len) \n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            vowel +=\
    \ word[i];\n            i++;\n            j++;\n        }\n        else if(word[j]\
    \ == 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u')\n\
    \        {\n            vowel += word[j];\n            j++;\n        }\n     \
    \   else\n        {\n            i++;\n            j++;\n        }\n    }\n  \
    \  \n    return vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjhs0w4dk.d(25): Error: no property `length` for type `string`\n/tmp/tmpjhs0w4dk.d(35):
    Error: slice `vowel` is not mutable\n/tmp/tmpjhs0w4dk.d(41): Error: slice `vowel`
    is not mutable\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjhs0w4dk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    string vowels_consonants\
    \ = vowels + consonants;\n    string vowels_consonants_reverse = consonants +\
    \ vowels;\n    string vowels_consonants_reverse2 = consonants + vowels + consonants;\n\
    \    string vowels_consonants_reverse3 = consonants + vowels + consonants + consonants;\n\
    \    string vowels_consonants_reverse4 = consonants + vowels + consonants + consonants\
    \ + consonants;\n    string vowels_consonants_reverse5 = consonants + vowels +\
    \ consonants + consonants + consonants + consonants;\n    string vowels_consonants_reverse6\
    \ = consonants + vowels + consonants + consonants + consonants + consonants +\
    \ consonants;\n    string vowels_consonants_reverse7 = consonants + vowels + consonants\
    \ + consonants + consonants + consonants + consonants + consonants;\n    string\
    \ vowels_consonants_reverse8 = consonants + vowels + consonants + consonants +\
    \ consonants + consonants + consonants + consonants + consonants;\n    string\
    \ vowels_consonants_reverse9 = consonants + vowels + consonants + consonants +\
    \ consonants + consonants + consonants + consonants + consonants + consonants;\n\
    \    string vowels_consonants_reverse10 = consonants + vowels + consonants + consonants\
    \ + consonants + consonants + consonants + consonants + consonants + consonants\
    \ + consonants;\n    string vowels_consonants_reverse11 = consonants + vowels\
    \ + consonants + consonants + consonants + consonants + consonants + consonants\
    \ + consonants + consonants + consonants + consonants;\n    string vowels_consonants_reverse12\
    \ = consonants + vowels + consonants + consonants + consonants + consonants +\
    \ consonants + consonants + consonants + consonants + consonants + consonants\
    \ + consonants\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkgjbf75u.d(40): Error: semicolon expected, not `unittest`\n/tmp/tmpkgjbf75u.d(40):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpkgjbf75u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  map<string, int> vowel_map;\n    for(int i = 0; i < word.length(); i++)\n \
    \   {\n        if(vowels.find(word[i]) != string::npos)\n        {\n         \
    \   vowel_map[word[i]] = i;\n        }\n    }\n    string vowel_found = \"\";\n\
    \    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(vowel_map.find(word[i])\
    \ != vowel_map.end())\n        {\n            int index = vowel_map[word[i]];\n\
    \            int j = index + 1;\n            while(j < word.length() && vowels.find(word[j])\
    \ != string::npos)\n            {\n                j++;\n            }\n     \
    \       if(j - index == 1)\n            {\n                vowel_found = word[i];\n\
    \                break;\n            }\n        }\n    }\n    return vowel_found;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq78ojs1x.d(26): Error: found `>` when expecting `.` following
    int\n/tmp/tmpq78ojs1x.d(29): Error: found `:` when expecting `)`\n/tmp/tmpq78ojs1x.d(29):
    Error: found `:` instead of statement\n/tmp/tmpq78ojs1x.d(35): Error: declaration
    expected, not `for`\n/tmp/tmpq78ojs1x.d(35): Error: no identifier for declarator
    `i`\n/tmp/tmpq78ojs1x.d(35): Error: declaration expected, not `>=`\n/tmp/tmpq78ojs1x.d(35):
    Error: no identifier for declarator `i`\n/tmp/tmpq78ojs1x.d(35): Error: declaration
    expected, not `--`\n/tmp/tmpq78ojs1x.d(41): Error: declaration expected, not `while`\n/tmp/tmpq78ojs1x.d(44):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq78ojs1x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            int j = word.length()\
    \ - 1;\n            while(j > 0 && word[j] != 'a' && word[j] != 'e' && word[j]\
    \ != 'i' && word[j] != 'o' && word[j] != 'u')\n            {\n               \
    \ j--;\n            }\n            int k = j;\n            while(k >= 0 && word[k]\
    \ != 'a' && word[k] != 'e' && word[k] != 'i' && word[k] != 'o' && word[k] != 'u')\n\
    \            {\n                k--;\n            }\n            if(k > j)\n \
    \           {\n                return word[i];\n            }\n        }\n   \
    \ }\n    return \"\";\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    This solution does not work if the word is \"ab\". It returns \"a\" instead of\
    \ \"\".\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. :)\n\
    <|/ c |>\n<| a tags=string,c++,algorithm |>\nI wrote a solution in Python which\
    \ I believe is pretty efficient:\n<code>\ndef get_closest_vowel(word):\n    vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n    vowels_set = set(vowels)\n    vowels_set.add(word[0])\n\
    \    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n\
    \    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n\
    \    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n\
    \    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n\
    \    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n\
    \    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n\
    \    vowels_set.add(word[-1])\n    vowels_set.add(word[0])\n    vowels_set.add(word[-1])\n\
    \nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7chw_x5p.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp7chw_x5p.d(54): Error: declaration expected, not `<`\n/tmp/tmp7chw_x5p.d(95):
    Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(96): Error: declaration
    expected, not `assert`\n/tmp/tmp7chw_x5p.d(97): Error: declaration expected, not
    `assert`\n/tmp/tmp7chw_x5p.d(98): Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(99):
    Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(100): Error: declaration
    expected, not `assert`\n/tmp/tmp7chw_x5p.d(101): Error: declaration expected,
    not `assert`\n/tmp/tmp7chw_x5p.d(102): Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(103):
    Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(104): Error: declaration
    expected, not `assert`\n/tmp/tmp7chw_x5p.d(105): Error: declaration expected,
    not `assert`\n/tmp/tmp7chw_x5p.d(106): Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(107):
    Error: declaration expected, not `assert`\n/tmp/tmp7chw_x5p.d(108): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7chw_x5p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    int i = 0;\n    int j = 0;\n    \n    while(i\
    \ < len && j < len) \n    {\n        if(word[i] == vowels[j]) \n        {\n  \
    \          i++;\n            j++;\n        }\n        else if(word[i] == vowels[j-1])\
    \ \n        {\n            i++;\n        }\n        else if(word[i] == vowels[j+1])\
    \ \n        {\n            j++;\n        }\n        else \n        {\n       \
    \     return \"\";\n        }\n    }\n    \n    if(j == len) return \"\";\n  \
    \  else return word[i];\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptji_937w.d(27): Error: no property `length` for type `string`\n/tmp/tmptji_937w.d(53):
    Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptji_937w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    for(int\
    \ i = len-1; i >= 0; i--)\n    {\n        if(isVowel(word[i]))\n        {\n  \
    \          int j = i+1;\n            while(j < len && isVowel(word[j]))\n    \
    \        {\n                j++;\n            }\n            if(j == len)\n  \
    \          {\n                return word[i];\n            }\n            else\n\
    \            {\n                int k = j-1;\n                while(k >= 0 &&\
    \ isVowel(word[k]))\n                {\n                    k--;\n           \
    \     }\n                if(k == -1)\n                {\n                    return\
    \ word[i];\n                }\n                else\n                {\n     \
    \               int m = k+1;\n                    while(m < len && isVowel(word[m]))\n\
    \                    {\n                        m++;\n                    }\n\
    \                    if(m == len)\n                    {\n                   \
    \     return word[i];\n                    }\n                    else\n     \
    \               {\n                        int n = m-1;\n                    \
    \    while(n>0 && isVowel(word[n]))\n                        {\n             \
    \               n--;\n                        }\n                        if(n\
    \ == -1)\n                        {\n                            return word[i];\n\
    \                        }\n                        else\n                   \
    \     {\n                            int o = n+1;\n                          \
    \  while(o<len && isVowel(word[o]))\n                            {\n         \
    \                       o++;\n                            }\n                \
    \            if(o == len)\n                            {\n                   \
    \             return word[i];\n                            }\n               \
    \             else\n                            {\n                          \
    \      int p = o-1;\n                                while(p>0 && isVowel(word[p]))\n\
    \                                {\n                                    p--;\n\
    \                                }\n                                if(p == -1)\n\
    \                                {\n                                    return\
    \ word[i];\n                                }\n                              \
    \  else\n                                {\n                                 \
    \   int q = p+1;\n                                    while(q<len && isVowel(word[q]))\n\
    \                                    {\n                                     \
    \   q++;\n                                    }\n                            \
    \        if(q == len)\n                                    {\n               \
    \                         return word[i];\n                                  \
    \  }\n                                    else\n                             \
    \       {\n                                        int r = q-1;\n            \
    \                            while(r>0 && isVowel(word[r]))\n                \
    \                        {\n                                            r--;\n\
    \                                        }\n                                 \
    \       if(r == -1)\n                                        {\n             \
    \                               return word[i];\n                            \
    \            }\n                                        else\n               \
    \                         {\n                                            int s\
    \ = r+1;\n                                            while(s>0 && isVowel(word[s]))\n\
    \                                            {\n                             \
    \                   s--;\n                                            }\n    \
    \                                        if(s == -1)\n                       \
    \                     {\n                                                return\
    \ word[i];\n                                            }\n                  \
    \                          else\n                                            {\n\
    \                                                int t = s-1;\n              \
    \                                  while(t>0 && isVowel(word[t]))\n          \
    \                                      {\n                                   \
    \                 t--;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgno7np82.d(133): Error: found `unittest` instead of statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpgno7np82.d(151):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgno7np82.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int len = word.length();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    string result = \"\";\n    \n    while(i < len && j < len) {\n        if(word[i]\
    \ == vowels[j]) {\n            i++;\n            j++;\n            k++;\n    \
    \    }\n        else if(word[i] == vowels[j-1]) {\n            i++;\n        \
    \    j++;\n        }\n        else if(word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[j-1]\
    \ && word[i] == vowels[j+1]) {\n            i++;\n            j++;\n         \
    \   k++;\n        }\n        else if(word[i] == vowels[j-1] && word[i] == vowels[j+1])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[j-1] && word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[j-1]\
    \ && word[i] == vowels[j+1]) {\n            i++;\n            j++;\n         \
    \   k++;\n        }\n        else if(word[i] == vowels[j-1] && word[i] == vowels[j+1])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[j-1] && word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[j-1]\
    \ && word[i] == vowels[j+1]) {\n            i++;\n            j++;\n         \
    \   k++;\n        }\n        else if(word[i] == vowels[j-1] && word[i] == vowels[j+1])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[j-1] && word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[j-1]\
    \ && word[i] == vowels[j+1]) {\n            i++;\n            j++;\n         \
    \   k++;\n        }\n        else if(word[i] == vowels[j-1] && word[i] == vowels[j+1])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[j-1] && word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word[i] == vowels[j-1]\
    \ && word[i] == vowels[j+1]) {\n            i++;\n            j++;\n         \
    \   k++;\n        }\n        else if(word[i] == vowels[j-1] && word[i] == vowels[j+1])\
    \ {\n            i++;\n            j++;\n            k++;\n        }\n       \
    \ else if(word[i] == vowels[j-1] && word[i] == vowels[j+1]) {\n            i++;\n\
    \            j++;\n            k++;\n        }\n        else if(word\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp7r6zhsc.d(123): Error: found `unittest` when expecting `)`\n/tmp/tmpp7r6zhsc.d(141):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpp7r6zhsc.d(141):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7r6zhsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string,int> vowels;\n    for(int\
    \ i=0;i<word.length();i++)\n    {\n        if(isalpha(word[i]))\n        {\n \
    \           string vowel = word[i];\n            for(int j=i+1;j<word.length();j++)\n\
    \            {\n                if(isalpha(word[j]))\n                {\n    \
    \                string consonant = word[j];\n                    if(vowels.find(consonant)\
    \ == vowels.end())\n                    {\n                        vowels[consonant]\
    \ = 1;\n                    }\n                    else\n                    {\n\
    \                        vowels[consonant]++;\n                    }\n       \
    \         }\n            }\n        }\n    }\n    map<string,int>::iterator it;\n\
    \    for(it=vowels.begin();it!=vowels.end();it++)\n    {\n        if(it->second\
    \ == 2)\n        {\n            return it->first;\n        }\n    }\n    return\
    \ \"\";\n}\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThis code doesn't work\
    \ if the word is \"ab\". It returns \"a\" instead of \"\".\n<|/ c |>\n<| c |>\n\
    It returns an empty string if the word is \"ab\"\n<|/ c |>\n<| c |>\nIt returns\
    \ an empty string if the word is \"ab\"\n<|/ c |>\n<| c |>\nIt returns an empty\
    \ string if the word is \"ab\"\n<|/ c |>\n<| c |>\nIt returns an empty string\
    \ if the word is \"ab\"\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp62gsezov.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp62gsezov.d(48): Error: found `>` when expecting `.` following int\n/tmp/tmp62gsezov.d(48):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp62gsezov.d(48):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp62gsezov.d(51):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp62gsezov.d(53): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp62gsezov.d(58): Error: declaration expected,
    not `<`\n/tmp/tmp62gsezov.d(61): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp62gsezov.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ < end)\n    {\n        if(word[start] == vowels[word[start].toInt()] && word[end]\
    \ == vowels[word[end].toInt()])\n        {\n            return word[start];\n\
    \        }\n        \n        start++;\n        end--;\n    }\n    \n    return\
    \ \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzle_mhal.d(28): Error: no property `length` for type `string`\n/tmp/tmpzle_mhal.d(32):
    Error: no property `toInt` for type `immutable(char)`\n/tmp/tmpzle_mhal.d(32):
    Error: no property `toInt` for type `immutable(char)`\n/tmp/tmpzle_mhal.d(34):
    Error: cannot implicitly convert expression `word[cast(ulong)start]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzle_mhal.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            vowels[word[i]]++;\n        }\n    }\n    \n    map<string,\
    \ int>::iterator it;\n    for(it = vowels.begin(); it != vowels.end(); it++)\n\
    \    {\n        if(it->second > 1)\n        {\n            string vowel = it->first;\n\
    \            int count = it->second;\n            int index = word.length() -\
    \ 1;\n            while(index >= 0)\n            {\n                if(isVowel(word[index]))\n\
    \                {\n                    if(word[index] == vowel)\n           \
    \         {\n                        count--;\n                        if(count\
    \ == 0)\n                        {\n                            return vowel;\n\
    \                        }\n                    }\n                    else\n\
    \                    {\n                        count++;\n                   \
    \ }\n                }\n                index--;\n            }\n        }\n \
    \   }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps0vgv3rx.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmps0vgv3rx.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmps0vgv3rx.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmps0vgv3rx.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmps0vgv3rx.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmps0vgv3rx.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmps0vgv3rx.d(40): Error: use `.` for member
    lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0vgv3rx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n      \
    \  {\n            string vowel = word[i];\n            vowels[vowel] = vowels[vowel]\
    \ + 1;\n        }\n    }\n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second > 1)\n        {\n  \
    \          string vowel = it->first;\n            int count = it->second;\n  \
    \          int index = word.length() - 1;\n            while(index >= 0)\n   \
    \         {\n                if(isVowel(word[index]))\n                {\n   \
    \                 string vowel2 = word[index];\n                    if(vowel ==\
    \ vowel2)\n                    {\n                        if(count > 1)\n    \
    \                    {\n                            string vowel3 = word[index];\n\
    \                            if(vowel3 != vowel)\n                           \
    \ {\n                                return vowel3;\n                        \
    \    }\n                        }\n                        else\n            \
    \            {\n                            return vowel;\n                  \
    \      }\n                    }\n                    else\n                  \
    \  {\n                        if(count > 1)\n                        {\n     \
    \                       string vowel3 = word[index];\n                       \
    \     if(vowel3 == vowel)\n                            {\n                   \
    \             return vowel3;\n                            }\n                \
    \        }\n                        else\n                        {\n        \
    \                    return vowel;\n                        }\n              \
    \      }\n                }\n                index--;\n            }\n       \
    \ }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphf2_c5ys.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmphf2_c5ys.d(34): Error: found `>` when expecting `.` following int\n/tmp/tmphf2_c5ys.d(34):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmphf2_c5ys.d(34):
    Error: found `:` when expecting `;` following statement\n/tmp/tmphf2_c5ys.d(37):
    Error: use `.` for member lookup, not `->`\n/tmp/tmphf2_c5ys.d(39): Error: use
    `.` for member lookup, not `->`\n/tmp/tmphf2_c5ys.d(40): Error: use `.` for member
    lookup, not `->`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphf2_c5ys.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n  \
    \  vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"\
    e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n  \
    \  vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"\
    i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n  \
    \  vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"\
    o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n  \
    \  vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"\
    u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n  \
    \  vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"\
    y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n  \
    \  vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"\
    a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n  \
    \  vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"\
    e\"]=1;\n    vowels[\"i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n  \
    \  vowels[\"y\"]=1;\n    vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"\
    i\"]=1;\n    vowels[\"o\"]=1;\n    vowels[\"u\"]=1;\n    vowels[\"y\"]=1;\n  \
    \  vowels[\"a\"]=1;\n    vowels[\"e\"]=1;\n    vowels[\"i\"]\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp92757y_7.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp92757y_7.d(89): Error: found `unittest` when expecting `;` following
    statement\n/tmp/tmp92757y_7.d(107): Error: found `End of File` when expecting
    `}` following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92757y_7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int len = word.length();\n    \n    for(int i = len-1; i >= 0; i--)\n\
    \    {\n        if(word.endsWith(vowels[i]))\n        {\n            int index\
    \ = word.lastIndexOf(vowels[i]);\n            \n            if(index != -1 &&\
    \ index != len-1)\n            {\n                return word.substring(index+1);\n\
    \            }\n        }\n    }\n    \n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp492ucwip.d(27): Error: no property `length` for type `string`\n/tmp/tmp492ucwip.d(31):
    Error: no property `endsWith` for type `string`\n/tmp/tmp492ucwip.d(33): Error:
    no property `lastIndexOf` for type `string`\n/tmp/tmp492ucwip.d(37): Error: no
    property `substring` for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp492ucwip.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9l9xnw3e.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9l9xnw3e.d(97): Error: unterminated string constant starting at /tmp/tmp9l9xnw3e.d(114)\n/tmp/tmp9l9xnw3e.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmp9l9xnw3e.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(106): Error: found `ali` when expecting `,`\n/tmp/tmp9l9xnw3e.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(107): Error: found `bad` when expecting `,`\n/tmp/tmp9l9xnw3e.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `o` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(110): Error: found `ba` when expecting `,`\n/tmp/tmp9l9xnw3e.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l9xnw3e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = 0;\n    \n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == vowels[start])\n        {\n            start\
    \ = i;\n        }\n        else if(word[i] == vowels[end])\n        {\n      \
    \      end = i;\n        }\n    }\n    \n    if(start > end)\n    {\n        return\
    \ \"\";\n    }\n    \n    int diff = end - start;\n    \n    if(diff < 0)\n  \
    \  {\n        diff += vowels.length();\n    }\n    \n    string result = \"\"\
    ;\n    \n    for(int i = 0; i < diff; i++)\n    {\n        result += vowels[start\
    \ + i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp28vt7j3i.d(30): Error: no property `length` for type `string`\n/tmp/tmp28vt7j3i.d(51):
    Error: no property `length` for type `string`\n/tmp/tmp28vt7j3i.d(58): Error:
    slice `result` is not mutable\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28vt7j3i.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string vowels_right = vowels.rbegin();\n    string vowels_left = vowels.rend();\n\
    \    \n    for(int i = 0; i < word.length(); i++)\n    {\n        if(word[i] ==\
    \ vowels_right[i])\n        {\n            int index = word.length() - 1 - i;\n\
    \            int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - 1 - i;\n \
    \           int index = word.length() - 1 - i;\n            int index = word.length()\
    \ - 1 - i;\n            int index = word.length() - 1 - i;\n            int index\
    \ = word.length() - 1 - i;\n            int index = word.length() - \nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp66m5l5us.d(84): Error: expression expected, not `unittest`\n/tmp/tmp66m5l5us.d(85):
    Error: semicolon expected, not `{`\n/tmp/tmp66m5l5us.d(102): Error: found `End
    of File` when expecting `}` following compound statement\n/tmp/tmp66m5l5us.d(102):
    Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp66m5l5us.d(102):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66m5l5us.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    int len = word.length();\n    int vowel_count\
    \ = 0;\n    for(int i = len-1; i>=0; i--)\n    {\n        if(isVowel(word[i]))\n\
    \        {\n            vowel_count++;\n        }\n    }\n    if(vowel_count ==\
    \ 0)\n    {\n        return \"\";\n    }\n    int consonant_count = len - vowel_count;\n\
    \    int consonant_index = len - 1;\n    int vowel_index = len - 1;\n    while(consonant_index\
    \ >= 0)\n    {\n        if(isVowel(word[consonant_index]))\n        {\n      \
    \      vowel_index = consonant_index;\n        }\n        consonant_index--;\n\
    \    }\n    while(vowel_index >= 0)\n    {\n        if(isVowel(word[vowel_index]))\n\
    \        {\n            consonant_index = vowel_index;\n        }\n        vowel_index--;\n\
    \    }\n    if(consonant_index == -1)\n    {\n        return \"\";\n    }\n  \
    \  if(vowel_index == -1)\n    {\n        return \"\";\n    }\n    string vowel\
    \ = word[vowel_index];\n    string consonant = word[consonant_index];\n    if(vowel\
    \ == consonant)\n    {\n        return vowel;\n    }\n    if(vowel < consonant)\n\
    \    {\n        return word[vowel_index];\n    }\n    return word[consonant_index];\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\nusing namespace std;\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbc5xq8cg.d(77): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbc5xq8cg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while (start\
    \ <= end) {\n        int mid = (start + end) / 2;\n        \n        if (word[mid]\
    \ == vowels[mid]) {\n            end = mid - 1;\n        } else {\n          \
    \  start = mid + 1;\n        }\n    }\n    \n    return word[end];\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm |>\n<| c |>\nThis doesn't work if you have a word\
    \ like \"aba\" where it returns \"a\" instead of \"b\".\n<|/ c |>\n<| c |>\nIt\
    \ works fine for me. Can you give an example where it doesn't work?\n<|/ c |>\n\
    <| c |>\nIt doesn't work for \"aba\" because \"aba\" has two vowels next to each\
    \ other and your algorithm returns \"a\" instead of \"b\".\n<|/ c |>\n<| c |>\n\
    I see. Thanks for pointing that out. I fixed my code accordingly.\n<|/ c |>\n\
    <| a tags=string,c++,algorithm |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkaz889t3.d(42): Error: declaration expected, not `<`\n/tmp/tmpkaz889t3.d(45):
    Error: unterminated character constant\n/tmp/tmpkaz889t3.d(48): Error: unterminated
    character constant\n/tmp/tmpkaz889t3.d(51): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkaz889t3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ <= end) {\n        string vowel = word.substr(start, 1);\n        if(vowels.find(vowel)\
    \ != string::npos) {\n            return vowel;\n        }\n        \n       \
    \ start += 1;\n        end -= 1;\n    }\n    \n    return \"\";\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzoc0g7uk.d(32): Error: found `:` when expecting `)`\n/tmp/tmpzoc0g7uk.d(32):
    Error: found `:` instead of statement\n/tmp/tmpzoc0g7uk.d(40): Error: declaration
    expected, not `return`\n/tmp/tmpzoc0g7uk.d(41): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzoc0g7uk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u')\n        {\n            return word[i];\n        }\n    }\n\
    \    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqg8qbe4t.d(26): Error: no property `length` for type `string`\n/tmp/tmpqg8qbe4t.d(30):
    Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`
    to `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqg8qbe4t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  \n    int left = 0;\n    int right = word.length() - 1;\n    \n    while (left\
    \ < right) {\n        int mid = left + (right - left) / 2;\n        \n       \
    \ if (word.at(mid) == vowels.at(mid)) {\n            left = mid;\n        } else\
    \ {\n            right = mid;\n        }\n    }\n    \n    return word.at(left);\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsbfe4yb5.d(28): Error: no property `length` for type `string`\n/tmp/tmpsbfe4yb5.d(33):
    Error: no property `at` for type `string`\n/tmp/tmpsbfe4yb5.d(33): Error: no property
    `at` for type `string`\n/tmp/tmpsbfe4yb5.d(40): Error: no property `at` for type
    `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbfe4yb5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] =\
    \ 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n\
    \    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"\
    i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] =\
    \ 0;\n    vowels[\"a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n\
    \    vowels[\"o\"] = 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"\
    a\"] = 0;\n    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] =\
    \ 0;\n    vowels[\"u\"] = 0;\n    vowels[\"y\"] = 0;\n    vowels[\"a\"] = 0;\n\
    \    vowels[\"e\"] = 0;\n    vowels[\"i\"] = 0;\n    vowels[\"o\"] = 0;\n    vowels[\"\
    u\"] = 0;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9l9xnw3e.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9l9xnw3e.d(97): Error: unterminated string constant starting at /tmp/tmp9l9xnw3e.d(114)\n/tmp/tmp9l9xnw3e.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmp9l9xnw3e.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmp9l9xnw3e.d(103): Error: found `u` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmp9l9xnw3e.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(106): Error: found `ali` when expecting `,`\n/tmp/tmp9l9xnw3e.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(107): Error: found `bad` when expecting `,`\n/tmp/tmp9l9xnw3e.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmp9l9xnw3e.d(108): Error: found `o` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmp9l9xnw3e.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmp9l9xnw3e.d(110): Error: found `ba` when expecting `,`\n/tmp/tmp9l9xnw3e.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l9xnw3e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    \n    int minDistance = INT_MAX;\n    string minVowel = \"\";\n    \n\
    \    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ || word[i] == 'y' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U' || word[i] == 'Y')\n        {\n            int distance\
    \ = abs(word.find_last_of(\"aeiouyAEEIOUY\", i) - i);\n            if(distance\
    \ < minDistance)\n            {\n                minDistance = distance;\n   \
    \             minVowel = word[i];\n            }\n        }\n    }\n    \n   \
    \ return minVowel;\n}\n</code>\n<|/ a tags=c++,string |>\n<| a tags=c++,string\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpexj6_z94.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpexj6_z94.d(69): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpexj6_z94.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"\
    i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] =\
    \ 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n\
    \    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"a\"] = 1;\n\
    \    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"\
    u\"] = 1;\n    vowels[\"y\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk57yzw2t.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk57yzw2t.d(97): Error: unterminated string constant starting at /tmp/tmpk57yzw2t.d(114)\n/tmp/tmpk57yzw2t.d(102):
    Error: found `yogurt` when expecting `,`\n/tmp/tmpk57yzw2t.d(102): Error: found
    `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `full` when expecting
    `,`\n/tmp/tmpk57yzw2t.d(103): Error: found `u` when expecting `,`\n/tmp/tmpk57yzw2t.d(104):
    Error: found `easy` when expecting `,`\n/tmp/tmpk57yzw2t.d(104): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(105): Error: found `eAsy` when expecting `,`\n/tmp/tmpk57yzw2t.d(105):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(106): Error: found `ali` when expecting `,`\n/tmp/tmpk57yzw2t.d(106):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(107): Error: found `bad` when expecting `,`\n/tmp/tmpk57yzw2t.d(107):
    Error: found `a` when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `most`
    when expecting `,`\n/tmp/tmpk57yzw2t.d(108): Error: found `o` when expecting `,`\n/tmp/tmpk57yzw2t.d(109):
    Error: found `ab` when expecting `,`\n/tmp/tmpk57yzw2t.d(109): Error: Implicit
    string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\n/tmp/tmpk57yzw2t.d(110): Error: found `ba` when expecting `,`\n/tmp/tmpk57yzw2t.d(110):
    Error: Implicit string concatenation is deprecated, use ") == " ~ ");\\x0a    assert(candidate("
    instead\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk57yzw2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    int left = 0;\n    int right = word.length()\
    \ - 1;\n    \n    while (left < right) {\n        int mid = (left + right) / 2;\n\
    \        if (vowels[word[mid]] >= vowels[word[right - 1]]) {\n            right\
    \ = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n  \
    \  return word[left];\n}\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThis code\
    \ doesn't work. Try it on \"ab\".\n<|/ c |>\n<| c |>\nIt works on \"ab\" because\
    \ \"ab\" has only one vowel at the end. Try it on \"abba\".\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it on \"abba\".\n<|/ c |>\n<| c |>\nIt works on \"abba\"\
    \ because \"abba\" has two vowels at the end. Try it on \"ab\".\n<|/ c |>\n<|\
    \ c |>\nIt works on \"ab\" because \"ab\" has only one vowel at the end. Try it\
    \ on \"abba\".\n<|/ c |>\n<| a tags=c++,string |>\n<code>\n#include <iostream>\n\
    #include <string>\nusing namespace std;\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9l4nlk1u.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp9l4nlk1u.d(45): Error: declaration expected, not `<`\n/tmp/tmp9l4nlk1u.d(48):
    Error: unterminated character constant\n/tmp/tmp9l4nlk1u.d(54): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l4nlk1u.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n\
    \    vowels[\"E\"] = 1;\n    vowels[\"I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"\
    U\"] = 1;\n    vowels[\"Y\"] = 1;\n    vowels[\"a\"] = 1;\n    vowels[\"e\"] =\
    \ 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] = 1;\n    vowels[\"u\"] = 1;\n\
    \    vowels[\"y\"] = 1;\n    vowels[\"A\"] = 1;\n    vowels[\"E\"] = 1;\n    vowels[\"\
    I\"] = 1;\n    vowels[\"O\"] = 1;\n    vowels[\"U\"] = 1;\n    vowels[\"Y\"] =\
    \ 1;\n    \n    map<string, int> consonants;\n    consonants[\"a\"] = 1;\n   \
    \ consonants[\"b\"] = 1;\n    consonants[\"c\"] = 1;\n    consonants[\"d\"] =\
    \ 1;\n    consonants[\"e\"] = 1;\n    consonants[\"f\"] = 1;\n    consonants[\"\
    g\"] = 1;\n    consonants[\"h\"] = 1;\n    consonants[\"i\"] = 1;\n    consonants[\"\
    j\"] = 1;\n    consonants[\"k\"] = 1;\n    consonants[\"l\"] = 1;\n    consonants[\"\
    m\"] = 1;\n    consonants[\"n\"] = 1;\n    consonants[\"o\"] = 1;\n    consonants[\"\
    p\"] = 1;\n    consonants[\"q\"] = 1;\n    consonants[\"r\"] = 1;\n    consonants[\"\
    s\"] = 1;\n    consonants[\"t\"] = 1;\n    consonants[\"u\"] = 1;\n    consonants[\"\
    v\"] = 1;\n    consonants[\"w\"] = 1;\n    consonants[\"x\"] = 1;\n    consonants[\"\
    y\"] = 1;\n    consonants[\"z\"] = 1;\n    consonants[\"A\"] = 1;\n    consonants[\"\
    B\"] = 1;\n    consonants[\"C\"] = 1;\n    consonants[\"D\"] = 1;\n    consonants[\"\
    E\"] = 1;\n    consonants[\"F\"] = 1;\n    consonants[\"G\"] = 1;\n    consonants[\"\
    H\"] = 1;\n    consonants[\"I\"] = 1;\n    consonants[\"J\"] = 1;\n    consonants[\"\
    K\"] = 1;\n    consonants[\"L\"] = 1;\n    consonants[\"M\"] = 1;\n    consonants[\"\
    N\"] = 1;\n    con\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsrix4wj_.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmpsrix4wj_.d(51): Error: found `>` when expecting `.` following int\n/tmp/tmpsrix4wj_.d(93):
    Error: found `unittest` when expecting `;` following statement\n/tmp/tmpsrix4wj_.d(111):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsrix4wj_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    vowels[\"\
    a\"] = 1;\n    vowels[\"e\"] = 1;\n    vowels[\"i\"] = 1;\n    vowels[\"o\"] =\
    \ 1;\n    vowels[\"u\"] = 1;\n    \n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        if(isVowel(word[i]))\n        {\n            string vowel\
    \ = word[i];\n            int count = 0;\n            for(int j = word.length()\
    \ - 1; j >= 0; j--)\n            {\n                if(isVowel(word[j]))\n   \
    \             {\n                    string vowel2 = word[j];\n              \
    \      if(vowel == vowel2)\n                    {\n                        count++;\n\
    \                    }\n                }\n            }\n            if(count\
    \ > 0)\n            {\n                if(vowels[vowel] > count)\n           \
    \     {\n                    return vowel;\n                }\n            }\n\
    \        }\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8zzdo81l.d(25): Error: found `>` when expecting `.` following
    int\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zzdo81l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    map<string, int> vowels;\n    for(int\
    \ i = 0; i < word.length(); i++)\n    {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n \
    \           vowels[word[i]] = 1;\n        }\n    }\n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n            vowels[word[i]]\
    \ = 1;\n        }\n    }\n    map<string, int>::iterator it;\n    for(it = vowels.begin();\
    \ it != vowels.end(); it++)\n    {\n        if(it->second == 1)\n        {\n \
    \           return it->first;\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <map>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6ewodxi7.d(25): Error: found `>` when expecting `.` following
    int\n/tmp/tmp6ewodxi7.d(40): Error: found `>` when expecting `.` following int\n/tmp/tmp6ewodxi7.d(40):
    Error: found `:` when expecting identifier following `int`.\n/tmp/tmp6ewodxi7.d(40):
    Error: found `:` when expecting `;` following statement\n/tmp/tmp6ewodxi7.d(43):
    Error: use `.` for member lookup, not `->`\n/tmp/tmp6ewodxi7.d(45): Error: use
    `.` for member lookup, not `->`\n/tmp/tmp6ewodxi7.d(50): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ewodxi7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    \n    string vowels = \"AEIOUaeiou\"\
    ;\n    \n    int start = 0;\n    int end = word.length() - 1;\n    \n    while(start\
    \ <= end) {\n        \n        string vowel = word.substr(start, 1);\n       \
    \ \n        if(vowels.find(vowel) != string::npos) {\n            \n         \
    \   if(start == end) {\n                return vowel;\n            }\n       \
    \     \n            int next_vowel = word.substr(end + 1, 1);\n            \n\
    \            if(vowels.find(next_vowel) != string::npos) {\n                return\
    \ next_vowel;\n            }\n            \n            end--;\n        }\n  \
    \      \n        start++;\n    }\n    \n    return \"\";\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjg9buel7.d(35): Error: found `:` when expecting `)`\n/tmp/tmpjg9buel7.d(35):
    Error: found `:` instead of statement\n/tmp/tmpjg9buel7.d(43): Error: found `:`
    when expecting `)`\n/tmp/tmpjg9buel7.d(43): Error: found `:` instead of statement\n/tmp/tmpjg9buel7.d(47):
    Error: no identifier for declarator `end`\n/tmp/tmpjg9buel7.d(47): Error: declaration
    expected, not `--`\n/tmp/tmpjg9buel7.d(48): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjg9buel7.d", "-I/tmp"]\n'''
  stdout: b''
