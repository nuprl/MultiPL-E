language: d
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdr_lwng8.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdr_lwng8.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdr_lwng8.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdr_lwng8.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdr_lwng8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzkqyjw36.d(23): Error: no identifier for declarator `v`\n/tmp/tmpzkqyjw36.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpzkqyjw36.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzkqyjw36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj_2twjc7.d(23): Error: no identifier for declarator `v`\n/tmp/tmpj_2twjc7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpj_2twjc7.d(23): Error: expression
    expected, not `in`\n/tmp/tmpj_2twjc7.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj_2twjc7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6pnjavdn.d(23): Error: no identifier for declarator `v`\n/tmp/tmp6pnjavdn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp6pnjavdn.d(23): Error: expression
    expected, not `in`\n/tmp/tmp6pnjavdn.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pnjavdn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (k is string) \n  \
    \      {\n            if (k is string) \n            {\n                if (k\
    \ is string) \n                {\n                    if (k is string) \n    \
    \                {\n                        return true;\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return false;\n}\n\
    </code>\n<|/ a tags=d |>\n<| c |>\nThis doesn't work if you have a string key\
    \ that happens to be a number or boolean.\n<|/ c |>\n<| c |>\n: Yes, it does.\
    \ I tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and \nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj90i9ymp.d(23): Error: no identifier for declarator `v`\n/tmp/tmpj90i9ymp.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpj90i9ymp.d(23): Error: expression
    expected, not `in`\n/tmp/tmpj90i9ymp.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpj90i9ymp.d(41): Error: declaration expected, not `<`\n/tmp/tmpj90i9ymp.d(44):
    Error: unterminated character constant\n/tmp/tmpj90i9ymp.d(52): Error: declaration
    expected, not `assert`\n/tmp/tmpj90i9ymp.d(53): Error: declaration expected, not
    `assert`\n/tmp/tmpj90i9ymp.d(54): Error: declaration expected, not `assert`\n/tmp/tmpj90i9ymp.d(55):
    Error: declaration expected, not `assert`\n/tmp/tmpj90i9ymp.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmpj90i9ymp.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmpj90i9ymp.d(58): Error: declaration expected, not `assert`\n/tmp/tmpj90i9ymp.d(59):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj90i9ymp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(is(string, k) || is(string,\
    \ toupper(k))) \n        {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwxd03jnd.d(23): Error: no identifier for declarator `v`\n/tmp/tmpwxd03jnd.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpwxd03jnd.d(23): Error: expression
    expected, not `in`\n/tmp/tmpwxd03jnd.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpwxd03jnd.d(25): Error: found `,` when expecting `)`\n/tmp/tmpwxd03jnd.d(25):
    Error: found `k` when expecting `)`\n/tmp/tmpwxd03jnd.d(25): Error: found `)`
    instead of statement\n/tmp/tmpwxd03jnd.d(30): Error: declaration expected, not
    `return`\n/tmp/tmpwxd03jnd.d(31): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpwxd03jnd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = is(typeof(v));\n\
    \        bool isStringInLower = isString && v.asLower();\n        bool isStringInUpper\
    \ = isString && v.asUpper();\n        bool isStringInBoth = isString && (isStringInLower\
    \ || isStringInUpper);\n        bool isStringInBothOrEmpty = isString && (isStringInBoth\
    \ || v.asString().isEmpty());\n        bool isStringInBothOrNotEmpty = isString\
    \ && (isStringInBoth || !v.asString().isEmpty());\n        bool isStringInBothOrNotNull\
    \ = isString && (isStringInBoth || !v.asString().isNull());\n        bool isStringInBothOrNotEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isEmpty() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmpty = isString && (isStringInBoth ||\
    \ !v.asString().isNull() || !v.asString().isEmpty());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull() || !v.asString().isNull());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmptyOrNull = isString && (isStringInBoth\
    \ || !v.asString().isNull() || !v.asString().isEmpty() || !v.asString().isNull()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmptyOrNull = isString && (isStringInBoth\
    \ || !v.asString().isNull() || !v.asString().isEmpty() || !v.asString().isNull()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull()\
    \ || !v.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcdx21666.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcdx21666.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcdx21666.d(39): Error: identifier
    expected following `.`, not `unittest`\n/tmp/tmpcdx21666.d(38): Error: found `{`
    when expecting `)`\n/tmp/tmpcdx21666.d(41): Error: semicolon expected, not `alias`\n/tmp/tmpcdx21666.d(51):
    Error: found `void` when expecting `)`\n/tmp/tmpcdx21666.d(51): Error: found `{`
    when expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpcdx21666.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp25dw8in1.d(23): Error: no identifier for declarator `v`\n/tmp/tmp25dw8in1.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp25dw8in1.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25dw8in1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7hpt3zc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpi7hpt3zc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpi7hpt3zc.d(24): Error: found `{`
    when expecting `)`\n/tmp/tmpi7hpt3zc.d(27): Error: declaration expected, not `return`\n/tmp/tmpi7hpt3zc.d(28):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7hpt3zc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2p7lfgg2.d(23): Error: no identifier for declarator `v`\n/tmp/tmp2p7lfgg2.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp2p7lfgg2.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2p7lfgg2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppoxiobx0.d(23): Error: no identifier for declarator `v`\n/tmp/tmppoxiobx0.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmppoxiobx0.d(23): Error: expression
    expected, not `in`\n/tmp/tmppoxiobx0.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppoxiobx0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(key is string)\
    \ || !(value is string))\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9bviks6u.d(23): Error: no identifier for declarator `value`\n/tmp/tmp9bviks6u.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp9bviks6u.d(23): Error: expression
    expected, not `in`\n/tmp/tmp9bviks6u.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9bviks6u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=d,arrays,dictionary |>\n<| a dscore=1 |>\n<code>\nimport\
    \ std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport\
    \ std.range;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorith\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1lxp2vtv.d(23): Error: no identifier for declarator `v`\n/tmp/tmp1lxp2vtv.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp1lxp2vtv.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp1lxp2vtv.d(32): Error: declaration expected, not `<`\n/tmp/tmp1lxp2vtv.d(112):
    Error: `;` expected\n/tmp/tmp1lxp2vtv.d(113): Error: declaration expected, not
    `{`\n/tmp/tmp1lxp2vtv.d(116): Error: declaration expected, not `assert`\n/tmp/tmp1lxp2vtv.d(117):
    Error: declaration expected, not `assert`\n/tmp/tmp1lxp2vtv.d(118): Error: declaration
    expected, not `assert`\n/tmp/tmp1lxp2vtv.d(119): Error: declaration expected,
    not `assert`\n/tmp/tmp1lxp2vtv.d(120): Error: declaration expected, not `assert`\n/tmp/tmp1lxp2vtv.d(121):
    Error: declaration expected, not `assert`\n/tmp/tmp1lxp2vtv.d(122): Error: declaration
    expected, not `assert`\n/tmp/tmp1lxp2vtv.d(123): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lxp2vtv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmz6ymtpq.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmz6ymtpq.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmz6ymtpq.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmz6ymtpq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is(string(k), string(k).lower()))\n\
    \        {\n            return false;\n        }\n        if(!is(string(k), string(k).upper()))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpys19hh33.d(23): Error: no identifier for declarator `v`\n/tmp/tmpys19hh33.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpys19hh33.d(23): Error: expression
    expected, not `in`\n/tmp/tmpys19hh33.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpys19hh33.d(25): Error: function declaration without return type.
    (Note that constructors are always named `this`)\n/tmp/tmpys19hh33.d(25): Error:
    found `,` when expecting `)`\n/tmp/tmpys19hh33.d(25): Error: found `string` when
    expecting `)`\n/tmp/tmpys19hh33.d(25): Error: found `)` when expecting `;` following
    statement\n/tmp/tmpys19hh33.d(25): Error: found `)` instead of statement\n/tmp/tmpys19hh33.d(29):
    Error: function declaration without return type. (Note that constructors are always
    named `this`)\n/tmp/tmpys19hh33.d(29): Error: found `,` when expecting `)`\n/tmp/tmpys19hh33.d(29):
    Error: found `string` when expecting `)`\n/tmp/tmpys19hh33.d(29): Error: found
    `)` when expecting `;` following statement\n/tmp/tmpys19hh33.d(29): Error: found
    `)` instead of statement\n/tmp/tmpys19hh33.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpys19hh33.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k as\
    \ string).isLower();\n        bool isString2 = (k as! string).isUpper();\n   \
    \     if(!isString && !isString2)\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppuxgmtz_.d(23): Error: no identifier for declarator `v`\n/tmp/tmppuxgmtz_.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmppuxgmtz_.d(23): Error: expression
    expected, not `in`\n/tmp/tmppuxgmtz_.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmppuxgmtz_.d(25): Error: found `as` when expecting `)`\n/tmp/tmppuxgmtz_.d(25):
    Error: semicolon expected, not `string`\n/tmp/tmppuxgmtz_.d(25): Error: found
    `)` when expecting `;` following statement\n/tmp/tmppuxgmtz_.d(26): Error: found
    `as` when expecting `)`\n/tmp/tmppuxgmtz_.d(26): Error: semicolon expected, not
    `!`\n/tmp/tmppuxgmtz_.d(26): Error: found `)` when expecting `;` following statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuxgmtz_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isUpper = isupper(k);\n \
    \       bool isLower = islower(k);\n        if(isUpper && isLower)\n        {\n\
    \            return false;\n        }\n        else if(!isUpper && !isLower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl_tt62q.d(23): Error: no identifier for declarator `v`\n/tmp/tmpkl_tt62q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpkl_tt62q.d(36): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkl_tt62q.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=d,arrays |>\n<code>\nimport std.stdio;\n\
    import std.string;\nimport std.array;\nimport std.algorithm;\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphbendo76.d(23): Error: no identifier for declarator `v`\n/tmp/tmphbendo76.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphbendo76.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmphbendo76.d(32): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphbendo76.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays |>\n<| c |>\nI like this solution, it's very concise.\
    \ However it does require a custom `Nullable` type. Which is fine for me. Thanks!\n\
    <|/ c |>\n<| a dscore=2 |>\nI wrote a function that checks whether the array contains\
    \ only strings or only numbers. \n<code>\nimport std.stdio;\nimport std.string;\n\
    import std.array;\nimport std.conv;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoi08070k.d(23): Error: no identifier for declarator `v`\n/tmp/tmpoi08070k.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpoi08070k.d(23): Error: expression
    expected, not `in`\n/tmp/tmpoi08070k.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpoi08070k.d(32): Error: declaration expected, not `<`\n/tmp/tmpoi08070k.d(35):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpoi08070k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string lowerCase = lower(k);\n\
    \        string upperCase = upper(k);\n        if(!lowerCase.empty() && !upperCase.empty()\
    \ && lowerCase != upperCase)\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n</code>\n<|/ a |>\n<| a tags=dictionary,c++,stl,c++11\
    \ |>\nI wrote a function that checks if a dictionary is empty or not:\n<code>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3ytambja.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3ytambja.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3ytambja.d(32): Error: found `return`
    when expecting `)`\n/tmp/tmp3ytambja.d(34): Error: declaration expected, not `<`\n/tmp/tmp3ytambja.d(43):
    Error: declaration expected, not `assert`\n/tmp/tmp3ytambja.d(44): Error: declaration
    expected, not `assert`\n/tmp/tmp3ytambja.d(45): Error: declaration expected, not
    `assert`\n/tmp/tmp3ytambja.d(46): Error: declaration expected, not `assert`\n/tmp/tmp3ytambja.d(47):
    Error: declaration expected, not `assert`\n/tmp/tmp3ytambja.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmp3ytambja.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmp3ytambja.d(50): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3ytambja.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays |>\n<| c |>\nThis doesn't work if you have an array\
    \ with non-string keys. E.g. `[\"foo\": 123, \"bar\": 456, \"baz\": 789]`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I tested it before posting. The function returns\
    \ false for that case. I'll update the answer to include that case.\n<|/ c |>\n\
    <| c |>\nOh, I see. Sorry, I missed that case. Thanks for pointing it out!\n<|/\
    \ c |>\n<| a tags=d,arrays |>\nI came up with a solution which I believe is more\
    \ efficient than using std.algorithm.allElementsEqual.\n<code>\nimport std.algorithm;\n\
    import std.array;\nimport std.conv;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplwaj68qn.d(23): Error: no identifier for declarator `v`\n/tmp/tmplwaj68qn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplwaj68qn.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmplwaj68qn.d(32): Error: declaration expected, not `<`\n/tmp/tmplwaj68qn.d(35):
    Error: unterminated character constant\n/tmp/tmplwaj68qn.d(38): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwaj68qn.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!(is_string(k) ||\
    \ is_string(k)))\n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6qti3f87.d(23): Error: no identifier for declarator `v`\n/tmp/tmp6qti3f87.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp6qti3f87.d(23): Error: expression
    expected, not `in`\n/tmp/tmp6qti3f87.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6qti3f87.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = is(typeof(v));\n\
    \        bool isLowercase = isString && strcasecmp(v.asString(), k) == 0;\n  \
    \      bool isUppercase = isString && strcasecmp(k, v.asString()) == 0;\n    \
    \    if(!isString || !isLowercase || !isUppercase)\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=d,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ casting in the `foreach` loop?\n<|/ c |>\n<| c |>\nI haven't found a way to\
    \ avoid the casting in the foreach loop. Casting in the foreach loop would require\
    \ a cast to `string` inside the loop, which would require a cast to `string` outside\
    \ the loop, which would require a cast to `string` inside the loop, which would\
    \ require a cast to `string` outside the loop, which would require a cast to `string`\
    \ inside the loop, which would require a cast to `string` outside the loop, which\
    \ would require a cast to `string` inside the loop, which would require a cast\
    \ to `string` outside the loop, which would require a cast to `string` inside\
    \ the loop, which would require a cast to `string` outside the loop, which would\
    \ require a cast to `string` inside the loop, which would require a cast to `string`\
    \ outside the loop, which would require a cast to `string` inside the loop, which\
    \ would require a cast to `string` outside the loop, which would require a cast\
    \ to `string` inside the loop, which would require a cast to `string` outside\
    \ the loop, which would require a cast to `string` inside the loop, which would\
    \ require a cast to `string` outside the loop, which would require a cast to `string`\
    \ inside the loop, which would require a cast to `string` outside the loop, which\
    \ would require a cast to `string` inside the loop, which would require a cast\
    \ to `string` outside the loop, which would require a cast to `string` inside\
    \ the loop, which would require a cast to `string` outside the loop, which would\
    \ require a cast to `string` inside the loop, which would require a cast to `string`\
    \ outside the loop, which would require a cast to `string` inside the loop, which\
    \ would require a cast to `string` outside the loop, which would require a cast\
    \ to `string` inside the loop, which would require a cast to `string` outside\
    \ the loop, which would require a cast to `string` inside the loop, which would\
    \ require a cast to `string` outside the loop, which would require a cast to `\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpar19gdf6.d(23): Error: no identifier for declarator `v`\n/tmp/tmpar19gdf6.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpar19gdf6.d(33): Error: found `return`
    when expecting `)`\n/tmp/tmpar19gdf6.d(35): Error: declaration expected, not `<`\n/tmp/tmpar19gdf6.d(41):
    Error: unterminated character constant\n/tmp/tmpar19gdf6.d(41): Error: unterminated
    string constant starting at /tmp/tmpar19gdf6.d(41)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpar19gdf6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !isNull(v) ? k : k;\n    return !dict.isEmpty();\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmcofy9cf.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmcofy9cf.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmcofy9cf.d(23): Error: found `;`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmcofy9cf.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpivrd_62w.d(23): Error: no identifier for declarator `v`\n/tmp/tmpivrd_62w.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpivrd_62w.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivrd_62w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnlex38lw.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnlex38lw.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnlex38lw.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpnlex38lw.d(25): Error: semicolon expected, not `string`\n/tmp/tmpnlex38lw.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnlex38lw.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpnlex38lw.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpnlex38lw.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpnlex38lw.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlex38lw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnlex38lw.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnlex38lw.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnlex38lw.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpnlex38lw.d(25): Error: semicolon expected, not `string`\n/tmp/tmpnlex38lw.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnlex38lw.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpnlex38lw.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpnlex38lw.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpnlex38lw.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlex38lw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp00ro644j.d(23): Error: no identifier for declarator `v`\n/tmp/tmp00ro644j.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp00ro644j.d(23): Error: expression
    expected, not `in`\n/tmp/tmp00ro644j.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp00ro644j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplwixt6pg.d(23): Error: no identifier for declarator `v`\n/tmp/tmplwixt6pg.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplwixt6pg.d(23): Error: expression
    expected, not `in`\n/tmp/tmplwixt6pg.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwixt6pg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnlex38lw.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnlex38lw.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnlex38lw.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpnlex38lw.d(25): Error: semicolon expected, not `string`\n/tmp/tmpnlex38lw.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnlex38lw.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpnlex38lw.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpnlex38lw.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpnlex38lw.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlex38lw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k is\
    \ string);\n        bool isStringUpper = (k is string) && k.isUpper();\n     \
    \   bool isStringLower = (k is string) && k.isLower();\n        bool isStringNull\
    \ = (k is string) && k == null;\n        bool isStringNullUpper = (k is string)\
    \ && k == null && k.isUpper();\n        bool isStringNullLower = (k is string)\
    \ && k == null && k.isLower();\n        bool isStringNullString = (k is string)\
    \ && k == null && k == null;\n        bool isStringNullStringUpper = (k is string)\
    \ && k == null && k == null && k.isUpper();\n        bool isStringNullStringLower\
    \ = (k is string) && k == null && k == null && k.isLower();\n        bool isStringNullStringString\
    \ = (k is string) && k == null && k == null && k == null;\n        bool isStringNullStringStringUpper\
    \ = (k is string) && k == null && k == null && k == null && k.isUpper();\n   \
    \     bool isStringNullStringStringLower = (k is string) && k == null && k ==\
    \ null && k == null && k.isLower();\n        bool isStringNullStringStringString\
    \ = (k is string) && k == null && k == null && k == null && k == null;\n     \
    \   bool isStringNullStringStringStringUpper = (k is string) && k == null && k\
    \ == null && k == null && k == null && k.isUpper();\n        bool isStringNullStringStringStringLower\
    \ = (k is string) && k == null && k == null && k == null && k == null && k.isLower();\n\
    \        bool isStringNullStringStringStringString = (k is string) && k == null\
    \ && k == null && k == null && k == null && k == null;\n        bool isStringNullStringStringStringUpper\
    \ = (k is string) && k == null && k == null && k == null && k == null && k ==\
    \ null && k.isUpper();\n        bool isStringNullStringStringStringLower = (k\
    \ is string) && k == null && k == null && k == null && k == null && k == null\
    \ && k.isLower();\n        bool isStringNullStringStringStringString = (k is string)\
    \ && k == null && k == null && k == null && k == null && k == null && k == null;\n\
    \        bool isStringNullStringStringStringStringUpper = (k is string) && k ==\
    \ null && k == null && k == null && k == null && k == null && k == null && k.isUpper();\n\
    \        bool isStringNullStringStringStringStringLower = (k\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvurg6s0r.d(23): Error: no identifier for declarator `v`\n/tmp/tmpvurg6s0r.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpvurg6s0r.d(23): Error: expression
    expected, not `in`\n/tmp/tmpvurg6s0r.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpvurg6s0r.d(45): Error: found `unittest` when expecting `)`\n/tmp/tmpvurg6s0r.d(47):
    Error: semicolon expected, not `{`\n/tmp/tmpvurg6s0r.d(58): Error: found `End
    of File` when expecting `}` following compound statement\n/tmp/tmpvurg6s0r.d(58):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvurg6s0r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        switch(v)\n        {\n\
    \            case null: \n            {\n                return false;\n     \
    \       }\n            case v: \n            {\n                return true;\n\
    \            }\n            case v: \n            {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=d |>\nI like Alexander's answer, but here's another one that uses\
    \ std.algorithm.allOf:\n<code>\nimport std.algorithm;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkcgwuj9x.d(23): Error: no identifier for declarator `v`\n/tmp/tmpkcgwuj9x.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpkcgwuj9x.d(23): Error: expression
    expected, not `in`\n/tmp/tmpkcgwuj9x.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpkcgwuj9x.d(43): Error: declaration expected, not `<`\n/tmp/tmpkcgwuj9x.d(46):
    Error: unterminated character constant\n/tmp/tmpkcgwuj9x.d(46): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkcgwuj9x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(isString &&\
    \ isStringUpper)\n            return false;\n        if(!isString && !isStringUpper)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=d,arrays |>\n<code>\nimport std.stdio;\nimport std.array;\nimport\
    \ std.string;\nimport std.algorithm;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3rq10d5a.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3rq10d5a.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3rq10d5a.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmp3rq10d5a.d(25): Error: semicolon expected, not `string`\n/tmp/tmp3rq10d5a.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmp3rq10d5a.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmp3rq10d5a.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmp3rq10d5a.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmp3rq10d5a.d(32): Error: found `return` when expecting
    `)`\n/tmp/tmp3rq10d5a.d(34): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp3rq10d5a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdb4nunsc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdb4nunsc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdb4nunsc.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdb4nunsc.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb4nunsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if (is_string(k) && is_string(v))\n\
    \        {\n            if (k.toLowerCase() == v.toLowerCase())\n            {\n\
    \                return true;\n            }\n        }\n        else if (is_integer(k)\
    \ && is_string(v))\n        {\n            if (k == v)\n            {\n      \
    \          return true;\n            }\n        }\n        else if (is_integer(k)\
    \ && is_integer(v))\n        {\n            if (k == v)\n            {\n     \
    \           return true;\n            }\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2fqki22r.d(23): Error: no identifier for declarator `v`\n/tmp/tmp2fqki22r.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp2fqki22r.d(47): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fqki22r.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (typeof(k) != \"string\"\
    ) return false;\n        if (typeof(v) != \"string\") return false;\n    }\n \
    \   return true;\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\nThis doesn't work\
    \ for me. `Nullable!(string[string])` doesn't compile. `Nullable!(string)` does\
    \ compile, but `Nullable!(string[string])` does not.\n<|/ c |>\n<| c |>\nI tested\
    \ this in DMD (DMD64 D Compiler v2.06) and it compiles fine. Maybe you have a\
    \ different version of DMD or something else is wrong with your code?\n<|/ c |>\n\
    <| c |>\nI tested this in DMD (DMD64 D Compiler v2.06) and it compiles fine. Maybe\
    \ you have a different version of DMD or something else is wrong with your code?\n\
    <|/ c |>\n<| c |>\nI tested this in DMD (DMD64 D Compiler v2.06) and it compiles\
    \ fine. Maybe you have a different version of DMD or something else is wrong with\
    \ your code?\n<|/ c |>\n<| c |>\nI tested this in DMD (DMD64 D Compiler v2.06)\
    \ and it compiles fine. Maybe you have a different version of DMD or something\
    \ else is wrong with your code?\n<|/ c |>\n<| a |>\nThe other answers here are\
    \ correct, but I thought I'd add my own solution. \n<code>\nimport std.stdio;\n\
    import std.array;\nimport std.string;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyhlfdyat.d(23): Error: no identifier for declarator `v`\n/tmp/tmpyhlfdyat.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpyhlfdyat.d(23): Error: expression
    expected, not `in`\n/tmp/tmpyhlfdyat.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpyhlfdyat.d(30): Error: declaration expected, not `<`\n/tmp/tmpyhlfdyat.d(33):
    Error: unterminated character constant\n/tmp/tmpyhlfdyat.d(33): Error: unterminated
    character constant\n/tmp/tmpyhlfdyat.d(48): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhlfdyat.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(k)) \n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp41fh8jcy.d(23): Error: no identifier for declarator `v`\n/tmp/tmp41fh8jcy.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp41fh8jcy.d(23): Error: expression
    expected, not `in`\n/tmp/tmp41fh8jcy.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41fh8jcy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!is_string(value)\
    \ || !is_string(key))\n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgu2pffpi.d(23): Error: no identifier for declarator `value`\n/tmp/tmpgu2pffpi.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpgu2pffpi.d(23): Error: expression
    expected, not `in`\n/tmp/tmpgu2pffpi.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgu2pffpi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = k.isUpper();\n\
    \        bool is_lower = k.isLower();\n        if(is_upper != is_lower)\n    \
    \    {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8j49z4f1.d(23): Error: no identifier for declarator `v`\n/tmp/tmp8j49z4f1.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp8j49z4f1.d(32): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j49z4f1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmiar01j4.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmiar01j4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmiar01j4.d(23): Error: expression
    expected, not `in`\n/tmp/tmpmiar01j4.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmiar01j4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\nI like your solution, but I believe\
    \ that `foreach` will iterate over the entire array even if the first element\
    \ is a string. `foreach(k, v; dict) if(is_string(k) || is_string(v)) return true;`\
    \ should do the trick.\n<|/ c |>\n<| c |>\nYes, you are right. I just wanted to\
    \ show that `foreach` can be used for both cases. But I agree that your solution\
    \ is more elegant.\n<|/ c |>\n<| c |>\nI like your solution, but I believe that\
    \ `foreach` will iterate over the entire array even if the first element is a\
    \ string. `foreach(k, v; dict) if(is_string(k) || is_string(v)) return true;`\
    \ should do the trick.\n<|/ c |>\n<| c |>\nYes, you are right. I just wanted to\
    \ show that `foreach` can be used for both cases. But I agree that your solution\
    \ is more elegant.\n<|/ c |>\n<| c |>\nI like your solution, but I believe that\
    \ `foreach` will iterate over the entire array even if the first element is a\
    \ string. `foreach(k, v; dict) if(is_string(k) || is_string(v)) return true;`\
    \ should do the trick.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc_vzdew6.d(23): Error: no identifier for declarator `v`\n/tmp/tmpc_vzdew6.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpc_vzdew6.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmpc_vzdew6.d(32): Error: declaration expected, not `<`\n/tmp/tmpc_vzdew6.d(55):
    Error: declaration expected, not `assert`\n/tmp/tmpc_vzdew6.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmpc_vzdew6.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmpc_vzdew6.d(58): Error: declaration expected, not `assert`\n/tmp/tmpc_vzdew6.d(59):
    Error: declaration expected, not `assert`\n/tmp/tmpc_vzdew6.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmpc_vzdew6.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmpc_vzdew6.d(62): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpc_vzdew6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=d\
    \ dscore=2 |>\n<| c |>\nI like the idea of using std.typecons.is_string, but I\
    \ wonder if there is a way to do it without using std.typecons.is_string. Maybe\
    \ something with std.typecons.is_char?\n<|/ c |>\n<| c |>\nI added a version that\
    \ doesn't use std.typecons.is_string\n<|/ c |>\n<| a dscore=2 |>\nI like Alexander's\
    \ answer, but here's another one that uses std.typecons.is_char and std.typecons.is_string.\
    \ \n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps53q15ov.d(23): Error: no identifier for declarator `v`\n/tmp/tmps53q15ov.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmps53q15ov.d(23): Error: expression
    expected, not `in`\n/tmp/tmps53q15ov.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmps53q15ov.d(30): Error: declaration expected, not `<`\n/tmp/tmps53q15ov.d(36):
    Error: unterminated character constant\n/tmp/tmps53q15ov.d(39): Error: unterminated
    character constant\n/tmp/tmps53q15ov.d(39): Error: unterminated character constant\n/tmp/tmps53q15ov.d(45):
    Error: declaration expected, not `assert`\n/tmp/tmps53q15ov.d(46): Error: declaration
    expected, not `assert`\n/tmp/tmps53q15ov.d(47): Error: declaration expected, not
    `assert`\n/tmp/tmps53q15ov.d(48): Error: declaration expected, not `assert`\n/tmp/tmps53q15ov.d(49):
    Error: declaration expected, not `assert`\n/tmp/tmps53q15ov.d(50): Error: declaration
    expected, not `assert`\n/tmp/tmps53q15ov.d(51): Error: declaration expected, not
    `assert`\n/tmp/tmps53q15ov.d(52): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps53q15ov.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !k.isNullable() ? k : Nullable!(string[string](k));\n\
    \    foreach(k, v) \n    {\n        bool isUpper = k.isUpper();\n        bool\
    \ isLower = k.isLower();\n        if(!isUpper && !isLower) \n        {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nI wrote a small library to solve this problem:\n<code>\nimport\
    \ std.stdio;\nimport std.string;\nimport std.array;\nimport std.conv;\nimport\
    \ std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorith\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnfrtq07o.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnfrtq07o.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnfrtq07o.d(23): Error: found `;`
    when expecting `)`\n/tmp/tmpnfrtq07o.d(24): Error: no identifier for declarator
    `v`\n/tmp/tmpnfrtq07o.d(24): Error: found `)` when expecting `;`\n/tmp/tmpnfrtq07o.d(33):
    Error: found `return` when expecting `)`\n/tmp/tmpnfrtq07o.d(35): Error: declaration
    expected, not `<`\n/tmp/tmpnfrtq07o.d(108): Error: `;` expected\n/tmp/tmpnfrtq07o.d(109):
    Error: declaration expected, not `{`\n/tmp/tmpnfrtq07o.d(112): Error: declaration
    expected, not `assert`\n/tmp/tmpnfrtq07o.d(113): Error: declaration expected,
    not `assert`\n/tmp/tmpnfrtq07o.d(114): Error: declaration expected, not `assert`\n/tmp/tmpnfrtq07o.d(115):
    Error: declaration expected, not `assert`\n/tmp/tmpnfrtq07o.d(116): Error: declaration
    expected, not `assert`\n/tmp/tmpnfrtq07o.d(117): Error: declaration expected,
    not `assert`\n/tmp/tmpnfrtq07o.d(118): Error: declaration expected, not `assert`\n/tmp/tmpnfrtq07o.d(119):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfrtq07o.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = false;\n     \
    \   foreach(k, v) \n        {\n            isString = isString || is_string(k);\n\
    \            isString = isString || is_string(k);\n        }\n        if(!isString)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpofi9vppv.d(23): Error: no identifier for declarator `v`\n/tmp/tmpofi9vppv.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpofi9vppv.d(26): Error: no identifier
    for declarator `v`\n/tmp/tmpofi9vppv.d(26): Error: found `)` when expecting `;`\n/tmp/tmpofi9vppv.d(31):
    Error: found `if` when expecting `)`\n/tmp/tmpofi9vppv.d(32): Error: found `return`
    when expecting `;` following statement\n/tmp/tmpofi9vppv.d(34): Error: found `return`
    when expecting `)`\n/tmp/tmpofi9vppv.d(36): Error: declaration expected, not `<`\n/tmp/tmpofi9vppv.d(44):
    Error: declaration expected, not `assert`\n/tmp/tmpofi9vppv.d(45): Error: declaration
    expected, not `assert`\n/tmp/tmpofi9vppv.d(46): Error: declaration expected, not
    `assert`\n/tmp/tmpofi9vppv.d(47): Error: declaration expected, not `assert`\n/tmp/tmpofi9vppv.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpofi9vppv.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpofi9vppv.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpofi9vppv.d(51): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpofi9vppv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k is\
    \ string);\n        bool isUpperCase = (k is string) && k.isUppercase();\n   \
    \     bool isLowerCase = (k is string) && k.isLowercase();\n        bool isNumber\
    \ = (k is number);\n        bool isNull = (k is null);\n        bool isBool =\
    \ (k is bool);\n        bool isDict = (k is dict);\n        bool isList = (k is\
    \ list);\n        bool isTuple = (k is tuple);\n        bool isSet = (k is set);\n\
    \        bool isMap = (k is map);\n        bool isEnum = (k is enum);\n      \
    \  bool isStruct = (k is struct);\n        bool isUnion = (k is union);\n    \
    \    bool isOptional = (k is Option);\n        bool isOptionalDict = (k is Option[dict]);\n\
    \        bool isOptionalList = (k is Option[list]);\n        bool isOptionalTuple\
    \ = (k is Option[tuple]);\n        bool isOptionalSet = (k is Option[set]);\n\
    \        bool isOptionalMap = (k is Option[map]);\n        bool isOptionalEnum\
    \ = (k is Option[enum]);\n        bool isOptionalStruct = (k is Option[struct]);\n\
    \        bool isOptionalUnion = (k is Option[union]);\n        bool isOptionalOptional\
    \ = (k is Option[Option]);\n        bool isOptionalOptionalDict = (k is Option[Option[dict]]);\n\
    \        bool isOptionalOptionalList = (k is Option[Option[list]]);\n        bool\
    \ isOptionalOptionalTuple = (k is Option[Option[tuple]]);\n        bool isOptionalOptionalSet\
    \ = (k is Option[Option[set]]);\n        bool isOptionalOptionalMap = (k is Option[Option[map]]);\n\
    \        bool isOptionalOptionalEnum = (k is Option[Option[enum]]);\n        bool\
    \ isOptionalOptionalStruct = (k is Option[Option[struct]]);\n        bool isOptionalOptionalUnion\
    \ = (k is Option[Option[union]]);\n        bool isOptionalOptionalOptional = (k\
    \ is Option[Option[Option]]);\n        bool isOptionalOptionalOptionalDict = (k\
    \ is Option[Option[Option[dict]]]);\n        bool isOptionalOptionalOptionalList\
    \ = (k is Option[Option[Option[list]]]);\n        bool isOptionalOptionalOptionalTuple\
    \ = (k is Option[Option[Option[tuple]]]);\n        bool isOptionalOptionalOptionalSet\
    \ = (k is Option[Option\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph8a3rahh.d(23): Error: no identifier for declarator `v`\n/tmp/tmph8a3rahh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmph8a3rahh.d(23): Error: expression
    expected, not `in`\n/tmp/tmph8a3rahh.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmph8a3rahh.d(30): Error: found `)` when expecting `.` following bool\n/tmp/tmph8a3rahh.d(30):
    Error: found `;` when expecting identifier following `bool`.\n/tmp/tmph8a3rahh.d(30):
    Error: found `bool` when expecting `)`\n/tmp/tmph8a3rahh.d(31): Error: semicolon
    expected, not `isDict`\n/tmp/tmph8a3rahh.d(36): Error: expression expected, not
    `enum`\n/tmp/tmph8a3rahh.d(37): Error: expression expected, not `struct`\n/tmp/tmph8a3rahh.d(38):
    Error: expression expected, not `union`\n/tmp/tmph8a3rahh.d(45): Error: expression
    expected, not `enum`\n/tmp/tmph8a3rahh.d(46): Error: expression expected, not
    `struct`\n/tmp/tmph8a3rahh.d(47): Error: expression expected, not `union`\n/tmp/tmph8a3rahh.d(54):
    Error: expression expected, not `enum`\n/tmp/tmph8a3rahh.d(55): Error: expression
    expected, not `struct`\n/tmp/tmph8a3rahh.d(56): Error: expression expected, not
    `union`\n/tmp/tmph8a3rahh.d(62): Error: found `unittest` when expecting `,`\n/tmp/tmph8a3rahh.d(74):
    Error: found `void` when expecting `,`\n/tmp/tmph8a3rahh.d(74): Error: found `{`
    when expecting `,`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph8a3rahh.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isLower = toLower(k) == k;\n\
    \        bool isUpper = toUpper(k) == k;\n        if(isLower && isUpper)\n   \
    \     {\n            return false;\n        }\n        if(!isLower && !isUpper)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays |>\n<| a tags=d,arrays |>\n<code>\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbaahl1fv.d(23): Error: no identifier for declarator `v`\n/tmp/tmpbaahl1fv.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpbaahl1fv.d(36): Error: found `return`
    when expecting `)`\n/tmp/tmpbaahl1fv.d(38): Error: declaration expected, not `<`\n/tmp/tmpbaahl1fv.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmpbaahl1fv.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpbaahl1fv.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpbaahl1fv.d(49): Error: declaration expected, not `assert`\n/tmp/tmpbaahl1fv.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpbaahl1fv.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpbaahl1fv.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpbaahl1fv.d(53): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpbaahl1fv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isString2 = (k as! string).isUpper();\n        if(!isString && !isString2)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=dictionary,c#,.net,nullable\
    \ |>\n<| a tags=dictionary,c#,.net,nullable |>\n<code>\npublic static bool IsNullableDictionary<T>(this\
    \ IDictionary<string, T?> dictionary)\n{\n    return dictionary.All(x => x.Value\
    \ == null);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\npublic static\
    \ bool IsNullableDictionary<T>(this IDictionary<string, T?> dictionary)\n{\n \
    \   return dictionary.All(x => x.Value == null);\n}\n</code>\n<|/ a tags=dictionary,c#,.net,nullable\
    \ |>\n<| a tags=dictionary,c#,.net,nullable |>\n<code>\npublic static bool IsNullableDictionary<T>(this\
    \ IDictionary<string, T?> dictionary)\n{\n    return dictionary.All(x => x.Value\
    \ == null);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\npublic static\
    \ bool IsNullableDictionary<T>(this IDictionary<string, T?> dictionary)\n{\n \
    \   return dictionary.All(x => x.Value == null);\n}\n</code>\n<|/ a tags=dictionary,c#,.net,nullable\
    \ |>\n<| a tags=dictionary,c#,.net,nullable |>\n<code>\npublic static bool IsNullableDictionary<T>(this\
    \ IDictionary<string, T?> dictionary)\n{\n    return dictionary.All(x => x.Value\
    \ == null);\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\npublic static bool\
    \ IsNullableDictionary<T>(this IDictionary<string, T?> dictionary)\n{\n    return\
    \ dictionary.All(x => x.Value == null);\n}\n</code>\n<|/ a tags=dictionary,c#,.net,nullable\
    \ dscore=1 |>\n<| a tags=dictionary,c#,.net,nullable |>\n<code>\npublic static\
    \ bool IsNullableDictionary<T>(this IDictionary<string, T?> dictionary)\n{\n \
    \   return dictionary.All(x => x.Value == null);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=dictionary\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkp1vzlhe.d(23): Error: no identifier for declarator `v`\n/tmp/tmpkp1vzlhe.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpkp1vzlhe.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpkp1vzlhe.d(25): Error: semicolon expected, not `string`\n/tmp/tmpkp1vzlhe.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpkp1vzlhe.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpkp1vzlhe.d(26): Error: semicolon
    expected, not `!`\n/tmp/tmpkp1vzlhe.d(26): Error: found `)` when expecting `;`
    following statement\n/tmp/tmpkp1vzlhe.d(30): Error: found `return` when expecting
    `)`\n/tmp/tmpkp1vzlhe.d(32): Error: declaration expected, not `<`\n/tmp/tmpkp1vzlhe.d(39):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkp1vzlhe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nimport std.stdio;\n\
    import std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\n\
    import std.array;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorith\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj9dj22_c.d(23): Error: no identifier for declarator `v`\n/tmp/tmpj9dj22_c.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpj9dj22_c.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpj9dj22_c.d(25): Error: semicolon expected, not `string`\n/tmp/tmpj9dj22_c.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpj9dj22_c.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpj9dj22_c.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpj9dj22_c.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpj9dj22_c.d(32): Error: found `return` when expecting
    `)`\n/tmp/tmpj9dj22_c.d(34): Error: declaration expected, not `<`\n/tmp/tmpj9dj22_c.d(111):
    Error: `;` expected\n/tmp/tmpj9dj22_c.d(112): Error: declaration expected, not
    `{`\n/tmp/tmpj9dj22_c.d(115): Error: declaration expected, not `assert`\n/tmp/tmpj9dj22_c.d(116):
    Error: declaration expected, not `assert`\n/tmp/tmpj9dj22_c.d(117): Error: declaration
    expected, not `assert`\n/tmp/tmpj9dj22_c.d(118): Error: declaration expected,
    not `assert`\n/tmp/tmpj9dj22_c.d(119): Error: declaration expected, not `assert`\n/tmp/tmpj9dj22_c.d(120):
    Error: declaration expected, not `assert`\n/tmp/tmpj9dj22_c.d(121): Error: declaration
    expected, not `assert`\n/tmp/tmpj9dj22_c.d(122): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9dj22_c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isUpper = isupper(k);\n \
    \       bool isLower = islower(k);\n        if(!isUpper && !isLower)\n       \
    \     return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy4poj79z.d(23): Error: no identifier for declarator `v`\n/tmp/tmpy4poj79z.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpy4poj79z.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4poj79z.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9y3wg74y.d(23): Error: no identifier for declarator `v`\n/tmp/tmp9y3wg74y.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp9y3wg74y.d(23): Error: expression
    expected, not `in`\n/tmp/tmp9y3wg74y.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9y3wg74y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isString2 = (k as! string).isUpper();\n        if(!isString && !isString2)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI came up with a solution that uses\
    \ reflection to get the property names and then compares them to the keys in the\
    \ dictionary. \n<code>\nimport std.stdio;\nimport std.string;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport st\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2m2en2ny.d(23): Error: no identifier for declarator `v`\n/tmp/tmp2m2en2ny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp2m2en2ny.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmp2m2en2ny.d(25): Error: semicolon expected, not `string`\n/tmp/tmp2m2en2ny.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmp2m2en2ny.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmp2m2en2ny.d(26): Error: semicolon
    expected, not `!`\n/tmp/tmp2m2en2ny.d(26): Error: found `)` when expecting `;`
    following statement\n/tmp/tmp2m2en2ny.d(32): Error: found `return` when expecting
    `)`\n/tmp/tmp2m2en2ny.d(34): Error: declaration expected, not `<`\n/tmp/tmp2m2en2ny.d(108):
    Error: `;` expected\n/tmp/tmp2m2en2ny.d(109): Error: declaration expected, not
    `{`\n/tmp/tmp2m2en2ny.d(112): Error: declaration expected, not `assert`\n/tmp/tmp2m2en2ny.d(113):
    Error: declaration expected, not `assert`\n/tmp/tmp2m2en2ny.d(114): Error: declaration
    expected, not `assert`\n/tmp/tmp2m2en2ny.d(115): Error: declaration expected,
    not `assert`\n/tmp/tmp2m2en2ny.d(116): Error: declaration expected, not `assert`\n/tmp/tmp2m2en2ny.d(117):
    Error: declaration expected, not `assert`\n/tmp/tmp2m2en2ny.d(118): Error: declaration
    expected, not `assert`\n/tmp/tmp2m2en2ny.d(119): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2m2en2ny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string key = k.stringValue();\n\
    \        string value = v.stringValue();\n        \n        if (key != null &&\
    \ value != null && key.length() > 0 && value.length() > 0)\n        {\n      \
    \      if (key.length() < value.length())\n            {\n                return\
    \ false;\n            }\n            else if (key.length() > value.length())\n\
    \            {\n                return true;\n            }\n        }\n    }\n\
    \    \n    return false;\n}\n</code>\n<|/ a tags=swift,dictionary |>\n<| c |>\n\
    This doesn't work if you have a key with multiple capital letters.\n<|/ c |>\n\
    <| a dscore=0 |>\nI wrote this extension to do just that:\n<code>\nextension Dictionary\
    \ where Key == String, Value == String {\n    func isNullOrEmpty() -> Bool {\n\
    \        guard let keys = self.keys else { return true }\n        return keys.isEmpty\n\
    \    }\n}\n</code>\n<|/ a tags=swift,dictionary |>\n<| a tags=swift,dictionary\
    \ |>\n<code>\nextension Dictionary where Key == String, Value == String {\n  \
    \  func isNullOrEmpty() -> Bool {\n        guard let keys = self.keys else { return\
    \ true }\n        return keys.isEmpty\n    }\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=swift,dictionary |>\n<code>\nextension Dictionary where Key == String,\
    \ Value == String {\n    func isNullOrEmpty() -> Bool {\n        guard let keys\
    \ = self.keys else { return true }\n        return keys.isEmpty\n    }\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding how and/or why it solves the problem would improve\
    \ the answer's long-term value.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/26825814)\n\
    <|/ c |>\n<| c |>\nThis does provide an answer to the question. While it may look\
    \ like it does not, it does provide an answer to the question. He asked how to\
    \ check if a dictionary is empty and I provided an answer that does exactly that.\
    \ He also asked how to check if a dictionary is nullable and I provided an answer\
    \ that does exactly that. He also asked how to check if a dictionary is nullable\
    \ and I provided an answer that does exactly that. He \nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvryt2pmm.d(23): Error: no identifier for declarator `v`\n/tmp/tmpvryt2pmm.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpvryt2pmm.d(41): Error: found `return`
    when expecting `)`\n/tmp/tmpvryt2pmm.d(43): Error: declaration expected, not `<`\n/tmp/tmpvryt2pmm.d(46):
    Error: unterminated character constant\n/tmp/tmpvryt2pmm.d(80): Error: unterminated
    character constant\n/tmp/tmpvryt2pmm.d(91): Error: declaration expected, not `assert`\n/tmp/tmpvryt2pmm.d(92):
    Error: declaration expected, not `assert`\n/tmp/tmpvryt2pmm.d(93): Error: declaration
    expected, not `assert`\n/tmp/tmpvryt2pmm.d(94): Error: declaration expected, not
    `assert`\n/tmp/tmpvryt2pmm.d(95): Error: declaration expected, not `assert`\n/tmp/tmpvryt2pmm.d(96):
    Error: declaration expected, not `assert`\n/tmp/tmpvryt2pmm.d(97): Error: declaration
    expected, not `assert`\n/tmp/tmpvryt2pmm.d(98): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvryt2pmm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !isNull(v) && isNull(dict[k]) ? !isNull(k)\
    \ : !isNull(k) ? !isNull(v) : !isNull(v);\n    return !dict.isEmpty();\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnuwieaj3.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnuwieaj3.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnuwieaj3.d(23): Error: found `;`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnuwieaj3.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isLower = islower(k);\n \
    \       bool isUpper = isupper(k);\n        if(isLower && isUpper)\n        {\n\
    \            return false;\n        }\n        else if(isLower && !isUpper)\n\
    \        {\n            return false;\n        }\n        else if(!isLower &&\
    \ isUpper)\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a tags=d |>\n<| a dscore=1 |>\n<code>\nimport std.stdio;\n\
    import std.string;\nimport std.algorithm;\nimport std.array;\nimport std.conv;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiirm5up9.d(23): Error: no identifier for declarator `v`\n/tmp/tmpiirm5up9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpiirm5up9.d(40): Error: found `return`
    when expecting `)`\n/tmp/tmpiirm5up9.d(42): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiirm5up9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplwixt6pg.d(23): Error: no identifier for declarator `v`\n/tmp/tmplwixt6pg.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplwixt6pg.d(23): Error: expression
    expected, not `in`\n/tmp/tmplwixt6pg.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwixt6pg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = k.toUpper() ==\
    \ k;\n        bool is_lower = k.toLower() == k;\n        if(is_upper && is_lower)\n\
    \            return true;\n        if(!is_upper && !is_lower)\n            return\
    \ false;\n    }\n    return false;\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\n\
    This doesn't work if you have a key that is a number or other type that isn't\
    \ a string.\n<|/ c |>\n<| c |>\n: Yes, it does. Try it yourself.\n<|/ c |>\n<|\
    \ c |>\n: I added a version that works with numbers and other types. I tested\
    \ it and it works.\n<|/ c |>\n<| c |>\n: I added a version that works with numbers\
    \ and other types. I tested it and it works.\n<|/ c |>\n<| c |>\n: I added a version\
    \ that works with numbers and other types. I tested it and it works.\n<|/ c |>\n\
    <| a tags=d,arrays |>\n<code>\nimport std.stdio;\nimport std.array;\nimport std.conv;\n\
    import std.algorithm;\nimport std.range;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport \nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmxkwyoo.d(23): Error: no identifier for declarator `v`\n/tmp/tmpkmxkwyoo.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpkmxkwyoo.d(32): Error: found `return`
    when expecting `)`\n/tmp/tmpkmxkwyoo.d(34): Error: declaration expected, not `<`\n/tmp/tmpkmxkwyoo.d(37):
    Error: unterminated character constant\n/tmp/tmpkmxkwyoo.d(37): Error: unterminated
    character constant\n/tmp/tmpkmxkwyoo.d(102): Error: identifier expected following
    `import`\n/tmp/tmpkmxkwyoo.d(102): Error: `;` expected\n/tmp/tmpkmxkwyoo.d(103):
    Error: declaration expected, not `{`\n/tmp/tmpkmxkwyoo.d(106): Error: declaration
    expected, not `assert`\n/tmp/tmpkmxkwyoo.d(107): Error: declaration expected,
    not `assert`\n/tmp/tmpkmxkwyoo.d(108): Error: declaration expected, not `assert`\n/tmp/tmpkmxkwyoo.d(109):
    Error: declaration expected, not `assert`\n/tmp/tmpkmxkwyoo.d(110): Error: declaration
    expected, not `assert`\n/tmp/tmpkmxkwyoo.d(111): Error: declaration expected,
    not `assert`\n/tmp/tmpkmxkwyoo.d(112): Error: declaration expected, not `assert`\n/tmp/tmpkmxkwyoo.d(113):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmxkwyoo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdb4nunsc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdb4nunsc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdb4nunsc.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdb4nunsc.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb4nunsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=d,arrays,dictionary\
    \ |>\n<| c |>\nI like your solution, however it fails for empty arrays. I added\
    \ a check for the empty array and also added a check for null arrays. I added\
    \ the code to the answer.\n<|/ c |>\n<| a tags=d,arrays,dictionary |>\nA simple\
    \ solution that doesn't require any additional libraries:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmob8cz0f.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmob8cz0f.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmob8cz0f.d(28): Error: found `return`
    when expecting `)`\n/tmp/tmpmob8cz0f.d(30): Error: declaration expected, not `<`\n/tmp/tmpmob8cz0f.d(36):
    Error: unterminated character constant\n/tmp/tmpmob8cz0f.d(42): Error: declaration
    expected, not `assert`\n/tmp/tmpmob8cz0f.d(43): Error: declaration expected, not
    `assert`\n/tmp/tmpmob8cz0f.d(44): Error: declaration expected, not `assert`\n/tmp/tmpmob8cz0f.d(45):
    Error: declaration expected, not `assert`\n/tmp/tmpmob8cz0f.d(46): Error: declaration
    expected, not `assert`\n/tmp/tmpmob8cz0f.d(47): Error: declaration expected, not
    `assert`\n/tmp/tmpmob8cz0f.d(48): Error: declaration expected, not `assert`\n/tmp/tmpmob8cz0f.d(49):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmob8cz0f.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(v) || !is_string(k))\n\
    \            return false;\n        if (v.length() != k.length())\n          \
    \  return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3md_0sn4.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3md_0sn4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3md_0sn4.d(23): Error: expression
    expected, not `in`\n/tmp/tmp3md_0sn4.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3md_0sn4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmiar01j4.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmiar01j4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmiar01j4.d(23): Error: expression
    expected, not `in`\n/tmp/tmpmiar01j4.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmiar01j4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_string = (k as string).isLower();\n\
    \        bool is_string_upper = (k as string).isUpper();\n        if(is_string\
    \ != is_string_upper)\n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7ovjocwa.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7ovjocwa.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7ovjocwa.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmp7ovjocwa.d(25): Error: semicolon expected, not `string`\n/tmp/tmp7ovjocwa.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmp7ovjocwa.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmp7ovjocwa.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmp7ovjocwa.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmp7ovjocwa.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ovjocwa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (is_string(k) && is_string(k))\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpauwir6ii.d(23): Error: no identifier for declarator `v`\n/tmp/tmpauwir6ii.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpauwir6ii.d(23): Error: expression
    expected, not `in`\n/tmp/tmpauwir6ii.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpauwir6ii.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(k)) \n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp41fh8jcy.d(23): Error: no identifier for declarator `v`\n/tmp/tmp41fh8jcy.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp41fh8jcy.d(23): Error: expression
    expected, not `in`\n/tmp/tmp41fh8jcy.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp41fh8jcy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if (k == k.toLowerCase()) \n \
    \       {\n            return true;\n        }\n        else if (k == k.toUpperCase())\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI wrote a function that checks if a dictionary\
    \ is nullable or not:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbi7rxiw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmpbi7rxiw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpbi7rxiw7.d(34): Error: found `return`
    when expecting `)`\n/tmp/tmpbi7rxiw7.d(36): Error: declaration expected, not `<`\n/tmp/tmpbi7rxiw7.d(45):
    Error: declaration expected, not `assert`\n/tmp/tmpbi7rxiw7.d(46): Error: declaration
    expected, not `assert`\n/tmp/tmpbi7rxiw7.d(47): Error: declaration expected, not
    `assert`\n/tmp/tmpbi7rxiw7.d(48): Error: declaration expected, not `assert`\n/tmp/tmpbi7rxiw7.d(49):
    Error: declaration expected, not `assert`\n/tmp/tmpbi7rxiw7.d(50): Error: declaration
    expected, not `assert`\n/tmp/tmpbi7rxiw7.d(51): Error: declaration expected, not
    `assert`\n/tmp/tmpbi7rxiw7.d(52): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpbi7rxiw7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k as\
    \ string).isLower();\n        bool isString2 = (k as! string).isUpper();\n   \
    \     if(!isString && !isString2)\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppuxgmtz_.d(23): Error: no identifier for declarator `v`\n/tmp/tmppuxgmtz_.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmppuxgmtz_.d(23): Error: expression
    expected, not `in`\n/tmp/tmppuxgmtz_.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmppuxgmtz_.d(25): Error: found `as` when expecting `)`\n/tmp/tmppuxgmtz_.d(25):
    Error: semicolon expected, not `string`\n/tmp/tmppuxgmtz_.d(25): Error: found
    `)` when expecting `;` following statement\n/tmp/tmppuxgmtz_.d(26): Error: found
    `as` when expecting `)`\n/tmp/tmppuxgmtz_.d(26): Error: semicolon expected, not
    `!`\n/tmp/tmppuxgmtz_.d(26): Error: found `)` when expecting `;` following statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuxgmtz_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays,dictionary |>\n<| a tags=d,arrays,dictionary |>\n\
    <code>\nimport std.stdio;\nimport std.array;\nimport std.string;\nimport std.algorithm;\n\
    import std.conv;\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnhmj2f_l.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnhmj2f_l.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnhmj2f_l.d(23): Error: expression
    expected, not `in`\n/tmp/tmpnhmj2f_l.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpnhmj2f_l.d(32): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpnhmj2f_l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k is\
    \ string);\n        bool isUpperCase = (k is string) && k.isUppercase();\n   \
    \     bool isLowerCase = (k is string) && k.isLowercase();\n        bool isNumber\
    \ = (k is number);\n        bool isNull = (k is null);\n        bool isNotNull\
    \ = (k is not null);\n        bool isNotString = (k is not string);\n        bool\
    \ isNotNumber = (k is not number);\n        bool isNotNullOrNotString = (k is\
    \ not null) || (k is not string);\n        bool isNotNullOrNotNumber = (k is not\
    \ null) || (k is not number);\n        bool isNotNullOrNotStringOrNotNumber =\
    \ (k is not null) || (k is not string) || (k is not number);\n        bool isNotNullOrNotStringOrNotNumberOrNotBoolean\
    \ = (k is not null) || (k is not string) || (k is not number) || (k is not boolean);\n\
    \        bool isNotNullOrNotStringOrNotNumberOrNotBooleanOrNotArray = (k is not\
    \ null) || (k is not string) || (k is not number) || (k is not boolean) || (k\
    \ is not array);\n        bool isNotNullOrNotStringOrNotNumberOrNotBooleanOrNotArrayOrNotObject\
    \ = (k is not null) || (k is not string) || (k is not number) || (k is not boolean)\
    \ || (k is not array) || (k is not object);\n        bool isNotNullOrNotStringOrNotNumberOrNotBooleanOrNotArrayOrNotObjectOrNotObjectOrNotFunction\
    \ = (k is not null) || (k is not string) || (k is not number) || (k is not boolean)\
    \ || (k is not array) || (k is not object) || (k is not object) || (k is not function);\n\
    \        bool isNotNullOrNotStringOrNotNumberOrNotBooleanOrNotArrayOrNotObjectOrNotObjectOrNotFunctionOrNotFunctionOrNotObjectOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNotObjectOrNotFunctionOrNot\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkctp4gnh.d(23): Error: no identifier for declarator `v`\n/tmp/tmpkctp4gnh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpkctp4gnh.d(23): Error: expression
    expected, not `in`\n/tmp/tmpkctp4gnh.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpkctp4gnh.d(30): Error: found `null` when expecting `)`\n/tmp/tmpkctp4gnh.d(30):
    Error: semicolon expected, not `)`\n/tmp/tmpkctp4gnh.d(30): Error: found `)` instead
    of statement\n/tmp/tmpkctp4gnh.d(31): Error: found `string` when expecting `)`\n/tmp/tmpkctp4gnh.d(31):
    Error: semicolon expected, not `)`\n/tmp/tmpkctp4gnh.d(31): Error: found `)` instead
    of statement\n/tmp/tmpkctp4gnh.d(32): Error: found `number` when expecting `)`\n/tmp/tmpkctp4gnh.d(32):
    Error: semicolon expected, not `)`\n/tmp/tmpkctp4gnh.d(32): Error: found `)` instead
    of statement\n/tmp/tmpkctp4gnh.d(33): Error: found `null` when expecting `)`\n/tmp/tmpkctp4gnh.d(33):
    Error: semicolon expected, not `)`\n/tmp/tmpkctp4gnh.d(33): Error: found `)` instead
    of statement\n/tmp/tmpkctp4gnh.d(34): Error: found `null` when expecting `)`\n/tmp/tmpkctp4gnh.d(34):
    Error: semicolon expected, not `)`\n/tmp/tmpkctp4gnh.d(34): Error: found `)` instead
    of statement\n/tmp/tmpkctp4gnh.d(35): Error: found `null` when expecting `)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkctp4gnh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplwixt6pg.d(23): Error: no identifier for declarator `v`\n/tmp/tmplwixt6pg.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplwixt6pg.d(23): Error: expression
    expected, not `in`\n/tmp/tmplwixt6pg.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwixt6pg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=d,arrays,dictionary |>\n<code>\nimport std.stdio;\n\
    import std.array;\nimport std.string;\nimport std.algorithm;\nimport std.conv;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0w8es219.d(23): Error: no identifier for declarator `v`\n/tmp/tmp0w8es219.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp0w8es219.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp0w8es219.d(32): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0w8es219.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !isNull(v) ? k : k.upperCase();\n    return\
    \ !dict.isEmpty();\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxubaxyti.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxubaxyti.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxubaxyti.d(23): Error: found `;`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxubaxyti.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(isString !=\
    \ isStringUpper)\n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the dictionary\
    \ is empty. `check_dict_case({})` returns true.\n<|/ c |>\n<| c |>\nI added a\
    \ check for empty dictionaries.\n<|/ c |>\n<| c |>\nThis doesn't work if the dictionary\
    \ is empty. `check_dict_case({})` returns true.\n<|/ c |>\n<| c |>\nI added a\
    \ check for empty dictionaries.\n<|/ c |>\n<| c |>\nThis doesn't work if the dictionary\
    \ is empty. `check_dict_case({})` returns true.\n<|/ c |>\n<| a dscore=4 |>\n\
    I came up with a solution that is very similar to what was suggested in the accepted\
    \ answer. \n<code>\nimport std.stdio;\nimport std.string;\nimport std.array;\n\
    import std.conv;\nimport std.algorithm;\nimport std.array;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport \nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnz2pjs33.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnz2pjs33.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnz2pjs33.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpnz2pjs33.d(25): Error: semicolon expected, not `string`\n/tmp/tmpnz2pjs33.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnz2pjs33.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpnz2pjs33.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpnz2pjs33.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpnz2pjs33.d(32): Error: found `return` when expecting
    `)`\n/tmp/tmpnz2pjs33.d(34): Error: declaration expected, not `<`\n/tmp/tmpnz2pjs33.d(37):
    Error: unterminated character constant\n/tmp/tmpnz2pjs33.d(43): Error: unterminated
    character constant\n/tmp/tmpnz2pjs33.d(49): Error: unterminated character constant\n/tmp/tmpnz2pjs33.d(104):
    Error: identifier expected following `import`\n/tmp/tmpnz2pjs33.d(104): Error:
    `;` expected\n/tmp/tmpnz2pjs33.d(105): Error: declaration expected, not `{`\n/tmp/tmpnz2pjs33.d(108):
    Error: declaration expected, not `assert`\n/tmp/tmpnz2pjs33.d(109): Error: declaration
    expected, not `assert`\n/tmp/tmpnz2pjs33.d(110): Error: declaration expected,
    not `assert`\n/tmp/tmpnz2pjs33.d(111): Error: declaration expected, not `assert`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnz2pjs33.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v)) \n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd2be68ri.d(23): Error: no identifier for declarator `v`\n/tmp/tmpd2be68ri.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpd2be68ri.d(23): Error: expression
    expected, not `in`\n/tmp/tmpd2be68ri.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2be68ri.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6pnjavdn.d(23): Error: no identifier for declarator `v`\n/tmp/tmp6pnjavdn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp6pnjavdn.d(23): Error: expression
    expected, not `in`\n/tmp/tmp6pnjavdn.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pnjavdn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays,associative-array |>\n<| c |>\nThis doesn't work\
    \ for associative arrays with non-string keys. For example, `check_dict_case([\"\
    a\": 42, \"b\": true].nullable)` returns true.\n<|/ c |>\n<| c |>\nI didn't realize\
    \ that associative arrays could have non-string keys. I updated my answer to include\
    \ a version that works with associative arrays with non-string keys.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>\nimport std.stdio;\nimport std.array;\nimport std.conv;\n\
    import std.string;\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp66tnsmbn.d(23): Error: no identifier for declarator `v`\n/tmp/tmp66tnsmbn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp66tnsmbn.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp66tnsmbn.d(32): Error: declaration expected, not `<`\n/tmp/tmp66tnsmbn.d(35):
    Error: unterminated character constant\n/tmp/tmp66tnsmbn.d(38): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66tnsmbn.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = k.toUpper() ==\
    \ k;\n        bool is_lower = k.toLower() == k;\n        if(is_upper || is_lower)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpil_i2chc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpil_i2chc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpil_i2chc.d(32): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpil_i2chc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp00ro644j.d(23): Error: no identifier for declarator `v`\n/tmp/tmp00ro644j.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp00ro644j.d(23): Error: expression
    expected, not `in`\n/tmp/tmp00ro644j.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp00ro644j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=d,arrays |>\nI like using std.algorithm.allOf:\n\
    <code>\nimport std.algorithm;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0jnftsb3.d(23): Error: no identifier for declarator `v`\n/tmp/tmp0jnftsb3.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp0jnftsb3.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp0jnftsb3.d(32): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0jnftsb3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v))\n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI wrote a function that\
    \ checks if a dictionary is nullable or not:\n<code>\nimport std.stdio;\nimport\
    \ std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport\
    \ std.array;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpllkcei3w.d(23): Error: no identifier for declarator `v`\n/tmp/tmpllkcei3w.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpllkcei3w.d(23): Error: expression
    expected, not `in`\n/tmp/tmpllkcei3w.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpllkcei3w.d(32): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpllkcei3w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = k.isUpper();\n\
    \        bool is_lower = k.isLower();\n        bool is_string = v.isString();\n\
    \        if(is_upper && is_lower)\n        {\n            return false;\n    \
    \    }\n        if(!is_upper && !is_lower)\n        {\n            return false;\n\
    \        }\n        if(!is_string)\n        {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnv41qph0.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnv41qph0.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnv41qph0.d(41): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnv41qph0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(isString &&\
    \ isStringUpper)\n        {\n            return false;\n        }\n        if(!isString\
    \ && !isStringUpper)\n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwvvp4nx9.d(23): Error: no identifier for declarator `v`\n/tmp/tmpwvvp4nx9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpwvvp4nx9.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpwvvp4nx9.d(25): Error: semicolon expected, not `string`\n/tmp/tmpwvvp4nx9.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpwvvp4nx9.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpwvvp4nx9.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpwvvp4nx9.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpwvvp4nx9.d(36): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwvvp4nx9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = is_upper(v);\n\
    \        bool is_lower = is_lower(v);\n        if(is_upper && is_lower)\n    \
    \    {\n            return false;\n        }\n        if(!is_upper && !is_lower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsijkg3g7.d(23): Error: no identifier for declarator `v`\n/tmp/tmpsijkg3g7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpsijkg3g7.d(36): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsijkg3g7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (typeof(k)\
    \ == string);\n        bool isStringUpper = (typeof(k) == string) && toupper(k)\
    \ == k;\n        bool isStringLower = (typeof(k) == string) && tolower(k) == k;\n\
    \        bool isStringUpperOrLower = (typeof(k) == string) && toupper(k) == tolower(k);\n\
    \        bool isStringLowerOrUpper = (typeof(k) == string) && tolower(k) == toupper(k);\n\
    \        bool isStringOrNumber = (typeof(k) == string) || typeof(k) == number);\n\
    \        bool isStringOrNumberUpper = (typeof(k) == string) || typeof(k) == number)\
    \ && toupper(k) == k;\n        bool isStringOrNumberLower = (typeof(k) == string)\
    \ || typeof(k) == number) && tolower(k) == k;\n        bool isStringOrNumberUpperOrLower\
    \ = (typeof(k) == string) || typeof(k) == number) && toupper(k) == tolower(k);\n\
    \        bool isStringOrNumberLowerOrUpper = (typeof(k) == string) || typeof(k)\
    \ == number) && tolower(k) == toupper(k);\n        bool isStringOrNumberOrString\
    \ = (typeof(k) == string) || typeof(k) == number) || typeof(k) == string);\n \
    \       bool isStringOrNumberOrStringUpper = (typeof(k) == string) || typeof(k)\
    \ == number) || typeof(k) == string) && toupper(k) == k;\n        bool isStringOrNumberOrStringLower\
    \ = (typeof(k) == string) || typeof(k) == number) || typeof(k) == string) && tolower(k)\
    \ == k;\n        bool isStringOrNumberOrStringUpperOrLower = (typeof(k) == string)\
    \ || typeof(k) == number) || typeof(k) == string) && toupper(k) == tolower(k);\n\
    \        bool isStringOrNumberOrStringLowerOrUpper = (typeof(k) == string) ||\
    \ typeof(k) == number) || typeof(k) == string) && tolower(k) == toupper(k);\n\
    \        bool isStringOrNumberOrStringOrNumber = (typeof(k) == string) || typeof(k)\
    \ == number) || typeof(k) == string) || typeof(k) == number);\n        bool isStringOrNumberOrStringOrNumberUpper\
    \ = (typeof(k) == string) || typeof(k) == number) || typeof(k) == string) || typeof(k)\
    \ == number) && toupper(k) == k;\n        bool isStringOrNumberOrStringOrNumberLower\
    \ = (typeof\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvprkbyz3.d(23): Error: no identifier for declarator `v`\n/tmp/tmpvprkbyz3.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpvprkbyz3.d(23): Error: expression
    expected, not `in`\n/tmp/tmpvprkbyz3.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpvprkbyz3.d(30): Error: semicolon expected, not `)`\n/tmp/tmpvprkbyz3.d(30):
    Error: found `)` instead of statement\n/tmp/tmpvprkbyz3.d(31): Error: semicolon
    expected, not `)`\n/tmp/tmpvprkbyz3.d(31): Error: found `)` instead of statement\n/tmp/tmpvprkbyz3.d(32):
    Error: semicolon expected, not `)`\n/tmp/tmpvprkbyz3.d(32): Error: found `)` instead
    of statement\n/tmp/tmpvprkbyz3.d(33): Error: semicolon expected, not `)`\n/tmp/tmpvprkbyz3.d(33):
    Error: found `)` instead of statement\n/tmp/tmpvprkbyz3.d(34): Error: semicolon
    expected, not `)`\n/tmp/tmpvprkbyz3.d(34): Error: found `)` instead of statement\n/tmp/tmpvprkbyz3.d(35):
    Error: semicolon expected, not `)`\n/tmp/tmpvprkbyz3.d(35): Error: found `)` instead
    of statement\n/tmp/tmpvprkbyz3.d(36): Error: semicolon expected, not `)`\n/tmp/tmpvprkbyz3.d(36):
    Error: found `)` instead of statement\n/tmp/tmpvprkbyz3.d(37): Error: semicolon
    expected, not `)`\n/tmp/tmpvprkbyz3.d(37): Error: found `)` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvprkbyz3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v)) \n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd2be68ri.d(23): Error: no identifier for declarator `v`\n/tmp/tmpd2be68ri.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpd2be68ri.d(23): Error: expression
    expected, not `in`\n/tmp/tmpd2be68ri.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2be68ri.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(key is string)\
    \ || !(value is string))\n            return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1yqc2pxh.d(23): Error: no identifier for declarator `value`\n/tmp/tmp1yqc2pxh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp1yqc2pxh.d(23): Error: expression
    expected, not `in`\n/tmp/tmp1yqc2pxh.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1yqc2pxh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (is_string(k) && is_string(k))\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpauwir6ii.d(23): Error: no identifier for declarator `v`\n/tmp/tmpauwir6ii.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpauwir6ii.d(23): Error: expression
    expected, not `in`\n/tmp/tmpauwir6ii.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpauwir6ii.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(key is string)\
    \ || !(value is string)) \n        {\n            return false;\n        }\n \
    \   }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe0nlilhh.d(23): Error: no identifier for declarator `value`\n/tmp/tmpe0nlilhh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpe0nlilhh.d(23): Error: expression
    expected, not `in`\n/tmp/tmpe0nlilhh.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0nlilhh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to avoid the extra function call. Something like `foreach(k, v) if(is_string(k)\
    \ && is_string(v))`\n<|/ c |>\n<| c |>\nYes, that would work. Although I find\
    \ it more readable this way. Also note that `foreach` doesn't return anything,\
    \ so you can't use it in a `if` statement.\n<|/ c |>\n<| c |>\nI agree, it's more\
    \ readable. But the extra function call makes it more expensive than it needs\
    \ to be. I'm looking for a way to avoid the extra function call.\n<|/ c |>\n<|\
    \ c |>\nI added a version that avoids the extra function call. Unfortunately it\
    \ still uses `foreach` but it's more readable this way.\n<|/ c |>\n<| c |>\nI\
    \ added a version that avoids the extra function call and is more readable this\
    \ way.\n<|/ c |>\n<| a tags=d,arrays |>\nI like Alexander's answer, but here's\
    \ another way that doesn't require any extra function calls:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3mk_vec6.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3mk_vec6.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3mk_vec6.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp3mk_vec6.d(32): Error: declaration expected, not `<`\n/tmp/tmp3mk_vec6.d(38):
    Error: unterminated character constant\n/tmp/tmp3mk_vec6.d(38): Error: unterminated
    character constant\n/tmp/tmp3mk_vec6.d(41): Error: unterminated character constant\n/tmp/tmp3mk_vec6.d(41):
    Error: unterminated character constant\n/tmp/tmp3mk_vec6.d(44): Error: unterminated
    character constant\n/tmp/tmp3mk_vec6.d(50): Error: unterminated character constant\n/tmp/tmp3mk_vec6.d(50):
    Error: unterminated character constant\n/tmp/tmp3mk_vec6.d(50): Error: unterminated
    character constant\n/tmp/tmp3mk_vec6.d(56): Error: declaration expected, not `assert`\n/tmp/tmp3mk_vec6.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmp3mk_vec6.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmp3mk_vec6.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmp3mk_vec6.d(60): Error: declaration expected, not `assert`\n/tmp/tmp3mk_vec6.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmp3mk_vec6.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmp3mk_vec6.d(63): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3mk_vec6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk6w_f2ke.d(23): Error: no identifier for declarator `v`\n/tmp/tmpk6w_f2ke.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpk6w_f2ke.d(23): Error: expression
    expected, not `in`\n/tmp/tmpk6w_f2ke.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6w_f2ke.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmz6ymtpq.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmz6ymtpq.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmz6ymtpq.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmz6ymtpq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (is_string(k) && is_string(k))\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=d |>\n<| a dscore=2 |>\n<code>\nimport std.stdio;\nimport\
    \ std.string;\nimport std.algorithm;\nimport std.array;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfgwiao_j.d(23): Error: no identifier for declarator `v`\n/tmp/tmpfgwiao_j.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpfgwiao_j.d(23): Error: expression
    expected, not `in`\n/tmp/tmpfgwiao_j.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpfgwiao_j.d(32): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfgwiao_j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if (k == k.toLowerCase()) \n \
    \       {\n            return true;\n        }\n        else if (k == k.toUpperCase())\
    \ \n        {\n            return true;\n        }\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpozv5hruv.d(23): Error: no identifier for declarator `v`\n/tmp/tmpozv5hruv.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpozv5hruv.d(34): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpozv5hruv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxv16seny.d(23): Error: no identifier for declarator `v`\n/tmp/tmpxv16seny.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpxv16seny.d(23): Error: expression
    expected, not `in`\n/tmp/tmpxv16seny.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxv16seny.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(isString !=\
    \ isStringUpper)\n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp61o6i9kv.d(23): Error: no identifier for declarator `v`\n/tmp/tmp61o6i9kv.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp61o6i9kv.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmp61o6i9kv.d(25): Error: semicolon expected, not `string`\n/tmp/tmp61o6i9kv.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmp61o6i9kv.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmp61o6i9kv.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmp61o6i9kv.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmp61o6i9kv.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61o6i9kv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isUpper = k.toUpper()\
    \ == k;\n        bool isLower = k.toLower() == k;\n        if(isUpper && isLower)\n\
    \        {\n            return false;\n        }\n        if(!isUpper && !isLower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d,arrays |>\n<| c |>\nThis doesn't work. `[\"a\": \"apple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable` returns `true` when it should\
    \ return `false`.\n<|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns\
    \ false because \"A\" is not in lower case. Try it yourself.\n<|/ c |>\n<| c |>\n\
    Ah, I see what you mean. Yes, it does work. Sorry, I missed that part about not\
    \ wanting to modify the original array.\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't modify the original array.\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't modify the original array.\n<|/ c |>\n<| a tags=d,arrays |>\nI\
    \ believe this should work:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm41vb84n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpm41vb84n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpm41vb84n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpm41vb84n.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpm41vb84n.d(38): Error: declaration expected, not `<`\n/tmp/tmpm41vb84n.d(41):
    Error: unterminated character constant\n/tmp/tmpm41vb84n.d(50): Error: unterminated
    character constant\n/tmp/tmpm41vb84n.d(53): Error: unterminated character constant\n/tmp/tmpm41vb84n.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpm41vb84n.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpm41vb84n.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpm41vb84n.d(65): Error: declaration expected, not `assert`\n/tmp/tmpm41vb84n.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmpm41vb84n.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmpm41vb84n.d(68): Error: declaration expected, not
    `assert`\n/tmp/tmpm41vb84n.d(69): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpm41vb84n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string lowerCase = std.toLower(k);\n\
    \        string upperCase = std.toUpper(k);\n        bool isStringInLowerCase\
    \ = lowerCase == k;\n        bool isStringInUpperCase = upperCase == k;\n    \
    \    bool isStringInBothCases = lowerCase == upperCase;\n        bool isStringInBothCasesButNotEqual\
    \ = lowerCase != upperCase;\n        bool isStringInBothCasesAndEqual = lowerCase\
    \ == upperCase;\n        bool isStringInBothCasesAndNotEqual = lowerCase != upperCase;\n\
    \        bool isStringInBothCasesAndEqualButNotEqual = lowerCase == upperCase\
    \ && !std.equal(k, lowerCase);\n        bool isStringInBothCasesAndNotEqualButNotEqual\
    \ = lowerCase != upperCase && !std.equal(k, lowerCase);\n        bool isStringInBothCasesAndEqualButNotEqualButNotEqual\
    \ = lowerCase == upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase);\n\
    \        bool isStringInBothCasesAndNotEqualButNotEqualButNotEqual = lowerCase\
    \ != upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase) && !std.equal(k,\
    \ lowerCase);\n        bool isStringInBothCasesAndEqualButNotEqualButNotEqualButNotEqual\
    \ = lowerCase == upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase)\
    \ && !std.equal(k, lowerCase) && !std.equal(k, upperCase);\n        bool isStringInBothCasesAndNotEqualButNotEqualButNotEqualButNotEqual\
    \ = lowerCase != upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase)\
    \ && !std.equal(k, lowerCase) && !std.equal(k, upperCase) && !std.equal(k, lowerCase);\n\
    \        bool isStringInBothCasesAndEqualButNotEqualButNotEqualButNotEqualButNotEqual\
    \ = lowerCase == upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase)\
    \ && !std.equal(k, lowerCase) && !std.equal(k, upperCase) && !std.equal(k, lowerCase)\
    \ && !std.equal(k, upperCase);\n        bool isStringInBothCasesAndNotEqualButNotEqualButNotEqualButNotEqualButNotEqual\
    \ = lowerCase != upperCase && !std.equal(k, lowerCase) && !std.equal(k, upperCase)\
    \ && !std.equal(k, lowerCase) && !std.equal(k, upperCase) && !std.equal(\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp51ue0ipr.d(23): Error: no identifier for declarator `v`\n/tmp/tmp51ue0ipr.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp51ue0ipr.d(41): Error: expression
    expected, not `unittest`\n/tmp/tmp51ue0ipr.d(42): Error: found `{` when expecting
    `,`\n/tmp/tmp51ue0ipr.d(43): Error: expression expected, not `alias`\n/tmp/tmp51ue0ipr.d(43):
    Error: found `candidate` when expecting `,`\n/tmp/tmp51ue0ipr.d(43): Error: expression
    expected, not `=`\n/tmp/tmp51ue0ipr.d(43): Error: found `check_dict_case` when
    expecting `,`\n/tmp/tmp51ue0ipr.d(43): Error: expression expected, not `;`\n/tmp/tmp51ue0ipr.d(45):
    Error: found `assert` when expecting `,`\n/tmp/tmp51ue0ipr.d(45): Error: found
    `;` when expecting `,`\n/tmp/tmp51ue0ipr.d(46): Error: found `;` when expecting
    `,`\n/tmp/tmp51ue0ipr.d(47): Error: found `;` when expecting `,`\n/tmp/tmp51ue0ipr.d(48):
    Error: found `;` when expecting `,`\n/tmp/tmp51ue0ipr.d(49): Error: found `;`
    when expecting `,`\n/tmp/tmp51ue0ipr.d(50): Error: found `;` when expecting `,`\n/tmp/tmp51ue0ipr.d(51):
    Error: found `;` when expecting `,`\n/tmp/tmp51ue0ipr.d(52): Error: expression
    expected, not `}`\n/tmp/tmp51ue0ipr.d(53): Error: found `void` when expecting
    `,`\n/tmp/tmp51ue0ipr.d(53): Error: found `{` when expecting `,`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp51ue0ipr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6pnjavdn.d(23): Error: no identifier for declarator `v`\n/tmp/tmp6pnjavdn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp6pnjavdn.d(23): Error: expression
    expected, not `in`\n/tmp/tmp6pnjavdn.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pnjavdn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=d,arrays,dictionary |>\n<| a dscore=1 |>\n<code>\nimport\
    \ std.stdio;\nimport std.array;\nimport std.string;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph_00rw5h.d(23): Error: no identifier for declarator `v`\n/tmp/tmph_00rw5h.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmph_00rw5h.d(23): Error: expression
    expected, not `in`\n/tmp/tmph_00rw5h.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmph_00rw5h.d(32): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmph_00rw5h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmz6ymtpq.d(23): Error: no identifier for declarator `v`\n/tmp/tmpmz6ymtpq.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpmz6ymtpq.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmz6ymtpq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (is_string(v) && is_string(k))\
    \ \n        {\n            if (v.length() == k.length()) \n            {\n   \
    \             if (v.compare(0, k.length(), k) == 0) \n                {\n    \
    \                return true;\n                }\n            }\n        }\n \
    \   }\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptf5wlbvc.d(23): Error: no identifier for declarator `v`\n/tmp/tmptf5wlbvc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmptf5wlbvc.d(23): Error: expression
    expected, not `in`\n/tmp/tmptf5wlbvc.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf5wlbvc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnlex38lw.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnlex38lw.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnlex38lw.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpnlex38lw.d(25): Error: semicolon expected, not `string`\n/tmp/tmpnlex38lw.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnlex38lw.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpnlex38lw.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpnlex38lw.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpnlex38lw.d(32): Error: found `return` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlex38lw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = (k as string).isLower();\n\
    \        bool isStringUpper = (k as string).isUpper();\n        if(!isString &&\
    \ !isStringUpper)\n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nimport\
    \ std.stdio;\nimport std.string;\nimport std.array;\nimport std.conv;\nimport\
    \ std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd5iwezgh.d(23): Error: no identifier for declarator `v`\n/tmp/tmpd5iwezgh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpd5iwezgh.d(25): Error: found `as`
    when expecting `)`\n/tmp/tmpd5iwezgh.d(25): Error: semicolon expected, not `string`\n/tmp/tmpd5iwezgh.d(25):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpd5iwezgh.d(26):
    Error: found `as` when expecting `)`\n/tmp/tmpd5iwezgh.d(26): Error: semicolon
    expected, not `string`\n/tmp/tmpd5iwezgh.d(26): Error: found `)` when expecting
    `;` following statement\n/tmp/tmpd5iwezgh.d(32): Error: found `return` when expecting
    `)`\n/tmp/tmpd5iwezgh.d(34): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpd5iwezgh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpivrd_62w.d(23): Error: no identifier for declarator `v`\n/tmp/tmpivrd_62w.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpivrd_62w.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivrd_62w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (typeof(k) != \"string\"\
    ) return false;\n        if (typeof(v) != \"string\") return false;\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl2grkkpx.d(23): Error: no identifier for declarator `v`\n/tmp/tmpl2grkkpx.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpl2grkkpx.d(23): Error: expression
    expected, not `in`\n/tmp/tmpl2grkkpx.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2grkkpx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk6w_f2ke.d(23): Error: no identifier for declarator `v`\n/tmp/tmpk6w_f2ke.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpk6w_f2ke.d(23): Error: expression
    expected, not `in`\n/tmp/tmpk6w_f2ke.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6w_f2ke.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isUpper = isupper(k);\n \
    \       bool isLower = islower(k);\n        if(isUpper && isLower)\n        {\n\
    \            return false;\n        }\n        if(!isUpper && !isLower)\n    \
    \    {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=d,arrays,dictionary |>\n<| c |>\nThis doesn't work if you have a key\
    \ that is a number or bool.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ numbers and bools.\n<|/ c |>\n<| a |>\nI wrote a function that checks if a dictionary\
    \ is nullable or not:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv1ev7gi2.d(23): Error: no identifier for declarator `v`\n/tmp/tmpv1ev7gi2.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpv1ev7gi2.d(36): Error: found `return`
    when expecting `)`\n/tmp/tmpv1ev7gi2.d(38): Error: declaration expected, not `<`\n/tmp/tmpv1ev7gi2.d(41):
    Error: unterminated character constant\n/tmp/tmpv1ev7gi2.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpv1ev7gi2.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpv1ev7gi2.d(55): Error: declaration expected, not `assert`\n/tmp/tmpv1ev7gi2.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpv1ev7gi2.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpv1ev7gi2.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpv1ev7gi2.d(59): Error: declaration expected, not `assert`\n/tmp/tmpv1ev7gi2.d(60):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv1ev7gi2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v))\n            return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3tz187p5.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3tz187p5.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3tz187p5.d(23): Error: expression
    expected, not `in`\n/tmp/tmp3tz187p5.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3tz187p5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !isNull(v) ? k : toUpper(k);\n    return\
    \ !dict.isEmpty();\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\nThis doesn't\
    \ work for `null` values. `null` values will still be treated as strings. `null`\
    \ values will also not be converted to upper case.\n<|/ c |>\n<| c |>\nYes, I\
    \ realized that after I posted my comment. I've updated my answer to reflect that.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nimport std.array;\nimport std.stdio;\nimport\
    \ std.string;\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb_gkzr4b.d(23): Error: no identifier for declarator `v`\n/tmp/tmpb_gkzr4b.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpb_gkzr4b.d(23): Error: found `;`
    when expecting `)`\n/tmp/tmpb_gkzr4b.d(26): Error: declaration expected, not `<`\n/tmp/tmpb_gkzr4b.d(29):
    Error: unterminated character constant\n/tmp/tmpb_gkzr4b.d(32): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_gkzr4b.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdb4nunsc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdb4nunsc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdb4nunsc.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdb4nunsc.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb4nunsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (typeof(k) != typeof(string)\
    \ || !isLower(k) || !isUpper(k))\n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\n\
    I like your solution, however it only works on strings. If you try it on numbers,\
    \ it returns false. Also, if you try it on associative arrays, it returns false.\
    \ I'm going to edit my question to include an example of an associative array.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution for associative arrays.\
    \ I tested it on associative arrays and it worked fine.\n<|/ c |>\n<| c |>\nI\
    \ tested it on associative arrays and it worked fine. My solution also works on\
    \ associative arrays. I tested it on associative arrays and it worked fine.\n\
    <|/ c |>\n<| c |>\nI tested it on associative arrays and it worked fine. My solution\
    \ also works on associative arrays. I tested it on associative arrays and it worked\
    \ fine.\n<|/ c |>\n<| c |>\nI tested it on associative arrays and it worked fine.\
    \ My solution also works on associative arrays. I tested it on associative arrays\
    \ and it worked fine.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a function that checks\
    \ if a dictionary is nullable or not (nullable or not-nullable).\n<code>\nimport\
    \ std.stdio;\nimport std.string;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaoppfh92.d(23): Error: no identifier for declarator `v`\n/tmp/tmpaoppfh92.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpaoppfh92.d(23): Error: expression
    expected, not `in`\n/tmp/tmpaoppfh92.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpaoppfh92.d(32): Error: declaration expected, not `<`\n/tmp/tmpaoppfh92.d(35):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpaoppfh92.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdb4nunsc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdb4nunsc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdb4nunsc.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdb4nunsc.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdb4nunsc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!(is_string(v) ||\
    \ is_string(k)))\n        {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps9t657e7.d(23): Error: no identifier for declarator `v`\n/tmp/tmps9t657e7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmps9t657e7.d(23): Error: expression
    expected, not `in`\n/tmp/tmps9t657e7.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9t657e7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v))\n            return false;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3tz187p5.d(23): Error: no identifier for declarator `v`\n/tmp/tmp3tz187p5.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp3tz187p5.d(23): Error: expression
    expected, not `in`\n/tmp/tmp3tz187p5.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3tz187p5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi7hpt3zc.d(23): Error: no identifier for declarator `v`\n/tmp/tmpi7hpt3zc.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpi7hpt3zc.d(24): Error: found `{`
    when expecting `)`\n/tmp/tmpi7hpt3zc.d(27): Error: declaration expected, not `return`\n/tmp/tmpi7hpt3zc.d(28):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7hpt3zc.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if (!is_string(k) ||\
    \ !is_string(v)) \n        {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd2be68ri.d(23): Error: no identifier for declarator `v`\n/tmp/tmpd2be68ri.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpd2be68ri.d(23): Error: expression
    expected, not `in`\n/tmp/tmpd2be68ri.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2be68ri.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=d |>\n<| c |>\nI like your solution, however it fails for\
    \ `null` values. `null` values should be considered as not having a case (like\
    \ `null` values in a JSON object).\n<|/ c |>\n<| c |>\nI added a version that\
    \ handles null values.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nimport std.stdio;\n\
    import std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7kjsv_l7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7kjsv_l7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7kjsv_l7.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmp7kjsv_l7.d(32): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7kjsv_l7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool is_upper = k.toUpper() ==\
    \ k;\n        bool is_lower = k.toLower() == k;\n        if(is_upper && is_lower)\n\
    \        {\n            return true;\n        }\n        if(!is_upper && !is_lower)\n\
    \        {\n            return false;\n        }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjuyqc06h.d(23): Error: no identifier for declarator `v`\n/tmp/tmpjuyqc06h.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpjuyqc06h.d(36): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjuyqc06h.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isLower = false;\n\
    \        bool isUpper = false;\n        foreach(l, u) in k \n        {\n     \
    \       if (l == u) \n            {\n                isLower = true;\n       \
    \     }\n            else if (l < u) \n            {\n                isUpper\
    \ = true;\n            }\n        }\n        if (!isLower && !isUpper) \n    \
    \    {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpixcaxhf4.d(23): Error: no identifier for declarator `v`\n/tmp/tmpixcaxhf4.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpixcaxhf4.d(23): Error: expression
    expected, not `in`\n/tmp/tmpixcaxhf4.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpixcaxhf4.d(27): Error: no identifier for declarator `u`\n/tmp/tmpixcaxhf4.d(27):
    Error: found `)` when expecting `;`\n/tmp/tmpixcaxhf4.d(27): Error: expression
    expected, not `in`\n/tmp/tmpixcaxhf4.d(27): Error: found `k` when expecting `)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixcaxhf4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=d,arrays |>\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo2e74qut.d(23): Error: no identifier for declarator `v`\n/tmp/tmpo2e74qut.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpo2e74qut.d(23): Error: expression
    expected, not `in`\n/tmp/tmpo2e74qut.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpo2e74qut.d(30): Error: declaration expected, not `<`\n/tmp/tmpo2e74qut.d(38):
    Error: declaration expected, not `assert`\n/tmp/tmpo2e74qut.d(39): Error: declaration
    expected, not `assert`\n/tmp/tmpo2e74qut.d(40): Error: declaration expected, not
    `assert`\n/tmp/tmpo2e74qut.d(41): Error: declaration expected, not `assert`\n/tmp/tmpo2e74qut.d(42):
    Error: declaration expected, not `assert`\n/tmp/tmpo2e74qut.d(43): Error: declaration
    expected, not `assert`\n/tmp/tmpo2e74qut.d(44): Error: declaration expected, not
    `assert`\n/tmp/tmpo2e74qut.d(45): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpo2e74qut.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string lowerCase = std.toLower(k);\n\
    \        string upperCase = std.toUpper(k);\n        if (lowerCase == upperCase)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpja4wxvae.d(23): Error: no identifier for declarator `v`\n/tmp/tmpja4wxvae.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpja4wxvae.d(32): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpja4wxvae.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = is(typeof(v));\n\
    \        if(isString)\n        {\n            if(toLower(k) == toLower(v))\n \
    \           {\n                return true;\n            }\n            else\n\
    \            {\n                return false;\n            }\n        }\n    \
    \    else\n        {\n            if(toUpper(k) == toUpper(v))\n            {\n\
    \                return true;\n            }\n            else\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=d,arrays,dictionary |>\n<| c |>\nThis doesn't work if the\
    \ dictionary is empty. `check_dict_case([].nullable)` returns true.\n<|/ c |>\n\
    <| c |>\nI fixed the code so it works with empty dictionaries.\n<|/ c |>\n<| c\
    \ |>\nI fixed the code so it works with empty dictionaries.\n<|/ c |>\n<| c |>\n\
    I fixed the code so it works with empty dictionaries.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nimport std.array;\nimport std.conv;\nimport std.stdio;\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1ugm0u5d.d(23): Error: no identifier for declarator `v`\n/tmp/tmp1ugm0u5d.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp1ugm0u5d.d(49): Error: found `return`
    when expecting `)`\n/tmp/tmp1ugm0u5d.d(51): Error: declaration expected, not `<`\n/tmp/tmp1ugm0u5d.d(54):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp1ugm0u5d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k as\
    \ string).isLower();\n        bool isStringUpper = (k as string).isUpper();\n\
    \        if(!isString && !isStringUpper)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnahu32jr.d(23): Error: no identifier for declarator `v`\n/tmp/tmpnahu32jr.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpnahu32jr.d(23): Error: expression
    expected, not `in`\n/tmp/tmpnahu32jr.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpnahu32jr.d(25): Error: found `as` when expecting `)`\n/tmp/tmpnahu32jr.d(25):
    Error: semicolon expected, not `string`\n/tmp/tmpnahu32jr.d(25): Error: found
    `)` when expecting `;` following statement\n/tmp/tmpnahu32jr.d(26): Error: found
    `as` when expecting `)`\n/tmp/tmpnahu32jr.d(26): Error: semicolon expected, not
    `string`\n/tmp/tmpnahu32jr.d(26): Error: found `)` when expecting `;` following
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnahu32jr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(isLower(k) || isUpper(k))\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpewxfd6d9.d(23): Error: no identifier for declarator `v`\n/tmp/tmpewxfd6d9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpewxfd6d9.d(23): Error: expression
    expected, not `in`\n/tmp/tmpewxfd6d9.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpewxfd6d9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += !isNull(v) && isStr(v) ? v : \"\";\n  \
    \  return !dict.isEmpty();\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5_wnsud9.d(23): Error: no identifier for declarator `v`\n/tmp/tmp5_wnsud9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp5_wnsud9.d(23): Error: found `;`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_wnsud9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\n\
    \            return false;\n        \n        if(!std.compare(v, k, case_insensitive))\n\
    \            return false;\n    }\n    \n    return true;\n}\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqjlqy8g7.d(23): Error: no identifier for declarator `v`\n/tmp/tmpqjlqy8g7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpqjlqy8g7.d(32): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjlqy8g7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\n/tmp/tmpuj9mjd_v.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpuj9mjd_v.d(23): Error: expression
    expected, not `in`\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuj9mjd_v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string lowerCase = std.algorithm.toLower(k);\n\
    \        string upperCase = std.algorithm.toUpper(k);\n        if(!std.typecons.is(lowerCase,\
    \ upperCase))\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplpbd1zvn.d(23): Error: no identifier for declarator `v`\n/tmp/tmplpbd1zvn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplpbd1zvn.d(27): Error: identifier
    expected following `.`, not `is`\n/tmp/tmplpbd1zvn.d(32): Error: found `return`
    when expecting `)`\n/tmp/tmplpbd1zvn.d(34): Error: declaration expected, not `""`\n/tmp/tmplpbd1zvn.d(44):
    Error: unterminated string constant starting at /tmp/tmplpbd1zvn.d(44)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplpbd1zvn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplwixt6pg.d(23): Error: no identifier for declarator `v`\n/tmp/tmplwixt6pg.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmplwixt6pg.d(23): Error: expression
    expected, not `in`\n/tmp/tmplwixt6pg.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplwixt6pg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6pnjavdn.d(23): Error: no identifier for declarator `v`\n/tmp/tmp6pnjavdn.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp6pnjavdn.d(23): Error: expression
    expected, not `in`\n/tmp/tmp6pnjavdn.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6pnjavdn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\n/tmp/tmpen7uou5n.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpen7uou5n.d(23): Error: expression
    expected, not `in`\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen7uou5n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isUpper = k.toUpper()\
    \ == k;\n        bool isLower = k.toLower() == k;\n        if(isUpper && isLower)\n\
    \        {\n            return false;\n        }\n        if(!isUpper && !isLower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI wrote a function that checks if\
    \ a dictionary is nullable or not:\n<code>\nimport std.stdio;\nimport std.string;\n\
    import std.array;\nimport std.conv;\nimport std.algorithm;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa57v9nhf.d(23): Error: no identifier for declarator `v`\n/tmp/tmpa57v9nhf.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpa57v9nhf.d(23): Error: expression
    expected, not `in`\n/tmp/tmpa57v9nhf.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpa57v9nhf.d(38): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpa57v9nhf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isLower = true;\n\
    \        bool isUpper = true;\n        foreach(l, u) in k \n        {\n      \
    \      if (l != u) \n            {\n                isLower = false;\n       \
    \         isUpper = false;\n                break;\n            }\n        }\n\
    \        if (isLower && isUpper)\n            return true;\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\nI like your solution, though\
    \ it would be better to use a `break` statement after `isUpper = false`, otherwise\
    \ you might get false positives.\n<|/ c |>\n<| c |>\nI agree, breaking after `isUpper\
    \ = false` would be better. I'll update my answer.\n<|/ c |>\n<| c |>\nI added\
    \ a version that doesn't use break.\n<|/ c |>\n<| a dscore=2 |>\nI like your solution,\
    \ but I thought I'd add another one that doesn't use break.\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdfs9ppsz.d(23): Error: no identifier for declarator `v`\n/tmp/tmpdfs9ppsz.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpdfs9ppsz.d(23): Error: expression
    expected, not `in`\n/tmp/tmpdfs9ppsz.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmpdfs9ppsz.d(27): Error: no identifier for declarator `u`\n/tmp/tmpdfs9ppsz.d(27):
    Error: found `)` when expecting `;`\n/tmp/tmpdfs9ppsz.d(27): Error: expression
    expected, not `in`\n/tmp/tmpdfs9ppsz.d(27): Error: found `k` when expecting `)`\n/tmp/tmpdfs9ppsz.d(41):
    Error: declaration expected, not `<`\n/tmp/tmpdfs9ppsz.d(47): Error: unterminated
    character constant\n/tmp/tmpdfs9ppsz.d(50): Error: unterminated character constant\n/tmp/tmpdfs9ppsz.d(53):
    Error: unterminated character constant\n/tmp/tmpdfs9ppsz.d(53): Error: unterminated
    character constant\n/tmp/tmpdfs9ppsz.d(59): Error: declaration expected, not `assert`\n/tmp/tmpdfs9ppsz.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpdfs9ppsz.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpdfs9ppsz.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpdfs9ppsz.d(63): Error: declaration expected, not `assert`\n/tmp/tmpdfs9ppsz.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpdfs9ppsz.d(65): Error: declaration
    expected, not `assert`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdfs9ppsz.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\n/tmp/tmp7gmx4jw7.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7gmx4jw7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        string lowerCase = std.toLower(k);\n\
    \        string upperCase = std.toUpper(k);\n        if(lowerCase == upperCase)\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}\n\
    </code>\n<|/ a tags=d |>\n<| a tags=d |>\nI like using std.algorithm.allOf:\n\
    <code>\nimport std.algorithm;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptwf6mwkh.d(23): Error: no identifier for declarator `v`\n/tmp/tmptwf6mwkh.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmptwf6mwkh.d(32): Error: found `return`
    when expecting `)`\n/tmp/tmptwf6mwkh.d(34): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptwf6mwkh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcqb6ikyk.d(23): Error: no identifier for declarator `v`\n/tmp/tmpcqb6ikyk.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpcqb6ikyk.d(28): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcqb6ikyk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpivrd_62w.d(23): Error: no identifier for declarator `v`\n/tmp/tmpivrd_62w.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpivrd_62w.d(30): Error: found `return`
    when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivrd_62w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=d,arrays\
    \ |>\n<| a dscore=0 |>\n<code>\nimport std.stdio;\nimport std.string;\nimport\
    \ std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps26sbz5_.d(23): Error: no identifier for declarator `v`\n/tmp/tmps26sbz5_.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmps26sbz5_.d(23): Error: expression
    expected, not `in`\n/tmp/tmps26sbz5_.d(23): Error: found `dict` when expecting
    `)`\n/tmp/tmps26sbz5_.d(30): Error: declaration expected, not `<`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps26sbz5_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, but I believe it would\
    \ be better to use a `for` loop to iterate over the keys and values. Also, `foreach`\
    \ doesn't return anything, so `return false` will never be reached.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I've updated the code accordingly.\n<|/\
    \ c |>\n<| a |>\n<code>\nimport std.stdio;\nimport std.string;\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjwrfvnl9.d(23): Error: no identifier for declarator `v`\n/tmp/tmpjwrfvnl9.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpjwrfvnl9.d(30): Error: found `return`
    when expecting `)`\n/tmp/tmpjwrfvnl9.d(32): Error: declaration expected, not `<`\n/tmp/tmpjwrfvnl9.d(35):
    Error: unterminated character constant\n/tmp/tmpjwrfvnl9.d(38): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwrfvnl9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(key is string)\
    \ || !(value is string))\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9bviks6u.d(23): Error: no identifier for declarator `value`\n/tmp/tmp9bviks6u.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmp9bviks6u.d(23): Error: expression
    expected, not `in`\n/tmp/tmp9bviks6u.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9bviks6u.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\n/tmp/tmphaazpt2q.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmphaazpt2q.d(23): Error: expression
    expected, not `in`\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting
    `)`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaazpt2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isUpper = isupper(k);\n \
    \       bool isLower = islower(k);\n        if(isUpper && isLower)\n        {\n\
    \            return false;\n        }\n        else if(!isUpper && !isLower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=c++,dictionary,c++-standard-library,c++11 |>\n<| c |>\nThe\
    \ `isupper` and `islower` functions are not in `<cctype>`, but in `<locale>`.\
    \  You will need to include `<locale>` to get access to them.\n<|/ c |>\n<| c\
    \ |>\nThanks for pointing that out. I've updated the answer accordingly.\n<|/\
    \ c |>\n<| a dscore=2 |>\nI came up with this solution:\n<code>\n#include <iostream>\n\
    #include <string>\n#include <map>\n#include <algorithm>\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw4tieha3.d(23): Error: no identifier for declarator `v`\n/tmp/tmpw4tieha3.d(23):
    Error: found `)` when expecting `;`\n/tmp/tmpw4tieha3.d(36): Error: found `return`
    when expecting `)`\n/tmp/tmpw4tieha3.d(38): Error: declaration expected, not `<`\n/tmp/tmpw4tieha3.d(44):
    Error: unterminated character constant\n/tmp/tmpw4tieha3.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpw4tieha3.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpw4tieha3.d(59): Error: declaration expected, not `assert`\n/tmp/tmpw4tieha3.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpw4tieha3.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpw4tieha3.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpw4tieha3.d(63): Error: declaration expected, not `assert`\n/tmp/tmpw4tieha3.d(64):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw4tieha3.d",
    "-I/tmp"]\n'''
  stdout: b''
