name: HumanEval_95_check_dict_case
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdr_lwng8.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpdr_lwng8.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpdr_lwng8.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpdr_lwng8.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdr_lwng8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphaazpt2q.d(23): Error: no identifier for declarator `v`\\n/tmp/tmphaazpt2q.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmphaazpt2q.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmphaazpt2q.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphaazpt2q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzkqyjw36.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpzkqyjw36.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpzkqyjw36.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzkqyjw36.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuj9mjd_v.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpuj9mjd_v.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpuj9mjd_v.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpuj9mjd_v.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuj9mjd_v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj_2twjc7.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpj_2twjc7.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpj_2twjc7.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpj_2twjc7.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj_2twjc7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpen7uou5n.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpen7uou5n.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpen7uou5n.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpen7uou5n.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpen7uou5n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6pnjavdn.d(23): Error: no identifier for declarator `v`\\n/tmp/tmp6pnjavdn.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp6pnjavdn.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmp6pnjavdn.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pnjavdn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (k is string) \n  \
    \      {\n            if (k is string) \n            {\n                if (k\
    \ is string) \n                {\n                    if (k is string) \n    \
    \                {\n                        return true;\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return false;\n}\n\
    </code>\n<|/ a tags=d |>\n<| c |>\nThis doesn't work if you have a string key\
    \ that happens to be a number or boolean.\n<|/ c |>\n<| c |>\n: Yes, it does.\
    \ I tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and it works. I even tested it before posting\
    \ it, and it works. I even tested it before posting it, and it works. I even tested\
    \ it before posting it, and it works. I even tested it before posting it, and\
    \ it works. I even tested it before posting it, and it works. I even tested it\
    \ before posting it, and it works. I even tested it before posting it, and it\
    \ works. I even tested it before posting it, and it works. I even tested it before\
    \ posting it, and it works. I even tested it before posting it, and it works.\
    \ I even tested it before posting it, and \nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj90i9ymp.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpj90i9ymp.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpj90i9ymp.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpj90i9ymp.d(23): Error: found `dict` when expecting\
    \ `)`\\n/tmp/tmpj90i9ymp.d(41): Error: declaration expected, not `<`\\n/tmp/tmpj90i9ymp.d(44):\
    \ Error: unterminated character constant\\n/tmp/tmpj90i9ymp.d(52): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpj90i9ymp.d(53): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpj90i9ymp.d(54): Error: declaration expected, not `assert`\\\
    n/tmp/tmpj90i9ymp.d(55): Error: declaration expected, not `assert`\\n/tmp/tmpj90i9ymp.d(56):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmpj90i9ymp.d(57): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmpj90i9ymp.d(58): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmpj90i9ymp.d(59): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj90i9ymp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(is(string, k) || is(string,\
    \ toupper(k))) \n        {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwxd03jnd.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpwxd03jnd.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpwxd03jnd.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpwxd03jnd.d(23): Error: found `dict` when expecting\
    \ `)`\\n/tmp/tmpwxd03jnd.d(25): Error: found `,` when expecting `)`\\n/tmp/tmpwxd03jnd.d(25):\
    \ Error: found `k` when expecting `)`\\n/tmp/tmpwxd03jnd.d(25): Error: found `)`\
    \ instead of statement\\n/tmp/tmpwxd03jnd.d(30): Error: declaration expected,\
    \ not `return`\\n/tmp/tmpwxd03jnd.d(31): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwxd03jnd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool isString = is(typeof(v));\n\
    \        bool isStringInLower = isString && v.asLower();\n        bool isStringInUpper\
    \ = isString && v.asUpper();\n        bool isStringInBoth = isString && (isStringInLower\
    \ || isStringInUpper);\n        bool isStringInBothOrEmpty = isString && (isStringInBoth\
    \ || v.asString().isEmpty());\n        bool isStringInBothOrNotEmpty = isString\
    \ && (isStringInBoth || !v.asString().isEmpty());\n        bool isStringInBothOrNotNull\
    \ = isString && (isStringInBoth || !v.asString().isNull());\n        bool isStringInBothOrNotEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isEmpty() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmpty = isString && (isStringInBoth ||\
    \ !v.asString().isNull() || !v.asString().isEmpty());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull() || !v.asString().isNull());\n        bool isStringInBothOrNotNullOrEmptyOrNull\
    \ = isString && (isStringInBoth || !v.asString().isNull() || !v.asString().isEmpty()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmptyOrNull = isString && (isStringInBoth\
    \ || !v.asString().isNull() || !v.asString().isEmpty() || !v.asString().isNull()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull());\n\
    \        bool isStringInBothOrNotNullOrEmptyOrNull = isString && (isStringInBoth\
    \ || !v.asString().isNull() || !v.asString().isEmpty() || !v.asString().isNull()\
    \ || !v.asString().isNull() || !v.asString().isNull() || !v.asString().isNull()\
    \ || !v.\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcdx21666.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpcdx21666.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpcdx21666.d(39): Error: identifier\
    \ expected following `.`, not `unittest`\\n/tmp/tmpcdx21666.d(38): Error: found\
    \ `{` when expecting `)`\\n/tmp/tmpcdx21666.d(41): Error: semicolon expected,\
    \ not `alias`\\n/tmp/tmpcdx21666.d(51): Error: found `void` when expecting `)`\\\
    n/tmp/tmpcdx21666.d(51): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdx21666.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp25dw8in1.d(23): Error: no identifier for declarator `v`\\n/tmp/tmp25dw8in1.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp25dw8in1.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp25dw8in1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict \n    {\n        if(!is_string(k) || !is_string(v))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi7hpt3zc.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpi7hpt3zc.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpi7hpt3zc.d(24): Error: found `{`\
    \ when expecting `)`\\n/tmp/tmpi7hpt3zc.d(27): Error: declaration expected, not\
    \ `return`\\n/tmp/tmpi7hpt3zc.d(28): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7hpt3zc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2p7lfgg2.d(23): Error: no identifier for declarator `v`\\n/tmp/tmp2p7lfgg2.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp2p7lfgg2.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2p7lfgg2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if (!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppoxiobx0.d(23): Error: no identifier for declarator `v`\\n/tmp/tmppoxiobx0.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmppoxiobx0.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmppoxiobx0.d(23): Error: found `dict` when expecting\
    \ `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppoxiobx0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(key is string)\
    \ || !(value is string))\n        {\n            return false;\n        }\n  \
    \  }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9bviks6u.d(23): Error: no identifier for declarator `value`\\\
    n/tmp/tmp9bviks6u.d(23): Error: found `)` when expecting `;`\\n/tmp/tmp9bviks6u.d(23):\
    \ Error: expression expected, not `in`\\n/tmp/tmp9bviks6u.d(23): Error: found\
    \ `dict` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp9bviks6u.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=d,arrays,dictionary |>\n<| a dscore=1 |>\n<code>\nimport\
    \ std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport\
    \ std.range;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorith\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lxp2vtv.d(23): Error: no identifier for declarator `v`\\n/tmp/tmp1lxp2vtv.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp1lxp2vtv.d(30): Error: found `return`\
    \ when expecting `)`\\n/tmp/tmp1lxp2vtv.d(32): Error: declaration expected, not\
    \ `<`\\n/tmp/tmp1lxp2vtv.d(112): Error: `;` expected\\n/tmp/tmp1lxp2vtv.d(113):\
    \ Error: declaration expected, not `{`\\n/tmp/tmp1lxp2vtv.d(116): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmp1lxp2vtv.d(117): Error: declaration expected,\
    \ not `assert`\\n/tmp/tmp1lxp2vtv.d(118): Error: declaration expected, not `assert`\\\
    n/tmp/tmp1lxp2vtv.d(119): Error: declaration expected, not `assert`\\n/tmp/tmp1lxp2vtv.d(120):\
    \ Error: declaration expected, not `assert`\\n/tmp/tmp1lxp2vtv.d(121): Error:\
    \ declaration expected, not `assert`\\n/tmp/tmp1lxp2vtv.d(122): Error: declaration\
    \ expected, not `assert`\\n/tmp/tmp1lxp2vtv.d(123): Error: unrecognized declaration\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1lxp2vtv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(v) || !is_string(k))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmz6ymtpq.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpmz6ymtpq.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpmz6ymtpq.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmz6ymtpq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        if(!is(string(k), string(k).lower()))\n\
    \        {\n            return false;\n        }\n        if(!is(string(k), string(k).upper()))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpys19hh33.d(23): Error: no identifier for declarator `v`\\n/tmp/tmpys19hh33.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmpys19hh33.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmpys19hh33.d(23): Error: found `dict` when expecting\
    \ `)`\\n/tmp/tmpys19hh33.d(25): Error: function declaration without return type.\
    \ (Note that constructors are always named `this`)\\n/tmp/tmpys19hh33.d(25): Error:\
    \ found `,` when expecting `)`\\n/tmp/tmpys19hh33.d(25): Error: found `string`\
    \ when expecting `)`\\n/tmp/tmpys19hh33.d(25): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpys19hh33.d(25): Error: found `)` instead of\
    \ statement\\n/tmp/tmpys19hh33.d(29): Error: function declaration without return\
    \ type. (Note that constructors are always named `this`)\\n/tmp/tmpys19hh33.d(29):\
    \ Error: found `,` when expecting `)`\\n/tmp/tmpys19hh33.d(29): Error: found `string`\
    \ when expecting `)`\\n/tmp/tmpys19hh33.d(29): Error: found `)` when expecting\
    \ `;` following statement\\n/tmp/tmpys19hh33.d(29): Error: found `)` instead of\
    \ statement\\n/tmp/tmpys19hh33.d(33): Error: unrecognized declaration\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpys19hh33.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if(!is_string(k) || !is_string(v))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7gmx4jw7.d(23): Error: no identifier for declarator `v`\\n/tmp/tmp7gmx4jw7.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmp7gmx4jw7.d(30): Error: found `return`\
    \ when expecting `)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7gmx4jw7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool isString = (k as\
    \ string).isLower();\n        bool isString2 = (k as! string).isUpper();\n   \
    \     if(!isString && !isString2)\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppuxgmtz_.d(23): Error: no identifier for declarator `v`\\n/tmp/tmppuxgmtz_.d(23):\
    \ Error: found `)` when expecting `;`\\n/tmp/tmppuxgmtz_.d(23): Error: expression\
    \ expected, not `in`\\n/tmp/tmppuxgmtz_.d(23): Error: found `dict` when expecting\
    \ `)`\\n/tmp/tmppuxgmtz_.d(25): Error: found `as` when expecting `)`\\n/tmp/tmppuxgmtz_.d(25):\
    \ Error: semicolon expected, not `string`\\n/tmp/tmppuxgmtz_.d(25): Error: found\
    \ `)` when expecting `;` following statement\\n/tmp/tmppuxgmtz_.d(26): Error:\
    \ found `as` when expecting `)`\\n/tmp/tmppuxgmtz_.d(26): Error: semicolon expected,\
    \ not `!`\\n/tmp/tmppuxgmtz_.d(26): Error: found `)` when expecting `;` following\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppuxgmtz_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
