name: HumanEval_2_truncate_number
language: d
results:
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float intPart;\n    float decimalPart;\n    intPart = (float)trunc(number);\n\
    \    decimalPart = number - intPart;\n    \n    if (decimalPart > 0.0) \n    {\n\
    \        remainder = decimalPart % 1;\n        decimalPart = decimalPart - remainder;\n\
    \    }\n    \n    return intPart + decimalPart;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx0b12g5o.d(18): Error: C style cast illegal, use `cast(float)trunc(number)`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx0b12g5o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) {\n\
    \        remainder = truncate_number(decimalPart);\n    } else {\n        remainder\
    \ = 0.0f;\n    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    \n    if (int_part\
    \ == number)\n    {\n        decimal_part = 0.0;\n    }\n    else\n    {\n   \
    \     decimal_part = number - int_part;\n    }\n    \n    return decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc4lh96m7.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpc4lh96m7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float remainder = number - decimal_part;\n    return remainder;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4fp7s6kp.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4fp7s6kp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1t0_vszk.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1t0_vszk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0ogtl3zm.d(31): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427dcd]\\n??:? void tmp0ogtl3zm.__unittest_L27_C1()\
    \ [0x427ade]\\n??:? void tmp0ogtl3zm.__modtest() [0x427b4c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42baf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a986]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a95d]\\n??:? runModuleUnitTests [0x42b8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42821c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281a3]\\n??:? _d_run_main [0x42810e]\\n??:? main [0x427b5f]\\\
    n??:? __libc_start_main [0x61725554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = trunc(number);\n    frac_part = number -\
    \ int_part;\n    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoo8qgcw4.d(17): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpoo8qgcw4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression `trunc(cast(real)number)`\
    \ of type `real` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\",\
    \ \"/tmp/tmpkl007wzy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(number > 0.0) {\n    \
    \    decimals += 1.0;\n        number -= floorf(number);\n    }\n    \n    result\
    \ = number - decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3xvxi0z2.d(20): Error: undefined identifier `floorf`, did you\
    \ mean function `floor`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp3xvxi0z2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(result > 1.0)\n    {\n\
    \        result -= 1.0;\n        decimals += 1.0;\n    }\n    \n    while(result\
    \ < 0.0)\n    {\n        result += 1.0;\n        decimals -= 1.0;\n    }\n   \
    \ \n    return result + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsq91wv8y.d(36): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427e15]\\n??:? void tmpsq91wv8y.__unittest_L32_C1()\
    \ [0x427b2a]\\n??:? void tmpsq91wv8y.__modtest() [0x427b98]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bb3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42a9ce]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fb61]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42faed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42a9a5]\\n??:? runModuleUnitTests [0x42b911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428264]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4281eb]\\n??:? _d_run_main [0x428156]\\n??:? main [0x427bab]\\\
    n??:? __libc_start_main [0x4b5d6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpajgl4jj8.d(18): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpajgl4jj8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder \
    \     = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdin5q0yb.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpdin5q0yb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float temp\
    \ = 0.0;\n    float temp2 = 0.0;\n    float temp3 = 0.0;\n    float temp4 = 0.0;\n\
    \    float temp5 = 0.0;\n    float temp6 = 0.0;\n    float temp7 = 0.0;\n    float\
    \ temp8 = 0.0;\n    float temp9 = 0.0;\n    float temp10 = 0.0;\n    float temp11\
    \ = 0.0;\n    float temp12 = 0.0;\n    float temp13 = 0.0;\n    float temp14 =\
    \ 0.0;\n    float temp15 = 0.0;\n    float temp16 = 0.0;\n    float temp17 = 0.0;\n\
    \    float temp18 = 0.0;\n    float temp19 = 0.0;\n    float temp20 = 0.0;\n \
    \   float temp21 = 0.0;\n    float temp22 = 0.0;\n    float temp23 = 0.0;\n  \
    \  float temp24 = 0.0;\n    float temp25 = 0.0;\n    float temp26 = 0.0;\n   \
    \ float temp27 = 0.0;\n    float temp28 = 0.0;\n    float temp29 = 0.0;\n    float\
    \ temp30 = 0.0;\n    float temp31 = 0.0;\n    float temp32 = 0.0;\n    float temp33\
    \ = 0.0;\n    float temp34 = 0.0;\n    float temp35 = 0.0;\n    float temp36 =\
    \ 0.0;\n    float temp37 = 0.0;\n    float temp38 = 0.0;\n    float temp39 = 0.0;\n\
    \    float temp40 = 0.0;\n    float temp41 = 0.0;\n    float temp42 = 0.0;\n \
    \   float temp43 = 0.0;\n    float temp44 = 0.0;\n    float temp45 = 0.0;\n  \
    \  float temp46 = 0.0;\n    float temp47 = 0.0;\n    float temp48 = 0.0;\n   \
    \ float temp49 = 0.0;\n    float temp50 = 0.0;\n    float temp51 = 0.0;\n    float\
    \ temp52 = 0.0;\n    float temp53 = 0.0;\n    float temp54 = 0.0;\n    float temp55\
    \ = 0.0;\n    float temp56 = 0.0;\n    float temp57 = 0.0;\n    float temp58 =\
    \ 0.0;\n    float temp59 = 0.0;\n    float temp60 = 0.0;\n    float temp61 = 0.0;\n\
    \    float temp62 = 0.0;\n    float temp63 = 0.0;\n    float temp64 = 0.0;\n \
    \   float temp65 = 0.0;\n    float temp66 = 0.0;\n    float temp67 = 0.0;\n  \
    \  float temp68 = 0.0;\n    \nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpau1b9jtw.d(87): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpau1b9jtw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpdjtl2tah.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator\
    \ `long`\\n/tmp/tmpnmvzujpn.d(16): Error: use `long` for a 64 bit integer instead\
    \ of `long long`\\n/tmp/tmpnmvzujpn.d(16): Error: no identifier for declarator\
    \ `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnmvzujpn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number - integerPart\
    \ * pow(10.0, decimalPart);\n    \n    return remainder;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp3aujc0c.d(19): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\n/tmp/tmpp3aujc0c.d(20): Error: cannot implicitly\
    \ convert expression `number - cast(float)integerPart` of type `float` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp3aujc0c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    while(trunc_number\
    \ >= 1)\n    {\n        remainder = trunc_number % 1;\n        trunc_number =\
    \ trunc_number / 1;\n        decimals = remainder;\n    }\n    return decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj5lbpg2q.d(19): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj5lbpg2q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression `number`\
    \ of type `float` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpci71zmfv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
