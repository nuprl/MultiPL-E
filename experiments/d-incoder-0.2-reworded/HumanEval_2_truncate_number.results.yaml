language: d
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float intPart;\n    float decimalPart;\n    intPart = (float)trunc(number);\n\
    \    decimalPart = number - intPart;\n    \n    if (decimalPart > 0.0) \n    {\n\
    \        remainder = decimalPart % 1;\n        decimalPart = decimalPart - remainder;\n\
    \    }\n    \n    return intPart + decimalPart;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx0b12g5o.d(18): Error: C style cast illegal, use `cast(float)trunc(number)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx0b12g5o.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) {\n\
    \        remainder = truncate_number(decimalPart);\n    } else {\n        remainder\
    \ = 0.0f;\n    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    \n    if (int_part\
    \ == number)\n    {\n        decimal_part = 0.0;\n    }\n    else\n    {\n   \
    \     decimal_part = number - int_part;\n    }\n    \n    return decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc4lh96m7.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc4lh96m7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float remainder = number - decimal_part;\n    return remainder;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4fp7s6kp.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fp7s6kp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1t0_vszk.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1t0_vszk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n \
    \       remainder = number % 10.0;\n        number = number / 10.0;\n        decimals\
    \ = decimals + remainder;\n    }\n    \n    return decimals;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp0ogtl3zm.d(31): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dcd]\n??:? void tmp0ogtl3zm.__unittest_L27_C1() [0x427ade]\n??:?
    void tmp0ogtl3zm.__modtest() [0x427b4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffc8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42faa5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a95d]\n??:? runModuleUnitTests [0x42b8c9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281a3]\n??:? _d_run_main [0x42810e]\n??:? main [0x427b5f]\n??:?
    __libc_start_main [0x61725554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = trunc(number);\n    frac_part = number -\
    \ int_part;\n    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoo8qgcw4.d(17): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpoo8qgcw4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(number > 0.0) {\n    \
    \    decimals += 1.0;\n        number -= floorf(number);\n    }\n    \n    result\
    \ = number - decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3xvxi0z2.d(20): Error: undefined identifier `floorf`, did you
    mean function `floor`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3xvxi0z2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(result > 1.0)\n    {\n\
    \        result -= 1.0;\n        decimals += 1.0;\n    }\n    \n    while(result\
    \ < 0.0)\n    {\n        result += 1.0;\n        decimals -= 1.0;\n    }\n   \
    \ \n    return result + decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpsq91wv8y.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e15]\n??:? void tmpsq91wv8y.__unittest_L32_C1() [0x427b2a]\n??:?
    void tmpsq91wv8y.__modtest() [0x427b98]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430010]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42faed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9a5]\n??:? runModuleUnitTests [0x42b911]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281eb]\n??:? _d_run_main [0x428156]\n??:? main [0x427bab]\n??:?
    __libc_start_main [0x4b5d6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpajgl4jj8.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajgl4jj8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder \
    \     = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdin5q0yb.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdin5q0yb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float temp\
    \ = 0.0;\n    float temp2 = 0.0;\n    float temp3 = 0.0;\n    float temp4 = 0.0;\n\
    \    float temp5 = 0.0;\n    float temp6 = 0.0;\n    float temp7 = 0.0;\n    float\
    \ temp8 = 0.0;\n    float temp9 = 0.0;\n    float temp10 = 0.0;\n    float temp11\
    \ = 0.0;\n    float temp12 = 0.0;\n    float temp13 = 0.0;\n    float temp14 =\
    \ 0.0;\n    float temp15 = 0.0;\n    float temp16 = 0.0;\n    float temp17 = 0.0;\n\
    \    float temp18 = 0.0;\n    float temp19 = 0.0;\n    float temp20 = 0.0;\n \
    \   float temp21 = 0.0;\n    float temp22 = 0.0;\n    float temp23 = 0.0;\n  \
    \  float temp24 = 0.0;\n    float temp25 = 0.0;\n    float temp26 = 0.0;\n   \
    \ float temp27 = 0.0;\n    float temp28 = 0.0;\n    float temp29 = 0.0;\n    float\
    \ temp30 = 0.0;\n    float temp31 = 0.0;\n    float temp32 = 0.0;\n    float temp33\
    \ = 0.0;\n    float temp34 = 0.0;\n    float temp35 = 0.0;\n    float temp36 =\
    \ 0.0;\n    float temp37 = 0.0;\n    float temp38 = 0.0;\n    float temp39 = 0.0;\n\
    \    float temp40 = 0.0;\n    float temp41 = 0.0;\n    float temp42 = 0.0;\n \
    \   float temp43 = 0.0;\n    float temp44 = 0.0;\n    float temp45 = 0.0;\n  \
    \  float temp46 = 0.0;\n    float temp47 = 0.0;\n    float temp48 = 0.0;\n   \
    \ float temp49 = 0.0;\n    float temp50 = 0.0;\n    float temp51 = 0.0;\n    float\
    \ temp52 = 0.0;\n    float temp53 = 0.0;\n    float temp54 = 0.0;\n    float temp55\
    \ = 0.0;\n    float temp56 = 0.0;\n    float temp57 = 0.0;\n    float temp58 =\
    \ 0.0;\n    float temp59 = 0.0;\n    float temp60 = 0.0;\n    float temp61 = 0.0;\n\
    \    float temp62 = 0.0;\n    float temp63 = 0.0;\n    float temp64 = 0.0;\n \
    \   float temp65 = 0.0;\n    float temp66 = 0.0;\n    float temp67 = 0.0;\n  \
    \  float temp68 = 0.0;\n    \nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpau1b9jtw.d(87): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpau1b9jtw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number - integerPart\
    \ * pow(10.0, decimalPart);\n    \n    return remainder;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp3aujc0c.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\n/tmp/tmpp3aujc0c.d(20): Error: cannot implicitly
    convert expression `number - cast(float)integerPart` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3aujc0c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    while(trunc_number\
    \ >= 1)\n    {\n        remainder = trunc_number % 1;\n        trunc_number =\
    \ trunc_number / 1;\n        decimals = remainder;\n    }\n    return decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj5lbpg2q.d(19): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5lbpg2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number-integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = floor(number);\n    decimalPart\
    \ = number - integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n   \
    \ alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n \
    \   assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\n\
    void main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4ube3lg0.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4ube3lg0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2rsxyufi.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\n/tmp/tmp2rsxyufi.d(23): Error:
    cannot implicitly convert expression `remainder` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rsxyufi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphc04uys9.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphc04uys9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprjmjfec6.d(19): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjmjfec6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, trunc(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprh9zb6rh.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprh9zb6rh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpahsdspdo.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpahsdspdo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float decimalPart = (number - int(number));\n    \n   \
    \ if (decimalPart > 0.0f)\n    {\n        result = number - decimalPart;\n   \
    \ }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_sasbnnp.d(17): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_sasbnnp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = int(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq4lmzitv.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4lmzitv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    int_part = trunc(number);\n    decimal_part = number\
    \ - int_part;\n    return decimal_part;\n}\n/*\n Given a positive floating point\
    \ number, it can be decomposed into\n    and integer part (largest integer smaller\
    \ than given number) and decimals\n    (leftover part always smaller than 1).\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy_sj2zv4.d(21): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpy_sj2zv4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integerPart;\n    \n    integerPart = number;\n\
    \    \n    decimals = number - integerPart;\n    \n    while(decimals > 0.0f)\
    \ {\n        decimals = decimals - 1.0f;\n        integerPart = integerPart +\
    \ 1.0f;\n    }\n    \n    remainder = number - integerPart;\n    \n    return\
    \ remainder;\n}\n/*\n Given a positive floating point number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdktgt8gi.d(32): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpdktgt8gi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long int) number;\n    long long int decimalPart = (long long\
    \ int) number - intPart;\n    \n    if (intPart == 0)\n        return 0;\n   \
    \ \n    return (float) decimalPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj1erkiip.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpj1erkiip.d(15): Error: no identifier for declarator `long`\n/tmp/tmpj1erkiip.d(15):
    Error: found `long` when expecting `.` following long\n/tmp/tmpj1erkiip.d(15):
    Error: found `int` when expecting identifier following `long`.\n/tmp/tmpj1erkiip.d(15):
    Error: semicolon expected, not `number`\n/tmp/tmpj1erkiip.d(16): Error: use `long`
    for a 64 bit integer instead of `long long`\n/tmp/tmpj1erkiip.d(16): Error: no
    identifier for declarator `long`\n/tmp/tmpj1erkiip.d(16): Error: found `long`
    when expecting `.` following long\n/tmp/tmpj1erkiip.d(16): Error: found `int`
    when expecting identifier following `long`.\n/tmp/tmpj1erkiip.d(16): Error: semicolon
    expected, not `number`\n/tmp/tmpj1erkiip.d(21): Error: C style cast illegal, use
    `cast(float)decimalPart`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1erkiip.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_mzrgki.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3_mzrgki.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2w9h45is.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2w9h45is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    \n    quotient\
    \ = number / FLT_EPSILON;\n    \n    if (number < 0.0) \n    {\n        quotient\
    \ = -quotient;\n    }\n    \n    remainder = number - quotient * FLT_EPSILON;\n\
    \    \n    if (remainder > FLT_EPSILON) \n    {\n        decimals = remainder\
    \ / FLT_EPSILON;\n    }\n    \n    return quotient + decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0obxk_7m.d(19): Error: undefined identifier `FLT_EPSILON`\n/tmp/tmp0obxk_7m.d(26):
    Error: undefined identifier `FLT_EPSILON`\n/tmp/tmp0obxk_7m.d(28): Error: undefined
    identifier `FLT_EPSILON`\n/tmp/tmp0obxk_7m.d(30): Error: undefined identifier
    `FLT_EPSILON`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0obxk_7m.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprjmjfec6.d(19): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjmjfec6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = trunc(number);\n    frac_part = number -\
    \ int_part;\n    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoo8qgcw4.d(17): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpoo8qgcw4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder = 0;\n    float int_part = 0;\n    float decimal_part\
    \ = 0;\n    \n    while(trunc_number > 0)\n    {\n        remainder = trunc_number\
    \ % 10;\n        int_part = int_part * 10 + remainder;\n        trunc_number =\
    \ trunc_number / 10;\n    }\n    \n    decimal_part = int_part * pow(10, (int_part\
    \ - 1));\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplr84y9te.d(35): unittest failure\n----------------\n??:?
    _d_unittestp [0x4289dd]\n??:? void tmplr84y9te.__unittest_L31_C1() [0x427dd2]\n??:?
    void tmplr84y9te.__modtest() [0x42875c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b63e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c80]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43075d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b615]\n??:? runModuleUnitTests [0x42c581]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428e2c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428db3]\n??:? _d_run_main [0x428d1e]\n??:? main [0x42876f]\n??:?
    __libc_start_main [0x4ed2c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpc0rim3ms.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpc0rim3ms.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpc0rim3ms.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x218eb554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8n3cst0.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpc8n3cst0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2w9h45is.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2w9h45is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int intPart =\
    \ (int) number;\n    float decimalPart = number - intPart;\n    \n    return decimalPart;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3ipdyy62.d(15): Error: C style cast illegal, use `cast(int)number`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ipdyy62.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8n3cst0.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpc8n3cst0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / FLT_EPSILON;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgwqc9kop.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\n/tmp/tmpgwqc9kop.d(23): Error:
    undefined identifier `FLT_EPSILON`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpgwqc9kop.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = trunc(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphzltl_d4.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmphzltl_d4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = int(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2slkb0fd.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2slkb0fd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphc04uys9.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphc04uys9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpajgl4jj8.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajgl4jj8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / 10;\n    remainder = number % 10;\n    decimals = remainder;\n  \
    \  \n    if (remainder > 0)\n    {\n        result = quotient + decimals;\n  \
    \  }\n    else\n    {\n        result = quotient;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1wvempwn.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ddd]\n??:? void tmp1wvempwn.__unittest_L35_C1() [0x427af2]\n??:?
    void tmp1wvempwn.__modtest() [0x427b60]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffd8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fab5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a96d]\n??:? runModuleUnitTests [0x42b8d9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281b3]\n??:? _d_run_main [0x42811e]\n??:? main [0x427b73]\n??:?
    __libc_start_main [0x83d3a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int integer_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxz7l0xh3.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxz7l0xh3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpc0rim3ms.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpc0rim3ms.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpc0rim3ms.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x218eb554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpajgl4jj8.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajgl4jj8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / 10;\n    remainder = number % 10;\n    decimals = remainder;\n  \
    \  \n    result = quotient;\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq8qtu2xg.d(32): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dad]\n??:? void tmpq8qtu2xg.__unittest_L28_C1() [0x427abe]\n??:?
    void tmpq8qtu2xg.__modtest() [0x427b2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa85]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a93d]\n??:? runModuleUnitTests [0x42b8a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428183]\n??:? _d_run_main [0x4280ee]\n??:? main [0x427b3f]\n??:?
    __libc_start_main [0xa4ba0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    float decimal_part;\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1l96f0_r.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmp1l96f0_r.d(15): Error: no identifier for declarator `long`\n/tmp/tmp1l96f0_r.d(17):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1l96f0_r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floorf(number);\n\
    \    decimalPart = number-integerPart;\n    \n    if (decimalPart > 0.0f)\n  \
    \  {\n        remainder = number-integerPart;\n        \n        if (remainder\
    \ > 0.0f)\n        {\n            integerPart += 1.0f;\n        }\n    }\n   \
    \ \n    return integerPart;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqf7m6jdt.d(19): Error: undefined identifier `floorf`, did you
    mean function `floor`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqf7m6jdt.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\n    \n    exponent = std.math.frexp(number,\
    \ &remainder);\n    \n    if (exponent == 0)\n    {\n        result = remainder;\n\
    \    }\n    else\n    {\n        result = number / powf(10.0, -exponent);\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgw74oulg.d(19): Error: template `std.math.frexp` cannot deduce
    function from argument types `!()(float, float*)`, candidates are:\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(2829):        `std.math.frexp(T)(const
    T value, out int exp) if (isFloatingPoint!T)`\n/tmp/tmpgw74oulg.d(27): Error:
    undefined identifier `powf`, did you mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F
    && isIntegral!G)`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgw74oulg.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    int exponent;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfui3oa7g.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfui3oa7g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbktd93hd.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427de5]\n??:? void tmpbktd93hd.__unittest_L30_C1() [0x427af6]\n??:?
    void tmpbktd93hd.__modtest() [0x427b64]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a975]\n??:? runModuleUnitTests [0x42b8e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281bb]\n??:? _d_run_main [0x428126]\n??:? main [0x427b77]\n??:?
    __libc_start_main [0x92391554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result = result / 10;\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg1new7h3.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpg1new7h3.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpg1new7h3.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0xf031a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float temp\
    \ = 0.0;\n    float temp2 = 0.0;\n    float temp3 = 0.0;\n    float temp4 = 0.0;\n\
    \    float temp5 = 0.0;\n    float temp6 = 0.0;\n    float temp7 = 0.0;\n    float\
    \ temp8 = 0.0;\n    float temp9 = 0.0;\n    float temp10 = 0.0;\n    float temp11\
    \ = 0.0;\n    float temp12 = 0.0;\n    float temp13 = 0.0;\n    float temp14 =\
    \ 0.0;\n    float temp15 = 0.0;\n    float temp16 = 0.0;\n    float temp17 = 0.0;\n\
    \    float temp18 = 0.0;\n    float temp19 = 0.0;\n    float temp20 = 0.0;\n \
    \   float temp21 = 0.0;\n    float temp22 = 0.0;\n    float temp23 = 0.0;\n  \
    \  float temp24 = 0.0;\n    float temp25 = 0.0;\n    float temp26 = 0.0;\n   \
    \ float temp27 = 0.0;\n    float temp28 = 0.0;\n    float temp29 = 0.0;\n    float\
    \ temp30 = 0.0;\n    float temp31 = 0.0;\n    float temp32 = 0.0;\n    float temp33\
    \ = 0.0;\n    float temp34 = 0.0;\n    float temp35 = 0.0;\n    float temp36 =\
    \ 0.0;\n    float temp37 = 0.0;\n    float temp38 = 0.0;\n    float temp39 = 0.0;\n\
    \    float temp40 = 0.0;\n    float temp41 = 0.0;\n    float temp42 = 0.0;\n \
    \   float temp43 = 0.0;\n    float temp44 = 0.0;\n    float temp45 = 0.0;\n  \
    \  float temp46 = 0.0;\n    float temp47 = 0.0;\n    float temp48 = 0.0;\n   \
    \ float temp49 = 0.0;\n    float temp50 = 0.0;\n    float temp51 = 0.0;\n    float\
    \ temp52 = 0.0;\n    float temp53 = 0.0;\n    float temp54 = 0.0;\n    float temp55\
    \ = 0.0;\n    float temp56 = 0.0;\n    float temp57 = 0.0;\n    float temp58 =\
    \ 0.0;\n    float temp59 = 0.0;\n    float temp60 = 0.0;\n    float temp61 = 0.0;\n\
    \    float temp62 = 0.0;\n    float temp63 = 0.0;\n    float temp64 = 0.0;\n \
    \   float temp65 = 0.0;\n    float temp66 = 0.0;\n    float temp67 = 0.0;\n  \
    \  float temp68 = 0.0;\n    \nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpau1b9jtw.d(87): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpau1b9jtw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8n3cst0.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpc8n3cst0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number % 1;\n    float remainder = number - decimals;\n    float integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = remainder < 0.5 ? remainder\
    \ : remainder - 1;\n    decimal_part = remainder - integer_part;\n    \n    return\
    \ decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7kxcaugv.d(29): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dd5]\n??:? void tmp7kxcaugv.__unittest_L25_C1() [0x427ae6]\n??:?
    void tmp7kxcaugv.__modtest() [0x427b54]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffd0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42faad]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a965]\n??:? runModuleUnitTests [0x42b8d1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281ab]\n??:? _d_run_main [0x428116]\n??:? main [0x427b67]\n??:?
    __libc_start_main [0xb1162554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2w9h45is.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2w9h45is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result = result / 10;\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg1new7h3.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpg1new7h3.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpg1new7h3.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0xf031a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    int_part = trunc(number);\n    frac_part = number -\
    \ int_part;\n    return frac_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoo8qgcw4.d(17): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpoo8qgcw4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcl7rhrx_.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\n/tmp/tmpcl7rhrx_.d(21): Error:
    cannot implicitly convert expression `number - cast(float)integer_part` of type
    `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcl7rhrx_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float trunc_number;\n    float int_part;\n    float decimal_part;\n    \n\
    \    int_part = floor(number);\n    decimal_part = number - int_part;\n    \n\
    \    remainder = number - int_part;\n    \n    trunc_number = int_part;\n    \n\
    \    if (remainder > 0)\n    {\n        trunc_number += 1;\n    }\n    \n    return\
    \ decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg7gk6xr6.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7gk6xr6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    remainder = number % 1;\n    integerPart = int(number);\n\
    \    \n    if (remainder == 0)\n        return integerPart;\n    else\n      \
    \  return integerPart + 1;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzfsxl_jb.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzfsxl_jb.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number;\n    decimals = 1;\n    \n    while(quotient > 1)\n    {\n       \
    \ remainder = quotient % 1;\n        quotient = quotient / 1;\n        decimals\
    \ = decimals + 1;\n    }\n    \n    result = remainder;\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\n    \n    integerPart = int(number);\n\
    \    remainder = number - integerPart;\n    decimals = remainder * pow(10.0, floor(log10(remainder)));\n\
    \    \n    return decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_yds_9g5.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_yds_9g5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    float remainder;\n    \n    float integer_part;\n    \n\
    \    float decimal_part;\n    \n    float decimal_part_remainder;\n    \n    float\
    \ decimal_part_remainder_magnitude;\n    \n    float decimal_part_remainder_magnitude2;\n\
    \    \n    float decimal_part_remainder_magnitude3;\n    \n    float decimal_part_remainder_magnitude4;\n\
    \    \n    float decimal_part_remainder_magnitude5;\n    \n    float decimal_part_remainder_magnitude6;\n\
    \    \n    float decimal_part_remainder_magnitude7;\n    \n    float decimal_part_remainder_magnitude8;\n\
    \    \n    float decimal_part_remainder_magnitude9;\n    \n    float decimal_part_remainder_magnitude10;\n\
    \    \n    float decimal_part_remainder_magnitude11;\n    \n    float decimal_part_remainder_magnitude12;\n\
    \    \n    float decimal_part_remainder_magnitude13;\n    \n    float decimal_part_remainder_magnitude14;\n\
    \    \n    float decimal_part_remainder_magnitude15;\n    \n    float decimal_part_remainder_magnitude16;\n\
    \    \n    float decimal_part_remainder_magnitude17;\n    \n    float decimal_part_remainder_magnitude18;\n\
    \    \n    float decimal_part_remainder_magnitude19;\n    \n    float decimal_part_remainder_magnitude20;\n\
    \    \n    float decimal_part_remainder_magnitude21;\n    \n    float decimal_part_remainder_magnitude22;\n\
    \    \n    float decimal_part_remainder_magnitude23;\n    \n    float decimal_part_remainder_magnitude24;\n\
    \    \n    float decimal_part_remainder_magnitude25;\n    \n    float decimal_part_remainder_magnitude26;\n\
    \    \n    float decimal_part_remainder_magnitude27;\n    \n    float decimal_part_remainder_magnitude28;\n\
    \    \n    float decimal_part_remainder_magnitude29;\n    \n    float decimal_part_remainder_magnitude30;\n\
    \    \n    float decimal_part_remainder_magnitude31;\n    \n    float decimal_part_remainder_magnitude32;\n\
    \    \n    float decimal_part_remainder_magnitude33;\n    \n    float decimal_part_remainder_magnitude34;\n\
    \    \n    float decimal_part_remainder_magnitude35;\n    \n    float decimal_part_remainder_magnitude36;\n\
    \    \n    float decimal_part_remainder_magnitude37;\n    \n    float decimal_part_remainder_magnitude38;\n\
    \    \n    float decimal_part_remainder_magnitude39;\n    \n    float decimal_part_remainder_magnitude40;\n\
    \    \n    float decimal_part_remainder_magnitude4\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv91koglc.d(106): Error: semicolon expected, not `unittest`\n/tmp/tmpv91koglc.d(106):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpv91koglc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result = result / 10;\n  \
    \  }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg1new7h3.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpg1new7h3.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpg1new7h3.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0xf031a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4hvxcf4r.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427de5]\n??:? void tmp4hvxcf4r.__unittest_L29_C1() [0x427af6]\n??:?
    void tmp4hvxcf4r.__modtest() [0x427b64]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a975]\n??:? runModuleUnitTests [0x42b8e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281bb]\n??:? _d_run_main [0x428126]\n??:? main [0x427b77]\n??:?
    __libc_start_main [0xc0c2f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\nunittest\n{\n    alias candidate = truncate_number;\n\n\
    \    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n  \
    \  assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsbziz5rz.d(17): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsbziz5rz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float intPart;\n    float decimalPart;\n    intPart = (float)trunc(number);\n\
    \    decimalPart = number - intPart;\n    remainder = decimalPart > 0.0 ? decimalPart\
    \ : 0.0;\n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6anhwdg3.d(18): Error: C style cast illegal, use `cast(float)trunc(number)`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6anhwdg3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpewzav2fl.d(28): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpewzav2fl.__unittest_L24_C1() [0x427a7e]\n??:?
    void tmpewzav2fl.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x9c07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part = number - truncate_number(int_part);\n    return decimal_part;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp239a1mns.d(19): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp239a1mns.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0f)\n\
    \    {\n        remainder = truncate_number(decimalPart);\n    }\n    else\n \
    \   {\n        remainder = 0.0f;\n    }\n    \n    return remainder;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(floorf(number));\n    \n  \
    \  integer_part = trunc(number);\n    \n    return decimal_part + integer_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp33y6fnqe.d(16): Error: undefined identifier `floorf`, did you
    mean function `floor`?\n/tmp/tmp33y6fnqe.d(18): Error: cannot implicitly convert
    expression `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp33y6fnqe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = int(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\n</code>\n<|/ a tags=c++,truncate |>\n<| a\
    \ tags=c++,truncate |>\n<code>\n#include <iostream>\n#include <cmath>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptedfv8qg.d(27): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptedfv8qg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return remainder;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpawvn5j9h.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpawvn5j9h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) \n\
    \    {\n        remainder = truncate_number(decimalPart);\n    }\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpewzav2fl.d(28): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpewzav2fl.__unittest_L24_C1() [0x427a7e]\n??:?
    void tmpewzav2fl.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x9c07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2w9h45is.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2w9h45is.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(floorf(number));\n    \n  \
    \  integer_part = trunc(number);\n    \n    return decimal_part + integer_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp33y6fnqe.d(16): Error: undefined identifier `floorf`, did you
    mean function `floor`?\n/tmp/tmp33y6fnqe.d(18): Error: cannot implicitly convert
    expression `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp33y6fnqe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder\
    \ / pow(10.0, floor(log10(remainder)));\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph335s2ih.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmph335s2ih.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    float decimals;\n    \n    decimals = number\
    \ - trunc(number);\n    \n    if (number < 0.0) \n    {\n        result += 0.0;\n\
    \    }\n    \n    remainder = number - trunc(number);\n    \n    if (remainder\
    \ > 0.0) \n    {\n        result += remainder;\n    }\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvmco97tg.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x427eb5]\n??:? void tmpvmco97tg.__unittest_L35_C1() [0x427bc6]\n??:?
    void tmpvmco97tg.__modtest() [0x427c34]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300c8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fba5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa5d]\n??:? runModuleUnitTests [0x42b9c9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428304]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42828b]\n??:? _d_run_main [0x4281f6]\n??:? main [0x427c47]\n??:?
    __libc_start_main [0xfcb48554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integer;\n    \n    integer = trunc(number);\n\
    \    \n    remainder = number - integer;\n    \n    decimals = remainder * pow(10.0,\
    \ floor(log10(remainder)));\n    \n    return decimals;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyptp22oo.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpyptp22oo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    float remainder = 0;\n    \n    while(number\
    \ > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n\
    \        decimals = decimals * 10 + remainder;\n    }\n    \n    result = result\
    \ / decimals;\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbktd93hd.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427de5]\n??:? void tmpbktd93hd.__unittest_L30_C1() [0x427af6]\n??:?
    void tmpbktd93hd.__modtest() [0x427b64]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffe0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fabd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a975]\n??:? runModuleUnitTests [0x42b8e1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281bb]\n??:? _d_run_main [0x428126]\n??:? main [0x427b77]\n??:?
    __libc_start_main [0x92391554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    int exponent;\nunittest\n{\n  \
    \  alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj5lbpg2q.d(19): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj5lbpg2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = floor(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0.0) \n\
    \    {\n        remainder = truncate_number(decimalPart);\n    }\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwpfihh99.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwpfihh99.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    if (integer_part == number)\n    {\n        decimal_part = 0.0;\n \
    \   }\n    else\n    {\n        decimal_part = number - integer_part;\n    }\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy2gtr0rk.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy2gtr0rk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\n/*\n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplukh_vqq.d(23): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmplukh_vqq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int int_part;\n\
    \    long int decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return float(decimal_part);\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8arni8ql.d(15): Error: no identifier for declarator `long`\n/tmp/tmp8arni8ql.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8arni8ql.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpewzav2fl.d(28): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpewzav2fl.__unittest_L24_C1() [0x427a7e]\n??:?
    void tmpewzav2fl.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x9c07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    if (decimalPart > 0)\n   \
    \ {\n        remainder = decimalPart % 1;\n        decimalPart = decimalPart /\
    \ 1;\n    }\n    \n    return float(integerPart) + remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpomo0fucq.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\n/tmp/tmpomo0fucq.d(20): Error: cannot implicitly
    convert expression `number - cast(float)integerPart` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpomo0fucq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float decimals_left;\n    float\
    \ decimals_left_float;\n    float decimals_left_float2;\n    float decimals_left_float3;\n\
    \    float decimals_left_float4;\n    float decimals_left_float5;\n    float decimals_left_float6;\n\
    \    float decimals_left_float7;\n    float decimals_left_float8;\n    float decimals_left_float9;\n\
    \    float decimals_left_float10;\n    float decimals_left_float11;\n    float\
    \ decimals_left_float12;\n    float decimals_left_float13;\n    float decimals_left_float14;\n\
    \    float decimals_left_float15;\n    float decimals_left_float16;\n    float\
    \ decimals_left_float17;\n    float decimals_left_float18;\n    float decimals_left_float19;\n\
    \    float decimals_left_float20;\n    float decimals_left_float21;\n    float\
    \ decimals_left_float22;\n    float decimals_left_float23;\n    float decimals_left_float24;\n\
    \    float decimals_left_float25;\n    float decimals_left_float26;\n    float\
    \ decimals_left_float27;\n    float decimals_left_float28;\n    float decimals_left_float29;\n\
    \    float decimals_left_float30;\n    float decimals_left_float31;\n    float\
    \ decimals_left_float32;\n    float decimals_left_float33;\n    float decimals_left_float34;\n\
    \    float decimals_left_float35;\n    float decimals_left_float36;\n    float\
    \ decimals_left_float37;\n    float decimals_left_float38;\n    float decimals_left_float39;\n\
    \    float decimals_left_float40;\n    float decimals_left_float41;\n    float\
    \ decimals_left_float42;\n    float decimals_left_float43;\n    float decimals_left_float44;\n\
    \    float decimals_left_float45;\n    float decimals_left_float46;\n    float\
    \ decimals_left_float47;\n    float decimals_left_float48;\n    float decimals_left_float49;\n\
    \    float decimals_left_float50;\n    float decimals_left_float51;\n    float\
    \ decimals_left_float52;\n    float decimals_left_float53;\n    float decimals_left_float54;\n\
    \    float decimals_left_float55;\n    float decimals_left_float56;\n    float\
    \ \nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl5b5sa__.d(76): Error: no identifier for declarator `float`\n/tmp/tmpl5b5sa__.d(76):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpl5b5sa__.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part;\n    \n    return decimal_part;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpben1khyo.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpben1khyo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0b7s1604.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmp0b7s1604.d(15): Error: no identifier for declarator `long`\n/tmp/tmp0b7s1604.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmp0b7s1604.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0b7s1604.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphc04uys9.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphc04uys9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg7gk6xr6.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7gk6xr6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder = 0;\n    float decimal_part = 0;\n    int decimal_part_length\
    \ = 0;\n    \n    while(trunc_number > 0)\n    {\n        remainder = trunc_number\
    \ % 10;\n        decimal_part_length++;\n        trunc_number = trunc_number /\
    \ 10;\n    }\n    \n    decimal_part_length = decimal_part_length + 1;\n    \n\
    \    while(trunc_number > 0)\n    {\n        remainder = trunc_number % 10;\n\
    \        decimal_part_length++;\n        trunc_number = trunc_number / 10;\n \
    \   }\n    \n    decimal_part_length = decimal_part_length + 1;\n    \n    while(trunc_number\
    \ > 0)\n    {\n        remainder = trunc_number % 10;\n        decimal_part_length++;\n\
    \        trunc_number = trunc_number / 10;\n    }\n    \n    decimal_part_length\
    \ = decimal_part_length + 1;\n    \n    while(trunc_number > 0)\n    {\n     \
    \   remainder = trunc_number % 10;\n        decimal_part_length++;\n        trunc_number\
    \ = trunc_number / 10;\n    }\n    \n    decimal_part_length = decimal_part_length\
    \ + 1;\n    \n    while(trunc_number > 0)\n    {\n        remainder = trunc_number\
    \ % 10;\n        decimal_part_length++;\n        trunc_number = trunc_number /\
    \ 10;\n    }\n    \n    decimal_part_length = decimal_part_length + 1;\n    \n\
    \    while(trunc_number > 0)\n    {\n        remainder = trunc_number % 10;\n\
    \        decimal_part_length++;\n        trunc_number = trunc_number / 10;\n \
    \   }\n    \n    decimal_part_length = decimal_part_length + 1;\n    \n    while(trunc_number\
    \ > 0)\n    {\n        remainder = trunc_number % 10;\n        decimal_part_length++;\n\
    \        trunc_number = trunc_number / 10;\n    }\n    \n    decimal_part_length\
    \ = decimal_part_length + 1;\n    \n    while(trunc_number > 0)\n    {\n     \
    \   remainder = trunc_number % 10;\n        decimal_part_length++;\n        trunc_number\
    \ = trunc_number / 10;\n    }\n    \n    decimal_part_length = decimal_part_length\
    \ + 1;\n    \n    while(trunc_number > 0)\n    {\n        remainder = trunc_number\
    \ % 10;\n        decimal_part_length++;\n        trunc_number = trunc_number /\
    \ 10;\n    }\n    \n    decimal_part_length = decimal_part_length + 1;\n    \n\
    \    while(trunc_number > 0)\n    {\n        remainder = trunc_number % 10;\n\
    \        decimal_part_length++;\n        trunc_number = trunc_number / \nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj1n26u83.d(106): Error: expression expected, not `unittest`\n/tmp/tmpj1n26u83.d(107):
    Error: found `{` when expecting `;` following statement\n/tmp/tmpj1n26u83.d(114):
    Error: found `End of File` when expecting `}` following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1n26u83.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number - integerPart;\n\
    \    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyzzzfbm4.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\n/tmp/tmpyzzzfbm4.d(20): Error: cannot implicitly
    convert expression `number - cast(float)integerPart` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyzzzfbm4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / float.pow(10, decimals);\n    remainder = number % float.pow(10,\
    \ decimals);\n    \n    result = remainder;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkbmzte2b.d(20): Error: cannot pass type `float` as a function
    argument\n/tmp/tmpkbmzte2b.d(21): Error: cannot pass type `float` as a function
    argument\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbmzte2b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float trunc_number;\n    \n    trunc_number = number;\n    \n    remainder\
    \ = number % 1;\n    \n    if (remainder > 0)\n    {\n        trunc_number = trunc_number\
    \ - remainder;\n    }\n    \n    return trunc_number;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6onp9ipd.d(33): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d9d]\n??:? void tmp6onp9ipd.__unittest_L29_C1() [0x427ab2]\n??:?
    void tmp6onp9ipd.__modtest() [0x427b20]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a92d]\n??:? runModuleUnitTests [0x42b899]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428173]\n??:? _d_run_main [0x4280de]\n??:? main [0x427b33]\n??:?
    __libc_start_main [0xc7b3c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part;\n    \n    int_part = int(number);\n    frac_part = number\
    \ - int_part;\n    \n    return frac_part;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg7gk6xr6.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7gk6xr6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = int(frac_part);\n\
    \    return frac_part - int_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpei2i59jr.d(17): Error: cannot implicitly convert expression
    `frac_part` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpei2i59jr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    \n    quotient = number;\n    decimals\
    \ = 1;\n    \n    while(quotient > 1)\n    {\n        remainder = quotient % 1;\n\
    \        quotient = quotient / 1;\n        decimals = decimals + 1;\n    }\n \
    \   \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    decimal_part = number - integer_part;\n    \n    remainder = number\
    \ - integer_part - decimal_part;\n    \n    return remainder;\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwpfihh99.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpwpfihh99.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    \n    int_part =\
    \ int(frac_part);\n    frac_part = frac_part - int_part;\n    \n    return frac_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgkptz82s.d(18): Error: cannot implicitly convert expression
    `frac_part` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpgkptz82s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    int decimalPart;\n    \n    integerPart = int(number);\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = number - integerPart\
    \ - decimalPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplc9we1dh.d(19): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\n/tmp/tmplc9we1dh.d(20): Error: cannot implicitly
    convert expression `number - cast(float)integerPart` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplc9we1dh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number / 10;\n    remainder = number % 10;\n    decimals = remainder;\n  \
    \  \n    result = quotient;\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq8qtu2xg.d(32): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dad]\n??:? void tmpq8qtu2xg.__unittest_L28_C1() [0x427abe]\n??:?
    void tmpq8qtu2xg.__modtest() [0x427b2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa85]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a93d]\n??:? runModuleUnitTests [0x42b8a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428183]\n??:? _d_run_main [0x4280ee]\n??:? main [0x427b3f]\n??:?
    __libc_start_main [0xa4ba0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = int(number);\n    remainder =\
    \ number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphc04uys9.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphc04uys9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpajgl4jj8.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajgl4jj8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppv6h6x73.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppv6h6x73.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(number > 0)\n    {\n      \
    \  remainder = number % 10;\n        number = number / 10;\n        result = remainder\
    \ + result;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9txb5aha.d(31): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dad]\n??:? void tmp9txb5aha.__unittest_L27_C1() [0x427ac2]\n??:?
    void tmp9txb5aha.__modtest() [0x427b30]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffa8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa85]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a93d]\n??:? runModuleUnitTests [0x42b8a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428183]\n??:? _d_run_main [0x4280ee]\n??:? main [0x427b43]\n??:?
    __libc_start_main [0x85fae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float remainder = 0.0;\n    float quotient = 0.0;\n    float quotient2\
    \ = 0.0;\n    float quotient3 = 0.0;\n    float quotient4 = 0.0;\n    float quotient5\
    \ = 0.0;\n    float quotient6 = 0.0;\n    float quotient7 = 0.0;\n    float quotient8\
    \ = 0.0;\n    float quotient9 = 0.0;\n    float quotient10 = 0.0;\n    float quotient11\
    \ = 0.0;\n    float quotient12 = 0.0;\n    float quotient13 = 0.0;\n    float\
    \ quotient14 = 0.0;\n    float quotient15 = 0.0;\n    float quotient16 = 0.0;\n\
    \    float quotient17 = 0.0;\n    float quotient18 = 0.0;\n    float quotient19\
    \ = 0.0;\n    float quotient20 = 0.0;\n    float quotient21 = 0.0;\n    float\
    \ quotient22 = 0.0;\n    float quotient23 = 0.0;\n    float quotient24 = 0.0;\n\
    \    float quotient25 = 0.0;\n    float quotient26 = 0.0;\n    float quotient27\
    \ = 0.0;\n    float quotient28 = 0.0;\n    float quotient29 = 0.0;\n    float\
    \ quotient30 = 0.0;\n    float quotient31 = 0.0;\n    float quotient32 = 0.0;\n\
    \    float quotient33 = 0.0;\n    float quotient34 = 0.0;\n    float quotient35\
    \ = 0.0;\n    float quotient36 = 0.0;\n    float quotient37 = 0.0;\n    float\
    \ quotient38 = 0.0;\n    float quotient39 = 0.0;\n    float quotient40 = 0.0;\n\
    \    float quotient41 = 0.0;\n    float quotient42 = 0.0;\n    float quotient43\
    \ = 0.0;\n    float quotient44 = 0.0;\n    float quotient45 = 0.0;\n    float\
    \ quotient46 = 0.0;\n    float quotient47 = 0.0;\n    float quotient48 = 0.0;\n\
    \    float quotient49 = 0.0;\n    float quotient50 = 0.0;\n    float quotient51\
    \ = 0.0;\n    float quotient52 = 0.0;\n    float quotient53 = 0.0;\n    float\
    \ quotient54 = 0.0;\n    float quotient55 = 0.0;\n    float quotient56 = 0.0;\n\
    \    float quotient57 = 0.0;\n    float quotient58 = 0.0;\n    float quotient59\
    \ = 0.0;\n    float quotient60 = 0.0;\n    float quotient61 = 0.\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp424a2l8y.d(78): Error: semicolon expected, not `unittest`\n/tmp/tmp424a2l8y.d(78):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp424a2l8y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float remainder;\n    \n    while(result > 1) {\n        remainder\
    \ = result % 1;\n        result = floor(result);\n        result = remainder +\
    \ result;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpc0rim3ms.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpc0rim3ms.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpc0rim3ms.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x218eb554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number;\n    \n    while(quotient > 1)\n    {\n        remainder = quotient\
    \ % 1;\n        quotient = quotient / 1;\n        decimals = remainder;\n    }\n\
    \    \n    result = quotient;\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    \n    integerPart = floorf(number);\n    decimalPart\
    \ = number-integerPart;\n    \n    return decimalPart;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcx6sco9e.d(18): Error: undefined identifier `floorf`, did you
    mean function `floor`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcx6sco9e.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float integerPart;\n    \n    integerPart = number;\n\
    \    decimals = number - integerPart;\n    \n    if (decimals < 0.0) {\n     \
    \   integerPart += 0.0;\n        decimals = 0.0;\n    }\n    \n    remainder =\
    \ decimals;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4ueclb17.d(35): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dbd]\n??:? void tmp4ueclb17.__unittest_L31_C1() [0x427ad2]\n??:?
    void tmp4ueclb17.__modtest() [0x427b40]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffb8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa95]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a94d]\n??:? runModuleUnitTests [0x42b8b9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428193]\n??:? _d_run_main [0x4280fe]\n??:? main [0x427b53]\n??:?
    __libc_start_main [0xda648554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float int_part = 0.0;\n    float remainder = 0.0;\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpap4z_ch7.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap4z_ch7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2rsxyufi.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\n/tmp/tmp2rsxyufi.d(23): Error:
    cannot implicitly convert expression `remainder` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rsxyufi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = number % 1;\n    float whole = number - decimals;\n    float result = whole\
    \ / 1;\n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqvao05ph.d(24): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d75]\n??:? void tmpqvao05ph.__unittest_L20_C1() [0x427a86]\n??:?
    void tmpqvao05ph.__modtest() [0x427af4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a905]\n??:? runModuleUnitTests [0x42b871]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42814b]\n??:? _d_run_main [0x4280b6]\n??:? main [0x427b07]\n??:?
    __libc_start_main [0xa2ac1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part = number - truncate_number(floor(number));\n    \n   \
    \ integer_part = floor(number);\n    \n    if (integer_part == number)\n     \
    \   return decimal_part;\n    \n    return number - integer_part + decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmadshllw.d(18): Error: cannot implicitly convert expression
    `floor(number)` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmadshllw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float result = 0.0;\n    float remainder = 0.0;\n    float quotient\
    \ = 0.0;\n    float quotient2 = 0.0;\n    float quotient3 = 0.0;\n    float quotient4\
    \ = 0.0;\n    float quotient5 = 0.0;\n    float quotient6 = 0.0;\n    float quotient7\
    \ = 0.0;\n    float quotient8 = 0.0;\n    float quotient9 = 0.0;\n    float quotient10\
    \ = 0.0;\n    float quotient11 = 0.0;\n    float quotient12 = 0.0;\n    float\
    \ quotient13 = 0.0;\n    float quotient14 = 0.0;\n    float quotient15 = 0.0;\n\
    \    float quotient16 = 0.0;\n    float quotient17 = 0.0;\n    float quotient18\
    \ = 0.0;\n    float quotient19 = 0.0;\n    float quotient20 = 0.0;\n    float\
    \ quotient21 = 0.0;\n    float quotient22 = 0.0;\n    float quotient23 = 0.0;\n\
    \    float quotient24 = 0.0;\n    float quotient25 = 0.0;\n    float quotient26\
    \ = 0.0;\n    float quotient27 = 0.0;\n    float quotient28 = 0.0;\n    float\
    \ quotient29 = 0.0;\n    float quotient30 = 0.0;\n    float quotient31 = 0.0;\n\
    \    float quotient32 = 0.0;\n    float quotient33 = 0.0;\n    float quotient34\
    \ = 0.0;\n    float quotient35 = 0.0;\n    float quotient36 = 0.0;\n    float\
    \ quotient37 = 0.0;\n    float quotient38 = 0.0;\n    float quotient39 = 0.0;\n\
    \    float quotient40 = 0.0;\n    float quotient41 = 0.0;\n    float quotient42\
    \ = 0.0;\n    float quotient43 = 0.0;\n    float quotient44 = 0.0;\n    float\
    \ quotient45 = 0.0;\n    float quotient46 = 0.0;\n    float quotient47 = 0.0;\n\
    \    float quotient48 = 0.0;\n    float quotient49 = 0.0;\n    float quotient50\
    \ = 0.0;\n    float quotient51 = 0.0;\n    float quotient52 = 0.0;\n    float\
    \ quotient53 = 0.0;\n    float quotient54 = 0.0;\n    float quotient55 = 0.0;\n\
    \    float quotient56 = 0.0;\n    float quotient57 = 0.0;\n    float quotient58\
    \ = 0.0;\n    float quotient59 = 0.0;\n    float quotient60 = 0.0;\n    \nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0la9d7zp.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0la9d7zp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1)\n    {\n        result /= 10;\n    }\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpewzav2fl.d(28): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpewzav2fl.__unittest_L24_C1() [0x427a7e]\n??:?
    void tmpewzav2fl.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x9c07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\n    \n    quotient = number;\n    exponent\
    \ = 0;\n    \n    while(quotient > 1) {\n        remainder = quotient % 1;\n \
    \       quotient = quotient / 1;\n        exponent++;\n    }\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long int int_part;\n\
    \    long int decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return float(decimal_part);\n}\nunittest\n{\n\
    \    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8arni8ql.d(15): Error: no identifier for declarator `long`\n/tmp/tmp8arni8ql.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8arni8ql.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\n    \n    quotient = number / powf(10.0,\
    \ floor(log10(number)));\n    remainder = number - quotient * powf(10.0, floor(log10(number)));\n\
    \    exponent = floor(log10(remainder));\n    \n    return remainder * powf(10.0,\
    \ -exponent);\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqby2gdw2.d(19): Error: undefined identifier `powf`, did you
    mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?\n/tmp/tmpqby2gdw2.d(20):
    Error: undefined identifier `powf`, did you mean template `pow(F, G)(F x, G n)
    if (isFloatingPoint!F && isIntegral!G)`?\n/tmp/tmpqby2gdw2.d(21): Error: cannot
    implicitly convert expression `floor(log10(cast(real)remainder))` of type `real`
    to `int`\n/tmp/tmpqby2gdw2.d(23): Error: undefined identifier `powf`, did you
    mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqby2gdw2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    int integerPart;\nunittest\n{\n    alias candidate =\
    \ truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc4efvlug.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc4efvlug.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    \n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc8n3cst0.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpc8n3cst0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    int decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    remainder = number - integer_part;\n    \n    decimal_part = remainder;\n\
    \    \n    return decimal_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2rsxyufi.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\n/tmp/tmp2rsxyufi.d(23): Error:
    cannot implicitly convert expression `remainder` of type `float` to `int`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2rsxyufi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float integerPart;\n    float decimalPart;\n    \n    integerPart = number;\n\
    \    decimalPart = number - integerPart;\n    \n    remainder = decimalPart %\
    \ 1;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpb9zncbyx.d(30): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d8d]\n??:? void tmpb9zncbyx.__unittest_L26_C1() [0x427a9e]\n??:?
    void tmpb9zncbyx.__modtest() [0x427b0c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff88]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa65]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a91d]\n??:? runModuleUnitTests [0x42b889]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428163]\n??:? _d_run_main [0x4280ce]\n??:? main [0x427b1f]\n??:?
    __libc_start_main [0x7de64554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int decimal_part\
    \ = int(number);\n    float trunc_number = number - decimal_part;\n    return\
    \ trunc_number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n  \
    \  assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpci71zmfv.d(15): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpci71zmfv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    float decimal_part;\n    \n    integer_part = trunc(number);\n\
    \    \n    if (integer_part == number)\n        decimal_part = 0.0;\n    else\n\
    \        decimal_part = number - integer_part;\n    \n    return decimal_part;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnp2rg_7n.d(19): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpnp2rg_7n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ intPart = (long long) number;\n    long long int decimalPart = (intPart % 10);\n\
    \    intPart = intPart / 10;\n    \n    if (decimalPart > 0)\n        return number;\n\
    \    else\n        return number - intPart;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpymnlqzm2.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpymnlqzm2.d(15): Error: no identifier for declarator `long`\n/tmp/tmpymnlqzm2.d(15):
    Error: found `long` when expecting `.` following long\n/tmp/tmpymnlqzm2.d(15):
    Error: found `)` when expecting identifier following `long`.\n/tmp/tmpymnlqzm2.d(15):
    Error: found `number` when expecting `)`\n/tmp/tmpymnlqzm2.d(16): Error: use `long`
    for a 64 bit integer instead of `long long`\n/tmp/tmpymnlqzm2.d(16): Error: no
    identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymnlqzm2.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float trunc_number;\n    int decimal_point;\n    int i;\n    \n    trunc_number\
    \ = number;\n    \n    decimal_point = trunc_number - trunc_number;\n    \n  \
    \  if (decimal_point < 0)\n    {\n        decimal_point += 1;\n        trunc_number\
    \ = trunc_number - 1;\n    }\n    \n    remainder = trunc_number % 1;\n    \n\
    \    for (i = decimal_point - 1; i >= 0; i--)\n    {\n        trunc_number = trunc_number\
    \ * 10;\n    }\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbzlfvg8z.d(22): Error: cannot implicitly convert expression
    `trunc_number - trunc_number` of type `float` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbzlfvg8z.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float trunc_number\
    \ = number;\n    float remainder;\n    int decimal_part;\n    \n    decimal_part\
    \ = int(number - trunc_number);\n    \n    if (decimal_part == 0)\n    {\n   \
    \     trunc_number = 0.0;\n        remainder = 0.0;\n    }\n    else\n    {\n\
    \        remainder = number - trunc_number;\n        trunc_number = trunc_number\
    \ - remainder;\n    }\n    \n    return trunc_number;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfl65noxc.d(19): Error: cannot implicitly convert expression
    `number - trunc_number` of type `float` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpfl65noxc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part = (long long) number;\n    long long int decimal_part = number - int_part;\n\
    \    \n    if (decimal_part > 0)\n        return number - int_part;\n    else\n\
    \        return number;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpshhslgu8.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpshhslgu8.d(15): Error: no identifier for declarator `long`\n/tmp/tmpshhslgu8.d(15):
    Error: found `long` when expecting `.` following long\n/tmp/tmpshhslgu8.d(15):
    Error: found `)` when expecting identifier following `long`.\n/tmp/tmpshhslgu8.d(15):
    Error: found `number` when expecting `)`\n/tmp/tmpshhslgu8.d(16): Error: use `long`
    for a 64 bit integer instead of `long long`\n/tmp/tmpshhslgu8.d(16): Error: no
    identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshhslgu8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integer_part;\n    \n    integer_part = trunc(number);\n    remainder\
    \ = number - integer_part;\n    \n    return remainder;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4pgck7eo.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4pgck7eo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimals\
    \ = 0.0;\n    float integer = 0.0;\n    \n    while(number > 0.0)\n    {\n   \
    \     integer = integer * 10.0;\n        decimals = decimals + number - integer;\n\
    \        number = number - integer;\n    }\n    \n    return decimals;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    long long int\
    \ int_part;\n    long long int decimal_part;\n    \n    int_part = trunc(number);\n\
    \    decimal_part = number - int_part;\n    \n    return float(decimal_part);\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnmvzujpn.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpnmvzujpn.d(15): Error: no identifier for declarator `long`\n/tmp/tmpnmvzujpn.d(16):
    Error: use `long` for a 64 bit integer instead of `long long`\n/tmp/tmpnmvzujpn.d(16):
    Error: no identifier for declarator `long`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnmvzujpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    int exponent;\n    \n    quotient = number;\n    exponent\
    \ = 0;\n    \n    while ((quotient > 1.0f) && (exponent < 32))\n    {\n      \
    \  quotient = quotient / 2.0f;\n        exponent++;\n    }\n    \n    remainder\
    \ = number - quotient * 2.0f;\n    \n    return remainder;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmzsm78oq.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dbd]\n??:? void tmpmzsm78oq.__unittest_L32_C1() [0x427ad2]\n??:?
    void tmpmzsm78oq.__modtest() [0x427b40]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffb8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa95]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a94d]\n??:? runModuleUnitTests [0x42b8b9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428193]\n??:? _d_run_main [0x4280fe]\n??:? main [0x427b53]\n??:?
    __libc_start_main [0xcfd9c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkl007wzy.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpkl007wzy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    \n    while(result > 0.0) {\n    \
    \    result += 1.0;\n        decimals += 1;\n    }\n    \n    return result -\
    \ decimals;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa27de_z9.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpa27de_z9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = trunc(number);\n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1zb5zwh8.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp1zb5zwh8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    while (number > 1) {\n        number\
    \ /= 10;\n        decimals++;\n    }\n    return result - decimals * 0.1;\n}\n\
    unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3xc_2j1t.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427db5]\n??:? void tmp3xc_2j1t.__unittest_L23_C1() [0x427aca]\n??:?
    void tmp3xc_2j1t.__modtest() [0x427b38]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffb0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa8d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a945]\n??:? runModuleUnitTests [0x42b8b1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42818b]\n??:? _d_run_main [0x4280f6]\n??:? main [0x427b4b]\n??:?
    __libc_start_main [0xa5770554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float decimalPart;\n\
    \    float integerPart;\n    float remainder;\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz8y9hzgq.d(18): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz8y9hzgq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    int integerPart;\n    \n    integerPart = int(number);\n    remainder = number\
    \ - integerPart;\n    \n    return remainder;\n}\nunittest\n{\n    alias candidate\
    \ = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdjtl2tah.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjtl2tah.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int integer_part;\n\
    \    float decimal_part;\n    \n    integer_part = int(number);\n    \n    decimal_part\
    \ = number - integer_part;\n    \n    return decimal_part;\n}\nunittest\n{\n \
    \   alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq4lmzitv.d(18): Error: cannot implicitly convert expression
    `number` of type `float` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq4lmzitv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float decimals;\n    float intPart;\n    \n    intPart = number;\n    \n\
    \    decimals = number - intPart;\n    \n    if (decimals < 0.0) \n    {\n   \
    \     intPart += 0.0;\n        decimals = 0.0;\n    }\n    \n    remainder = number\
    \ - intPart;\n    \n    return remainder + decimals;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8kemxl6k.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427dd5]\n??:? void tmp8kemxl6k.__unittest_L33_C1() [0x427ae6]\n??:?
    void tmp8kemxl6k.__modtest() [0x427b54]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ffd0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42faad]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a965]\n??:? runModuleUnitTests [0x42b8d1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281ab]\n??:? _d_run_main [0x428116]\n??:? main [0x427b67]\n??:?
    __libc_start_main [0xbf892554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    \n    quotient = number / float.pow(10,\
    \ decimals);\n    remainder = number % float.pow(10, decimals);\n    \n    return\
    \ remainder;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsr7ff3en.d(19): Error: cannot pass type `float` as a function
    argument\n/tmp/tmpsr7ff3en.d(20): Error: cannot pass type `float` as a function
    argument\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsr7ff3en.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float decimal_part;\n    \n    int_part = trunc(number);\n    decimal_part\
    \ = number - int_part;\n    \n    return decimal_part;\n}\nunittest\n{\n    alias\
    \ candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25)\
    \ == 0.25);\n    assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa27de_z9.d(18): Error: cannot implicitly convert expression
    `trunc(cast(real)number)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpa27de_z9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float remainder;\n\
    \    float quotient;\n    float decimals;\n    float result;\n    \n    quotient\
    \ = number;\n    decimals = 1;\n    \n    while (quotient > 1) {\n        remainder\
    \ = quotient % 1;\n        quotient = quotient / 1;\n        decimals = decimals\
    \ + 1;\n    }\n    \n    result = remainder;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    int int_part;\n\
    \    float frac_part = number - truncate_number(number);\n    int_part = trunc(frac_part);\n\
    \    return number - int_part;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps6ha8k6n.d(17): Error: cannot implicitly convert expression
    `trunc(cast(real)frac_part)` of type `real` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmps6ha8k6n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 0.0;\n    float integer_part = 0.0;\n    float\
    \ remainder = 0.0;\n    \n    while(number > 0.0)\n    {\n        remainder =\
    \ number % 10.0;\n        decimals = decimals + remainder;\n        integer_part\
    \ = integer_part + remainder;\n        number = number / 10.0;\n    }\n    \n\
    \    result = integer_part + decimals;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5) == 0.5);\n\
    \    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) == 0.0);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmppe9km86u.d(36): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e05]\n??:? void tmppe9km86u.__unittest_L32_C1() [0x427b1a]\n??:?
    void tmppe9km86u.__modtest() [0x427b88]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb2b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9be]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb51]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430000]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fadd]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a995]\n??:? runModuleUnitTests [0x42b901]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428254]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4281db]\n??:? _d_run_main [0x428146]\n??:? main [0x427b9b]\n??:?
    __libc_start_main [0xcb14b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    \n    while(result > 1) {\n        result /= 10;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = truncate_number;\n\
    \n    assert(candidate(3.5) == 0.5);\n    assert(candidate(1.25) == 0.25);\n \
    \   assert(candidate(123.0) == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpc0rim3ms.d(27): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d6d]\n??:? void tmpc0rim3ms.__unittest_L23_C1() [0x427a7e]\n??:?
    void tmpc0rim3ms.__modtest() [0x427aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff68]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a8fd]\n??:? runModuleUnitTests [0x42b869]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428143]\n??:? _d_run_main [0x4280ae]\n??:? main [0x427aff]\n??:?
    __libc_start_main [0x218eb554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n\
    \    0.5\n    \n*/\nfloat truncate_number(float number) \n{\n    float result\
    \ = number;\n    float decimals = 1;\n    \n    while (number > 1) {\n       \
    \ number /= 10;\n        decimals++;\n    }\n    \n    return result - decimals;\n\
    }\nunittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
    \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0)\
    \ == 0.0);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4a9k1vlx.d(29): unittest failure\n----------------\n??:?
    _d_unittestp [0x427d9d]\n??:? void tmp4a9k1vlx.__unittest_L25_C1() [0x427ab2]\n??:?
    void tmp4a9k1vlx.__modtest() [0x427b20]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bac3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a956]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x42ff98]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fa75]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a92d]\n??:? runModuleUnitTests [0x42b899]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ec]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428173]\n??:? _d_run_main [0x4280de]\n??:? main [0x427b33]\n??:?
    __libc_start_main [0xcf654554]\n1/1 unittests FAILED\n'''
  stdout: b''
