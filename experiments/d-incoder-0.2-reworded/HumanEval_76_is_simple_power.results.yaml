language: d
name: HumanEval_76_is_simple_power
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 0L) return false;\n\
    \    long a = x;\n    long b = n;\n    long c = 1L;\n    long d = 1L;\n    long\
    \ e = 1L;\n    long f = 1L;\n    long g = 1L;\n    long h = 1L;\n    long i =\
    \ 1L;\n    long j = 1L;\n    long k = 1L;\n    long l = 1L;\n    long m = 1L;\n\
    \    long n = 2L;\n    long o = 2L;\n    long p = 2L;\n    long q = 2L;\n    long\
    \ r = 2L;\n    long s = 2L;\n    long t = 2L;\n    long u = 2L;\n    long v =\
    \ 2L;\n    long w = 2L;\n    long x = 2L;\n    long y = 2L;\n    long z = 2L;\n\
    \    long A = 2L;\n    long B = 2L;\n    long C = 2L;\n    long D = 2L;\n    long\
    \ E = 2L;\n    long F = 2L;\n    long G = 2L;\n    long H = 2L;\n    long I =\
    \ 2L;\n    long J = 2L;\n    long K = 2L;\n    long L = 2L;\n    long M = 2L;\n\
    \    long N = 2L;\n    long O = 2L;\n    long P = 2L;\n    long Q = 2L;\n    long\
    \ R = 2L;\n    long S = 1L;\n    long T = 1L;\n    long U = 1L;\n    long V =\
    \ 1L;\n    long W = 1L;\n    long X = 1L;\n    long Y = 1L;\n    long Z = 1L;\n\
    \    long A = 1L;\n    long B = 1L;\n    long C = 1L;\n    long D = 1L;\n    long\
    \ E = 1L;\n    long F = 1L;\n    long G = 1L;\n    long H = 1L;\n    long I =\
    \ 1L;\n    long J = 1L;\n    long K = 1L;\n    long L = 1L;\n    long M = 1L;\n\
    \    long N = 1L;\n    long O = 1L;\n    long P = 1L;\n    long Q = 1L\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2c8tb83x.d(98): Error: semicolon expected, not `unittest`\n/tmp/tmp2c8tb83x.d(98):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2c8tb83x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    return result == power;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `is_simple_power(3L,\
    \ 3L)` returns `true` when it should return `false`.\n<|/ c |>\n<| c |>\n: I fixed\
    \ the bug, thanks. I didn't test the code so I didn't notice that bug. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_vzixtal.d(34): Error: declaration expected, not `<`\n/tmp/tmp_vzixtal.d(37):
    Error: unterminated character constant\n/tmp/tmp_vzixtal.d(40): Error: unterminated
    character constant\n/tmp/tmp_vzixtal.d(40): Error: unterminated character constant\n/tmp/tmp_vzixtal.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmp_vzixtal.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmp_vzixtal.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmp_vzixtal.d(51): Error: declaration expected, not `assert`\n/tmp/tmp_vzixtal.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmp_vzixtal.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmp_vzixtal.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmp_vzixtal.d(55): Error: declaration expected, not `assert`\n/tmp/tmp_vzixtal.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmp_vzixtal.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmp_vzixtal.d(58): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vzixtal.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 0) {\n            power *= x;\n        }\n        n /= 2;\n        x *=\
    \ x;\n    }\n    \n    if (n == 1) {\n        if (power * x == x) {\n        \
    \    return true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6d_z4ha5.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e8d]\n??:? void tmp6d_z4ha5.__unittest_L42_C1() [0x427ab9]\n??:?
    void tmp6d_z4ha5.__modtest() [0x427c10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430088]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb65]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa1d]\n??:? runModuleUnitTests [0x42b989]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428263]\n??:? _d_run_main [0x4281ce]\n??:? main [0x427c23]\n??:?
    __libc_start_main [0x4bcaa554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while (power < n)\n    {\n     \
    \   result *= x;\n        power *= x;\n    }\n    \n    if (result == x)\n   \
    \ {\n        return true;\n    }\n    else\n    {\n        return false;\n   \
    \ }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq_tqpzmz.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpq_tqpzmz.__unittest_L42_C1() [0x427ab1]\n??:?
    void tmpq_tqpzmz.__modtest() [0x427be4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bf7]\n??:?
    __libc_start_main [0x138a1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 0) {\n            power *= x;\n        }\n        n /= 2;\n        x *=\
    \ x;\n    }\n    \n    if (n == 1) {\n        if (power * x == x) {\n        \
    \    return true;\n        } else {\n            return false;\n        }\n  \
    \  } else {\n        if (power * x == x) {\n            return false;\n      \
    \  } else {\n            return true;\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpynyeupm8.d(53): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ead]\n??:? void tmpynyeupm8.__unittest_L49_C1() [0x427ad9]\n??:?
    void tmpynyeupm8.__modtest() [0x427c30]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbd3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa66]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300a8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb85]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa3d]\n??:? runModuleUnitTests [0x42b9a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428283]\n??:? _d_run_main [0x4281ee]\n??:? main [0x427c43]\n??:?
    __libc_start_main [0x7451c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while (n > 0)\n    {\n        if\
    \ (n % 2 == 0)\n        {\n            result *= x;\n            power *= n;\n\
    \        }\n        n /= 2;\n        x *= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_t9llclz.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e85]\n??:? void tmp_t9llclz.__unittest_L40_C1() [0x427aad]\n??:?
    void tmp_t9llclz.__modtest() [0x427c04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430080]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb5d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa15]\n??:? runModuleUnitTests [0x42b981]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42825b]\n??:? _d_run_main [0x4281c6]\n??:? main [0x427c17]\n??:?
    __libc_start_main [0xec830554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long i = 1L;\n    while(i<n)\n    {\n        r *= x;\n        i++;\n\
    \    }\n    return r == x;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\n\
    The question says \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases\"\n<|/ c |>\n<| c |>\nYes, I know. But I\
    \ thought that maybe the OP wants to know how this algorithm works. So I wrote\
    \ a code snippet that shows how it works.\n<|/ c |>\n<| c |>\nI guess you missed\
    \ the part where OP said \"Write a function that returns true if a number x is\
    \ a simple power of n and false in other cases\"\n<|/ c |>\n<| c |>\nYes, I missed\
    \ that part. Thanks for pointing out. I've edited my answer.\n<|/ c |>\n<| c |>\n\
    The question says \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases\"\n<|/ c |>\n<| a tags=c++,algorithm |>\n\
    <code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpizoxqwrd.d(33): Error: declaration expected, not `<`\n/tmp/tmpizoxqwrd.d(45):
    Error: unterminated character constant\n/tmp/tmpizoxqwrd.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmpizoxqwrd.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmpizoxqwrd.d(58): Error: declaration expected, not `assert`\n/tmp/tmpizoxqwrd.d(59):
    Error: declaration expected, not `assert`\n/tmp/tmpizoxqwrd.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmpizoxqwrd.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmpizoxqwrd.d(62): Error: declaration expected, not `assert`\n/tmp/tmpizoxqwrd.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpizoxqwrd.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpizoxqwrd.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpizoxqwrd.d(66): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpizoxqwrd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        power = power * n;\n        \n        if(power == x)\n        {\n   \
    \         return true;\n        }\n        \n        result = result * n;\n  \
    \      \n        if(result > x)\n        {\n            return false;\n      \
    \  }\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpretjr0h0.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpretjr0h0.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpretjr0h0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return true;\n    if (x == 1) return true;\n\
    \    if (x == n) return true;\n    \n    long r = 1;\n    \n    long d = 1;\n\
    \    \n    long t = 1;\n    \n    long m = 1;\n    \n    long r = 1;\n    \n \
    \   long c = 1;\n    \n    long a = 1;\n    \n    long b = 1;\n    \n    long\
    \ d = 1;\n    \n    long t = 1;\n    \n    long m = 1;\n    \n    long r = 1;\n\
    \    \n    long c = 1;\n    \n    long a = 1;\n    \n    long b = 1;\n    \n \
    \   long d = 1;\n    \n    long t = 1;\n    \n    long m = 1;\n    \n    long\
    \ r = 1;\n    \n    long c = 1;\n    \n    long a = 1;\n    \n    long b = 1;\n\
    \    \n    long d = 1;\n    \n    long t = 1;\n    \n    long m = 1;\n    \n \
    \   long r = 1;\n    \n    long c = 1;\n    \n    long a = 1;\n    \n    long\
    \ b = 1;\n    \n    long d = 1;\n    \n    long t = 1;\n    \n    long m = 1;\n\
    \    \n    long r = 1;\n    \n    long c = 1;\n    \n    long a = 1;\n    \n \
    \   long b = 1;\n    \n    long d = 1;\n    \n    long t = 1;\n    \n    long\
    \ m = 1;\n    \n    long r = 1;\n    \n    long c = 1;\n    \n    long a = 1;\n\
    \    \n    long b = 1;\n    \n    long d = 1;\n    \n    long t = 1;\n    \n \
    \   long m = 1;\n    \n    long r = 1;\n    \n    long c = 1;\n    \n    long\
    \ a = 1;\n    \n    long b = 1;\n    \n    long d = 1;\n    \n    long t = 1;\n\
    \    \n    long m = 1;\n    \n    long r = 1;\n    \n    long c = 1;\n    \n \
    \   long a = 1;\n    \n    long b = 1;\n    \n    long d = 1;\n    \n    long\
    \ t = 1;\n    \n    long m = 1;\n    \n    long r = 1;\n    \n    long c = 1;\n\
    \    \n    long a = 1;\n    \n    long b = 1;\n    \n    long d = 1;\n    \n \
    \   long t = 1;\n    \n    long m = 1;\n    \n    long r = 1;\n    \n    long\
    \ c = 1;\n    \n    \nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2aecbk1i.d(168): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2aecbk1i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = n;\n    long power2 = power;\n    \n    while\
    \ (power2 > 1) {\n        if (power2 % 2 == 1) {\n            result *= x;\n \
    \       }\n        power2 /= 2;\n        x *= x;\n    }\n    \n    if (power2\
    \ == 1) {\n        result *= x;\n    }\n    \n    if (result == power) {\n   \
    \     return true;\n    } else {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzu2ng3qw.d(50): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e8d]\n??:? void tmpzu2ng3qw.__unittest_L46_C1() [0x427ab9]\n??:?
    void tmpzu2ng3qw.__modtest() [0x427c10]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430088]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb65]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa1d]\n??:? runModuleUnitTests [0x42b989]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428263]\n??:? _d_run_main [0x4281ce]\n??:? main [0x427c23]\n??:?
    __libc_start_main [0x69c69554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq3bt2rr7.d(31): unittest failure\n----------------\n??:?
    _d_unittestp [0x427efd]\n??:? void tmpq3bt2rr7.__unittest_L27_C1() [0x427a8d]\n??:?
    void tmpq3bt2rr7.__modtest() [0x427c80]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fbd5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa8d]\n??:? runModuleUnitTests [0x42b9f9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282d3]\n??:? _d_run_main [0x42823e]\n??:? main [0x427c93]\n??:?
    __libc_start_main [0x464a0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4gegbff8.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e75]\n??:? void tmp4gegbff8.__unittest_L33_C1() [0x427a9d]\n??:?
    void tmp4gegbff8.__modtest() [0x427bf4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa05]\n??:? runModuleUnitTests [0x42b971]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42824b]\n??:? _d_run_main [0x4281b6]\n??:? main [0x427c07]\n??:?
    __libc_start_main [0x84dd1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= x;\n        result *= power;\n        n--;\n    }\n    \n    return result\
    \ == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvgf6bnm3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmpvgf6bnm3.__unittest_L36_C1() [0x427a79]\n??:?
    void tmpvgf6bnm3.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xc4a23554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    while(m > 1)\n    {\n        if((m & 1) == 1)\n\
    \        {\n            if((x & m) == 0)\n            {\n                return\
    \ false;\n            }\n            else\n            {\n                x >>=\
    \ m;\n            }\n        }\n        else\n        {\n            if((x & m)\
    \ == 0)\n            {\n                return false;\n            }\n       \
    \     else\n            {\n                x >>= m;\n            }\n        }\n\
    \        m *= n;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nI appreciate your efforts, but the question was about how to solve this\
    \ problem using only `if` and `else` statements.\n<|/ c |>\n<| c |>\nI didn't\
    \ know that `if` and `else` statements could be used only with `if` statements.\
    \ I thought that `if` and `else` statements could be used only with `while` statements.\
    \ Thank you for pointing this out.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4q_ybc_a.d(54): Error: declaration expected, not `<`\n/tmp/tmp4q_ybc_a.d(60):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4q_ybc_a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 0L) return false;\n\
    \    if (n % 3 == 0L) return false;\n    if (n % 5 == 0L) return false;\n    long\
    \ res = 1L;\n    long d = 1L;\n    while (d <= n) \n    {\n        if (x % d ==\
    \ 0L) \n        {\n            res = false;\n            break;\n        }\n \
    \       d = d * 2L;\n    }\n    return res;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nThis fails for `is_simple_power(1L, 0L)` which should return `true`.\n\
    <|/ c |>\n<| c |>\nYes, I noticed that and fixed it\n<|/ c |>\n<| c |>\nThis fails\
    \ for `is_simple_power(1L, 1L)` which should return `true`.\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it\n<|/ c |>\n<| c |>\nThis fails for `is_simple_power(1L,\
    \ 2L)` which should return `true`.\n<|/ c |>\n<| a tags=c++,algorithm |>\nI believe\
    \ this can be solved using logarithms. \n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo_3wthan.d(44): Error: declaration expected, not `<`\n/tmp/tmpo_3wthan.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmpo_3wthan.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmpo_3wthan.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmpo_3wthan.d(71): Error: declaration expected, not `assert`\n/tmp/tmpo_3wthan.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmpo_3wthan.d(73): Error: declaration
    expected, not `assert`\n/tmp/tmpo_3wthan.d(74): Error: declaration expected, not
    `assert`\n/tmp/tmpo_3wthan.d(75): Error: declaration expected, not `assert`\n/tmp/tmpo_3wthan.d(76):
    Error: declaration expected, not `assert`\n/tmp/tmpo_3wthan.d(77): Error: declaration
    expected, not `assert`\n/tmp/tmpo_3wthan.d(78): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_3wthan.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long\
    \ u = 1;\n    long v = 1;\n    long w = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp89sfna3g.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89sfna3g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (n == 0L) return false;\n    if (n % 2 == 1L) return\
    \ is_simple_power(x, n / 2L);\n    long r = x;\n    while (r != 1L) {\n      \
    \  if (n % r == 0L) return true;\n        r /= 2L;\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=c++,algorithm,math |>\n<| c |>\nThis doesn't work for `is_simple_power(2L,\
    \ 3L)` which returns `true` but should return `false`.\n<|/ c |>\n<| c |>\nI see\
    \ what you mean. I've fixed the code.\n<|/ c |>\n<| c |>\nThis doesn't work for\
    \ `is_simple_power(2L, 3L)` which returns `true` but should return `false`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've fixed the code.\n<|/ c |>\n<| c |>\n\
    This doesn't work for `is_simple_power(2L, 3L)` which returns `true` but should\
    \ return `false`.\n<|/ c |>\n<| a |>\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp46t0qq2.d(34): Error: declaration expected, not `<`\n/tmp/tmpp46t0qq2.d(37):
    Error: unterminated character constant\n/tmp/tmpp46t0qq2.d(40): Error: unterminated
    character constant\n/tmp/tmpp46t0qq2.d(43): Error: unterminated character constant\n/tmp/tmpp46t0qq2.d(46):
    Error: unterminated character constant\n/tmp/tmpp46t0qq2.d(49): Error: unterminated
    character constant\n/tmp/tmpp46t0qq2.d(57): Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpp46t0qq2.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpp46t0qq2.d(61): Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpp46t0qq2.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpp46t0qq2.d(65): Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmpp46t0qq2.d(67): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp46t0qq2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 0) {\n            power *= x;\n            result *= power;\n        }\n\
    \        n /= 2;\n        x *= x;\n    }\n    \n    if (n == 1) {\n        return\
    \ result == x;\n    }\n    \n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8eh026bp.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e95]\n??:? void tmp8eh026bp.__unittest_L42_C1() [0x427ac1]\n??:?
    void tmp8eh026bp.__modtest() [0x427c18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430090]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb6d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa25]\n??:? runModuleUnitTests [0x42b991]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42826b]\n??:? _d_run_main [0x4281d6]\n??:? main [0x427c2b]\n??:?
    __libc_start_main [0xb60c6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 1L) return false;\n\
    \    if (n % 3 == 1L) return false;\n    if (n % 5 == 1L) return false;\n    long\
    \ r = 1L;\n    long m = n / 2;\n    while (m > 1L) {\n        if (m % 2 == 1L)\
    \ r = r * x;\n        if (m % 3 == 1L) r = r * x * x;\n        if (m % 5 == 1L)\
    \ r = r * x * x * x;\n        m = m / 2;\n    }\n    return r == x;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `is_simple_power(1L, 4L)` returns\
    \ `true` but `is_simple_power(2L, 2L)` returns `false`.\n<|/ c |>\n<| c |>\n:\
    \ I fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| a tags=c++,algorithm\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx5a74ftb.d(41): Error: declaration expected, not `<`\n/tmp/tmpx5a74ftb.d(44):
    Error: unterminated character constant\n/tmp/tmpx5a74ftb.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpx5a74ftb.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpx5a74ftb.d(57): Error: declaration expected, not `assert`\n/tmp/tmpx5a74ftb.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpx5a74ftb.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpx5a74ftb.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpx5a74ftb.d(61): Error: declaration expected, not `assert`\n/tmp/tmpx5a74ftb.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpx5a74ftb.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpx5a74ftb.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpx5a74ftb.d(65): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpx5a74ftb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while (n > 0)\n    {\n        result\
    \ *= x;\n        power *= n;\n        n--;\n    }\n    \n    if (result == x)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpan3edt9i.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpan3edt9i.__unittest_L43_C1() [0x427a8d]\n??:?
    void tmpan3edt9i.__modtest() [0x427be4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bf7]\n??:?
    __libc_start_main [0x98237554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long d = 1;\n    long m = 1;\n    long e = 1;\n    long e2 = 1;\n\
    \    long e3 = 1;\n    long e4 = 0;\n    long e5 = 0;\n    long e6 = 1;\n    long\
    \ e7 = 1;\n    long e8 = 1;\n    long e9 = 1;\n    long e10 = 1;\n    long e11\
    \ = 1;\n    long e12 = 1;\n    long e13 = 1;\n    long e14 = 1;\n    long e15\
    \ = 1;\n    long e16 = 1;\n    long e17 = 1;\n    long e18 = 1;\n    long e19\
    \ = 1;\n    long e20 = 1;\n    long e21 = 1;\n    long e22 = 1;\n    long e23\
    \ = 1;\n    long e24 = 1;\n    long e25 = 1;\n    long e26 = 1;\n    long e27\
    \ = 1;\n    long e28 = 1;\n    long e29 = 1;\n    long e30 = 1;\n    long e31\
    \ = 1;\n    long e32 = 1;\n    long e33 = 1;\n    long e34 = 1;\n    long e35\
    \ = 1;\n    long e36 = 1;\n    long e37 = 1;\n    long e38 = 1;\n    long e39\
    \ = 1;\n    long e40 = 1;\n    long e41 = 1;\n    long e42 = 0;\n    long e43\
    \ = 0;\n    long e44 = 0;\n    long e45 = 0;\n    long e46 = 1;\n    long e47\
    \ = 1;\n    long e48 = 1;\n    long e49 = 1;\n    long e50 = 1;\n    long e51\
    \ = 1;\n    long e52 = 0;\n    long e53 = 0;\n    long e54 = 0;\n    long e55\
    \ = 0;\n    long e56 = 1;\n    long e57 = 1;\n    long e58 = 1;\n    long e59\
    \ = 1;\n    long e60 = 1;\n    long e61 = 1;\n    long e62 = 1;\n    long e63\
    \ = 1;\n    long e64 = 1;\n    long e65 = 1;\n    long e66 = 1;\n    long e67\
    \ = 1;\n    long e68 = 1;\n    long e69 = 1;\n    long e70 = 1;\n    long e71\
    \ = 1;\n    long e72 = 0;\n    long e73 = 1;\n    long e74 = 1;\n    long e75\
    \ = 1;\n    long e76 = 1;\n    long e77 = 1;\n    long e78 = 1;\n    long e79\
    \ = 1;\n    long e80 = 1;\n    long e81 = 1;\n    long e82 = 1;\n    long e83\
    \ = 1;\n    long e84 = 1;\n    long e85 = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphyosqssx.d(113): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphyosqssx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(power < n)\n    {\n      \
    \  result *= x;\n        power *= x;\n    }\n    \n    return result == x;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5lkj5hwe.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp5lkj5hwe.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmp5lkj5hwe.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x92ecc554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L)\n        return true;\n    if (x == 0L)\n        return false;\n    if\
    \ (n == 0L)\n        return false;\n    if (n % 2 == 0L)\n        return is_simple_power(x,\
    \ n / 2L);\n    if (n % 2 == 1L)\n        return is_simple_power(x, n / 2L) &&\
    \ is_simple_power(x, n / 2L);\n    return false;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis does not work. `is_simple_power(1L, 4L)` returns `true` but `is_simple_power(2L,\
    \ 2L)` returns `false`\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpslsnn_83.d(36): Error: declaration expected, not `<`\n/tmp/tmpslsnn_83.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpslsnn_83.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpslsnn_83.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpslsnn_83.d(53): Error: declaration expected, not `assert`\n/tmp/tmpslsnn_83.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpslsnn_83.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpslsnn_83.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpslsnn_83.d(57): Error: declaration expected, not `assert`\n/tmp/tmpslsnn_83.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpslsnn_83.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpslsnn_83.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpslsnn_83.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbul6et8k.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpbul6et8k.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpbul6et8k.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0xa4793554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    return (result ==\
    \ x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpo31hryfd.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpo31hryfd.__unittest_L35_C1() [0x427aa1]\n??:?
    void tmpo31hryfd.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x4ad21554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    long res = 1L;\n    long d = 1L;\n\
    \    long r = 1L;\n    while (n > 1L) {\n        if (n % 2L == 1L) {\n       \
    \     res = res * x;\n            if (res == x) return true;\n        }\n    \
    \    d = d * n;\n        n = n / 2L;\n    }\n    return res == x;\n}\n</code>\n\
    <|/ a tags=c++,algorithm |>\n<| c |>\n`is_simple_power(3L, 2L)` returns `true`\
    \ but `is_simple_power(3L, 1L)` returns `false`\n<|/ c |>\n<| c |>\nI fixed the\
    \ bug. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n`is_simple_power(3L, 1L)`\
    \ returns `true` but `is_simple_power(3L, 2L)` returns `false`\n<|/ c |>\n<| c\
    \ |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n`is_simple_power(3L,\
    \ 1L)` returns `true` but `is_simple_power(3L, 2L)` returns `false`\n<|/ c |>\n\
    <| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp46eyzhia.d(41): Error: declaration expected, not `<`\n/tmp/tmp46eyzhia.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmp46eyzhia.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmp46eyzhia.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmp46eyzhia.d(67): Error: declaration expected, not `assert`\n/tmp/tmp46eyzhia.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmp46eyzhia.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmp46eyzhia.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmp46eyzhia.d(71): Error: declaration expected, not `assert`\n/tmp/tmp46eyzhia.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmp46eyzhia.d(73): Error: declaration
    expected, not `assert`\n/tmp/tmp46eyzhia.d(74): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp46eyzhia.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long temp = 1;\n    \n    while(n > 0)\n    {\n        if(n%2 ==\
    \ 1)\n        {\n            temp *= x;\n        }\n        n /= 2;\n        x\
    \ *= x;\n    }\n    \n    return temp == x;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `is_simple_power(-4, 2)`\
    \ returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nI fixed the bug. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `is_simple_power(-4, 2)` returns `true` instead of `false`.\n<|/ c |>\n<| c\
    \ |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. `is_simple_power(-4, 2)` returns `true` instead of\
    \ `false`.\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8wa7i06g.d(39): Error: declaration expected, not `<`\n/tmp/tmp8wa7i06g.d(42):
    Error: unterminated character constant\n/tmp/tmp8wa7i06g.d(48): Error: unterminated
    character constant\n/tmp/tmp8wa7i06g.d(54): Error: unterminated character constant\n/tmp/tmp8wa7i06g.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmp8wa7i06g.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmp8wa7i06g.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmp8wa7i06g.d(65): Error: declaration expected, not `assert`\n/tmp/tmp8wa7i06g.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmp8wa7i06g.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmp8wa7i06g.d(68): Error: declaration expected, not
    `assert`\n/tmp/tmp8wa7i06g.d(69): Error: declaration expected, not `assert`\n/tmp/tmp8wa7i06g.d(70):
    Error: declaration expected, not `assert`\n/tmp/tmp8wa7i06g.d(71): Error: declaration
    expected, not `assert`\n/tmp/tmp8wa7i06g.d(72): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wa7i06g.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a tags=c++,algorithm,math\
    \ |>\n<| c |>\nThis doesn't work for negative exponents. `is_simple_power(-1,\
    \ 2)` returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nI fixed the negative\
    \ exponent issue. Thanks for pointing it out.\n<|/ c |>\n<| a tags=c++,algorithm,math\
    \ |>\n<code>\n#include <iostream>\n#include <cmath>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnzholycw.d(33): Error: declaration expected, not `<`\n/tmp/tmpnzholycw.d(36):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnzholycw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    while(n > power) {\n        power *= n;\n    }\n    return x\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpoh24bs_t.d(34): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e3d]\n??:? void tmpoh24bs_t.__unittest_L30_C1() [0x427a69]\n??:?
    void tmpoh24bs_t.__modtest() [0x427bc0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9f6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb89]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430038]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb15]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9cd]\n??:? runModuleUnitTests [0x42b939]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42828c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428213]\n??:? _d_run_main [0x42817e]\n??:? main [0x427bd3]\n??:?
    __libc_start_main [0x71364554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    return result == x;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7dbvd8pq.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp7dbvd8pq.__unittest_L35_C1() [0x427aa1]\n??:?
    void tmp7dbvd8pq.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x7e854554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(power < n)\n    {\n      \
    \  result *= x;\n        power *= x;\n    }\n    \n    return (result == x);\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1a45w6z6.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp1a45w6z6.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmp1a45w6z6.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x3ef47554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L)\n        return true;\n    if (n == 0L)\n        return false;\n    if\
    \ (n % 2 == 0L)\n        return is_simple_power(x, n / 2L);\n    else\n      \
    \  return is_simple_power(x, n / 2L) && is_simple_power(x, n / 2L);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI appreciate your efforts, but the question was about\
    \ a recursive solution, not a iterative one.\n<|/ c |>\n<| c |>\nI didn't say\
    \ it was iterative, just recursive. Recursion is just a way of thinking about\
    \ a problem in terms of smaller problems. In this case, a recursive solution would\
    \ be a recursive solution. Recursion is just a way of thinking about a problem\
    \ in terms of smaller problems. In this case, a recursive solution would be a\
    \ recursive solution.\n<|/ c |>\n<| c |>\nI understand that, but I thought that\
    \ iterative solutions are more efficient than recursive ones. I guess I should\
    \ rephrase my question then.\n<|/ c |>\n<| c |>\nI rephrased my question to make\
    \ it more clear.\n<|/ c |>\n<| c |>\nI added a recursive solution to my answer.\
    \ Hope it helps.\n<|/ c |>\n<| a dscore=1 |>\nI believe this can be done with\
    \ recursion. \n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7ej589p3.d(33): Error: declaration expected, not `<`\n/tmp/tmp7ej589p3.d(39):
    Error: unterminated character constant\n/tmp/tmp7ej589p3.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmp7ej589p3.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmp7ej589p3.d(59): Error: declaration expected, not `assert`\n/tmp/tmp7ej589p3.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmp7ej589p3.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmp7ej589p3.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmp7ej589p3.d(63): Error: declaration expected, not `assert`\n/tmp/tmp7ej589p3.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmp7ej589p3.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmp7ej589p3.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmp7ej589p3.d(67): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7ej589p3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (n == 0L) return false;\n    if (n == 1L) return\
    \ true;\n    if (x == 0L) return false;\n    if (x == -1L) return false;\n   \
    \ if (x == -2L) return false;\n    if (x == -3L) return false;\n    if (x == -4L)\
    \ return false;\n    if (x == -5L) return false;\n    if (x == -6L) return false;\n\
    \    if (x == -7L) return false;\n    if (x == -8L) return false;\n    if (x ==\
    \ -9L) return false;\n    if (x == -10L) return false;\n    if (x == -11L) return\
    \ false;\n    if (x == -12L) return false;\n    if (x == -13L) return false;\n\
    \    if (x == -14L) return false;\n    if (x == -15L) return false;\n    if (x\
    \ == -16L) return false;\n    if (x == -17L) return false;\n    if (x == -18L)\
    \ return false;\n    if (x == -19L) return false;\n    if (x == -20L) return false;\n\
    \    if (x == -21L) return false;\n    if (x == -22L) return false;\n    if (x\
    \ == -23L) return false;\n    if (x == -24L) return false;\n    if (x == -25L)\
    \ return false;\n    if (x == -26L) return false;\n    if (x == -27L) return false;\n\
    \    if (x == -28L) return false;\n    if (x == -29L) return false;\n    if (x\
    \ == -30L) return false;\n    if (x == -31L) return false;\n    if (x == -32L)\
    \ return false;\n    if (x == -33L) return false;\n    if (x == -34L) return false;\n\
    \    if (x == -35L) return false;\n    if (x == -36L) return false;\n    if (x\
    \ == -37L) return false;\n    if (x == -38L) return false;\n    if (x == -39L)\
    \ return false;\n    if (x == -40L) return false;\n    if (x == -41L) return false;\n\
    \    if (x == -42L) return false;\n    if (x == -43L) return false;\n    if (x\
    \ == -44L) return false;\n    if (x == -45L) return false;\n    if (x == -46L)\
    \ return false;\n    if (x == -47L) return false;\n    if (x == -48L) return false;\n\
    \    if (x == -49L) return false;\n    if (x == -50L) return false;\n    if (x\
    \ == -51L) return false;\n    if (x == -52L) return false;\n    if (x == -53L)\
    \ return false;\n    if (x == -54L) return false;\n    if (x == -55L) return false;\n\
    \    if (x == -56L) return false;\n    if (x == -57L) return false;\n    if (x\
    \ == -58L) return false;\n    if (x == -59L) return false;\n    if (x == -60L)\
    \ return false;\n    if (x == -61L) return false;\n    if (x == -62L) return false;\n\
    \    if (x == -63L) return false;\n    if (x == -64L) return false;\n    if (x\
    \ == -65L) return false;\n    if (x == -66L) return false;\n    if (x == -67L)\
    \ return false;\n    if (x == -68L) return false;\n    if (x == -69L) return false;\n\
    \    if (x == -70L) return false;\n    if (x == -71L) return false;\n    if (x\
    \ == -72L) return false;\n    if (x == \nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmputh_i4ln.d(101): Error: expression expected, not `unittest`\n/tmp/tmputh_i4ln.d(102):
    Error: found `{` when expecting `)`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmputh_i4ln.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * x;\n        result = result * n;\n        n = n - 1;\n    }\n    \n\
    \    return (result == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbd25rlob.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpbd25rlob.__unittest_L36_C1() [0x427a8d]\n??:?
    void tmpbd25rlob.__modtest() [0x427be4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bf7]\n??:?
    __libc_start_main [0x3ce43554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L)\n        return true;\n    if (n == 0L)\n        return false;\n    if\
    \ (n % 2 == 0L)\n        return is_simple_power(x, n / 2L);\n    else\n      \
    \  return is_simple_power(x, n / 2L) && is_simple_power(x, n / 2L);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmxdciy1_.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e85]\n??:? void tmpmxdciy1_.__unittest_L33_C1() [0x427ab1]\n??:?
    void tmpmxdciy1_.__modtest() [0x427c08]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430080]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb5d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa15]\n??:? runModuleUnitTests [0x42b981]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42825b]\n??:? _d_run_main [0x4281c6]\n??:? main [0x427c1b]\n??:?
    __libc_start_main [0x9a5dd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 1L) return true;\n    if (n == 0L) return false;\n    if (x == 0L) return\
    \ false;\n    if (x == 1L) return true;\n    \n    long r = 1L;\n    long d =\
    \ 1L;\n    long t = 1L;\n    \n    while (d < n) {\n        if (x % d == 0) {\n\
    \            r = r * x;\n            t *= d;\n        }\n        d *= 2L;\n  \
    \  }\n    \n    return r == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_3ncoapz.d(51): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ead]\n??:? void tmp_3ncoapz.__unittest_L43_C1() [0x427b65]\n??:?
    void tmp_3ncoapz.__modtest() [0x427c2c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbd3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa66]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300a8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb85]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa3d]\n??:? runModuleUnitTests [0x42b9a9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428283]\n??:? _d_run_main [0x4281ee]\n??:? main [0x427c3f]\n??:?
    __libc_start_main [0xae104554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L)\n        return true;\n    if (x == 0L)\n        return false;\n    if\
    \ (n == 0L)\n        return false;\n    if (n % 2 == 1L)\n        return false;\n\
    \    long r = 1L;\n    while (n > 1L) {\n        if ((n % 4 == 0L) && (n % n ==\
    \ 0L))\n            return false;\n        r <<= 1L;\n        n >>= 1L;\n    }\n\
    \    return (r == x);\n}\n</code>\n<|/ a |>\n<| c |>\nI like the idea of using\
    \ bitwise operators to solve this problem. Thanks!\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I believe that it is wrong. For example, `is_simple_power(3L,\
    \ 2L)` returns `true` while `3L**2 == 9L` returns `false`. So your solution returns\
    \ `true` when it should return `false`.\n<|/ c |>\n<| c |>\nI believe that `3L**2\
    \ == 9L` returns `false` because `3L` is `3L` and not `9L`.\n<|/ c |>\n<| c |>\n\
    Yes, you're right. My mistake. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n\
    I believe that `3L**2 == 9L` returns `false` because `3L` is `3L` and not `9L`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpigf5n1vx.d(41): Error: declaration expected, not `<`\n/tmp/tmpigf5n1vx.d(53):
    Error: unterminated character constant\n/tmp/tmpigf5n1vx.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpigf5n1vx.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpigf5n1vx.d(66): Error: declaration expected, not `assert`\n/tmp/tmpigf5n1vx.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpigf5n1vx.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpigf5n1vx.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmpigf5n1vx.d(70): Error: declaration expected, not `assert`\n/tmp/tmpigf5n1vx.d(71):
    Error: declaration expected, not `assert`\n/tmp/tmpigf5n1vx.d(72): Error: declaration
    expected, not `assert`\n/tmp/tmpigf5n1vx.d(73): Error: declaration expected, not
    `assert`\n/tmp/tmpigf5n1vx.d(74): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpigf5n1vx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = n;\n    while (power > 1) {\n        if (power\
    \ % 2 == 0) {\n            result *= x;\n        }\n        power /= 2;\n    \
    \    x *= x;\n    }\n    if (power == 1) {\n        return result == x;\n    }\n\
    \    return false;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm |>\n\
    <code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpee0v006y.d(38): Error: declaration expected, not `<`\n/tmp/tmpee0v006y.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmpee0v006y.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpee0v006y.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpee0v006y.d(49): Error: declaration expected, not `assert`\n/tmp/tmpee0v006y.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpee0v006y.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpee0v006y.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpee0v006y.d(53): Error: declaration expected, not `assert`\n/tmp/tmpee0v006y.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpee0v006y.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpee0v006y.d(56): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpee0v006y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= x;\n    }\n    return (result == power);\n\
    }\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis is not the fastest solution,\
    \ since it uses exponentiation by squaring which is O(n^2). Also it uses integer\
    \ division, which is not the fastest solution, since it uses integer division.\n\
    <|/ c |>\n<| c |>\nI agree, it's O(n^2) but it's also O(n) since it uses integer\
    \ division which is O(n). So the total complexity is O(n).\n<|/ c |>\n<| c |>\n\
    The question asks for an algorithm that can solve this problem in O(log n) time.\
    \ Your algorithm is O(n).\n<|/ c |>\n<| c |>\n: O(log n) is the same as O(n),\
    \ since log n grows faster than n. O(log n) is also O(n), since log n grows faster\
    \ than n.\n<|/ c |>\n<| c |>\n: O(log n) is the same as O(n), since log n grows\
    \ faster than n. O(log n) is also O(n), since log n grows faster than n.\n<|/\
    \ c |>\n<| a |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy54kdbhx.d(34): Error: declaration expected, not `<`\n/tmp/tmpy54kdbhx.d(40):
    Error: unterminated character constant\n/tmp/tmpy54kdbhx.d(40): Error: unterminated
    character constant\n/tmp/tmpy54kdbhx.d(57): Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpy54kdbhx.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpy54kdbhx.d(61): Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpy54kdbhx.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmpy54kdbhx.d(65): Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmpy54kdbhx.d(67): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy54kdbhx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        result = result * x;\n        n = n - 1;\n    }\n    \n\
    \    return (result == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmppxt6h1xi.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmppxt6h1xi.__unittest_L36_C1() [0x427a8d]\n??:?
    void tmppxt6h1xi.__modtest() [0x427be4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bf7]\n??:?
    __libc_start_main [0x9d6e4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\n`is_simple_power(3L,\
    \ 3L)` returns `true` but `is_simple_power(3L, 2L)` returns `false`\n<|/ c |>\n\
    <| c |>\nYes, I forgot about that case. Fixed now.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfb_41xch.d(36): Error: declaration expected, not `<`\n/tmp/tmpfb_41xch.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpfb_41xch.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpfb_41xch.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpfb_41xch.d(53): Error: declaration expected, not `assert`\n/tmp/tmpfb_41xch.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpfb_41xch.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpfb_41xch.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpfb_41xch.d(57): Error: declaration expected, not `assert`\n/tmp/tmpfb_41xch.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpfb_41xch.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpfb_41xch.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfb_41xch.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    \n    return (result ==\
    \ power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpwdqnudin.d(39): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpwdqnudin.__unittest_L35_C1() [0x427a91]\n??:?
    void tmpwdqnudin.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x8d7cd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= x;\n        result *= power;\n        n--;\n    }\n    \n    return result\
    \ == x;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your efforts, but\
    \ the question was about a specific language and I wanted to know why my code\
    \ didn't work. Your code doesn't work because you didn't use any language features.\
    \ I wanted to know why my code didn't work and how to fix it.\n<|/ c |>\n<| c\
    \ |>\nI didn't say that my code doesn't work. I said that your question was about\
    \ a specific language and I wanted to know why my code didn't work. Your code\
    \ doesn't work because you didn't use any language features. I wanted to know\
    \ why my code didn't work and how to fix it.\n<|/ c |>\n<| c |>\nI didn't say\
    \ that my code doesn't work. I said that your question was about a specific language\
    \ and I wanted to know why my code didn't work. Your code doesn't work because\
    \ you didn't use any language features. I wanted to know why my code didn't work\
    \ and how to fix it.\n<|/ c |>\n<| c |>\nI didn't say that my code doesn't work.\
    \ I said that your question was about a specific language and I wanted to know\
    \ why my code didn't work. Your code doesn't work because you didn't use any language\
    \ features. I wanted to know why my code didn't work and how to fix it.\n<|/ c\
    \ |>\n<| c |>\nI didn't say that my code doesn't work. I said that your question\
    \ was about a specific language and I wanted to know why my code didn't work.\
    \ Your code doesn't work because you didn't use any language features. I wanted\
    \ to know why my code didn't work and how to fix it.\n<|/ c |>\n<| a tags=c++,algorithm\
    \ |>\n<code>\n#include <iostream>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5j4tbn1a.d(36): Error: declaration expected, not `<`\n/tmp/tmp5j4tbn1a.d(39):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(39): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(39): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(39):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(42): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(42): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(42):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(42): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(42): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(42):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(45): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(45): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(45):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(45): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(45): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(45):
    Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(48): Error: unterminated
    character constant\n/tmp/tmp5j4tbn1a.d(48): Error: unterminated character constant\n/tmp/tmp5j4tbn1a.d(48):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp5j4tbn1a.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(n > 0)\n    {\n        result\
    \ *= x;\n        power *= n;\n        n--;\n    }\n    \n    return result ==\
    \ power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpxeblwn8r.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e5d]\n??:? void tmpxeblwn8r.__unittest_L36_C1() [0x427a85]\n??:?
    void tmpxeblwn8r.__modtest() [0x427bdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9ed]\n??:? runModuleUnitTests [0x42b959]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428233]\n??:? _d_run_main [0x42819e]\n??:? main [0x427bef]\n??:?
    __libc_start_main [0x1bd42554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ res = 1;\n    while(n > 0)\n    {\n        if(n & 1)\n            res = res\
    \ * x;\n        n = n >> 1;\n        x = x * x;\n    }\n    return res == x;\n\
    }\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis doesn't work. Try is_simple_power(3L,\
    \ 3L).\n<|/ c |>\n<| c |>\nIt works. Try is_simple_power(3L, 3L). You will get\
    \ false\n<|/ c |>\n<| c |>\nIt works. Try is_simple_power(3L, 3L). You will get\
    \ false\n<|/ c |>\n<| c |>\nIt works. Try is_simple_power(3L, 3L). You will get\
    \ false\n<|/ c |>\n<| c |>\nIt works. Try is_simple_power(3L, 3L). You will get\
    \ false\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw8kl2jnf.d(34): Error: declaration expected, not `<`\n/tmp/tmpw8kl2jnf.d(37):
    Error: unterminated character constant\n/tmp/tmpw8kl2jnf.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpw8kl2jnf.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpw8kl2jnf.d(59): Error: declaration expected, not `assert`\n/tmp/tmpw8kl2jnf.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpw8kl2jnf.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpw8kl2jnf.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpw8kl2jnf.d(63): Error: declaration expected, not `assert`\n/tmp/tmpw8kl2jnf.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpw8kl2jnf.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpw8kl2jnf.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpw8kl2jnf.d(67): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpw8kl2jnf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= x;\n    }\n    return result == power;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpldunkknw.d(34): Error: declaration expected, not `<`\n/tmp/tmpldunkknw.d(42):
    Error: declaration expected, not `assert`\n/tmp/tmpldunkknw.d(43): Error: declaration
    expected, not `assert`\n/tmp/tmpldunkknw.d(44): Error: declaration expected, not
    `assert`\n/tmp/tmpldunkknw.d(45): Error: declaration expected, not `assert`\n/tmp/tmpldunkknw.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmpldunkknw.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpldunkknw.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpldunkknw.d(49): Error: declaration expected, not `assert`\n/tmp/tmpldunkknw.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpldunkknw.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpldunkknw.d(52): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldunkknw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= x;\n    }\n    return result == power;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative numbers. Try `is_simple_power(-1L,\
    \ 4L)`.\n<|/ c |>\n<| c |>\nI believe that `is_simple_power(-1L, 4L)` should return\
    \ `false` because `-1L**4` is `-1L` and not `0`.\n<|/ c |>\n<| c |>\nYes, but\
    \ `-1L**4` isn't `-1L`, it's `-1L` **raised to the fourth power**.\n<|/ c |>\n\
    <| c |>\nYes, you are right. I misunderstood your question. Sorry.\n<|/ c |>\n\
    <| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpouy1sv0e.d(34): Error: declaration expected, not `<`\n/tmp/tmpouy1sv0e.d(37):
    Error: unterminated character constant\n/tmp/tmpouy1sv0e.d(43): Error: unterminated
    character constant\n/tmp/tmpouy1sv0e.d(43): Error: unterminated character constant\n/tmp/tmpouy1sv0e.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpouy1sv0e.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpouy1sv0e.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpouy1sv0e.d(57): Error: declaration expected, not `assert`\n/tmp/tmpouy1sv0e.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpouy1sv0e.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpouy1sv0e.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpouy1sv0e.d(61): Error: declaration expected, not `assert`\n/tmp/tmpouy1sv0e.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpouy1sv0e.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmpouy1sv0e.d(64): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpouy1sv0e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n -= 1;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpu79_6s0i.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e5d]\n??:? void tmpu79_6s0i.__unittest_L36_C1() [0x427a85]\n??:?
    void tmpu79_6s0i.__modtest() [0x427bdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9ed]\n??:? runModuleUnitTests [0x42b959]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428233]\n??:? _d_run_main [0x42819e]\n??:? main [0x427bef]\n??:?
    __libc_start_main [0x23326554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 0;\n    long\
    \ h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n\
    \    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long\
    \ q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n\
    \    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long\
    \ z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n\
    \    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long\
    \ I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n\
    \    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long\
    \ R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n\
    \    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long A = 0;\n    long\
    \ B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n\
    \    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long\
    \ K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n\
    \    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long\
    \ T = 0;\n    long U = 0;\n    long V = 0;\n    long W\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfj9d0izl.d(127): Error: semicolon expected, not `unittest`\n/tmp/tmpfj9d0izl.d(127):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpfj9d0izl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while (n > 1) {\n    \
    \    if (n % 2 == 0) {\n            power *= x;\n        }\n        result *=\
    \ x;\n        n /= 2;\n        x *= x;\n    }\n    \n    if (n == 1) {\n     \
    \   if (power == result) {\n            return true;\n        }\n    }\n    \n\
    \    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplhte5n6k.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmplhte5n6k.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhte5n6k.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power = power\
    \ * n;\n        result += power;\n        n--;\n    }\n    return (result == x);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work for `is_simple_power(3L,\
    \ 3L)` which should return `true`.\n<|/ c |>\n<| c |>\nI didn't see that case.\
    \ Thanks for pointing it out. I've edited my answer.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd1ffbbn1.d(34): Error: declaration expected, not `<`\n/tmp/tmpd1ffbbn1.d(37):
    Error: unterminated character constant\n/tmp/tmpd1ffbbn1.d(40): Error: unterminated
    character constant\n/tmp/tmpd1ffbbn1.d(40): Error: unterminated character constant\n/tmp/tmpd1ffbbn1.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpd1ffbbn1.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpd1ffbbn1.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpd1ffbbn1.d(51): Error: declaration expected, not `assert`\n/tmp/tmpd1ffbbn1.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmpd1ffbbn1.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpd1ffbbn1.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpd1ffbbn1.d(55): Error: declaration expected, not `assert`\n/tmp/tmpd1ffbbn1.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpd1ffbbn1.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpd1ffbbn1.d(58): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1ffbbn1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ res = 1;\n    long power = 1;\n    \n    while (power < n)\n    {\n        res\
    \ *= x;\n        power *= x;\n    }\n    \n    return res == x;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5fzdzea3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp5fzdzea3.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmp5fzdzea3.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0xc34a5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        \n        if(power == x)\n        {\n            result\
    \ = true;\n            break;\n        }\n        \n        power = power/n;\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6evdwo0d.d(40): Error: cannot implicitly convert expression
    `result` of type `long` to `bool`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6evdwo0d.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 0) {\n            power *= x;\n        }\n        n /= 2;\n        x *=\
    \ x;\n    }\n    \n    if (n == 1) {\n        if (power == x) {\n            return\
    \ true;\n        }\n    }\n    \n    return false;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpwgepaec1.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e8d]\n??:? void tmpwgepaec1.__unittest_L43_C1() [0x427ab5]\n??:?
    void tmpwgepaec1.__modtest() [0x427c0c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430088]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb65]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa1d]\n??:? runModuleUnitTests [0x42b989]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428263]\n??:? _d_run_main [0x4281ce]\n??:? main [0x427c1f]\n??:?
    __libc_start_main [0x24e2b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long tmp = 1;\n    \n    while (tmp < n)\n    {\n        r *= x;\n\
    \        tmp++;\n    }\n    \n    return r == x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzlep6u_9.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmpzlep6u_9.__unittest_L35_C1() [0x427ae5]\n??:?
    void tmpzlep6u_9.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xc5633554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        power *= n;\n        result *= x;\n        n -= 1;\n    }\n    \n   \
    \ return (result == power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\n\
    The question was about C++, not C. Also, your solution doesn't work for `is_simple_power(3L,\
    \ 3L)`.\n<|/ c |>\n<| c |>\nI added a C++ solution. Thanks for pointing out.\n\
    <|/ c |>\n<| c |>\nYour C++ solution doesn't work for `is_simple_power(3L, 3L)`\
    \ because `pow` returns a `double` which is not precise enough to represent `3L`.\n\
    <|/ c |>\n<| c |>\nI added a C++ solution. Thanks for pointing out.\n<|/ c |>\n\
    <| c |>\nThe C++ solution doesn't work for `is_simple_power(3L, 3L)` because `pow`\
    \ returns a `double` which is not precise enough to represent `3L`.\n<|/ c |>\n\
    <| a |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy5e8rtoa.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpy5e8rtoa.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\n/tmp/tmpy5e8rtoa.d(36): Error: declaration expected, not
    `<`\n/tmp/tmpy5e8rtoa.d(39): Error: unterminated character constant\n/tmp/tmpy5e8rtoa.d(45):
    Error: unterminated character constant\n/tmp/tmpy5e8rtoa.d(51): Error: unterminated
    character constant\n/tmp/tmpy5e8rtoa.d(59): Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpy5e8rtoa.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpy5e8rtoa.d(63): Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpy5e8rtoa.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpy5e8rtoa.d(67): Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmpy5e8rtoa.d(69): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5e8rtoa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp388ruuqj.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp388ruuqj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkibw3nm8.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkibw3nm8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. `is_simple_power(-1, 2)` returns `true`,\
    \ but `is_simple_power(-1, -2)` returns `false`.\n<|/ c |>\n<| c |>\nIt works\
    \ for negative numbers. `is_simple_power(-1, 2)` returns `true`, but `is_simple_power(-1,\
    \ -2)` returns `false`.\n<|/ c |>\n<| c |>\nIt works for negative numbers. `is_simple_power(-1,\
    \ 2)` returns `true`, but `is_simple_power(-1, -2)` returns `false`.\n<|/ c |>\n\
    <| c |>\nIt works for negative numbers. `is_simple_power(-1, 2)` returns `true`,\
    \ but `is_simple_power(-1, -2)` returns `false`.\n<|/ c |>\n<| c |>\nIt works\
    \ for negative numbers. `is_simple_power(-1, 2)` returns `true`, but `is_simple_power(-1,\
    \ -2)` returns `false`.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8xuxxt71.d(33): Error: declaration expected, not `<`\n/tmp/tmp8xuxxt71.d(36):
    Error: unterminated character constant\n/tmp/tmp8xuxxt71.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmp8xuxxt71.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmp8xuxxt71.d(58): Error: declaration expected, not `assert`\n/tmp/tmp8xuxxt71.d(59):
    Error: declaration expected, not `assert`\n/tmp/tmp8xuxxt71.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmp8xuxxt71.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmp8xuxxt71.d(62): Error: declaration expected, not `assert`\n/tmp/tmp8xuxxt71.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmp8xuxxt71.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmp8xuxxt71.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmp8xuxxt71.d(66): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp8xuxxt71.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis doesn't work\
    \ for negative numbers. `is_simple_power(-1L, 4L)` returns `true`.\n<|/ c |>\n\
    <| c |>\nYes, I forgot about negative numbers. I fixed my answer. Thanks.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work for negative numbers. `is_simple_power(-1L,\
    \ 4L)` returns `true`.\n<|/ c |>\n<| c |>\nYes, I forgot about negative numbers.\
    \ I fixed my answer. Thanks.\n<|/ c |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. `is_simple_power(-1L, 4L)` returns `true`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaf9aghq9.d(36): Error: declaration expected, not `<`\n/tmp/tmpaf9aghq9.d(39):
    Error: unterminated character constant\n/tmp/tmpaf9aghq9.d(45): Error: unterminated
    character constant\n/tmp/tmpaf9aghq9.d(51): Error: unterminated character constant\n/tmp/tmpaf9aghq9.d(59):
    Error: declaration expected, not `assert`\n/tmp/tmpaf9aghq9.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmpaf9aghq9.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmpaf9aghq9.d(62): Error: declaration expected, not `assert`\n/tmp/tmpaf9aghq9.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpaf9aghq9.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpaf9aghq9.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpaf9aghq9.d(66): Error: declaration expected, not `assert`\n/tmp/tmpaf9aghq9.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpaf9aghq9.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpaf9aghq9.d(69): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaf9aghq9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(power < n)\n    {\n      \
    \  result *= x;\n        power *= x;\n    }\n    \n    return result == x;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5lkj5hwe.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp5lkj5hwe.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmp5lkj5hwe.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x92ecc554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n < 0L) return false;\n    if\
    \ (n < 1L) return false;\n    if (x == 1L) return true;\n    if (x == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n == 0L) return false;\n    long\
    \ res = 1L;\n    long power = 1L;\n    while (power < n)\n    {\n        res =\
    \ res * x;\n        power = power + 1;\n    }\n    if (res == x) return true;\n\
    \    return false;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis code\
    \ doesn't work for negative numbers. Try it with `is_simple_power(-1L, 2L)`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for negative numbers. Try it with `is_simple_power(-1L,\
    \ 2L)`.\n<|/ c |>\n<| c |>\nIt doesn't work for negative numbers. Try it with\
    \ `is_simple_power(-1L, 2L)`.\n<|/ c |>\n<| c |>\nIt doesn't work for negative\
    \ numbers. Try it with `is_simple_power(-1L, 2L)`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for negative numbers. Try it with `is_simple_power(-1L, 2L)`.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>\n#include <iostream>\n#include <cmath>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvh42mse6.d(44): Error: declaration expected, not `<`\n/tmp/tmpvh42mse6.d(47):
    Error: unterminated character constant\n/tmp/tmpvh42mse6.d(50): Error: unterminated
    character constant\n/tmp/tmpvh42mse6.d(53): Error: unterminated character constant\n/tmp/tmpvh42mse6.d(56):
    Error: unterminated character constant\n/tmp/tmpvh42mse6.d(59): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvh42mse6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    long d = 1;\n    long e = 1;\n    long e2 = 1;\n\
    \    long e3 = 1;\n    long e4 = 1;\n    long e5 = 1;\n    long e6 = 1;\n    long\
    \ e7 = 1;\n    long e8 = 1;\n    long e9 = 1;\n    long e10 = 1;\n    long e11\
    \ = 1;\n    long e12 = 1;\n    long e13 = 1;\n    long e14 = 1;\n    long e15\
    \ = 1;\n    long e16 = 1;\n    long e17 = 1;\n    long e18 = 1;\n    long e19\
    \ = 1;\n    long e20 = 1;\n    long e21 = 1;\n    long e22 = 1;\n    long e23\
    \ = 1;\n    long e24 = 1;\n    long e25 = 1;\n    long e26 = 1;\n    long e27\
    \ = 1;\n    long e28 = 1;\n    long e29 = 1;\n    long e30 = 1;\n    long e31\
    \ = 1;\n    long e32 = 1;\n    long e33 = 1;\n    long e34 = 1;\n    long e35\
    \ = 1;\n    long e36 = 1;\n    long e37 = 1;\n    long e38 = 1;\n    long e39\
    \ = 1;\n    long e40 = 1;\n    long e41 = 1;\n    long e42 = 0;\n    long e43\
    \ = 0;\n    long e44 = 0;\n    long e45 = 0;\n    long e46 = 0;\n    long e47\
    \ = 0;\n    long e48 = 0;\n    long e49 = 0;\n    long e50 = 0;\n    long e51\
    \ = 1;\n    long e52 = 0;\n    long e53 = 0;\n    long e54 = 0;\n    long e55\
    \ = 0;\n    long e56 = 0;\n    long e57 = 0;\n    long e58 = 0;\n    long e59\
    \ = 0;\n    long e60 = 0;\n    long e61 = 1;\n    long e62 = 0;\n    long e63\
    \ = 0;\n    long e64 = 0;\n    long e65 = 0;\n    long e66 = 0;\n    long e67\
    \ = 0;\n    long e68 = 0;\n    long e69 = 0;\n    long e70 = 0;\n    long e71\
    \ = 1;\n    long e72 = 0;\n    long e73 = 0;\n    long e74 = 0;\n    long e75\
    \ = 0;\n    long e76 = 0;\n    long e77 = 0;\n    long e78 = 0;\n    long e79\
    \ = 0;\n    long e80 = 0;\n    long e81 = 1;\n    long e82 = 0;\n    long e83\
    \ = 0;\n    long e84 = 0;\n    long e85\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2xnpkq5i.d(112): Error: semicolon expected, not `unittest`\n/tmp/tmp2xnpkq5i.d(112):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp2xnpkq5i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    long r = 1L;\n    long\
    \ m = 1L;\n    while (m <= n) \n    {\n        if (x == m) return true;\n    \
    \    long r = r * x;\n        long m = m * x;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=c++,algorithm |>\n<| c |>\nThis is not the correct solution. `is_simple_power(1L,\
    \ 4L)` returns `true` but `is_simple_power(2L, 2L)` returns `false`.\n<|/ c |>\n\
    <| c |>\nI tested it on ideone and it returns `true` for `is_simple_power(1L,\
    \ 4L)` and `is_simple_power(2L, 2L)`\n<|/ c |>\n<| c |>\nYes, it returns true\
    \ for 1L and 4L, but false for 2L and 2L. Your code returns true for 1L and 4L,\
    \ but false for 2L and 2L.\n<|/ c |>\n<| c |>\nI tested it on ideone and it returns\
    \ `true` for `is_simple_power(1L, 4L)` and `is_simple_power(2L, 2L)`\n<|/ c |>\n\
    <| c |>\nI tested it on ideone and it returns `true` for `is_simple_power(1L,\
    \ 4L)` and `is_simple_power(2L, 2L)`\n<|/ c |>\n<| a tags=c++,algorithm |>\nI\
    \ believe this can be solved using logarithms. \n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqj9_el73.d(36): Error: declaration expected, not `<`\n/tmp/tmpqj9_el73.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpqj9_el73.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpqj9_el73.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpqj9_el73.d(63): Error: declaration expected, not `assert`\n/tmp/tmpqj9_el73.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpqj9_el73.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpqj9_el73.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpqj9_el73.d(67): Error: declaration expected, not `assert`\n/tmp/tmpqj9_el73.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmpqj9_el73.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmpqj9_el73.d(70): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqj9_el73.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n -= 1;\n    }\n    \n    return result\
    \ == power;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Unfortunately\
    \ I cannot use any library functions. I must use only basic functions like pow,\
    \ sqrt, log, etc.\n<|/ c |>\n<| c |>\nI edited my answer, I hope it helps you.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. Unfortunately I cannot use any library\
    \ functions. I must use only basic functions like pow, sqrt, log, etc.\n<|/ c\
    \ |>\n<| c |>\nI edited my answer, I hope it helps you.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. Unfortunately I cannot use any library functions. I must use\
    \ only basic functions like pow, sqrt, log, etc.\n<|/ c |>\n<| a |>\n<code>\n\
    #include <iostream>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2e9k7ulb.d(36): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2e9k7ulb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    return result == x;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7dbvd8pq.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp7dbvd8pq.__unittest_L35_C1() [0x427aa1]\n??:?
    void tmp7dbvd8pq.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x7e854554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        if(power == x)\n        {\n            return true;\n        }\n\
    \        result *= n;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work for `is_simple_power(3L, 3L)`\n<|/ c |>\n<| c |>\n\
    It works for me. `is_simple_power(3L, 3L)` returns `false`\n<|/ c |>\n<| c |>\n\
    It works for me too. `is_simple_power(3L, 3L)` returns `false`\n<|/ c |>\n<| c\
    \ |>\nIt works for me too. `is_simple_power(3L, 3L)` returns `false`\n<|/ c |>\n\
    <| c |>\nIt works for me too. `is_simple_power(3L, 3L)` returns `false`\n<|/ c\
    \ |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppyu92fgc.d(37): Error: declaration expected, not `<`\n/tmp/tmppyu92fgc.d(40):
    Error: unterminated character constant\n/tmp/tmppyu92fgc.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmppyu92fgc.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmppyu92fgc.d(62): Error: declaration expected, not `assert`\n/tmp/tmppyu92fgc.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmppyu92fgc.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmppyu92fgc.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmppyu92fgc.d(66): Error: declaration expected, not `assert`\n/tmp/tmppyu92fgc.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmppyu92fgc.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmppyu92fgc.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmppyu92fgc.d(70): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmppyu92fgc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    return (result ==\
    \ x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpo31hryfd.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpo31hryfd.__unittest_L35_C1() [0x427aa1]\n??:?
    void tmpo31hryfd.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x4ad21554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ res = 1;\n    for(int i=1; i<=n; i++)\n    {\n        res = res * x;\n    }\n\
    \    return res == x;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not provide\
    \ an answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/10278156)\n\
    <|/ c |>\n<| c |>\nI believe it does answer the question. He asked how to check\
    \ if a number is a power of another number. He also asked how to do that in O(1)\
    \ time. He also asked how to do that in O(1) space. He also asked how to do that\
    \ in O(1) time AND O(1) space. He also asked how to do that in O(1) time AND O(1)\
    \ space. He also asked how to do that in O(1) time AND O(1) space. He also asked\
    \ how to do that in O(1) time AND O(1) space. He also asked how to do that in\
    \ O(1) time AND O(1) space. He also asked how to do that in O(1) time AND O(1)\
    \ space. He also asked how to do that in O(1) time AND O(1) space. He also asked\
    \ how to do that in O(1) time AND O(1) space. He also asked how to do that in\
    \ O(1) time AND O(1) space. He also asked how to do that in O(1) time AND O(1)\
    \ space. He also asked how to do that in O(1) time AND O(1) space. He also asked\
    \ how to do that in O(1) time AND O(1) space. He also asked how to do that in\
    \ O(1) time AND O(1) space. He also asked how to do that in O(1) time AND O(1)\
    \ space. He also asked how to do that in O(1) time AND O(1) space. He also asked\
    \ how to do that in O(1) time AND O(1) space. He also asked how to do that in\
    \ O(1) time AND O(1) space. He also asked how to do that in O(1) time AND O(1)\
    \ space. He also asked how to do that in O(1) time AND O(1) space. He also asked\
    \ how to do that in O(1) time AND O(1) space. He also asked how to do that in\
    \ O(1) time AND O(1) space. He also \nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplx1vwqsz.d(31): Error: declaration expected, not `<`\n/tmp/tmplx1vwqsz.d(42):
    Error: declaration expected, not `assert`\n/tmp/tmplx1vwqsz.d(43): Error: declaration
    expected, not `assert`\n/tmp/tmplx1vwqsz.d(44): Error: declaration expected, not
    `assert`\n/tmp/tmplx1vwqsz.d(45): Error: declaration expected, not `assert`\n/tmp/tmplx1vwqsz.d(46):
    Error: declaration expected, not `assert`\n/tmp/tmplx1vwqsz.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmplx1vwqsz.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmplx1vwqsz.d(49): Error: declaration expected, not `assert`\n/tmp/tmplx1vwqsz.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmplx1vwqsz.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmplx1vwqsz.d(52): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplx1vwqsz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    while(n > power) {\n        power *= n;\n    }\n    return (x\
    \ == power);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work. Try `is_simple_power(3L,\
    \ 3L)`.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out.\
    \ I edited my answer to fix the problem.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ Thanks for pointing that out. I edited my answer to fix the problem.\n<|/ c\
    \ |>\n<| a |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuk9tcz5w.d(30): Error: declaration expected, not `<`\n/tmp/tmpuk9tcz5w.d(33):
    Error: unterminated character constant\n/tmp/tmpuk9tcz5w.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpuk9tcz5w.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpuk9tcz5w.d(49): Error: declaration expected, not `assert`\n/tmp/tmpuk9tcz5w.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpuk9tcz5w.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpuk9tcz5w.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpuk9tcz5w.d(53): Error: declaration expected, not `assert`\n/tmp/tmpuk9tcz5w.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpuk9tcz5w.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpuk9tcz5w.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpuk9tcz5w.d(57): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuk9tcz5w.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (x == 1)\n        return is_simple_power(x, n - 1);\n    if (x < n)\n   \
    \     return is_simple_power(x, n);\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm,math\
    \ |>\n<| c |>\nI believe this fails for `is_simple_power(3L, 3L)` which should\
    \ return `true`.\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing\
    \ out. I've updated my answer.\n<|/ c |>\n<| a tags=c++,algorithm,math |>\n<code>\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj41j8xma.d(34): Error: declaration expected, not `<`\n/tmp/tmpj41j8xma.d(40):
    Error: unterminated character constant\n/tmp/tmpj41j8xma.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmpj41j8xma.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmpj41j8xma.d(50): Error: declaration expected, not `assert`\n/tmp/tmpj41j8xma.d(51):
    Error: declaration expected, not `assert`\n/tmp/tmpj41j8xma.d(52): Error: declaration
    expected, not `assert`\n/tmp/tmpj41j8xma.d(53): Error: declaration expected, not
    `assert`\n/tmp/tmpj41j8xma.d(54): Error: declaration expected, not `assert`\n/tmp/tmpj41j8xma.d(55):
    Error: declaration expected, not `assert`\n/tmp/tmpj41j8xma.d(56): Error: declaration
    expected, not `assert`\n/tmp/tmpj41j8xma.d(57): Error: declaration expected, not
    `assert`\n/tmp/tmpj41j8xma.d(58): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpj41j8xma.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while (power < n)\n    {\n     \
    \   result *= x;\n        power *= x;\n    }\n    \n    return result == x;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpeg9djw8f.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpeg9djw8f.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmpeg9djw8f.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0xfa92d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L)\n        return true;\n    if (x == 0L)\n        return false;\n    if\
    \ (n == 0L)\n        return false;\n    if (n % 2L == 0L)\n        return is_simple_power(x\
    \ / 2L, n/2L);\n    else\n        return is_simple_power(x * x, n/2L);\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg3ceo9ar.d(35): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg3ceo9ar.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk5jq9248.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk5jq9248.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 0;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 0;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 0;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 0;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9f8ha6y1.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9f8ha6y1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    if (result == x)\n\
    \    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmdkd67fk.d(47): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e5d]\n??:? void tmpmdkd67fk.__unittest_L42_C1() [0x427aad]\n??:?
    void tmpmdkd67fk.__modtest() [0x427be0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9ed]\n??:? runModuleUnitTests [0x42b959]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428233]\n??:? _d_run_main [0x42819e]\n??:? main [0x427bf3]\n??:?
    __libc_start_main [0x4f238554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (n == 0L) return false;\n    if (n == 1L) return\
    \ true;\n    if (n % 2 == 0L) return false;\n    long m = n / 2L;\n    long r\
    \ = 1L;\n    while (r < m) r = r * 2L;\n    return (r == x);\n}\n</code>\n<|/\
    \ a tags=c++,algorithm |>\n<| c |>\nThanks for your answer. I tried it but my\
    \ code is not working. Can you please check my code once again?\n<|/ c |>\n<|\
    \ c |>\nI checked your code. Your code is not working because you didn't implement\
    \ the function is_simple_power. I've edited my answer to include it.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. I tried it but my code is not working. Can you\
    \ please check my code once again?\n<|/ c |>\n<| c |>\nI checked your code. Your\
    \ code is not working because you didn't implement the function is_simple_power.\
    \ I've edited my answer to include it.\n<|/ c |>\n<| a tags=c++,algorithm |>\n\
    <code>\n#include <iostream>\n#include <cmath>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7jvl6wky.d(33): Error: declaration expected, not `<`\n/tmp/tmp7jvl6wky.d(39):
    Error: unterminated character constant\n/tmp/tmp7jvl6wky.d(39): Error: unterminated
    character constant\n/tmp/tmp7jvl6wky.d(45): Error: unterminated character constant\n/tmp/tmp7jvl6wky.d(45):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp7jvl6wky.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while (power < n)\n    {\n     \
    \   result *= x;\n        power *= x;\n    }\n    \n    return (result == x);\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfw0gsvew.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpfw0gsvew.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmpfw0gsvew.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x319e4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (x == 1)\n        return false;\n    if (n % 2 == 0)\n        return is_simple_power(x,\
    \ n / 2);\n    else\n        return is_simple_power(x * x, n / 2);\n}\n</code>\n\
    <|/ a tags=c++,algorithm |>\n<| c |>\nI believe this fails for `is_simple_power(3L,\
    \ 3L)`\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(3L, 3L)`\n\
    <|/ c |>\n<| c |>\nIt fails for `is_simple_power(3L, 3L)` because 3L is not a\
    \ power of 3\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(3L,\
    \ 3L)`\n<|/ c |>\n<| c |>\nIt fails for `is_simple_power(3L, 3L)` because 3L is\
    \ not a power of 3\n<|/ c |>\n<| a dscore=2 |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp250teixg.d(35): Error: declaration expected, not `<`\n/tmp/tmp250teixg.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmp250teixg.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmp250teixg.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmp250teixg.d(61): Error: declaration expected, not `assert`\n/tmp/tmp250teixg.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmp250teixg.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmp250teixg.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmp250teixg.d(65): Error: declaration expected, not `assert`\n/tmp/tmp250teixg.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmp250teixg.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmp250teixg.d(68): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp250teixg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return false;\n    if (x == 1) return false;\n\
    \    if (x == n) return true;\n    if (n % 2 == 0) return false;\n    if (n %\
    \ 3 == 0) return false;\n    if (n % 5 == 0) return false;\n    if (n % 7 == 0)\
    \ return false;\n    if (n % 11 == 0) return false;\n    if (n % 13 == 0) return\
    \ false;\n    if (n % 17 == 0) return false;\n    if (n % 19 == 0) return false;\n\
    \    if (n % 23 == 0) return false;\n    if (n % 29 == 0) return false;\n    if\
    \ (n % 37 == 0) return false;\n    if (n % 53 == 0) return false;\n    if (n %\
    \ 59 == 0) return false;\n    if (n % 67 == 0) return false;\n    if (n % 73 ==\
    \ 0) return false;\n    if (n % 79 == 0) return false;\n    if (n % 83 == 0) return\
    \ false;\n    if (n % 89 == 0) return false;\n    if (n % 97 == 0) return false;\n\
    \    if (n % 103 == 0) return false;\n    if (n % 109 == 0) return false;\n  \
    \  if (n % 113 == 0) return false;\n    if (n % 127 == 0) return false;\n    if\
    \ (n % 131 == 0) return false;\n    if (n % 137 == 0) return false;\n    if (n\
    \ % 147 == 0) return false;\n    if (n % 151 == 0) return false;\n    if (n %\
    \ 157 == 0) return false;\n    if (n % 163 == 0) return false;\n    if (n % 169\
    \ == 0) return false;\n    if (n % 173 == 0) return false;\n    if (n % 177 ==\
    \ 0) return false;\n    if (n % 181 == 0) return false;\n    if (n % 187 == 0)\
    \ return false;\n    if (n % 191 == 0) return false;\n    if (n % 197 == 0) return\
    \ false;\n    if (n % 201 == 0) return false;\n    if (n % 207 == 0) return false;\n\
    \    if (n % 211 == 0) return false;\n    if (n % 217 == 0) return false;\n  \
    \  if (n % 221 == 0) return false;\n    if (n % 227 == 0) return false;\n    if\
    \ (n % 231 == 0) return false;\n    if (n % 237 == 0) return false;\n    if (n\
    \ % 241 == 0) return false;\n    if (n % 247 == 0) return false;\n    if (n %\
    \ 251 == 0) return false;\n    if (n % 257 == 0) return false;\n    if (n % 263\
    \ == 0) return false;\n    if (n % 269 == 0) return false;\n    if (n % 273 ==\
    \ 0) return false;\n    if (n % 277 == 0) return false;\n    if (n % 281 == 0)\
    \ return false;\n    if (n % 287 == 0) return false;\n    if (n % 291 == 0) return\
    \ false;\n    if (n % 297 == 0) return false;\n    if (n % 301 == 0) return false;\n\
    \    if (n % 307 == 0) return false;\n    if (n % 311 == 0) return false;\n  \
    \  if (n % 317 == 0) return false;\n    if (n % 321 == 0) return false;\n\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfnhqsu8r.d(90): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnhqsu8r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer!\
    \ I understand your solution and it works perfectly! However, I cannot use any\
    \ loops or conditionals. I only can use basic functions like `pow`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`,\
    \ `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`,\
    \ `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `log`, `sqrt`, `\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaatphiwk.d(36): Error: declaration expected, not `<`\n/tmp/tmpaatphiwk.d(39):
    Error: unterminated string constant starting at /tmp/tmpaatphiwk.d(39)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaatphiwk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 1) {\n            power *= x;\n        }\n        result *= x;\n      \
    \  n /= 2;\n        x *= x;\n    }\n    \n    if (n == 1) {\n        power *=\
    \ x;\n    }\n    \n    return (result == power);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmwxkcxot.d(46): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e95]\n??:? void tmpmwxkcxot.__unittest_L42_C1() [0x427ac1]\n??:?
    void tmpmwxkcxot.__modtest() [0x427c18]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430090]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb6d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa25]\n??:? runModuleUnitTests [0x42b991]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42826b]\n??:? _d_run_main [0x4281d6]\n??:? main [0x427c2b]\n??:?
    __libc_start_main [0xf454b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ res = 1;\n    for(long i = 1; i < n; i++){\n        res = res * x;\n    }\n\
    \    return res == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7twmcz8g.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmp7twmcz8g.__unittest_L30_C1() [0x427ae5]\n??:?
    void tmp7twmcz8g.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xa5521554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    long power = n;\n    \n    while(power\
    \ > 1)\n    {\n        if(power % 2 == 1)\n        {\n            result *= x;\n\
    \        }\n        power /= 2;\n        x *= x;\n    }\n    \n    if(result ==\
    \ x)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n\
    \    }\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6jmc72nt.d(26): Error: declaration `tmp6jmc72nt.is_simple_power.power`
    is already defined\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jmc72nt.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(power < n)\n    {\n      \
    \  result *= x;\n        power *= x;\n    }\n    \n    return result == x;\n}\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp5lkj5hwe.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp5lkj5hwe.__unittest_L35_C1() [0x427aa5]\n??:?
    void tmp5lkj5hwe.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x92ecc554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        power =\
    \ power * n;\n        result = result * x;\n        n = n - 1;\n    }\n    \n\
    \    if (result == power) {\n        return true;\n    }\n    \n    return false;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqip2szv8.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpqip2szv8.__unittest_L39_C1() [0x427a99]\n??:?
    void tmpqip2szv8.__modtest() [0x427bf0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427c03]\n??:?
    __libc_start_main [0x3c379554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= 2;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzvan087m.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpzvan087m.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpzvan087m.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x23c90554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        result = result * x;\n        n = n - 1;\n    }\n    \n\
    \    return result == power;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work.\
    \ Try `is_simple_power(1L, 4L)`.\n<|/ c |>\n<| c |>\nI edited my answer. Now it\
    \ works. Thanks for pointing out.\n<|/ c |>\n<| c |>\nThis doesn't work. Try `is_simple_power(1L,\
    \ 4L)`.\n<|/ c |>\n<| c |>\nI edited my answer. Now it works. Thanks for pointing\
    \ out.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp148no9u8.d(36): Error: declaration expected, not `<`\n/tmp/tmp148no9u8.d(39):
    Error: unterminated character constant\n/tmp/tmp148no9u8.d(45): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp148no9u8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis doesn't work.\
    \ `is_simple_power(3L, 3L)` returns true.\n<|/ c |>\n<| c |>\n: I fixed the bug,\
    \ thank you. Now it works.\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(3L,\
    \ 2L)` returning `true` when it should return `false`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I fixed it too.\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(3L,\
    \ 1L)` returning `true` when it should return `false`.\n<|/ c |>\n<| a |>\n<code>\n\
    #include <iostream>\n#include <cmath>\nusing namespace std;\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxa6fpjfq.d(36): Error: declaration expected, not `<`\n/tmp/tmpxa6fpjfq.d(39):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpxa6fpjfq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\n</code>\n<|/ a tags=c++,algorithm,math,c |>\n<| c |>\nThis is\
    \ not the right answer. `is_simple_power(1L, 4L)` returns `true` while it should\
    \ be `false`.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks.\n<|/ c |>\n<| c |>\n\
    : I fixed the bug. Thanks.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks.\n<|/\
    \ c |>\n<| c |>\n: I fixed the bug. Thanks.\n<|/ c |>\n<| a dscore=2 |>\nThis\
    \ can be done in O(log(n)) time using binary search. \n<code>\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6c7d66a9.d(36): Error: declaration expected, not `<`\n/tmp/tmp6c7d66a9.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmp6c7d66a9.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmp6c7d66a9.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmp6c7d66a9.d(63): Error: declaration expected, not `assert`\n/tmp/tmp6c7d66a9.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmp6c7d66a9.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmp6c7d66a9.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmp6c7d66a9.d(67): Error: declaration expected, not `assert`\n/tmp/tmp6c7d66a9.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmp6c7d66a9.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmp6c7d66a9.d(70): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6c7d66a9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4gegbff8.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e75]\n??:? void tmp4gegbff8.__unittest_L33_C1() [0x427a9d]\n??:?
    void tmp4gegbff8.__modtest() [0x427bf4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa05]\n??:? runModuleUnitTests [0x42b971]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42824b]\n??:? _d_run_main [0x4281b6]\n??:? main [0x427c07]\n??:?
    __libc_start_main [0x84dd1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long temp;\n    \n    while(n > 0)\n \
    \   {\n        temp = power;\n        power = temp * x;\n        result += power;\n\
    \        n--;\n    }\n    \n    return (result == x);\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp61_o36ye.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e45]\n??:? void tmp61_o36ye.__unittest_L38_C1() [0x427a71]\n??:?
    void tmp61_o36ye.__modtest() [0x427bc8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb6b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9fe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb91]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430040]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb1d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9d5]\n??:? runModuleUnitTests [0x42b941]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428294]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42821b]\n??:? _d_run_main [0x428186]\n??:? main [0x427bdb]\n??:?
    __libc_start_main [0x97022554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        power *= n;\n        result *= x;\n        n /= x;\n    }\n    \n   \
    \ return (result == power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\n\
    This doesn't work for negative numbers. Try `is_simple_power(-1L, 3L)`.\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I edited my\
    \ answer to include a check for negative numbers.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for negative numbers. Try `is_simple_power(-1L, 3L)`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. Thanks for pointing that out. I edited my answer to include\
    \ a check for negative numbers.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\n#include <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt5n8iat_.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpt5n8iat_.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\n/tmp/tmpt5n8iat_.d(36): Error: declaration expected, not
    `<`\n/tmp/tmpt5n8iat_.d(39): Error: unterminated character constant\n/tmp/tmpt5n8iat_.d(45):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpt5n8iat_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) \n    {\n        return true;\n    }\n    long r = 1;\n    while (n) \n\
    \    {\n        if ((n % 2) == 0) \n        {\n            r *= x;\n        }\n\
    \        n /= 2;\n        x *= x;\n    }\n    return r == x;\n}\n</code>\n<|/\
    \ a tags=c++,algorithm,math |>\n<| c |>\nThis doesn't work for `is_simple_power(3L,\
    \ 2L)` which returns `true` but should return `false`.\n<|/ c |>\n<| c |>\nI guess\
    \ I misunderstood the question. I'll edit my answer.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for `is_simple_power(3L, 2L)` which returns `true` but should return\
    \ `false`.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll edit\
    \ my answer.\n<|/ c |>\n<| c |>\nThis doesn't work for `is_simple_power(3L, 2L)`\
    \ which returns `true` but should return `false`.\n<|/ c |>\n<| a tags=c++,algorithm,math\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp52tf9ps.d(40): Error: declaration expected, not `<`\n/tmp/tmpp52tf9ps.d(43):
    Error: unterminated character constant\n/tmp/tmpp52tf9ps.d(46): Error: unterminated
    character constant\n/tmp/tmpp52tf9ps.d(49): Error: unterminated character constant\n/tmp/tmpp52tf9ps.d(52):
    Error: unterminated character constant\n/tmp/tmpp52tf9ps.d(55): Error: unterminated
    character constant\n/tmp/tmpp52tf9ps.d(63): Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpp52tf9ps.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpp52tf9ps.d(67): Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmpp52tf9ps.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmpp52tf9ps.d(71): Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmpp52tf9ps.d(73): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp52tf9ps.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 0)\n    {\n        if\
    \ (n % 2 == 0)\n        {\n            power *= x;\n        }\n        \n    \
    \    result *= x;\n        n /= 2;\n    }\n    \n    return result == power;\n\
    }\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8g7_wck2.d(44): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e7d]\n??:? void tmp8g7_wck2.__unittest_L40_C1() [0x427aa9]\n??:?
    void tmp8g7_wck2.__modtest() [0x427c00]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bba3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430078]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb55]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa0d]\n??:? runModuleUnitTests [0x42b979]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282cc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428253]\n??:? _d_run_main [0x4281be]\n??:? main [0x427c13]\n??:?
    __libc_start_main [0x7103d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    long power2 = 1;\n    long power3 = 1;\n\
    \    long power4 = 1;\n    long power5 = 1;\n    long power6 = 1;\n    long power7\
    \ = 1;\n    long power8 = 1;\n    long power9 = 1;\n    long power10 = 1;\n  \
    \  long power11 = 1;\n    long power12 = 1;\n    long power13 = 1;\n    long power14\
    \ = 1;\n    long power15 = 1;\n    long power16 = 1;\n    long power17 = 1;\n\
    \    long power18 = 1;\n    long power19 = 1;\n    long power20 = 1;\n    long\
    \ power21 = 1;\n    long power22 = 1;\n    long power23 = 1;\n    long power24\
    \ = 1;\n    long power25 = 1;\n    long power26 = 1;\n    long power27 = 1;\n\
    \    long power28 = 1;\n    long power29 = 1;\n    long power30 = 1;\n    long\
    \ power31 = 1;\n    long power32 = 1;\n    long power33 = 1;\n    long power34\
    \ = 1;\n    long power35 = 1;\n    long power36 = 1;\n    long power37 = 1;\n\
    \    long power38 = 1;\n    long power39 = 1;\n    long power40 = 1;\n    long\
    \ power41 = 1;\n    long power42 = 1;\n    long power43 = 1;\n    long power44\
    \ = 1;\n    long power45 = 1;\n    long power46 = 1;\n    long power47 = 1;\n\
    \    long power48 = 1;\n    long power49 = 1;\n    long power50 = 1;\n    long\
    \ power51 = 1;\n    long power52 = 1;\n    long power53 = 1;\n    long power54\
    \ = 1;\n    long power55 = 1;\n    long power56 = 1;\n    long power57 = 1;\n\
    \    long power58 = 1;\n    long power59 = 1;\n    long power60 = 1;\n    long\
    \ power61 = 1;\n    long power62 = 1;\n    long power63 = 1;\n    long power64\
    \ = 1;\n    long power65 = 1;\n    long power66 = 1;\n    long power67 = 1;\n\
    \    long power68 = 1;\n    long power69 = 1;\n    long power70 = 1;\n    long\
    \ power71 = 1;\n    long power72 = 1;\n    long power73 = 1;\n    long power74\
    \ = 1;\n    long power75 = 1;\n    long power76 = 1;\n    long power77 = 1;\n\
    \    long power78 = 1;\n    long power79 = 1;\n    long power80 = 1;\n    long\
    \ power81 = 1;\n    long power82 = 1;\n    long power83 = 1;\n\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq6gz8j_n.d(109): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6gz8j_n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        power *= x;\n        result *= power;\n        n--;\n    }\n    \n  \
    \  return result == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5pul0h5w.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmp5pul0h5w.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pul0h5w.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long limit = n;\n    long counter = 1;\n\
    \    while(power < limit)\n    {\n        counter *= x;\n        power += 1;\n\
    \        result += counter;\n    }\n    if(result != x)\n    {\n        return\
    \ false;\n    }\n    else\n    {\n        return true;\n    }\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis doesn't work for `is_simple_power(3L, 2L)` which\
    \ returns `true` but should return `false`.\n<|/ c |>\n<| c |>\nI believe this\
    \ should return false for 3L and 2L. Can you please check again?\n<|/ c |>\n<|\
    \ c |>\nIt returns false for 3L and 2L because 3L**2L is 8L and 8L is not equal\
    \ to 3L. 3L**3L is 27L and 27L is not equal to 3L. 3L**4L is 81L and 81L is not\
    \ equal to 3L. 3L**5L is 3840L and 3840L is not equal to 3L.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I missed that case. Thanks for pointing it out.\n<|/ c |>\n\
    <| c |>\nI believe this should return false for 3L and 2L. Can you please check\
    \ again?\n<|/ c |>\n<| a dscore=1 |>\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2lr4ibok.d(43): Error: declaration expected, not `<`\n/tmp/tmp2lr4ibok.d(46):
    Error: unterminated character constant\n/tmp/tmp2lr4ibok.d(66): Error: declaration
    expected, not `assert`\n/tmp/tmp2lr4ibok.d(67): Error: declaration expected, not
    `assert`\n/tmp/tmp2lr4ibok.d(68): Error: declaration expected, not `assert`\n/tmp/tmp2lr4ibok.d(69):
    Error: declaration expected, not `assert`\n/tmp/tmp2lr4ibok.d(70): Error: declaration
    expected, not `assert`\n/tmp/tmp2lr4ibok.d(71): Error: declaration expected, not
    `assert`\n/tmp/tmp2lr4ibok.d(72): Error: declaration expected, not `assert`\n/tmp/tmp2lr4ibok.d(73):
    Error: declaration expected, not `assert`\n/tmp/tmp2lr4ibok.d(74): Error: declaration
    expected, not `assert`\n/tmp/tmp2lr4ibok.d(75): Error: declaration expected, not
    `assert`\n/tmp/tmp2lr4ibok.d(76): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp2lr4ibok.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `pow` returns `double`, so `pow_of_n == x` will\
    \ never be true.\n<|/ c |>\n<| c |>\nI didn't know that. Thanks for the info.\
    \ I'll update my answer.\n<|/ c |>\n<| c |>\nI updated my answer with a solution\
    \ that works with `long`s.\n<|/ c |>\n<| c |>\nThe question was about `long`s,\
    \ not `double`s. `pow` returns a `double`, so `pow_of_n == x` will never be true.\n\
    <|/ c |>\n<| c |>\nI updated my answer with a solution that works with `long`s.\n\
    <|/ c |>\n<| a |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqauaf484.d(27): Error: declaration expected, not `<`\n/tmp/tmpqauaf484.d(30):
    Error: unterminated character constant\n/tmp/tmpqauaf484.d(33): Error: unterminated
    character constant\n/tmp/tmpqauaf484.d(33): Error: unterminated character constant\n/tmp/tmpqauaf484.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpqauaf484.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpqauaf484.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpqauaf484.d(53): Error: declaration expected, not `assert`\n/tmp/tmpqauaf484.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpqauaf484.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpqauaf484.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpqauaf484.d(57): Error: declaration expected, not `assert`\n/tmp/tmpqauaf484.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpqauaf484.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpqauaf484.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqauaf484.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try is_simple_power(3L, 3L).\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. I've updated the answer to include a check for that\
    \ case.\n<|/ c |>\n<| c |>\nThis doesn't work for `is_simple_power(3L, 3L)`\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated the answer to include a check\
    \ for that case.\n<|/ c |>\n<| c |>\nThis doesn't work for `is_simple_power(3L,\
    \ 3L)`\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxuxlke6d.d(33): Error: declaration expected, not `<`\n/tmp/tmpxuxlke6d.d(36):
    Error: unterminated character constant\n/tmp/tmpxuxlke6d.d(39): Error: unterminated
    character constant\n/tmp/tmpxuxlke6d.d(42): Error: unterminated character constant\n/tmp/tmpxuxlke6d.d(45):
    Error: unterminated character constant\n/tmp/tmpxuxlke6d.d(48): Error: unterminated
    character constant\n/tmp/tmpxuxlke6d.d(56): Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmpxuxlke6d.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmpxuxlke6d.d(60): Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmpxuxlke6d.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmpxuxlke6d.d(64): Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmpxuxlke6d.d(66): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxuxlke6d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    for(long i = 1; i < n; i++)\n    {\n        result = result\
    \ * x;\n    }\n    return result == x;\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpdpruxr_s.d(38): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmpdpruxr_s.__unittest_L31_C1() [0x427ae5]\n??:?
    void tmpdpruxr_s.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xcdc75554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq3bt2rr7.d(31): unittest failure\n----------------\n??:?
    _d_unittestp [0x427efd]\n??:? void tmpq3bt2rr7.__unittest_L27_C1() [0x427a8d]\n??:?
    void tmpq3bt2rr7.__modtest() [0x427c80]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fbd5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa8d]\n??:? runModuleUnitTests [0x42b9f9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282d3]\n??:? _d_run_main [0x42823e]\n??:? main [0x427c93]\n??:?
    __libc_start_main [0x464a0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 0L) return false;\n\
    \    long r = 1L;\n    while (n-- != 0L) r *= x;\n    return r == x;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I am not allowed to use any\
    \ library functions. I only have to use basic math functions like pow, sqrt, log,\
    \ sin, cos, etc.\n<|/ c |>\n<| c |>\nI added a solution that does not use any\
    \ library functions.\n<|/ c |>\n<| c |>\nThanks for your answer. I am not allowed\
    \ to use any library functions. I only have to use basic math functions like pow,\
    \ sqrt, log, sin, cos, etc.\n<|/ c |>\n<| c |>\nI added a solution that does not\
    \ use any library functions.\n<|/ c |>\n<| c |>\nThanks for your answer. I am\
    \ not allowed to use any library functions. I only have to use basic math functions\
    \ like pow, sqrt, log, sin, cos, etc.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqynwxe0d.d(33): Error: declaration expected, not `<`\n/tmp/tmpqynwxe0d.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpqynwxe0d.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpqynwxe0d.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpqynwxe0d.d(59): Error: declaration expected, not `assert`\n/tmp/tmpqynwxe0d.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpqynwxe0d.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpqynwxe0d.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpqynwxe0d.d(63): Error: declaration expected, not `assert`\n/tmp/tmpqynwxe0d.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpqynwxe0d.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpqynwxe0d.d(66): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqynwxe0d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (x == 1)\n        return false;\n    if\
    \ (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n        return\
    \ is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm,math,c\
    \ |>\n<code>\n#include <stdio.h>\n#include <math.h>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxwhh13ub.d(33): Error: declaration expected, not `<`\n/tmp/tmpxwhh13ub.d(43):
    Error: declaration expected, not `assert`\n/tmp/tmpxwhh13ub.d(44): Error: declaration
    expected, not `assert`\n/tmp/tmpxwhh13ub.d(45): Error: declaration expected, not
    `assert`\n/tmp/tmpxwhh13ub.d(46): Error: declaration expected, not `assert`\n/tmp/tmpxwhh13ub.d(47):
    Error: declaration expected, not `assert`\n/tmp/tmpxwhh13ub.d(48): Error: declaration
    expected, not `assert`\n/tmp/tmpxwhh13ub.d(49): Error: declaration expected, not
    `assert`\n/tmp/tmpxwhh13ub.d(50): Error: declaration expected, not `assert`\n/tmp/tmpxwhh13ub.d(51):
    Error: declaration expected, not `assert`\n/tmp/tmpxwhh13ub.d(52): Error: declaration
    expected, not `assert`\n/tmp/tmpxwhh13ub.d(53): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxwhh13ub.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= x;\n        result *= power;\n        n /= 2;\n    }\n    \n    return (result\
    \ == x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpupiqgz8v.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e5d]\n??:? void tmpupiqgz8v.__unittest_L36_C1() [0x427a85]\n??:?
    void tmpupiqgz8v.__modtest() [0x427bdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9ed]\n??:? runModuleUnitTests [0x42b959]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428233]\n??:? _d_run_main [0x42819e]\n??:? main [0x427bef]\n??:?
    __libc_start_main [0x12c2b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        \n        if(power == x)\n        {\n            return\
    \ true;\n        }\n        \n        result = result * n;\n    }\n    \n    return\
    \ false;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try is_simple_power(1L,\
    \ 4L).\n<|/ c |>\n<| c |>\nIt does work. Try it yourself. It returns true for\
    \ 1L, 4L and false for 2L, 2L and 8L, 2L and 3L, 2L and 3L, 1L and 5L, 3L. Which\
    \ is exactly what OP wanted.\n<|/ c |>\n<| c |>\nIt doesn't work for `is_simple_power(1L,\
    \ 4L)`. It returns false for 1L, 4L and true for 2L, 2L and 8L, 2L and 3L, 2L\
    \ and 3L, 1L and 5L, 3L.\n<|/ c |>\n<| c |>\nYes, it does work. Try it yourself.\
    \ It returns true for 1L, 4L and false for 2L, 2L and 8L, 2L and 3L, 2L and 3L,\
    \ 1L and 5L, 3L. Which is exactly what OP wanted.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for `is_simple_power(1L, 4L)`. It returns false for 1L, 4L and true for\
    \ 2L, 2L and 8L, 2L and 3L, 2L and 3L, 1L and 5L, 3L.\n<|/ c |>\n<| a tags=c++,algorithm\
    \ |>\nThe algorithm is as follows:\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv3_uu1ue.d(41): Error: declaration expected, not `<`\n/tmp/tmpv3_uu1ue.d(44):
    Error: unterminated character constant\n/tmp/tmpv3_uu1ue.d(50): Error: unterminated
    character constant\n/tmp/tmpv3_uu1ue.d(56): Error: unterminated character constant\n/tmp/tmpv3_uu1ue.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpv3_uu1ue.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpv3_uu1ue.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpv3_uu1ue.d(67): Error: declaration expected, not `assert`\n/tmp/tmpv3_uu1ue.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmpv3_uu1ue.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmpv3_uu1ue.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmpv3_uu1ue.d(71): Error: declaration expected, not `assert`\n/tmp/tmpv3_uu1ue.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmpv3_uu1ue.d(73): Error: declaration
    expected, not `assert`\n/tmp/tmpv3_uu1ue.d(74): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3_uu1ue.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nI believe that `is_simple_power(3L, 2L)` should be `false` and\
    \ not `true`.\n<|/ c |>\n<| c |>\nI believe that `is_simple_power(3L, 2L)` should\
    \ be `false` and not `true`.\n<|/ c |>\n<| c |>\nI believe that `is_simple_power(3L,\
    \ 2L)` should be `false` and not `true`.\n<|/ c |>\n<| c |>\nI believe that `is_simple_power(3L,\
    \ 2L)` should be `false` and not `true`.\n<|/ c |>\n<| c |>\nI believe that `is_simple_power(3L,\
    \ 2L)` should be `false` and not `true`.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdm9qhd0_.d(33): Error: declaration expected, not `<`\n/tmp/tmpdm9qhd0_.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpdm9qhd0_.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpdm9qhd0_.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpdm9qhd0_.d(59): Error: declaration expected, not `assert`\n/tmp/tmpdm9qhd0_.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpdm9qhd0_.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpdm9qhd0_.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpdm9qhd0_.d(63): Error: declaration expected, not `assert`\n/tmp/tmpdm9qhd0_.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpdm9qhd0_.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpdm9qhd0_.d(66): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm9qhd0_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= 2;\n    }\n    \n    return (result\
    \ == power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis is not correct.\
    \ `is_simple_power(3L, 3L)` returns `true` but `is_simple_power(3L, 2L)` returns\
    \ `false`\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Fixed now.\n<|/ c\
    \ |>\n<| c |>\nThis is not correct. `is_simple_power(3L, 3L)` returns `true` but\
    \ `is_simple_power(3L, 2L)` returns `false`\n<|/ c |>\n<| c |>\nFixed again. Thanks.\n\
    <|/ c |>\n<| c |>\nThis is not correct. `is_simple_power(3L, 3L)` returns `true`\
    \ but `is_simple_power(3L, 2L)` returns `false`\n<|/ c |>\n<| a dscore=1 |>\n\
    The algorithm is simple and straightforward.\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8s408l65.d(36): Error: declaration expected, not `<`\n/tmp/tmp8s408l65.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmp8s408l65.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmp8s408l65.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmp8s408l65.d(63): Error: declaration expected, not `assert`\n/tmp/tmp8s408l65.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmp8s408l65.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmp8s408l65.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmp8s408l65.d(67): Error: declaration expected, not `assert`\n/tmp/tmp8s408l65.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmp8s408l65.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmp8s408l65.d(70): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8s408l65.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = 1;\n    long y = 1;\n    long z = 1;\n    \n    while(n\
    \ > 0)\n    {\n        if(n%2 == 1)\n        {\n            r *= x;\n        }\n\
    \        \n        m += 1;\n        n /= 2;\n    }\n    \n    while(m > 0)\n \
    \   {\n        if(m%2 == 1)\n        {\n            y *= x;\n        }\n     \
    \   \n        z += 1;\n        m /= 2;\n    }\n    \n    if(r == y)\n    {\n \
    \       if(z == n)\n        {\n            return true;\n        }\n    }\n  \
    \  \n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpgo68bm0v.d(65): unittest failure\n----------------\n??:?
    _d_unittestp [0x427ed5]\n??:? void tmpgo68bm0v.__unittest_L61_C1() [0x427b01]\n??:?
    void tmpgo68bm0v.__modtest() [0x427c58]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300d0]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fbad]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa65]\n??:? runModuleUnitTests [0x42b9d1]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428324]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282ab]\n??:? _d_run_main [0x428216]\n??:? main [0x427c6b]\n??:?
    __libc_start_main [0x50b97554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        if(n % 2 == 1)\n        {\n            power *= x;\n        }\n     \
    \   \n        result *= x;\n        n /= 2;\n    }\n    \n    return (result ==\
    \ power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_z6kqf1t.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmp_z6kqf1t.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_z6kqf1t.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 0L) return false;\n\
    \    if (n % 3 == 0L) return false;\n    long r = 1L;\n    long m = n / 2;\n \
    \   while (m != 0L) {\n        if (m % 2 == 1L) r = r * x;\n        m /= 2;\n\
    \        x *= x;\n    }\n    return r == x;\n}\n</code>\n<|/ a |>\n<| c |>\nI\
    \ believe this fails for `is_simple_power(3L, 3L)`\n<|/ c |>\n<| c |>\nYes, it\
    \ fails for `is_simple_power(3L, 3L)`\n<|/ c |>\n<| c |>\nIt fails for `is_simple_power(3L,\
    \ 3L)`\n<|/ c |>\n<| c |>\nIt fails for `is_simple_power(3L, 3L)`\n<|/ c |>\n\
    <| c |>\nIt fails for `is_simple_power(3L, 3L)`\n<|/ c |>\n<| a tags=c++,algorithm\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp36bw4h5b.d(39): Error: declaration expected, not `<`\n/tmp/tmp36bw4h5b.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmp36bw4h5b.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmp36bw4h5b.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmp36bw4h5b.d(65): Error: declaration expected, not `assert`\n/tmp/tmp36bw4h5b.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmp36bw4h5b.d(67): Error: declaration
    expected, not `assert`\n/tmp/tmp36bw4h5b.d(68): Error: declaration expected, not
    `assert`\n/tmp/tmp36bw4h5b.d(69): Error: declaration expected, not `assert`\n/tmp/tmp36bw4h5b.d(70):
    Error: declaration expected, not `assert`\n/tmp/tmp36bw4h5b.d(71): Error: declaration
    expected, not `assert`\n/tmp/tmp36bw4h5b.d(72): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36bw4h5b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long p = 1;\n    long q = 1;\n    long m = 1;\n    long a = 1;\n\
    \    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long\
    \ f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n\
    \    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long\
    \ o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n\
    \    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long\
    \ x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n\
    \    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long\
    \ g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n\
    \    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long\
    \ p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n\
    \    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n    long\
    \ y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo47wyou_.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo47wyou_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq3bt2rr7.d(31): unittest failure\n----------------\n??:?
    _d_unittestp [0x427efd]\n??:? void tmpq3bt2rr7.__unittest_L27_C1() [0x427a8d]\n??:?
    void tmpq3bt2rr7.__modtest() [0x427c80]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x4300f8]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fbd5]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa8d]\n??:? runModuleUnitTests [0x42b9f9]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x4282d3]\n??:? _d_run_main [0x42823e]\n??:? main [0x427c93]\n??:?
    __libc_start_main [0x464a0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 0) {\n            power *= x;\n        }\n        x /= 2;\n        n /=\
    \ 2;\n    }\n    \n    if (n == 1) {\n        power *= x;\n    }\n    \n    if\
    \ (power == x) {\n        result = true;\n    }\n    \n    return result;\n}\n\
    </code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis code doesn't work. `is_simple_power(1L,\
    \ 4L)` returns `true` instead of `false`. `is_simple_power(3L, 2L)` returns `true`\
    \ instead of `false`.\n<|/ c |>\n<| c |>\nI tested it and it works. I used the\
    \ code from your question and added the missing `is_simple_power(3L, 2L)` case.\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I used the code from your question\
    \ and added the missing `is_simple_power(3L, 2L)` case.\n<|/ c |>\n<| c |>\nI\
    \ tested it and it works. I used the code from your question and added the missing\
    \ `is_simple_power(3L, 2L)` case.\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I used the code from your question and added the missing `is_simple_power(3L,\
    \ 2L)` case.\n<|/ c |>\n<| a tags=c++,algorithm |>\nI wrote this in Python:\n\
    <code>\ndef is_simple_power(x, n):\n    power = 1\n    result = 1\n    while n\
    \ > 1:\n        if n % 2 == 1:\n            power *= x\n        x /= 2\n     \
    \   n /= 2\n    if n == 1 and power == x:\n        return True\n    return False\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n\
    \    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpksfuqwz4.d(45): Error: declaration expected, not `<`\n/tmp/tmpksfuqwz4.d(48):
    Error: unterminated character constant\n/tmp/tmpksfuqwz4.d(84): Error: declaration
    expected, not `assert`\n/tmp/tmpksfuqwz4.d(85): Error: declaration expected, not
    `assert`\n/tmp/tmpksfuqwz4.d(86): Error: declaration expected, not `assert`\n/tmp/tmpksfuqwz4.d(87):
    Error: declaration expected, not `assert`\n/tmp/tmpksfuqwz4.d(88): Error: declaration
    expected, not `assert`\n/tmp/tmpksfuqwz4.d(89): Error: declaration expected, not
    `assert`\n/tmp/tmpksfuqwz4.d(90): Error: declaration expected, not `assert`\n/tmp/tmpksfuqwz4.d(91):
    Error: declaration expected, not `assert`\n/tmp/tmpksfuqwz4.d(92): Error: declaration
    expected, not `assert`\n/tmp/tmpksfuqwz4.d(93): Error: declaration expected, not
    `assert`\n/tmp/tmpksfuqwz4.d(94): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpksfuqwz4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long limit = (long) pow(x, n);\n    long\
    \ temp = 1;\n    while(temp <= limit)\n    {\n        temp = temp * x;\n     \
    \   power++;\n    }\n    while(power < n)\n    {\n        result = result * x;\n\
    \        power++;\n    }\n    if(result == x)\n    {\n        return true;\n \
    \   }\n    else\n    {\n        return false;\n    }\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try is_simple_power(2L, 4L).\n<|/ c |>\n<| c\
    \ |>\nIt does work. Try it yourself. It returns true for 2L and 4L. 2L**4=8L.\
    \ 8L**2=16L. 16L**2=32L. 32L**2=64L. 64L**2=128L. 128L**2=256L. 256L**2=512L.\
    \ 512L**2=1024L. 1024L**2=2048L. 2048L**2=4096L. 4096L**2=8192L. 8192L**2=16384L.\
    \ 16384L**2=32768L. 32768L**2=65536L. 65536L**2=131072L. 131072L**2=262144L. 262144L**2=524288L.\
    \ 524288L**2=1048576L. 1048576L**2=2097152L. 2097152L**2=4194304L. 4194304L**2=8388608L.\
    \ 8388608L**2=16777216L. 16777216L**2=33554432L. 33554432L**2=67108864L. 67108864L**2=134217728L.\
    \ 134217728L**2=268435456L. 268435456L**2=536870912L. 536870912L**2=1073741824L.\
    \ 1073741824L**2=2147483648L. 2147483648L**2=4294967296L. 4294967296L**2=8589934592L.\
    \ 8589934592L**2=17179869184L. 17179869184L**2=34359738368L. 34359738368L**2=68719476736L.\
    \ 68719476736L**2=\nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphncm0jlr.d(26): Error: C style cast illegal, use `cast(long)pow(x,
    n)`\n/tmp/tmphncm0jlr.d(47): Error: declaration expected, not `<`\n/tmp/tmphncm0jlr.d(50):
    Error: unterminated character constant\n/tmp/tmphncm0jlr.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmphncm0jlr.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmphncm0jlr.d(60): Error: declaration expected, not `assert`\n/tmp/tmphncm0jlr.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmphncm0jlr.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmphncm0jlr.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmphncm0jlr.d(64): Error: declaration expected, not `assert`\n/tmp/tmphncm0jlr.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmphncm0jlr.d(66): Error: declaration
    expected, not `assert`\n/tmp/tmphncm0jlr.d(67): Error: declaration expected, not
    `assert`\n/tmp/tmphncm0jlr.d(68): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphncm0jlr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    return (result ==\
    \ x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpo31hryfd.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpo31hryfd.__unittest_L35_C1() [0x427aa1]\n??:?
    void tmpo31hryfd.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x4ad21554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplv_t5rmy.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplv_t5rmy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return true;\n    if (n % 2 == 0) return\
    \ false;\n    long a = 1;\n    long b = x;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n\
    \    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long\
    \ c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n\
    \    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long\
    \ l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n\
    \    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    \nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfg87wz2x.d(126): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfg87wz2x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    long counter = 1;\n    \n    while (counter\
    \ <= n) {\n        power = power * x;\n        counter++;\n    }\n    \n    if\
    \ (power == x) {\n        return true;\n    }\n    else {\n        return false;\n\
    \    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not an answer. Explain\
    \ what your code does, and how it does it.\n<|/ c |>\n<| c |>\nI added some explanation.\n\
    <|/ c |>\n<| c |>\nThis doesn't work. Try it with `is_simple_power(2L, 3L)`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<|\
    \ a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoqq2bkq9.d(40): Error: declaration expected, not `<`\n/tmp/tmpoqq2bkq9.d(49):
    Error: unterminated character constant\n/tmp/tmpoqq2bkq9.d(60): Error: declaration
    expected, not `assert`\n/tmp/tmpoqq2bkq9.d(61): Error: declaration expected, not
    `assert`\n/tmp/tmpoqq2bkq9.d(62): Error: declaration expected, not `assert`\n/tmp/tmpoqq2bkq9.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpoqq2bkq9.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpoqq2bkq9.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpoqq2bkq9.d(66): Error: declaration expected, not `assert`\n/tmp/tmpoqq2bkq9.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpoqq2bkq9.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpoqq2bkq9.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmpoqq2bkq9.d(70): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpoqq2bkq9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return true;\n    if (n % 2 == 0) return\
    \ false;\n    long a = 1;\n    long b = x;\n    long c = 1;\n    while (b != 0)\
    \ {\n        if (b % 2 == 0) {\n            long d = b / 2;\n            if (d\
    \ == 0) return false;\n            long e = (b - d) / 2;\n            if (e ==\
    \ 0) return false;\n            long f = a * e * c;\n            if (f == 0) return\
    \ false;\n            a = f;\n            c += 1;\n        } else {\n        \
    \    long d = b / 2;\n            if (d == 0) return false;\n            long\
    \ e = (b - d) / 2;\n            if (e == 0) return false;\n            long f\
    \ = a * e * c;\n            if (f == 0) return false;\n            a = f;\n  \
    \          c += 1;\n        }\n        b -= 1;\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=c++,algorithm |>\n<| c |>\nI believe this fails for `is_simple_power(1L,\
    \ 2L)` because `1L` isn't a power of `2L`.\n<|/ c |>\n<| c |>\nYes, I forgot to\
    \ add that case. Thanks for pointing out.\n<|/ c |>\n<| c |>\nThis fails for `is_simple_power(1L,\
    \ 3L)` because `1L` isn't a power of `3L`.\n<|/ c |>\n<| c |>\nYes, I forgot to\
    \ add that case. Thanks for pointing out.\n<|/ c |>\n<| c |>\nThis fails for `is_simple_power(1L,\
    \ 4L)` because `1L` isn't a power of `4L`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpybm54vh8.d(54): Error: declaration expected, not `<`\n/tmp/tmpybm54vh8.d(57):
    Error: unterminated character constant\n/tmp/tmpybm54vh8.d(63): Error: unterminated
    character constant\n/tmp/tmpybm54vh8.d(69): Error: unterminated character constant\n/tmp/tmpybm54vh8.d(77):
    Error: declaration expected, not `assert`\n/tmp/tmpybm54vh8.d(78): Error: declaration
    expected, not `assert`\n/tmp/tmpybm54vh8.d(79): Error: declaration expected, not
    `assert`\n/tmp/tmpybm54vh8.d(80): Error: declaration expected, not `assert`\n/tmp/tmpybm54vh8.d(81):
    Error: declaration expected, not `assert`\n/tmp/tmpybm54vh8.d(82): Error: declaration
    expected, not `assert`\n/tmp/tmpybm54vh8.d(83): Error: declaration expected, not
    `assert`\n/tmp/tmpybm54vh8.d(84): Error: declaration expected, not `assert`\n/tmp/tmpybm54vh8.d(85):
    Error: declaration expected, not `assert`\n/tmp/tmpybm54vh8.d(86): Error: declaration
    expected, not `assert`\n/tmp/tmpybm54vh8.d(87): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpybm54vh8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long remainder;\n    \n    while(n > 0)\n\
    \    {\n        remainder = x % n;\n        power = power * n;\n        x = remainder;\n\
    \        result = result * power;\n        n = n - remainder;\n    }\n    \n \
    \   return (result == x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        if(power == result)\n        {\n         \
    \   return true;\n        }\n        n /= x;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=c++,algorithm |>\n<| c |>\nThis doesn't work for negative powers. `is_simple_power(-1L,\
    \ 4L)` returns `true`, but `is_simple_power(-1L, 2L)` returns `false`.\n<|/ c\
    \ |>\n<| c |>\nI thought that negative powers are also simple. Anyway, I added\
    \ a solution that works for negative powers.\n<|/ c |>\n<| c |>\nThe OP said \"\
    simple power\", not \"simple exponent\"\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works for negative powers.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ works for negative powers.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n\
    #include <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmbwtn7uj.d(38): Error: declaration expected, not `<`\n/tmp/tmpmbwtn7uj.d(41):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmbwtn7uj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = n;\n    \n    while(power != 0)\n    {\n     \
    \   if(power % 2 == 1)\n        {\n            result *= x;\n        }\n     \
    \   power /= 2;\n        x *= x;\n    }\n    \n    return result == x;\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzsz9iju3.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e7d]\n??:? void tmpzsz9iju3.__unittest_L39_C1() [0x427aa5]\n??:?
    void tmpzsz9iju3.__modtest() [0x427bfc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bba3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430078]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb55]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa0d]\n??:? runModuleUnitTests [0x42b979]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282cc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428253]\n??:? _d_run_main [0x4281be]\n??:? main [0x427c0f]\n??:?
    __libc_start_main [0x1c5de554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        result = result * x;\n        n = n - 1;\n    }\n    \n\
    \    return (result == power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c\
    \ |>\nThis fails for `is_simple_power(3L, 3L)` which returns true.\n<|/ c |>\n\
    <| c |>\nYes, I missed that case. Thanks for pointing it out. Fixed now.\n<|/\
    \ c |>\n<| c |>\nThis fails for `is_simple_power(3L, 3L)` which returns true.\n\
    <|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing it out. Fixed\
    \ now.\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbogj0owg.d(36): Error: declaration expected, not `<`\n/tmp/tmpbogj0owg.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpbogj0owg.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpbogj0owg.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpbogj0owg.d(59): Error: declaration expected, not `assert`\n/tmp/tmpbogj0owg.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpbogj0owg.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpbogj0owg.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpbogj0owg.d(63): Error: declaration expected, not `assert`\n/tmp/tmpbogj0owg.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpbogj0owg.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpbogj0owg.d(66): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbogj0owg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= x;\n    }\n    return (result == power);\n\
    }\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis fails for `is_simple_power(3L,\
    \ 2L)`\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Thanks for pointing\
    \ it out. I've updated the answer.\n<|/ c |>\n<| c |>\nThis fails for `is_simple_power(3L,\
    \ 2L)`\n<|/ c |>\n<| c |>\nYes, I forgot about that case. Thanks for pointing\
    \ it out. I've updated the answer.\n<|/ c |>\n<| c |>\nThis fails for `is_simple_power(3L,\
    \ 2L)`\n<|/ c |>\n<| a dscore=1 |>\n<code>\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1e10tfcc.d(34): Error: declaration expected, not `<`\n/tmp/tmp1e10tfcc.d(40):
    Error: unterminated character constant\n/tmp/tmp1e10tfcc.d(46): Error: unterminated
    character constant\n/tmp/tmp1e10tfcc.d(57): Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmp1e10tfcc.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmp1e10tfcc.d(61): Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(63): Error: declaration
    expected, not `assert`\n/tmp/tmp1e10tfcc.d(64): Error: declaration expected, not
    `assert`\n/tmp/tmp1e10tfcc.d(65): Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(66):
    Error: declaration expected, not `assert`\n/tmp/tmp1e10tfcc.d(67): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1e10tfcc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (x < 0)\n        return false;\n    if (x == 1)\n        return true;\n \
    \   if (x == 2)\n        return (n == 1);\n    if (n % 2 == 0)\n        return\
    \ is_simple_power(x, n / 2);\n    if (n % 3 == 0)\n        return is_simple_power(x,\
    \ n / 3);\n    return false;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI believe\
    \ this fails for `is_simple_power(3L, 3L)`\n<|/ c |>\n<| c |>\nYes, it fails for\
    \ 3L and 3L. 3L**3L should be true but it is false because 3L**3L is not a power\
    \ of 3.\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(3L, 2L)`\n\
    <|/ c |>\n<| c |>\nYes, it fails for 3L and 2L. 3L**2L should be true but it is\
    \ false because 3L**2L is not a power of 2.\n<|/ c |>\n<| c |>\nI believe this\
    \ fails for `is_simple_power(3L, 1L)`\n<|/ c |>\n<| a tags=c++,algorithm |>\n\
    <code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwiy_kw2c.d(40): Error: declaration expected, not `<`\n/tmp/tmpwiy_kw2c.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpwiy_kw2c.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpwiy_kw2c.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpwiy_kw2c.d(66): Error: declaration expected, not `assert`\n/tmp/tmpwiy_kw2c.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpwiy_kw2c.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpwiy_kw2c.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmpwiy_kw2c.d(70): Error: declaration expected, not `assert`\n/tmp/tmpwiy_kw2c.d(71):
    Error: declaration expected, not `assert`\n/tmp/tmpwiy_kw2c.d(72): Error: declaration
    expected, not `assert`\n/tmp/tmpwiy_kw2c.d(73): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwiy_kw2c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n\
    \    long d = 1;\n    long e = 1;\n    long f = 0;\n    long g = 1;\n    long\
    \ h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n\
    \    long m = 1;\n    long n = 1;\n    long o = 1;\n    long p = 1;\n    long\
    \ q = 1;\n    long r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n\
    \    long v = 1;\n    long w = 1;\n    long x = 1;\n    long y = 1;\n    long\
    \ z = 1;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n\
    \    long e = 1;\n    long f = 0;\n    long g = 1;\n    long h = 1;\n    long\
    \ i = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n\
    \    long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long\
    \ r = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n\
    \    long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long\
    \ a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n\
    \    long f = 0;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long\
    \ j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n\
    \    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long\
    \ s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n\
    \    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long\
    \ b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 0;\n\
    \    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\
    \    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long\
    \ t = 1;\n    long u = 1;\n    long v = 1;\n\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk5jq9248.d(127): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk5jq9248.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: -1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        x /= n;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: None
  stdout: None
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    while(n > 0)\n    {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    return result == power;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks so much for the help. I appreciate\
    \ it!\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy2i_73s7.d(34): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2i_73s7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (x < 0)\n        return false;\n    if (x == 1)\n        return true;\n \
    \   if (x < n)\n        return false;\n    long res = 1;\n    while (n > 0)\n\
    \    {\n        if (n % 2 == 0)\n        {\n            if (res * x == x)\n  \
    \              return true;\n        }\n        res *= x;\n        n /= 2;\n \
    \   }\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nI\
    \ believe that `is_simple_power(1L, 4L)` should return `true` because `1L**4 ==\
    \ 1L`\n<|/ c |>\n<| c |>\nYes, you are right. Thanks for pointing out. Fixed now.\n\
    <|/ c |>\n<| c |>\n`is_simple_power(1L, 4L)` should return `true` because `1L**4\
    \ == 1L`\n<|/ c |>\n<| c |>\n`is_simple_power(1L, 4L)` should return `true` because\
    \ `1L**4 == 1L`\n<|/ c |>\n<| c |>\n`is_simple_power(1L, 4L)` should return `true`\
    \ because `1L**4 == 1L`\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpedbh5fts.d(47): Error: declaration expected, not `<`\n/tmp/tmpedbh5fts.d(70):
    Error: declaration expected, not `assert`\n/tmp/tmpedbh5fts.d(71): Error: declaration
    expected, not `assert`\n/tmp/tmpedbh5fts.d(72): Error: declaration expected, not
    `assert`\n/tmp/tmpedbh5fts.d(73): Error: declaration expected, not `assert`\n/tmp/tmpedbh5fts.d(74):
    Error: declaration expected, not `assert`\n/tmp/tmpedbh5fts.d(75): Error: declaration
    expected, not `assert`\n/tmp/tmpedbh5fts.d(76): Error: declaration expected, not
    `assert`\n/tmp/tmpedbh5fts.d(77): Error: declaration expected, not `assert`\n/tmp/tmpedbh5fts.d(78):
    Error: declaration expected, not `assert`\n/tmp/tmpedbh5fts.d(79): Error: declaration
    expected, not `assert`\n/tmp/tmpedbh5fts.d(80): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpedbh5fts.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long limit = n;\n    long counter = 0;\n\
    \    while(power < limit)\n    {\n        counter++;\n        power *= x;\n  \
    \  }\n    if(counter == limit)\n    {\n        result = true;\n    }\n    else\n\
    \    {\n        result = false;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include\
    \ <cmath>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf_yzyii7.d(43): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_yzyii7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) return true;\n    if (x == 0L) return false;\n    if (n == 0L) return\
    \ false;\n    if (n == 1L) return true;\n    if (n % 2 == 0L) return false;\n\
    \    long d = n % 2 == 1L ? n / 2L : n / 2L + 1;\n    long r = pow(x, d);\n  \
    \  return r == x;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work for\
    \ `is_simple_power(3L, 2L)` which returns `true` but should return `false`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I updated\
    \ the answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nunittest\n{\n \
    \   alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk9eccvpu.d(33): Error: declaration expected, not `<`\n/tmp/tmpk9eccvpu.d(36):
    Error: unterminated character constant\n/tmp/tmpk9eccvpu.d(47): Error: declaration
    expected, not `assert`\n/tmp/tmpk9eccvpu.d(48): Error: declaration expected, not
    `assert`\n/tmp/tmpk9eccvpu.d(49): Error: declaration expected, not `assert`\n/tmp/tmpk9eccvpu.d(50):
    Error: declaration expected, not `assert`\n/tmp/tmpk9eccvpu.d(51): Error: declaration
    expected, not `assert`\n/tmp/tmpk9eccvpu.d(52): Error: declaration expected, not
    `assert`\n/tmp/tmpk9eccvpu.d(53): Error: declaration expected, not `assert`\n/tmp/tmpk9eccvpu.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpk9eccvpu.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpk9eccvpu.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpk9eccvpu.d(57): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpk9eccvpu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ = power * n;\n        \n        if(power == x)\n        {\n            return\
    \ true;\n        }\n        \n        result = result * n;\n        \n       \
    \ if(result > x)\n        {\n            return false;\n        }\n    }\n   \
    \ \n    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1jev8xrt.d(59): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmp1jev8xrt.__unittest_L46_C1() [0x427bc3]\n??:?
    void tmp1jev8xrt.__modtest() [0x427bd8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427beb]\n??:?
    __libc_start_main [0x7f94f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return true;\n    if (x == 1) return true;\n\
    \    if (x == n) return true;\n    if (n % 2 == 0) return false;\n    long a =\
    \ n / 2;\n    long b = n - a;\n    long c = x;\n    long d = 1;\n    long e =\
    \ 1;\n    long f = 1;\n    long g = n;\n    long h = 1;\n    long i = 1;\n   \
    \ long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n =\
    \ 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n   \
    \ long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w =\
    \ 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long A = 1;\n   \
    \ long B = 1;\n    long C = 1;\n    long D = 1;\n    long E = 1;\n    long F =\
    \ 1;\n    long G = 1;\n    long H = 1;\n    long I = 1;\n    long J = 1;\n   \
    \ long K = 1;\n    long L = 1;\n    long M = 1;\n    long N = 1;\n    long O =\
    \ 1;\n    long P = 1;\n    long Q = 1;\n    long R = 1;\n    long S = 1;\n   \
    \ long T = 1;\n    long U = 1;\n    long V = 1;\n    long W = 1;\n    long X =\
    \ 1;\n    long Y = 1;\n    long Z = 1;\n    long A1 = 1;\n    long B1 = 1;\n \
    \   long C1 = 1;\n    long D1 = 1;\n    long E1 = 1;\n    long F1 = 1;\n    long\
    \ G1 = 1;\n    long H1 = 1;\n    long I1 = 1;\n    long J1 = 1;\n    long K1 =\
    \ 1;\n    long L1 = 1;\n    long M1 = 1;\n    long N1 = 1;\n    long O1 = 1;\n\
    \    long P1 = 1;\n    long Q1 = 1;\n    long R1 = 1;\n    long S1 = 1;\n    long\
    \ T1 = 1;\n    long U1 = 1;\n    long V1 = 1;\n    long W1 = 1;\n    long X1 =\
    \ 1;\n    long Y1 = 1;\n    long Z1 = 1;\n    long A2 = 1;\n    long B2 = 1;\n\
    \    long C2 = 1;\n    long D2 = 1;\n    long E2 = 1;\n    long F2 = 1;\n    long\
    \ G2 = 1;\n    long H2 = 1;\n    long I2 = 1;\n    long J2 = 1;\n    long K2 =\
    \ 1;\n    long L2 = 1;\n    long M2 = 1;\n    long N2 = 1;\n    long \nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiy1a93rb.d(122): Error: no identifier for declarator `long`\n/tmp/tmpiy1a93rb.d(122):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpiy1a93rb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= x;\n        result *= power;\n        n--;\n    }\n    \n    return (result\
    \ == x);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp2o4say47.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmp2o4say47.__unittest_L36_C1() [0x427a79]\n??:?
    void tmp2o4say47.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xec935554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    \n    if (result == power)\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbirofxg9.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpbirofxg9.__unittest_L39_C1() [0x427a99]\n??:?
    void tmpbirofxg9.__modtest() [0x427bf0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427c03]\n??:?
    __libc_start_main [0x91c7d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (x\
    \ == 1L) {\n        return true;\n    }\n    if (x == 0L) {\n        return false;\n\
    \    }\n    if (n == 0L) {\n        return false;\n    }\n    if (n == 1L) {\n\
    \        return true;\n    }\n    if (n % 2 == 0L) {\n        return is_simple_power(x,\
    \ n / 2L);\n    }\n    return is_simple_power(x, n / 2L) && is_simple_power(x,\
    \ n / 2L);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm,math |>\n<code>\n\
    unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0g984l8n.d(41): Error: declaration expected, not `<`\n/tmp/tmp0g984l8n.d(49):
    Error: declaration expected, not `assert`\n/tmp/tmp0g984l8n.d(50): Error: declaration
    expected, not `assert`\n/tmp/tmp0g984l8n.d(51): Error: declaration expected, not
    `assert`\n/tmp/tmp0g984l8n.d(52): Error: declaration expected, not `assert`\n/tmp/tmp0g984l8n.d(53):
    Error: declaration expected, not `assert`\n/tmp/tmp0g984l8n.d(54): Error: declaration
    expected, not `assert`\n/tmp/tmp0g984l8n.d(55): Error: declaration expected, not
    `assert`\n/tmp/tmp0g984l8n.d(56): Error: declaration expected, not `assert`\n/tmp/tmp0g984l8n.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmp0g984l8n.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmp0g984l8n.d(59): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0g984l8n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    while(n > power) {\n        power *= n;\n    }\n    return x\
    \ == power;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis doesn't work.\
    \ Try `is_simple_power(3L, 3L)`\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. The function returns true for 3L and 3L.\n<|/ c |>\n<| c\
    \ |>\nI tested it on `3L` before posting it. I get `true` for `3L` and `3L`.\n\
    <|/ c |>\n<| c |>\nI tested it on `3L` before posting it. I get `true` for `3L`\
    \ and `3L`.\n<|/ c |>\n<| c |>\nI tested it on `3L` before posting it. I get `true`\
    \ for `3L` and `3L`.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgi8rl1n9.d(30): Error: declaration expected, not `<`\n/tmp/tmpgi8rl1n9.d(33):
    Error: unterminated character constant\n/tmp/tmpgi8rl1n9.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpgi8rl1n9.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmpgi8rl1n9.d(55): Error: declaration expected, not `assert`\n/tmp/tmpgi8rl1n9.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmpgi8rl1n9.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpgi8rl1n9.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpgi8rl1n9.d(59): Error: declaration expected, not `assert`\n/tmp/tmpgi8rl1n9.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpgi8rl1n9.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpgi8rl1n9.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpgi8rl1n9.d(63): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgi8rl1n9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0) return true;\n    if (n == 1) return true;\n    if (x == 1) return true;\n\
    \    if (x == n) return true;\n    if (x < n) return is_simple_power(x, n-1);\n\
    \    return false;\n}\n</code>\n<|/ a tags=c++,algorithm,math |>\n<| c |>\nThis\
    \ doesn't work. Try is_simple_power(1L, 4L).\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it yourself. It returns true for 1L and 4L. Try is_simple_power(1L, 4L).\n\
    <|/ c |>\n<| c |>\nIt returns true for 1L and 4L. Try is_simple_power(1L, 4L).\n\
    <|/ c |>\n<| c |>\nIt returns true for 1L and 4L. Try is_simple_power(1L, 4L).\n\
    <|/ c |>\n<| c |>\nIt returns true for 1L and 4L. Try is_simple_power(1L, 4L).\n\
    <|/ c |>\n<| a tags=c++,algorithm,math |>\n<code>\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyh_2xx4q.d(31): Error: declaration expected, not `<`\n/tmp/tmpyh_2xx4q.d(34):
    Error: unterminated character constant\n/tmp/tmpyh_2xx4q.d(54): Error: declaration
    expected, not `assert`\n/tmp/tmpyh_2xx4q.d(55): Error: declaration expected, not
    `assert`\n/tmp/tmpyh_2xx4q.d(56): Error: declaration expected, not `assert`\n/tmp/tmpyh_2xx4q.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmpyh_2xx4q.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmpyh_2xx4q.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmpyh_2xx4q.d(60): Error: declaration expected, not `assert`\n/tmp/tmpyh_2xx4q.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmpyh_2xx4q.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmpyh_2xx4q.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmpyh_2xx4q.d(64): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpyh_2xx4q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    long power = 1;\n    \n    while(n > 0)\n    {\n        result\
    \ *= x;\n        power *= n;\n        n--;\n    }\n    \n    return (result ==\
    \ power);\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThe question was\
    \ about C++, not C. `pow` isn't available in C++.\n<|/ c |>\n<| c |>\nYes, I know,\
    \ but I thought that maybe the OP can use some of his knowledge to solve the problem\
    \ in C++.\n<|/ c |>\n<| c |>\nI agree with you, but I thought that maybe the OP\
    \ can use some of his knowledge to solve the problem in C++.\n<|/ c |>\n<| c |>\n\
    The OP didn't specify that he was using C++. He did specify that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was using C. He also specified that he was using\
    \ C. He also specified that he was \nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbyopydsb.d(36): Error: declaration expected, not `<`\n/tmp/tmpbyopydsb.d(39):
    Error: unterminated character constant\n/tmp/tmpbyopydsb.d(48): Error: unterminated
    character constant\n/tmp/tmpbyopydsb.d(53): Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(54):
    Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(55): Error: declaration
    expected, not `assert`\n/tmp/tmpbyopydsb.d(56): Error: declaration expected, not
    `assert`\n/tmp/tmpbyopydsb.d(57): Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(58):
    Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(59): Error: declaration
    expected, not `assert`\n/tmp/tmpbyopydsb.d(60): Error: declaration expected, not
    `assert`\n/tmp/tmpbyopydsb.d(61): Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(62):
    Error: declaration expected, not `assert`\n/tmp/tmpbyopydsb.d(63): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbyopydsb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    \n    if (result == power)\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbirofxg9.d(43): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e6d]\n??:? void tmpbirofxg9.__unittest_L39_C1() [0x427a99]\n??:?
    void tmpbirofxg9.__modtest() [0x427bf0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430068]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb45]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9fd]\n??:? runModuleUnitTests [0x42b969]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282bc]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428243]\n??:? _d_run_main [0x4281ae]\n??:? main [0x427c03]\n??:?
    __libc_start_main [0x91c7d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long temp;\n    \n    while(n > 0)\n \
    \   {\n        temp = power;\n        power = power * x;\n        temp = temp\
    \ / n;\n        result = result && temp == power;\n        n = n - 1;\n    }\n\
    \    \n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code is not correct.\
    \ Try is_simple_power(3L, 3L).\n<|/ c |>\n<| c |>\nYes, you are right. I've corrected\
    \ my answer. Thank you!\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ofwyhbh.d(39): Error: declaration expected, not `<`\n/tmp/tmp_ofwyhbh.d(45):
    Error: unterminated character constant\n/tmp/tmp_ofwyhbh.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmp_ofwyhbh.d(54): Error: declaration expected, not
    `assert`\n/tmp/tmp_ofwyhbh.d(55): Error: declaration expected, not `assert`\n/tmp/tmp_ofwyhbh.d(56):
    Error: declaration expected, not `assert`\n/tmp/tmp_ofwyhbh.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmp_ofwyhbh.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmp_ofwyhbh.d(59): Error: declaration expected, not `assert`\n/tmp/tmp_ofwyhbh.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmp_ofwyhbh.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmp_ofwyhbh.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmp_ofwyhbh.d(63): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp_ofwyhbh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4gegbff8.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e75]\n??:? void tmp4gegbff8.__unittest_L33_C1() [0x427a9d]\n??:?
    void tmp4gegbff8.__modtest() [0x427bf4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa05]\n??:? runModuleUnitTests [0x42b971]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42824b]\n??:? _d_run_main [0x4281b6]\n??:? main [0x427c07]\n??:?
    __libc_start_main [0x84dd1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= 2;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9zcf35i6.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmp9zcf35i6.__unittest_L36_C1() [0x427a91]\n??:?
    void tmp9zcf35i6.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x37951554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis does not work. Try is_simple_power(3L, 2L).\n<|/ c |>\n<|\
    \ c |>\nI tested it and it works. I added a test case to my answer.\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I added a test case to my answer.\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I added a test case to my answer.\n<|/ c |>\n\
    <| c |>\nI tested it and it works. I added a test case to my answer.\n<|/ c |>\n\
    <| a tags=c++,algorithm |>\n<code>\n#include <iostream>\n#include <cmath>\n#include\
    \ <cstdlib>\nusing namespace std;\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoxf_ixje.d(27): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxf_ixje.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a |>\n<| c |>\nI didn't\
    \ know that `pow` was a function in C++. Thanks for pointing that out!\n<|/ c\
    \ |>\n<| c |>\n: It's a function in C and C++. `pow` is a function in C and C++.\n\
    <|/ c |>\n<| c |>\n: I didn't know that `pow` was a function in C++. Thanks for\
    \ pointing that out!\n<|/ c |>\n<| c |>\n: I didn't know that `pow` was a function\
    \ in C++. Thanks for pointing that out!\n<|/ c |>\n<| c |>\n: I didn't know that\
    \ `pow` was a function in C++. Thanks for pointing that out!\n<|/ c |>\n<| a tags=c++,algorithm\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7lwikfyf.d(33): Error: declaration expected, not `<`\n/tmp/tmp7lwikfyf.d(36):
    Error: unterminated character constant\n/tmp/tmp7lwikfyf.d(39): Error: unterminated
    character constant\n/tmp/tmp7lwikfyf.d(42): Error: unterminated character constant\n/tmp/tmp7lwikfyf.d(45):
    Error: unterminated character constant\n/tmp/tmp7lwikfyf.d(48): Error: unterminated
    character constant\n/tmp/tmp7lwikfyf.d(56): Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmp7lwikfyf.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmp7lwikfyf.d(60): Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmp7lwikfyf.d(63): Error: declaration expected, not
    `assert`\n/tmp/tmp7lwikfyf.d(64): Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(65):
    Error: declaration expected, not `assert`\n/tmp/tmp7lwikfyf.d(66): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7lwikfyf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        power *=\
    \ n;\n        result *= x;\n        n /= 2;\n    }\n    \n    if (n == 1) {\n\
    \        if (result == x) {\n            return true;\n        }\n    }\n    \n\
    \    return false;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n\
    \    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmphhm9x9cp.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e75]\n??:? void tmphhm9x9cp.__unittest_L41_C1() [0x427b31]\n??:?
    void tmphhm9x9cp.__modtest() [0x427bf8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa05]\n??:? runModuleUnitTests [0x42b971]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42824b]\n??:? _d_run_main [0x4281b6]\n??:? main [0x427c0b]\n??:?
    __libc_start_main [0xa0035554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long m = n;\n    long c = 1;\n    while(m > 0)\n    {\n        if(m\
    \ & 1)\n        {\n            r *= x;\n        }\n        x *= x;\n        m\
    \ >>= 1;\n        c++;\n    }\n    return c == n;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nI believe this fails for `is_simple_power(1L, 4L)` which returns\
    \ `true` but should return `false`.\n<|/ c |>\n<| c |>\n: Yes, you are right.\
    \ I've fixed my answer. Thanks.\n<|/ c |>\n<| c |>\nI believe this fails for `is_simple_power(1L,\
    \ 4L)` which returns `true` but should return `false`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ you are right. I've fixed my answer. Thanks.\n<|/ c |>\n<| c |>\nI believe this\
    \ fails for `is_simple_power(1L, 4L)` which returns `true` but should return `false`.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjmpm7zuy.d(39): Error: declaration expected, not `<`\n/tmp/tmpjmpm7zuy.d(45):
    Error: unterminated character constant\n/tmp/tmpjmpm7zuy.d(51): Error: unterminated
    character constant\n/tmp/tmpjmpm7zuy.d(62): Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmpjmpm7zuy.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmpjmpm7zuy.d(66): Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmpjmpm7zuy.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmpjmpm7zuy.d(70): Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(71):
    Error: declaration expected, not `assert`\n/tmp/tmpjmpm7zuy.d(72): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmpm7zuy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long temp;\n    \n    while(n > 0)\n \
    \   {\n        temp = power;\n        power = temp * x;\n        result += power;\n\
    \        n--;\n    }\n    \n    if (result == x)\n        return true;\n    else\n\
    \        return false;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code does\
    \ not work. For example, `is_simple_power(1L, 4L)` returns `true` but `is_simple_power(3L,\
    \ 2L)` returns `false`.\n<|/ c |>\n<| c |>\nI tested it and it works fine. Can\
    \ you please explain why it returns true for 1L and 4L but false for 3L and 2L?\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine. Can you please explain why it\
    \ returns true for 1L and 4L but false for 3L and 2L?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Can you please explain why it returns true for 1L and\
    \ 4L but false for 3L and 2L?\n<|/ c |>\n<| c |>\nI tested it and it works fine.\
    \ Can you please explain why it returns true for 1L and 4L but false for 3L and\
    \ 2L?\n<|/ c |>\n<| a tags=c++,algorithm,math |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp15ql8p3x.d(41): Error: declaration expected, not `<`\n/tmp/tmp15ql8p3x.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmp15ql8p3x.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmp15ql8p3x.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmp15ql8p3x.d(67): Error: declaration expected, not `assert`\n/tmp/tmp15ql8p3x.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmp15ql8p3x.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmp15ql8p3x.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmp15ql8p3x.d(71): Error: declaration expected, not `assert`\n/tmp/tmp15ql8p3x.d(72):
    Error: declaration expected, not `assert`\n/tmp/tmp15ql8p3x.d(73): Error: declaration
    expected, not `assert`\n/tmp/tmp15ql8p3x.d(74): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15ql8p3x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n==0)\
    \ return true;\n    if (n==1) return true;\n    if (x==0) return false;\n    if\
    \ (x==1) return true;\n    if (x==n) return true;\n    long r = 1;\n    long m\
    \ = n;\n    long a = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n \
    \   long e = 1;\n    long f = 1;\n    long g = 1;\n    long h = 1;\n    long i\
    \ = 1;\n    long j = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n \
    \   long n = 1;\n    long o = 1;\n    long p = 1;\n    long q = 1;\n    long r\
    \ = 1;\n    long s = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n \
    \   long w = 1;\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    long a\
    \ = 1;\n    long b = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n \
    \   long f = 1;\n    long g = 1;\n    long h = 1;\n    long i = 1;\n    long j\
    \ = 1;\n    long k = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n \
    \   long o = 1;\n    long p = 1;\n    long q = 1;\n    long r = 1;\n    long s\
    \ = 1;\n    long t = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n \
    \   long x = 1;\n    long y = 1;\n    long z = 1;\n    long a = 1;\n    long b\
    \ = 1;\n    long c = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n \
    \   long g = 1;\n    long h = 1;\n    long i = 1;\n    long j = 1;\n    long k\
    \ = 1;\n    long l = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n \
    \   long p = 1;\n    long q = 1;\n    long r = 1;\n    long s = 1;\n    long t\
    \ = 1;\n    long u = 1;\n    long v = 1;\n    long w = 1;\n    long x = 1;\n \
    \   long y = 1;\n    long z = 1;\n    long a = 1;\n    long b = 1;\n    long c\
    \ = 1;\n    long d = 1;\n    long e = 1;\n    long f = 1;\n    long g = 1;\n \
    \   long h = 1;\n    long i = 1;\n    long j = 1;\n    long k = 1;\n    long l\
    \ = 1;\n    long m = 1;\n    long n = 1;\n    long o = 1;\n\nunittest\n{\n   \
    \ alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n\
    \    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjwuy2nxx.d(125): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwuy2nxx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpcadr9_87.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpcadr9_87.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpcadr9_87.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x85b9d554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (n > 1) {\n        if (n %\
    \ 2 == 1) {\n            power *= x;\n        }\n        result *= x;\n      \
    \  n /= 2;\n        x *= x;\n    }\n    \n    return (result == power);\n}\nunittest\n\
    {\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) ==\
    \ true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmptce22yeg.d(42): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e85]\n??:? void tmptce22yeg.__unittest_L38_C1() [0x427aad]\n??:?
    void tmptce22yeg.__modtest() [0x427c04]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430080]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb5d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa15]\n??:? runModuleUnitTests [0x42b981]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282d4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42825b]\n??:? _d_run_main [0x4281c6]\n??:? main [0x427c17]\n??:?
    __libc_start_main [0x80dd1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    long long result = 1;\n    \n    while(n > 0)\n    {\n\
    \        power *= n;\n        result *= x;\n        n /= 10;\n    }\n    \n  \
    \  return result == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiimbg0p1.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\n/tmp/tmpiimbg0p1.d(25): Error: use `long` for a 64 bit integer
    instead of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiimbg0p1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ result = 1;\n    for(long i = 1; i < n; i++)\n    {\n        result = result\
    \ * x;\n    }\n    return result == x;\n}\nunittest\n{\n    alias candidate =\
    \ is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpdpruxr_s.d(38): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e4d]\n??:? void tmpdpruxr_s.__unittest_L31_C1() [0x427ae5]\n??:?
    void tmpdpruxr_s.__modtest() [0x427bd0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430048]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb25]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9dd]\n??:? runModuleUnitTests [0x42b949]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42829c]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428223]\n??:? _d_run_main [0x42818e]\n??:? main [0x427be3]\n??:?
    __libc_start_main [0xcdc75554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while (power < n)\n    {\n     \
    \   power *= x;\n        result *= power;\n    }\n    \n    if (result == x)\n\
    \    {\n        return true;\n    }\n    \n    return false;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/26839439)\n<|/ c |>\n<| c |>\n\
    The question was \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases.\" The answer is \"Write a function that\
    \ returns true if a number x is a simple power of n and false in other cases.\"\
    \ I provided a solution that is simple and straightforward.\n<|/ c |>\n<| c |>\n\
    The question was \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases.\" The answer is \"Write a function that\
    \ returns true if a number x is a simple power of n and false in other cases.\"\
    \ I provided a solution that is simple and straightforward.\n<|/ c |>\n<| c |>\n\
    The question was \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases.\" The answer is \"Write a function that\
    \ returns true if a number x is a simple power of n and false in other cases.\"\
    \ I provided a solution that is simple and straightforward.\n<|/ c |>\n<| c |>\n\
    The question was \"Write a function that returns true if a number x is a simple\
    \ power of n and false in other cases.\" The answer is \"Write a function that\
    \ returns true if a number x is a simple power of n and false in other cases.\"\
    \ I provided a solution that is simple and straightforward.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3zgls5kr.d(40): Error: declaration expected, not `<`\n/tmp/tmp3zgls5kr.d(63):
    Error: declaration expected, not `assert`\n/tmp/tmp3zgls5kr.d(64): Error: declaration
    expected, not `assert`\n/tmp/tmp3zgls5kr.d(65): Error: declaration expected, not
    `assert`\n/tmp/tmp3zgls5kr.d(66): Error: declaration expected, not `assert`\n/tmp/tmp3zgls5kr.d(67):
    Error: declaration expected, not `assert`\n/tmp/tmp3zgls5kr.d(68): Error: declaration
    expected, not `assert`\n/tmp/tmp3zgls5kr.d(69): Error: declaration expected, not
    `assert`\n/tmp/tmp3zgls5kr.d(70): Error: declaration expected, not `assert`\n/tmp/tmp3zgls5kr.d(71):
    Error: declaration expected, not `assert`\n/tmp/tmp3zgls5kr.d(72): Error: declaration
    expected, not `assert`\n/tmp/tmp3zgls5kr.d(73): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3zgls5kr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= x;\n        result *= power;\n        n /= 2;\n    }\n    \n    return result\
    \ == x;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp7gswhe7k.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e5d]\n??:? void tmp7gswhe7k.__unittest_L36_C1() [0x427a85]\n??:?
    void tmp7gswhe7k.__modtest() [0x427bdc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430058]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb35]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9ed]\n??:? runModuleUnitTests [0x42b959]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428233]\n??:? _d_run_main [0x42819e]\n??:? main [0x427bef]\n??:?
    __libc_start_main [0x8ebe5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ long power = 1;\n    \n    while(n > 0)\n    {\n        power = power * x;\n\
    \        n--;\n    }\n    \n    return power==x;\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9kshup6.d(24): Error: use `long` for a 64 bit integer instead
    of `long long`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9kshup6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ your solution. Thank you!\n<|/ c |>\n<| a |>\n<code>\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkult2yfz.d(33): Error: declaration expected, not `<`\n/tmp/tmpkult2yfz.d(44):
    Error: declaration expected, not `assert`\n/tmp/tmpkult2yfz.d(45): Error: declaration
    expected, not `assert`\n/tmp/tmpkult2yfz.d(46): Error: declaration expected, not
    `assert`\n/tmp/tmpkult2yfz.d(47): Error: declaration expected, not `assert`\n/tmp/tmpkult2yfz.d(48):
    Error: declaration expected, not `assert`\n/tmp/tmpkult2yfz.d(49): Error: declaration
    expected, not `assert`\n/tmp/tmpkult2yfz.d(50): Error: declaration expected, not
    `assert`\n/tmp/tmpkult2yfz.d(51): Error: declaration expected, not `assert`\n/tmp/tmpkult2yfz.d(52):
    Error: declaration expected, not `assert`\n/tmp/tmpkult2yfz.d(53): Error: declaration
    expected, not `assert`\n/tmp/tmpkult2yfz.d(54): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkult2yfz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ pow_of_n = pow(n, x);\n    return pow_of_n == x;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include <cmath>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6dcflz2n.d(27): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6dcflz2n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n==0)\n\
    \        return true;\n    if (n==1)\n        return (x==1);\n    if (x==1)\n\
    \        return is_simple_power(x, n-1);\n    if (x%n==0)\n        return is_simple_power(x,\
    \ n-1);\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\n\
    This code doesn't work for negative numbers. `is_simple_power(-1L, 2L)` returns\
    \ `true` instead of `false`.\n<|/ c |>\n<| c |>\nI tested it on `-1L` and `2L`\
    \ and it returns `false` as expected.\n<|/ c |>\n<| c |>\nI tested it on `-1L`\
    \ and `2L` and it returns `false` as expected.\n<|/ c |>\n<| c |>\nI tested it\
    \ on `-1L` and `2L` and it returns `false` as expected.\n<|/ c |>\n<| c |>\nI\
    \ tested it on `-1L` and `2L` and it returns `false` as expected.\n<|/ c |>\n\
    <| a |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpesn8gis1.d(34): Error: declaration expected, not `<`\n/tmp/tmpesn8gis1.d(37):
    Error: unterminated character constant\n/tmp/tmpesn8gis1.d(57): Error: declaration
    expected, not `assert`\n/tmp/tmpesn8gis1.d(58): Error: declaration expected, not
    `assert`\n/tmp/tmpesn8gis1.d(59): Error: declaration expected, not `assert`\n/tmp/tmpesn8gis1.d(60):
    Error: declaration expected, not `assert`\n/tmp/tmpesn8gis1.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmpesn8gis1.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmpesn8gis1.d(63): Error: declaration expected, not `assert`\n/tmp/tmpesn8gis1.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmpesn8gis1.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmpesn8gis1.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmpesn8gis1.d(67): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpesn8gis1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return is_simple_power(x * x, n / 2);\n}\nunittest\n{\n    alias candidate\
    \ = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L,\
    \ 16L) == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp4gegbff8.d(37): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e75]\n??:? void tmp4gegbff8.__unittest_L33_C1() [0x427a9d]\n??:?
    void tmp4gegbff8.__modtest() [0x427bf4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430070]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb4d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42aa05]\n??:? runModuleUnitTests [0x42b971]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282c4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42824b]\n??:? _d_run_main [0x4281b6]\n??:? main [0x427c07]\n??:?
    __libc_start_main [0x84dd1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long temp = 1;\n    \n    while(n > 0)\n\
    \    {\n        temp = power;\n        power = temp * x;\n        result *= power;\n\
    \        n--;\n    }\n    \n    if(result == x)\n    {\n        return true;\n\
    \    }\n    else\n    {\n        return false;\n    }\n}\nunittest\n{\n    alias\
    \ candidate = is_simple_power;\n\n    assert(candidate(16L, 2L) == true);\n  \
    \  assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L, 2L) ==\
    \ true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L, 4L)\
    \ == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpv_84gj2m.d(49): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e55]\n??:? void tmpv_84gj2m.__unittest_L45_C1() [0x427a7d]\n??:?
    void tmpv_84gj2m.__modtest() [0x427bd4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb7b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430050]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb2d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9e5]\n??:? runModuleUnitTests [0x42b951]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282a4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42822b]\n??:? _d_run_main [0x428196]\n??:? main [0x427be7]\n??:?
    __libc_start_main [0x3f094554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return result\
    \ == power;\n}\nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnrggl0h3.d(40): unittest failure\n----------------\n??:?
    _d_unittestp [0x427e65]\n??:? void tmpnrggl0h3.__unittest_L36_C1() [0x427a91]\n??:?
    void tmpnrggl0h3.__modtest() [0x427be8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430060]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x42fb3d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42a9f5]\n??:? runModuleUnitTests [0x42b961]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x42823b]\n??:? _d_run_main [0x4281a6]\n??:? main [0x427bfb]\n??:?
    __libc_start_main [0x511ae554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    if (n\
    \ == 0)\n        return true;\n    if (n == 1)\n        return (x == 1);\n   \
    \ if (x == 1)\n        return is_simple_power(x, n-1);\n    if (x == 0)\n    \
    \    return false;\n    long r = 1;\n    while (n > 0)\n    {\n        if (x%n\
    \ == 0)\n        {\n            r = r*x;\n            x /= n;\n        }\n   \
    \     else\n            break;\n    }\n    return (r == x);\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjrttvl07.d(45): Error: declaration expected, not `<`\n/tmp/tmpjrttvl07.d(53):
    Error: declaration expected, not `assert`\n/tmp/tmpjrttvl07.d(54): Error: declaration
    expected, not `assert`\n/tmp/tmpjrttvl07.d(55): Error: declaration expected, not
    `assert`\n/tmp/tmpjrttvl07.d(56): Error: declaration expected, not `assert`\n/tmp/tmpjrttvl07.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmpjrttvl07.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmpjrttvl07.d(59): Error: declaration expected, not
    `assert`\n/tmp/tmpjrttvl07.d(60): Error: declaration expected, not `assert`\n/tmp/tmpjrttvl07.d(61):
    Error: declaration expected, not `assert`\n/tmp/tmpjrttvl07.d(62): Error: declaration
    expected, not `assert`\n/tmp/tmpjrttvl07.d(63): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrttvl07.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ r = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    long power = 1;\n    long power = 1;\n    long power = 1;\n    long power\
    \ = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n    long\
    \ power = 1;\n    long power = 1;\n    long power = 1;\n    long power = 1;\n\
    \    \nunittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
    \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
    \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
    \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
    \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
    \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw002d4b9.d(110): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw002d4b9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = 1;\n    long result = 1;\n    long power = 1;\n    long result\
    \ = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n    long\
    \ result = 1;\n    long power = 1;\n    long result = 1;\n    long power = 1;\n\
    \    long result = 1;\n    long power = 1;\n    long result = 1;\n    long power\
    \ = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n    long\
    \ power = 1;\n    long result = 1;\n    long power = 1;\n    long result = 1;\n\
    \    long power = \nunittest\n{\n    alias candidate = is_simple_power;\n\n  \
    \  assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L) ==\
    \ false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L, 3L)\
    \ == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplnpsph0l.d(117): Error: expression expected, not `unittest`\n/tmp/tmplnpsph0l.d(118):
    Error: semicolon expected, not `{`\n/tmp/tmplnpsph0l.d(132): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmplnpsph0l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\nYour task is to write a function\
    \ that returns true if a number x is a simple\n    power of n and false in other\
    \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>>\
    \ is_simple_power(1L, 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n\
    \    >>> is_simple_power(8L, 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n\
    \    false\n    >>> is_simple_power(3L, 1L)\n    false\n    >>> is_simple_power(5L,\
    \ 3L)\n    false\n    \n*/\nbool is_simple_power(long x, long n) \n{\n    long\
    \ power = 1;\n    long result = 1;\n    \n    while(n > 0)\n    {\n        power\
    \ *= n;\n        result *= x;\n        n /= x;\n    }\n    \n    return (result\
    \ == power);\n}\n</code>\n<|/ a tags=c++,algorithm,c |>\n<| c |>\nI like your\
    \ solution, but I believe that `pow` function will overflow for large numbers.\
    \ I believe that `long long` should be used instead.\n<|/ c |>\n<| c |>\nYes,\
    \ `pow` function will overflow for large numbers. I believe that `long long` should\
    \ be used instead. I've edited my answer to include this information.\n<|/ c |>\n\
    <| c |>\nI believe that `long long` should be used instead. I've edited my answer\
    \ to include this information.\n<|/ c |>\n<| c |>\nI believe that `long long`\
    \ should be used instead. I've edited my answer to include this information.\n\
    <|/ c |>\n<| c |>\nI believe that `long long` should be used instead. I've edited\
    \ my answer to include this information.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    #include <stdio.h>\n#include <math.h>\nunittest\n{\n    alias candidate = is_simple_power;\n\
    \n    assert(candidate(16L, 2L) == true);\n    assert(candidate(143214L, 16L)\
    \ == false);\n    assert(candidate(4L, 2L) == true);\n    assert(candidate(9L,\
    \ 3L) == true);\n    assert(candidate(16L, 4L) == true);\n    assert(candidate(24L,\
    \ 2L) == false);\n    assert(candidate(128L, 4L) == false);\n    assert(candidate(12L,\
    \ 6L) == false);\n    assert(candidate(1L, 1L) == true);\n    assert(candidate(1L,\
    \ 12L) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphj4aqku_.d(36): Error: declaration expected, not `<`\n/tmp/tmphj4aqku_.d(42):
    Error: unterminated character constant\n/tmp/tmphj4aqku_.d(45): Error: unterminated
    character constant\n/tmp/tmphj4aqku_.d(48): Error: unterminated character constant\n/tmp/tmphj4aqku_.d(51):
    Error: unterminated character constant\n/tmp/tmphj4aqku_.d(61): Error: declaration
    expected, not `assert`\n/tmp/tmphj4aqku_.d(62): Error: declaration expected, not
    `assert`\n/tmp/tmphj4aqku_.d(63): Error: declaration expected, not `assert`\n/tmp/tmphj4aqku_.d(64):
    Error: declaration expected, not `assert`\n/tmp/tmphj4aqku_.d(65): Error: declaration
    expected, not `assert`\n/tmp/tmphj4aqku_.d(66): Error: declaration expected, not
    `assert`\n/tmp/tmphj4aqku_.d(67): Error: declaration expected, not `assert`\n/tmp/tmphj4aqku_.d(68):
    Error: declaration expected, not `assert`\n/tmp/tmphj4aqku_.d(69): Error: declaration
    expected, not `assert`\n/tmp/tmphj4aqku_.d(70): Error: declaration expected, not
    `assert`\n/tmp/tmphj4aqku_.d(71): Error: unrecognized declaration\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmphj4aqku_.d", "-I/tmp"]\n'''
  stdout: b''
