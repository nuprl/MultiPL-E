name: HumanEval_98_count_upper
language: d
prompt: "import std.math;\n/*\n\n    Given a string s, count the number of uppercase\
  \ vowels in even indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\"\
  )\n    1L\n    >>> count_upper(\"abcdefg\")\n    0L\n    >>> count_upper(\"dBBE\"\
  )\n    0L\n    \n*/\nlong count_upper(string s) \n"
tests: "unittest\n{\n    alias candidate = count_upper;\n\n    assert(candidate(\"\
  aBCdEf\") == 1L);\n    assert(candidate(\"abcdefg\") == 0L);\n    assert(candidate(\"\
  dBBE\") == 0L);\n    assert(candidate(\"B\") == 0L);\n    assert(candidate(\"U\"\
  ) == 1L);\n    assert(candidate(\"\") == 0L);\n    assert(candidate(\"EEEE\") ==\
  \ 2L);\n}\nvoid main(){}"
completions: ["{\n    long count = 0;\n    for(int i = 0; i < s.length(); i++)\n \
    \   {\n        if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' ||\
    \ s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i]\
    \ == 'u')\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nThis doesn't work. Try it on \"\
    aBCdEf\".\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. What do\
    \ you mean by \"doesn't work\"?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it on\
    \ \"aBCdEf\".\n<|/ c |>\n<| c |>\nI tested it before posting. What do you mean\
    \ by \"doesn't work\"?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it on \"aBCdEf\"\
    .\n<|/ c |>\n<| a |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace\
    \ std;", "{\n    long result = 0;\n    \n    foreach(i, s) {\n        if (i %\
    \ 2 == 0) {\n            if (s[i] == 'A' || s[i] == 'a') {\n                result\
    \ += 1;\n            }\n        }\n    }\n    \n    return result;\n}", "{\n \
    \   long count = 0;\n    for(int i = 0; i < s.length(); i++)\n    {\n        if(i\
    \ % 2 == 0)\n        {\n            if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E'\
    \ || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' ||\
    \ s[i] == 'U' || s[i] == 'u')\n            {\n                count++;\n     \
    \       }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n\
    \    for(int i = 0; i < s.length(); i++)\n    {\n        if(i % 2 == 0)\n    \
    \    {\n            if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e'\
    \ || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' ||\
    \ s[i] == 'u')\n            {\n                count++;\n            }\n     \
    \   }\n    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n\
    <| c |>\nThis doesn't work. Try it with `count_upper(\"ab\")`.\n<|/ c |>\n<| c\
    \ |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. Try it with `count_upper(\"ab\")`.\n<|/ c |>\n<| c |>\nI fixed the bug.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with\
    \ `count_upper(\"ab\")`.\n<|/ c |>\n<| a tags=c++,string,algorithm |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    for(int i = 0; i < s.length(); i++)\n  \
    \  {\n        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i]\
    \ == 'U')\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't work if you have a string\
    \ like \"abBcD\" where \"B\" is a vowel.\n<|/ c |>\n<| c |>\n: Yes, it does. I\
    \ tested it before posting it. I also tested it on \"abBcD\" where \"B\" is a\
    \ vowel.\n<|/ c |>\n<| c |>\n: I tested it on \"abBcD\" where \"B\" is a vowel.\
    \ My code returns `1L` for the string `\"abBcD\"`.\n<|/ c |>\n<| c |>\n: I tested\
    \ it on \"abBcD\" where \"B\" is a vowel. My code returns `1L` for the string\
    \ `\"abBcD\"`.\n<|/ c |>\n<| c |>\n: I tested it on \"abBcD\" where \"B\" is a\
    \ vowel. My code returns `1L` for the string `\"abBcD\"`.\n<|/ c |>\n<| a tags=c++,string\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;", "{\n\
    \    long count = 0;\n    for(int i = 0; i < s.length(); i++)\n    {\n       \
    \ if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i] == 'I' ||\
    \ s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] == 'u')\n \
    \       {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=c++,string |>\n<| c |>\nThis does not answer the question. The question\
    \ was about how to count the number of uppercase vowels in a string. Your code\
    \ does not do that.\n<|/ c |>\n<| c |>\nThe question was about how to count the\
    \ number of uppercase vowels in a string. Your code does not do that.\n<|/ c |>\n\
    <| c |>\nThe question was about how to count the number of uppercase vowels in\
    \ a string. Your code does not do that.\n<|/ c |>\n<| c |>\nThe question was about\
    \ how to count the number of uppercase vowels in a string. Your code does not\
    \ do that.\n<|/ c |>\n<| c |>\nThe question was about how to count the number\
    \ of uppercase vowels in a string. Your code does not do that.\n<|/ c |>\n<| a\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;", "{\n    long result = 0;\n    for (auto c : s)\n    {\n   \
    \     if (c == 'A' || c == 'a') result += 1;\n        if (c == 'E' || c == 'e')\
    \ result += 1;\n        if (c == 'I' || c == 'i') result += 1;\n        if (c\
    \ == 'O' || c == 'o') result += 1;\n        if (c == 'U' || c == 'u') result +=\
    \ 1;\n    }\n    return result;\n}", "{\n    long count = 0;\n    for (auto c\
    \ : s)\n        if (c == 'A' || c == 'a') count++;\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, but I wonder why you didn't use `std::count_if`\
    \ instead of `std::for_each`?\n<|/ c |>\n<| c |>\nBecause I didn't know about\
    \ `std::count_if`. I thought that `std::for_each` was a good solution, but I didn't\
    \ know about `std::count_if`. Thanks for pointing it out!\n<|/ c |>\n<| c |>\n\
    I didn't know about `std::count_if` either, but now I do. Thanks for pointing\
    \ it out!\n<|/ c |>\n<| a dscore=2 |>\n<code>\n#include <iostream>\n#include <string>\n\
    #include <algorithm>", "{\n    long count = 0;\n    for(int i = 0; i < s.length();\
    \ i++)\n    {\n        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] ==\
    \ 'O' || s[i] == 'U')\n        {\n            count++;\n        }\n    }\n   \
    \ return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI believe this solution\
    \ will fail for strings like \"aBcDeFgH\"\n<|/ c |>\n<| c |>\nI believe this solution\
    \ will fail for strings like \"aBcDeFgH\"\n<|/ c |>\n<| c |>\nI believe this solution\
    \ will fail for strings like \"aBcDeFgH\"\n<|/ c |>\n<| c |>\nI believe this solution\
    \ will fail for strings like \"aBcDeFgH\"\n<|/ c |>\n<| c |>\nI believe this solution\
    \ will fail for strings like \"aBcDeFgH\"\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    for (int i = 0; i < s.length; ++i)\n   \
    \ {\n        if (s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i]\
    \ == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] ==\
    \ 'u')\n        {\n            ++count;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    for (int i = 0; i < s.length(); i++)\n    {\n\
    \        if (s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i]\
    \ == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] ==\
    \ 'u')\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }", "{\n    long count = 0;\n    \n    foreach(char c in s)\n    {\n        if(c\
    \ == 'A' || c == 'a') \n            count++;\n    }\n    \n    return count;\n\
    }", "{\n    long count = 0;\n    for(int i = 0; i < s.length(); i++)\n    {\n\
    \        if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i] ==\
    \ 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] == 'u')\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work. `count_upper(\"aBCdEf\")` returns `1L`,\
    \ not `1`.\n<|/ c |>\n<| c |>\nOops, I missed that one. Thanks for pointing it\
    \ out. Fixed now.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n    long count = 0;\n    \n    for (int\
    \ i = 0; i < s.length(); i++)\n    {\n        if (s[i] == 'A' || s[i] == 'a' ||\
    \ s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i]\
    \ == 'o' || s[i] == 'U' || s[i] == 'u')\n        {\n            count++;\n   \
    \     }\n    }\n    \n    return count;\n}", "{\n    long result = 0;\n    for(int\
    \ i = 0; i < s.length(); i++)\n    {\n        if(s[i] == 'A' || s[i] == 'E' ||\
    \ s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n        {\n            result +=\
    \ 1;\n        }\n    }\n    return result;\n}", "{\n    long count = 0;\n    \n\
    \    for(int i = 0; i < s.length(); i++)\n    {\n        if(i % 2 == 0)\n    \
    \    {\n            if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U')\n            {\n                count++;\n            }\n  \
    \      }\n    }\n    \n    return count;\n}", "{\n    long result = 0;\n    for(int\
    \ i = 0; i < s.length(); i++)\n    {\n        if(s[i] == 'A' || s[i] == 'a' ||\
    \ s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i]\
    \ == 'o' || s[i] == 'U' || s[i] == 'u')\n        {\n            result += 1;\n\
    \        }\n    }\n    return result;\n}", "{\n    long result = 0;\n    for(int\
    \ i = 0; i < s.length(); i++)\n    {\n        if(i % 2 == 0)\n        {\n    \
    \        result += std.toupper(s[i]);\n        }\n    }\n    return result;\n}",
  "{\n    long count = 0;\n    for(int i = 0; i < s.length(); i++)\n    {\n      \
    \  if(s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] == 'e' || s[i] == 'I'\
    \ || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] == 'U' || s[i] == 'u')\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long result = 0;\n    \n    for (int i = 0; i < s.length; ++i)\n    {\n \
    \       if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] ==\
    \ 'U')\n        {\n            result += 1;\n        }\n    }\n    \n    return\
    \ result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
