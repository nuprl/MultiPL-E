language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pointer = 0;\n    long level_count = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_stack[MAX_LEVELS];\n    long paren_level_stack_pointer\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_counter = 0;\n \
    \   long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n    long\
    \ paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long paren_level_counter6\
    \ = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n\
    \    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n   \
    \ long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n    long\
    \ paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long paren_level_counter15\
    \ = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17 =\
    \ 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n\
    \    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n  \
    \  long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n    long\
    \ paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long paren_level_counter26\
    \ = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28 =\
    \ 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n\
    \    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n  \
    \  long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n    long\
    \ paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long paren_level_counter37\
    \ = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39 =\
    \ 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n\
    \    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n  \
    \  long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n    long\
    \ paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long paren_level_counter48\
    \ = 0;\n    long paren_level_counter49 = 0;\n    long paren_\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqhjzbxcp.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmpqhjzbxcp.d(20): Deprecation:
    instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] paren_level_stack`\n/tmp/tmpqhjzbxcp.d(73):
    Error: semicolon expected, not `unittest`\n/tmp/tmpqhjzbxcp.d(73): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhjzbxcp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp48vu_3pr.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp48vu_3pr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_levels[] =\
    \ new long[paren_string.length()];\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening = false;\n    bool is_closing = false;\n    bool\
    \ is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket_or_paren\
    \ = false;\n    bool is_closing_curly_bracket_or_paren = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_closing_curly_bracket_or_paren_or_space = false;\n    bool is_opening_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_closing_curly_bracket_or_paren_or_space = false;\n   \
    \ bool is_opening_curly_bracket_or_paren_or_space = false;\n    bool is_closing_curly_bracket_or_paren_or_space\
    \ = false;\n    bool is_opening_curly_bracket_or_paren_or_space = false;\n   \
    \ \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkizpup1j.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpkizpup1j.d(19): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] current_levels`\n/tmp/tmpkizpup1j.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpkizpup1j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_b\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmporrof8_0.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmporrof8_0.d(48): Error: semicolon expected,
    not `unittest`\n/tmp/tmporrof8_0.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmporrof8_0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.size()];\n\
    \    long max_level = 0;\n    long level = 0;\n    long level_count = 0;\n   \
    \ long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1zef9ouh.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zef9ouh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long pos = 0;\n    bool in_parens = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_open_brace\
    \ = false;\n    bool in_group_close_brace = false;\n    bool in_group_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_paren = false;\n    bool in_group_close_brace_or_close_paren\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace = false;\n    bool\
    \ in_group_open_brace_or_close_paren_brace_or_close_paren = false;\n    bool in_group_close_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_close_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_close_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_close_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace\
    \ = false;\n    bool in_group_open_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_brace_or_close_paren_bra\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprq2u00hy.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmprq2u00hy.d(41): Error: semicolon expected,
    not `unittest`\n/tmp/tmprq2u00hy.d(41): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprq2u00hy.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    long parens_index = 0;\n\
    \    long parens_level = 0;\n    long parens_level_max = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing = false;\n    bool is_opening_paren_closed = false;\n   \
    \ bool is_opening_paren_open = false;\n    bool is_closing_bracket = false;\n\
    \    bool is_closing_bracket_closed = false;\n    bool is_closing_bracket_open\
    \ = false;\n    bool is_opening_square = false;\n    bool is_opening_curly_bracket\
    \ = false;\n    bool is_opening_curly_bracket_closed = false;\n    bool is_opening_curly_bracket_open\
    \ = false;\n    bool is_closing_square = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_closing_curly_bracket_closed = false;\n    bool is_closing_curly_bracket_open\
    \ = false;\n    bool is_closing_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_closing_curly_brace_closed\
    \ = false;\n    bool is_closing_curly_brace_open = false;\n    bool is_closing_curly_brace_bracket\
    \ = false;\n    bool is_closing_square_brace_closed = false;\n    bool is_closing_square_brace_open\
    \ = false;\n    bool is_closing_square_brace_bracket = false;\n    bool is_closing_square_brace_closed\
    \ = false;\n    bool is_closing_square_brace_open = false;\n    bool is_closing_square_brace_bracket\
    \ = false;\n    bool is_closing_square_brace_closed = false;\n    bool is_closing_square_brace_open\
    \ = false;\n    bool is_closing_square_brace_bracket = false;\n    bool is_closing_square_brace_closed\
    \ = false;\n    bool is_closing_square_brace_open = false;\n    bool is_closing_square_brace_bracket\
    \ = false;\n    bool is_closing_square_brace_closed = false;\n    bool is_closing_square_brace_open\
    \ = false;\n    bool is_closing_square_brace_bracket = false;\n    bool is_closing_square_brace_closed\
    \ = false;\n    bool is_closing_square_brace_open = false;\n    bool is_closing_square_brace_bracket\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1fuvdxeq.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp1fuvdxeq.d(64): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1fuvdxeq.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            level++;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n        }\n        levels[i]\
    \ = level;\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2agid4h6.d(31): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2agid4h6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long levels_index = 0;\n\
    \    long levels_index_max = 0;\n    bool is_open = false;\n    bool is_closed\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening = false;\n\
    \    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzzyoinfr.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpzzyoinfr.d(40): Error: semicolon expected,
    not `unittest`\n/tmp/tmpzzyoinfr.d(40): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzzyoinfr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] levels = new long[paren_groups.length()];\n\
    \    long[] levels_stack = new long[paren_groups.length()];\n    long level =\
    \ 0;\n    long level_stack = 0;\n    long max_level = 0;\n    long max_level_stack\
    \ = 0;\n    long max_level_group = 0;\n    long max_level_group_stack = 0;\n \
    \   long max_level_group_length = 0;\n    long max_level_group_length_stack =\
    \ 0;\n    long max_level_group_length_group = 0;\n    long max_level_group_length_group_stack\
    \ = 0;\n    long max_level_group_length_group_length = 0;\n    long max_level_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group = 0;\n    long max_level_group_length_group_length_group_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length = 0;\n    long\
    \ max_level_group_length_group_length_group_length_stack = 0;\n    long max_level_group_length_group_length_group_length_group\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_length_stack\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_length\
    \ = 0;\n    long max_level_group_length_group_length_group_length_group_length_group_length_group_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsle99no5.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmpsle99no5.d(53):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpsle99no5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe8f6xczn.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpe8f6xczn.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpe8f6xczn.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8f6xczn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_paran = false;\n    bool in_paran2 = false;\n    bool\
    \ in_paran3 = false;\n    bool in_paran4 = false;\n    bool in_paran5 = false;\n\
    \    bool in_paran6 = false;\n    bool in_paran7 = false;\n    bool in_paran8\
    \ = false;\n    bool in_paran9 = false;\n    bool in_paran10 = false;\n    bool\
    \ in_paran11 = false;\n    bool in_paran12 = false;\n    bool in_paran13 = false;\n\
    \    bool in_paran14 = false;\n    bool in_paran15 = false;\n    bool in_paran16\
    \ = false;\n    bool in_paran17 = false;\n    bool in_paran18 = false;\n    bool\
    \ in_paran19 = false;\n    bool in_paran20 = false;\n    bool in_paran21 = false;\n\
    \    bool in_paran22 = false;\n    bool in_paran23 = false;\n    bool in_paran24\
    \ = false;\n    bool in_paran25 = false;\n    bool in_paran26 = false;\n    bool\
    \ in_paran27 = false;\n    bool in_paran28 = false;\n    bool in_paran29 = false;\n\
    \    bool in_paran30 = false;\n    bool in_paran31 = false;\n    bool in_paran32\
    \ = false;\n    bool in_paran33 = false;\n    bool in_paran34 = false;\n    bool\
    \ in_paran35 = false;\n    bool in_paran36 = false;\n    bool in_paran37 = false;\n\
    \    bool in_paran38 = false;\n    bool in_paran39 = false;\n    bool in_paran40\
    \ = false;\n    bool in_paran41 = false;\n    bool in_paran42 = false;\n    bool\
    \ in_paran43 = false;\n    bool in_paran44 = false;\n    bool in_paran45 = false;\n\
    \    bool in_paran46 = false;\n    bool in_paran47 = false;\n    bool in_paran48\
    \ = false;\n    bool in_paran49 = false;\n    bool in_paran50 = false;\n    bool\
    \ in_paran51 = false;\n    bool in_paran52 = false;\n    bool in_paran53 = false;\n\
    \    bool in_paran54 = false;\n    bool in_paran55 = false;\n    bool in_paran56\
    \ = false;\n    bool in_paran57 = false;\n    bool in_paran58 = false;\n    bool\
    \ in_paran59 = false;\n    bool in_paran60\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvv1dwv1b.d(77): Error: semicolon expected, not `unittest`\n/tmp/tmpvv1dwv1b.d(77):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvv1dwv1b.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long level_counters[] = new long[paren_string.length()];\n\
    \    long level_counters_index = 0;\n    long level_counters_index2 = 0;\n   \
    \ long level_counters_index3 = 0;\n    long level_counters_index4 = 0;\n    long\
    \ level_counters_index5 = 0;\n    long level_counters_index6 = 0;\n    long level_counters_index7\
    \ = 0;\n    long level_counters_index8 = 0;\n    long level_counters_index9 =\
    \ 0;\n    long level_counters_index10 = 0;\n    long level_counters_index11 =\
    \ 0;\n    long level_counters_index12 = 0;\n    long level_counters_index13 =\
    \ 0;\n    long level_counters_index14 = 0;\n    long level_counters_index15 =\
    \ 0;\n    long level_counters_index16 = 0;\n    long level_counters_index17 =\
    \ 0;\n    long level_counters_index18 = 0;\n    long level_counters_index19 =\
    \ 0;\n    long level_counters_index20 = 0;\n    long level_counters_index21 =\
    \ 0;\n    long level_counters_index22 = 0;\n    long level_counters_index23 =\
    \ 0;\n    long level_counters_index24 = 0;\n    long level_counters_index25 =\
    \ 0;\n    long level_counters_index26 = 0;\n    long level_counters_index27 =\
    \ 0;\n    long level_counters_index28 = 0;\n    long level_counters_index29 =\
    \ 0;\n    long level_counters_index30 = 0;\n    long level_counters_index31 =\
    \ 0;\n    long level_counters_index32 = 0;\n    long level_counters_index33 =\
    \ 0;\n    long level_counters_index34 = 0;\n    long level_counters_index35 =\
    \ 0;\n    long level_counters_index36 = 0;\n    long level_counters_index37 =\
    \ 0;\n    long level_counters_index38 = 0;\n    long level_counters_index39 =\
    \ 0;\n    long level_counters_index40 = 0;\n    long level_counters_index41 =\
    \ 0;\n    long level_counters_index42 = 0;\n    long level_counters_index43 =\
    \ 0;\n    long level_counters_index44 = 0;\n    long level_counters_index45 =\
    \ 0;\n    long level_counters_index46 = 0;\n    long level_counters_index47 =\
    \ 0;\n    long level_counters_index48 = 0;\n    long level_counters_index49 =\
    \ 0;\n    long level_counters_index50 = 0;\n    long level_counters_index51 =\
    \ 0;\n    long level_counters_index52 = 0;\n    long level_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpntl0fdpe.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpntl0fdpe.d(18): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] level_counters`\n/tmp/tmpntl0fdpe.d(72):
    Error: semicolon expected, not `unittest`\n/tmp/tmpntl0fdpe.d(72): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntl0fdpe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n            levels[i] = level;\n        }\n\
    \        else if(paren_string[i] == ')') {\n            level--;\n           \
    \ levels[i] = level;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            level--;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            level--;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            level--;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            level--;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')') {\n            level--;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            level++;\n       \
    \ }\n        else if(paren_string[i] == ')') {\n            level--;\n       \
    \ }\n    }\n    for(int i = 0; i < paren_string.length\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvz0n4raj.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpvz0n4raj.d(116): Error: found `unittest`
    when expecting `;` following `for` condition\n/tmp/tmpvz0n4raj.d(124): Error:
    found `void` when expecting `)`\n/tmp/tmpvz0n4raj.d(124): Error: found `{` when
    expecting `;` following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvz0n4raj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzk3grmex.d(63): Error: no identifier for declarator `long`\n/tmp/tmpzk3grmex.d(63):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzk3grmex.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_group;\n    long max_level = 0;\n    long level = 0;\n    long levels[]\
    \ = new long[MAX_GROUPS];\n    long groups[] = new long[MAX_GROUPS];\n    long\
    \ group_index = 0;\n    long index = 0;\n    bool in_group = false;\n    bool\
    \ in_paren = false;\n    bool in_group_bracket = false;\n    bool in_group_paren\
    \ = false;\n    bool in_group_paren_bracket = false;\n    bool in_group_paren_paren\
    \ = false;\n    bool in_group_paren_paren_bracket = false;\n    bool in_group_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_bracket = false;\n    bool in_group_paren_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_paren_bracket = false;\n    bool\
    \ in_group_paren_paren_paren_paren_paren = false;\n    bool in_group_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren = false;\n \
    \   bool in_group_paren_paren_paren_paren_paren_paren_bracket = false;\n    bool\
    \ in_group_paren_paren_paren_paren_paren_paren_paren = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_bracket\
    \ = false;\n    bool in_group_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphwzs242e.d(17): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmphwzs242e.d(18): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] groups`\n/tmp/tmphwzs242e.d(47): Error:
    semicolon expected, not `unittest`\n/tmp/tmphwzs242e.d(47): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphwzs242e.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char = \"()\";\n    string paren_group = \"\";\n    string paren_group_str\
    \ = \"\";\n    string paren_group_str2 = \"\";\n    string paren_group_str3 =\
    \ \"\";\n    string paren_group_str4 = \"\";\n    string paren_group_str5 = \"\
    \";\n    string paren_group_str6 = \"\";\n    string paren_group_str7 = \"\";\n\
    \    string paren_group_str8 = \"\";\n    string paren_group_str9 = \"\";\n  \
    \  string paren_group_str10 = \"\";\n    string paren_group_str11 = \"\";\n  \
    \  string paren_group_str12 = \"\";\n    string paren_group_str13 = \"\";\n  \
    \  string paren_group_str14 = \"\";\n    string paren_group_str15 = \"\";\n  \
    \  string paren_group_str16 = \"\";\n    string paren_group_str17 = \"\";\n  \
    \  string paren_group_str18 = \"\";\n    string paren_group_str19 = \"\";\n  \
    \  string paren_group_str20 = \"\";\n    string paren_group_str21 = \"\";\n  \
    \  string paren_group_str22 = \"\";\n    string paren_group_str23 = \"\";\n  \
    \  string paren_group_str24 = \"\";\n    string paren_group_str25 = \"\";\n  \
    \  string paren_group_str26 = \"\";\n    string paren_group_str27 = \"\";\n  \
    \  string paren_group_str28 = \"\";\n    string paren_group_str29 = \"\";\n  \
    \  string paren_group_str30 = \"\";\n    string paren_group_str31 = \"\";\n  \
    \  string paren_group_str32 = \"\";\n    string paren_group_str33 = \"\";\n  \
    \  string paren_group_str34 = \"\";\n    string paren_group_str35 = \"\";\n  \
    \  string paren_group_str36 = \"\";\n    string paren_group_str37 = \"\";\n  \
    \  string paren_group_str38 = \"\";\n    string paren_group_str39 = \"\";\n  \
    \  string paren_group_str40 = \"\";\n    string paren_group_str41 = \"\";\n  \
    \  string paren_group_str42 = \"\";\n    string paren_group_str43 = \"\";\n  \
    \  string paren_group_str44 = \"\";\n    string paren_group_str45 = \"\";\n  \
    \  string paren_group_str46 = \"\";\n    string paren_group_str47 = \"\";\n  \
    \  string paren_group_str48 = \"\";\n    string paren_group_str49 = \"\";\n  \
    \  string paren_group_str50 = \"\";\n    string paren_group_str51 = \"\";\n  \
    \  string paren_group_str52 = \"\";\n    string paren_group_str53 = \"\";\n  \
    \  string paren_group_str54 = \"\";\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxy_pdx6y.d(71): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxy_pdx6y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_top = new long[paren_string.length()];\n    long levels_stack_index\
    \ = 0;\n    long levels_stack_top_index = 0;\n    long levels_stack_top_value\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_value_count = 0;\n    long levels_stack_top_value_index\
    \ = 0;\n    long levels_stack_top_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp96r29pbe.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmp96r29pbe.d(67):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp96r29pbe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_counter = 0;\n\
    \    long paren_level_max_counter2 = 0;\n    long paren_level_max_counter3 = 0;\n\
    \    long paren_level_max_counter4 = 0;\n    long paren_level_max_counter5 = 0;\n\
    \    long paren_level_max_counter6 = 0;\n    long paren_level_max_counter7 = 0;\n\
    \    long paren_level_max_counter8 = 0;\n    long paren_level_max_counter9 = 0;\n\
    \    long paren_level_max_counter10 = 0;\n    long paren_level_max_counter11 =\
    \ 0;\n    long paren_level_max_counter12 = 0;\n    long paren_level_max_counter13\
    \ = 0;\n    long paren_level_max_counter14 = 0;\n    long paren_level_max_counter15\
    \ = 0;\n    long paren_level_max_counter16 = 0;\n    long paren_level_max_counter17\
    \ = 0;\n    long paren_level_max_counter18 = 0;\n    long paren_level_max_counter19\
    \ = 0;\n    long paren_level_max_counter20 = 0;\n    long paren_level_max_counter21\
    \ = 0;\n    long paren_level_max_counter22 = 0;\n    long paren_level_max_counter23\
    \ = 0;\n    long paren_level_max_counter24 = 0;\n    long paren_level_max_counter25\
    \ = 0;\n    long paren_level_max_counter26 = 0;\n    long paren_level_max_counter27\
    \ = 0;\n    long paren_level_max_counter28 = 0;\n    long paren_level_max_counter29\
    \ = 0;\n    long paren_level_max_counter30 = 0;\n    long paren_level_max_counter31\
    \ = 0;\n    long paren_level_max_counter32 = 0;\n    long paren_level_max_counter33\
    \ = 0;\n    long paren_level_max_counter34 = 0;\n    long paren_level_max_counter35\
    \ = 0;\n    long paren_level_max_counter36 = 0;\n    long paren_level_max_counter37\
    \ = 0;\n    long paren_level_max_counter38 = 0;\n    long paren_level_max_counter39\
    \ = 0;\n    long paren_level_max_counter40 = 0;\n    long paren_level_max_counter41\
    \ = 0;\n    long paren_level_max_counter42 = 0;\n    long paren_level_max_counter43\
    \ = 0;\n    long paren_level_max_counter44 = 0;\n    long paren_level_max_counter45\
    \ = 0;\n    long paren_level_max_counter46 = 0;\n    long paren_level_max_counter47\
    \ = 0;\n    long paren_level_max_counter48 = 0;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps4nqoqaa.d(68): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4nqoqaa.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_cur\
    \ = 0;\n    long parens_level_max2 = 0;\n    long parens_level_cur2 = 0;\n   \
    \ long parens_level_max3 = 0;\n    long parens_level_cur3 = 0;\n    long parens_level_max4\
    \ = 0;\n    long parens_level_cur4 = 0;\n    long parens_level_max5 = 0;\n   \
    \ long parens_level_cur5 = 0;\n    long parens_level_max6 = 0;\n    long parens_level_cur6\
    \ = 0;\n    long parens_level_max7 = 0;\n    long parens_level_cur7 = 0;\n   \
    \ long parens_level_max8 = 0;\n    long parens_level_cur8 = 0;\n    long parens_level_max9\
    \ = 0;\n    long parens_level_cur9 = 0;\n    long parens_level_max10 = 0;\n  \
    \  long parens_level_cur10 = 0;\n    long parens_level_max11 = 0;\n    long parens_level_cur11\
    \ = 0;\n    long parens_level_max12 = 0;\n    long parens_level_cur12 = 0;\n \
    \   long parens_level_max13 = 0;\n    long parens_level_cur13 = 0;\n    long parens_level_max14\
    \ = 0;\n    long parens_level_cur14 = 0;\n    long parens_level_max15 = 0;\n \
    \   long parens_level_cur15 = 0;\n    long parens_level_max16 = 0;\n    long parens_level_cur16\
    \ = 0;\n    long parens_level_max17 = 0;\n    long parens_level_cur17 = 0;\n \
    \   long parens_level_max18 = 0;\n    long parens_level_cur18 = 0;\n    long parens_level_max19\
    \ = 0;\n    long parens_level_cur19 = 0;\n    long parens_level_max20 = 0;\n \
    \   long parens_level_cur20 = 0;\n    long parens_level_max21 = 0;\n    long parens_level_cur21\
    \ = 0;\n    long parens_level_max22 = 0;\n    long parens_level_cur22 = 0;\n \
    \   long parens_level_max23 = 0;\n    long parens_level_cur23 = 0;\n    long parens_level_max24\
    \ = 0;\n    long parens_level_cur24 = 0;\n    long parens_level_max25 = 0;\n \
    \   long parens_level_cur25 = 0;\n    long parens_level_max26 = 0;\n    long parens_level_cur26\
    \ = 0;\n    long parens_level_max27 = 0;\n    long parens_level_cur27 = 0;\n \
    \   long parens_level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprm06znwm.d(73): Error: semicolon expected, not `unittest`\n/tmp/tmprm06znwm.d(73):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprm06znwm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_copy = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long levels_stack_index = 0;\n    long levels_stack_copy_index = 0;\n\
    \    bool has_left_paren = false;\n    bool has_right_paren = false;\n    bool\
    \ has_left_curly = false;\n    bool has_right_curly = false;\n    bool has_left_square\
    \ = false;\n    bool has_right_square = false;\n    bool has_left_curly_square\
    \ = false;\n    bool has_right_curly_square = false;\n    bool has_left_square_curly\
    \ = false;\n    bool has_right_square_curly = false;\n    bool has_left_square_curly_square\
    \ = false;\n    bool has_right_square_curly_square = false;\n    bool has_left_square_curly_curly\
    \ = false;\n    bool has_right_square_curly_curly = false;\n    bool has_left_square_curly_square_curly\
    \ = false;\n    bool has_right_square_curly_square_curly = false;\n    bool has_left_square_curly_curly_square\
    \ = false;\n    bool has_right_square_curly_curly_square = false;\n    bool has_left_square_curly_curly_square_curly\
    \ = false;\n    bool has_right_square_curly_curly_square_curly = false;\n    bool\
    \ has_left_square_curly_curly_square_curly_square = false;\n    bool has_right_square_curly_curly_square_curly_square\
    \ = false;\n    bool has_left_square_curly_curly_square_curly_curly_square = false;\n\
    \    bool has_right_square_curly_curly_square_curly_curly_square = false;\n  \
    \  bool has_left_square_curly_curly_square_curly_curly_curly_square = false;\n\
    \    bool has_right_square_curly_curly_square_curly_curly_curly_square = false;\n\
    \    bool has_left_square_curly_curly_square_curly_curly_curly_square = false;\n\
    \    bool has_right_square_curly_curly_square_curly_curly_curly_square = false;\n\
    \    bool has_left_square_curly_curly_square_curly_curly_curly_curly_square =\
    \ false;\n    bool has_right_square_curly_curly_square_curly_curly_curly_curly_square\
    \ = false;\n    bool has_left_square_curly_curly_square_curly_curly_curly_curly_curly_square\
    \ = false;\n    bool has_right_square_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb0aqog6m.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpb0aqog6m.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpb0aqog6m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    bool in_paren = false;\n    bool in_paren_prev\
    \ = false;\n    bool in_paren_next_prev = false;\n    bool in_paren_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_prev = false;\n    bool\
    \ in_paren_next_next_next_next_next_next_prev = false;\n    bool in_paren_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_prev = false;\n\
    \    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\n    bool in_paren_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpua53pbpn.d(44): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpua53pbpn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            in_paren = true;\n     \
    \       level++;\n        }\n        else if(paren_string[i] == ')')\n       \
    \ {\n            in_paren = false;\n            level--;\n        }\n        if(in_paren)\n\
    \        {\n            levels[i] = level;\n        }\n    }\n    return levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe335du6d.d(14): Error: no property `length` for type `string`\n/tmp/tmpe335du6d.d(17):
    Error: no property `length` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpe335du6d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    bool in_paren = false;\n    long\
    \ level = 0;\n    long max_level = 0;\n    long max_level_index = 0;\n    long\
    \ index = 0;\n    \n    for(long i = 0; i < paren_string.length(); i++) {\n  \
    \      char c = paren_string[i];\n        \n        if(c == '(') {\n         \
    \   if(!in_paren) {\n                levels[index] = level;\n                index++;\n\
    \                in_paren = true;\n                level++;\n            }\n \
    \       }\n        else if(c == ')') {\n            in_paren = false;\n      \
    \      level--;\n        }\n        else if(c == ' ') {\n            levels[index]\
    \ = level;\n            index++;\n        }\n    }\n    \n    for(long i = 0;\
    \ i < levels.length; i++) {\n        if(levels[i] > max_level) {\n           \
    \ max_level = levels[i];\n            max_level_index = i;\n        }\n    }\n\
    \    \n    return levels[max_level_index];\n}\n</code>\n<|/ a tags=algorithm,c++,string,parentheses\
    \ |>\n<| c |>\nThis doesn't work. Try it with `\"(()()) ((())) () ((())()())\"\
    `\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test case to my answer.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `(\"(()()) ((())) () ((())()())\")`\n<|/\
    \ c |>\n<| c |>\nI tested it and it works. I added a test case to my answer.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `(\"(()()) ((())) () ((())()())\")`\n<|/\
    \ c |>\n<| a dscore=3 |>\nHere's a solution using recursion:\n<code>\n#include\
    \ <iostream>\n#include <string>\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpza8nig37.d(51): Error: declaration expected, not `<`\n/tmp/tmpza8nig37.d(54):
    Error: unterminated character constant\n/tmp/tmpza8nig37.d(60): Error: unterminated
    character constant\n/tmp/tmpza8nig37.d(66): Error: unterminated character constant\n/tmp/tmpza8nig37.d(69):
    Error: unterminated character constant\n/tmp/tmpza8nig37.d(77): Error: declaration
    expected, not `assert`\n/tmp/tmpza8nig37.d(78): Error: declaration expected, not
    `assert`\n/tmp/tmpza8nig37.d(79): Error: declaration expected, not `assert`\n/tmp/tmpza8nig37.d(80):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpza8nig37.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn3c7vfxp.d(75): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3c7vfxp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool has_left_paren\
    \ = false;\n    bool has_right_paren = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        char c = paren_string[i];\n        if(c == '(') {\n        \
    \    has_left_paren = true;\n            level++;\n        }\n        else if(c\
    \ == ')') {\n            has_right_paren = true;\n            level--;\n     \
    \   }\n        else if(c == ' ') {\n            levels[level] = levels[level]\
    \ + 1;\n        }\n    }\n    if(has_left_paren && has_right_paren) {\n      \
    \  throw new Exception(\"Invalid parenthesis string\");\n    }\n    return levels;\n\
    }\n</code>\n<|/ a tags=algorithm,c++,string,parsing |>\n<| c |>\nThis doesn't\
    \ work if there are multiple spaces between the parentheses.\n<|/ c |>\n<| c |>\n\
    It does work if there are multiple spaces between the parentheses. I tested it\
    \ before posting it.\n<|/ c |>\n<| c |>\nIt does work if there are multiple spaces\
    \ between the parentheses. I tested it before posting it.\n<|/ c |>\n<| c |>\n\
    It does work if there are multiple spaces between the parentheses. I tested it\
    \ before posting it.\n<|/ c |>\n<| c |>\nIt does work if there are multiple spaces\
    \ between the parentheses. I tested it before posting it.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI wrote a solution in Python that uses recursion to solve this problem.\
    \ It also handles nested parentheses.\n<code>\ndef paren_count(s):\n    count\
    \ = 0\n    stack = []\n    open_brackets = 0\n    close_brackets = 0\n    open_brackets_stack\
    \ = []\n    close_brackets_stack = []\n    \n    for c in s:\n        if c ==\
    \ '(':\n            open_brackets += 1\n            open_brackets_stack.append(c)\n\
    \        elif c == ')':\n            close_brackets += 1\n            close_brackets_stack.append(c)\n\
    \        elif c == ' ':\n            if open_brackets == close_brackets:\n   \
    \             count += 1\n            elif open_brackets > close_brackets:\n \
    \               open_brackets_stack.pop()\n                close_brackets_stack.pop()\n\
    \                open_brackets -= 1\n                close_brackets -= 1\n   \
    \         else:\n                open_brackets_stack.pop()\n                close_brackets_stack.pop()\n\
    \                open_brackets -= 1\n                close_bra\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsl6e1z_8.d(37): Error: declaration expected, not `<`\n/tmp/tmpsl6e1z_8.d(40):
    Error: unterminated character constant\n/tmp/tmpsl6e1z_8.d(89): Error: declaration
    expected, not `assert`\n/tmp/tmpsl6e1z_8.d(90): Error: declaration expected, not
    `assert`\n/tmp/tmpsl6e1z_8.d(91): Error: declaration expected, not `assert`\n/tmp/tmpsl6e1z_8.d(92):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsl6e1z_8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_quote = false;\n    bool in_double_quote\
    \ = false;\n    bool in_single_quote = false;\n    bool in_backslash = false;\n\
    \    bool in_backslash_escape = false;\n    bool in_backslash_escape_char = false;\n\
    \    bool in_backslash_escape_char_escape = false;\n    bool in_backslash_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape = false;\n  \
    \  bool in_backslash_escape_char_escape_char_escape_char = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape_char_escape\
    \ = false;\n    bool in_backslash_escape_char_escape_char_escape_char_escape_char_escape_char_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmnphswi4.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpmnphswi4.d(46): Error: semicolon expected,
    not `unittest`\n/tmp/tmpmnphswi4.d(46): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmnphswi4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n \
    \   bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group = false;\n    bool in_paren_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_close = false;\n    bool\
    \ in_paren_group_open_close_group_open_close = false;\n    bool in_paren_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open = false;\n\
    \    bool in_paren_group_open_close_group_open_close_group_close = false;\n  \
    \  bool in_paren_group_open_close_group_open_close_group_open_close = false;\n\
    \    bool in_paren_group_open_close_group_open_close_group_open_close_group =\
    \ false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8njp691p.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp8njp691p.d(48): Error: semicolon expected,
    not `unittest`\n/tmp/tmp8njp691p.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8njp691p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_or_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma_brace = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n   \
    \ bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace = false;\n \
    \   bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_bra\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv94a3_f8.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpv94a3_f8.d(45): Error: semicolon expected,
    not `unittest`\n/tmp/tmpv94a3_f8.d(45): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv94a3_f8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq2z01jja.d(75): Error: semicolon expected, not `unittest`\n/tmp/tmpq2z01jja.d(75):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq2z01jja.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long level = 0;\n    long level_stack = 0;\n    bool in_paren = false;\n\
    \    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n   \
    \ bool in_paren_group_close = false;\n    bool in_paren_group_open_brace = false;\n\
    \    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma = false;\n    bool in_paren_group_open_brace_colon\
    \ = false;\n    bool in_paren_group_close_brace_colon = false;\n    bool in_paren_group_open_brace_semicolon\
    \ = false;\n    bool in_paren_group_close_brace_semicolon = false;\n    bool in_paren_group_open_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_colon_colon = false;\n    bool in_paren_group_close_brace_colon_colon\
    \ = false;\n    bool in_paren_group_open_brace_semicolon_colon = false;\n    bool\
    \ in_paren_group_close_brace_semicolon_colon = false;\n    bool in_paren_group_open_brace_comma_brace_semicolon\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_semicolon = false;\n\
    \    bool in_paren_group_open_brace_colon_semicolon = false;\n    bool in_paren_group_close_brace_colon_semicolon\
    \ = false;\n    bool in_paren_group_open_brace_semicolon_semicolon = false;\n\
    \    bool in_paren_group_close_brace_semicolon_semicolon = false;\n    bool in_paren_group_open_brace_comma_brace_semicolon_semicolon\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace_semicolon_semicolon\
    \ = false;\n    bool in_paren_group_open_brace_colon_colon_semicolon = false;\n\
    \    bool in_paren_group_close_brace_colon_colon_semicolon = false;\n    bool\
    \ in_paren_group_open_brace_semicolon_colon_semicolon = false;\n    bool in_paren_group_close_brace_semicolon_colon_semicolon\
    \ = false;\n    bool in_paren_group_open_brace_comma_brace_semicolon_colon_semicolon\
    \ = false;\n    bool in_paren_group_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnga8dpur.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmpnga8dpur.d(50):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnga8dpur.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpijec8jki.d(75): Error: semicolon expected, not `unittest`\n/tmp/tmpijec8jki.d(75):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpijec8jki.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels = { 0 };\n    long[]\
    \ levels = { 0 };\n    long[] levels_stack = { 0 };\n    bool has_open_bracket\
    \ = false;\n    bool has_closed_bracket = false;\n    bool has_open_brackets =\
    \ false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = false;\n    bool has_closed_brackets = false;\n    bool has_open_square_brackets\
    \ = false;\n    bool has_closed_square_brackets = false;\n    bool has_open_brackets\
    \ = \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6k99i4_4.d(63): Error: expression expected, not `unittest`\n/tmp/tmp6k99i4_4.d(64):
    Error: semicolon expected, not `{`\n/tmp/tmp6k99i4_4.d(71): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6k99i4_4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_reversed = \"()\";\n    string\
    \ paren_chars_reversed_reversed = \"()\";\n    string paren_chars_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed = \"()\"\
    ;\n    string paren_chars_reversed_reversed_reversed_reversed_reversed = \"()\"\
    ;\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = \"()\";\n    string paren_chars_reversed_reversed_reversed_reversed_reverse\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnl_cgcsu.d(34): Error: found `paren_chars_reversed_reversed_reversed_reversed_reverse`
    when expecting `;` following statement\n/tmp/tmpnl_cgcsu.d(35): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnl_cgcsu.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_levels[]\
    \ = new long[paren_string.length()];\n    long paren_levels_size = 0;\n    long\
    \ paren_levels_index = 0;\n    long paren_levels_size_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_size_index2 = 0;\n    long paren_levels_index3 =\
    \ 0;\n    long paren_levels_size_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_size_index4 = 0;\n    long paren_levels_index5 = 0;\n \
    \   long paren_levels_size_index5 = 0;\n    long paren_levels_index6 = 0;\n  \
    \  long paren_levels_size_index6 = 0;\n    long paren_levels_index7 = 0;\n   \
    \ long paren_levels_size_index7 = 0;\n    long paren_levels_index8 = 0;\n    long\
    \ paren_levels_size_index8 = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_size_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_size_index10\
    \ = 0;\n    long paren_levels_index11 = 0;\n    long paren_levels_size_index11\
    \ = 0;\n    long paren_levels_index12 = 0;\n    long paren_levels_size_index12\
    \ = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_size_index13\
    \ = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_size_index14\
    \ = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_size_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_size_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_size_index17\
    \ = 0;\n    long paren_levels_index18 = 0;\n    long paren_levels_size_index18\
    \ = 0;\n    long paren_levels_index19 = 0;\n    long paren_levels_size_index19\
    \ = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_size_index20\
    \ = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_size_index21\
    \ = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_size_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmhlsfpfp.d(17): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] paren_levels`\n/tmp/tmpmhlsfpfp.d(65): Error: semicolon
    expected, not `unittest`\n/tmp/tmpmhlsfpfp.d(65): Error: found `unittest` instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhlsfpfp.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string s = paren_chars[i];\n    \
    \    level = 0;\n        for(long j = 0; j < s.length(); ++j)\n        {\n   \
    \         char c = s[j];\n            if(c == '(')\n                ++level;\n\
    \            if(c == ')')\n                --level;\n            levels[level]\
    \ = max(levels[level], level);\n        }\n        max_level = max(max_level,\
    \ level);\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjyjzbky8.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpjyjzbky8.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmpjyjzbky8.d(35):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpjyjzbky8.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closed\
    \ = false;\n    bool is_closing_paren_or_open = false;\n    bool is_opening_paren_or_closed_or_open\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren = false;\n    bool is_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool is_closing_paren_or_closing_paren_or_opening_paren_or_closed = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_closing_paren = false;\n    bool\
    \ is_closing_paren_or_closing_paren_or_closing_paren_or_open = false;\n    bool\
    \ is_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren = false;\n\
    \    bool is_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_open\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_closing_paren_or_opening_paren_or_closed\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprnm1co_1.d(43): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnm1co_1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] levels = new long[paren_groups.length()];\n\
    \    long[] max_levels = new long[paren_groups.length()];\n    long[] current_levels\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels = new long[paren_groups.length()];\n\
    \    long[] current_levels_index = new long[paren_groups.length()];\n    long[]\
    \ current_max_levels_index = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_index_in_paren_groups_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpefw19tv3.d(36): Error: semicolon expected, not `unittest`\n/tmp/tmpefw19tv3.d(36):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpefw19tv3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long\
    \ m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n\
    \    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long\
    \ v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long\
    \ E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n\
    \    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long\
    \ N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n\
    \    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long\
    \ W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long _ = 0;\n\
    \    long _1 = 0;\n    long _2 = 1;\n    long _3 = 1;\n    long _4 = 2;\n    long\
    \ _5 = 3;\n    long _6 = 6;\n    long _7 = 7;\n    long _8 = 8;\n    long _9 =\
    \ 9;\n    long _10 = 10;\n    long _11 = 11;\n    long _12 = 12;\n    long _13\
    \ = 13;\n    long _14 = 14;\n    long _15 = 15;\n    long _16 = 16;\n    long\
    \ _17 = 17;\n    long _18 = 18;\n    long _19 = 19;\n    long _20 = 20;\n    long\
    \ _21 = 21;\n    long _22 = 22;\n    long _23 = 23;\n    long _24 = 24;\n    long\
    \ _25 = 25;\n    long _26 = 26;\n    long _27 = 27;\n    long _28 = 28;\n    long\
    \ _29 = 29;\n    long _30 = 30;\n    long _31 = 31;\n    long _32 = 32;\n    long\
    \ _33 = 33;\n    long _34 = 34;\n    long _35 = 35;\n    long _36 = 36;\n    long\
    \ _37 = 37;\n    long _38 = 38;\n    long _39 = 39;\n    long _\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplkyk49_x.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmplkyk49_x.d(102): Error: semicolon expected,
    not `unittest`\n/tmp/tmplkyk49_x.d(102): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplkyk49_x.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_paren = false;\n    bool in_paren_group_close_paren\
    \ = false;\n    bool in_paren_group_open_curly = false;\n    bool in_paren_group_close_curly\
    \ = false;\n    bool in_paren_group_open_angle = false;\n    bool in_paren_group_close_angle\
    \ = false;\n    bool in_paren_group_open_paren_curly = false;\n    bool in_paren_group_close_paren_curly\
    \ = false;\n    bool in_paren_group_open_paren_angle = false;\n    bool in_paren_group_close_paren_angle\
    \ = false;\n    bool in_paren_group_open_curly_curly = false;\n    bool in_paren_group_close_curly_curly\
    \ = false;\n    bool in_paren_group_open_curly_angle = false;\n    bool in_paren_group_close_curly_angle\
    \ = false;\n    bool in_paren_group_open_angle_brace = false;\n    bool in_paren_group_close_angle_brace\
    \ = false;\n    bool in_paren_group_open_angle_brace_curly = false;\n    bool\
    \ in_paren_group_close_angle_brace_curly = false;\n    bool in_paren_group_open_angle_brace_angle\
    \ = false;\n    bool in_paren_group_close_angle_brace_angle = false;\n    bool\
    \ in_paren_group_open_angle_brace_angle_brace = false;\n    bool in_paren_group_close_angle_brace_angle_brace\
    \ = false;\n    bool in_paren_group_open_angle_brace_angle_brace_curly = false;\n\
    \    bool in_paren_group_close_angle_brace_angle_brace_curly = false;\n    bool\
    \ in_paren_group_open_angle_brace_angle_brace_angle = false;\n    bool in_paren_group_close_angle_brace_angle_brace_angle\
    \ = false;\n    bool in_paren_group_open_angle_brace_angle_brace_angle_brace =\
    \ false;\n    bool in_paren_group_close_angle_brace_angle_brace_angle_brace =\
    \ false;\n    bool in_paren_group_open_angle_brace_angle_brace_angle_brace_curly\
    \ = false;\n    bool in_paren_group_close_angle_brace_angle_bra\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr3di7six.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpr3di7six.d(54): Error: semicolon expected,
    not `unittest`\n/tmp/tmpr3di7six.d(54): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3di7six.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long pos = 0;\n    long i = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close = false;\n    bool in_paren_group_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open = false;\n    bool in_paren_group_close_brace_open\
    \ = false;\n    bool in_paren_group_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_close_brace = false;\n    bool in_paren_group_open_brace_open_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace = false;\n    bool\
    \ in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_close_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_close_brace_close_brace_close_brace = false;\n\
    \    bool in_paren_group_open_brace_open_b\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpboyxyox6.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpboyxyox6.d(49): Error: semicolon expected,
    not `unittest`\n/tmp/tmpboyxyox6.d(49): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpboyxyox6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n            levels[i] = level;\n        }\n\
    \        else if(paren_string[i] == ')') {\n            level--;\n           \
    \ levels[i] = level;\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(levels[paren_string[i]] == 0) {\n            max_level =\
    \ max(max_level, level);\n        }\n    }\n    long[] result = new long[max_level\
    \ + 1];\n    for(int i = 0; i < paren_string.length(); i++) {\n        if(levels[paren_string[i]]\
    \ == 0) {\n            result[i] = level;\n        }\n        else {\n       \
    \     result[i] = levels[paren_string[i]];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,parentheses,language-agnostic\
    \ |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2r_577ob.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp2r_577ob.d(43): Error: declaration expected,
    not `<`\n/tmp/tmp2r_577ob.d(48): Error: identifier expected following `package`\n/tmp/tmp2r_577ob.d(48):
    Error: `;` expected\n/tmp/tmp2r_577ob.d(49): Error: identifier expected following
    `package`\n/tmp/tmp2r_577ob.d(49): Error: `;` expected\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2r_577ob.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool has_open = false;\n\
    \    bool has_close = false;\n    bool has_open_brace = false;\n    bool has_close_brace\
    \ = false;\n    bool has_open_brace_or_close_brace = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    bool has_open_brace_or_close_brace_or_close\
    \ = false;\n    bool has_open_brace_or_close_brace_or_close = false;\n    bool\
    \ has_open_brace_or_close_brace_or_close = false;\n    \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyhvawzi1.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpyhvawzi1.d(52): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhvawzi1.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_char = \"()\";\n    string paren_group = \"\";\n    long max_level = 0;\n\
    \    long level = 0;\n    bool in_group = false;\n    bool in_paren = false;\n\
    \    bool in_group2 = false;\n    bool in_paren2 = false;\n    bool in_group3\
    \ = false;\n    bool in_paren3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_paren4 = false;\n    bool in_group5 = false;\n    bool in_paren5 = false;\n\
    \    bool in_group6 = false;\n    bool in_paren6 = false;\n    bool in_group7\
    \ = false;\n    bool in_paren7 = false;\n    bool in_group8 = false;\n    bool\
    \ in_paren8 = false;\n    bool in_group9 = false;\n    bool in_paren9 = false;\n\
    \    bool in_group10 = false;\n    bool in_paren10 = false;\n    bool in_group11\
    \ = false;\n    bool in_paren11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_paren12 = false;\n    bool in_group13 = false;\n    bool in_paren13 = false;\n\
    \    bool in_group14 = false;\n    bool in_paren14 = false;\n    bool in_group15\
    \ = false;\n    bool in_paren15 = false;\n    bool in_group16 = false;\n    bool\
    \ in_paren16 = false;\n    bool in_group17 = false;\n    bool in_paren17 = false;\n\
    \    bool in_group18 = false;\n    bool in_paren18 = false;\n    bool in_group19\
    \ = false;\n    bool in_paren19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_paren20 = false;\n    bool in_group21 = false;\n    bool in_paren21 = false;\n\
    \    bool in_group22 = false;\n    bool in_paren22 = false;\n    bool in_group23\
    \ = false;\n    bool in_paren23 = false;\n    bool in_group24 = false;\n    bool\
    \ in_paren24 = false;\n    bool in_group25 = false;\n    bool in_paren25 = false;\n\
    \    bool in_group26 = false;\n    bool in_paren26 = false;\n    bool in_group27\
    \ = false;\n    bool in_paren27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_paren28 = false;\n    bool in_group29 = false;\n    bool in_paren29 = false;\n\
    \    bool in_group30 = false;\n    bool in_paren30 = false;\n    bool in_group31\
    \ = false;\n    bool in_paren31 = false;\n    bool in_group32 = false;\n    bool\
    \ in_paren32 = false;\n    bool in_group33 = false;\n    bool in_paren33 = false;\n\
    \    bool in_group34 = false;\n    bool in_paren34 = false;\n    bool in_group35\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx2c3yhtj.d(87): Error: semicolon expected, not `unittest`\n/tmp/tmpx2c3yhtj.d(87):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpx2c3yhtj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long paren_index = 0;\n    long paren_level =\
    \ 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    bool paren_found = false;\n    bool paren_found2 = false;\n    bool\
    \ paren_found3 = false;\n    bool paren_found4 = false;\n    bool paren_found5\
    \ = false;\n    bool paren_found6 = false;\n    bool paren_found7 = false;\n \
    \   bool paren_found8 = false;\n    bool paren_found9 = false;\n    bool paren_found10\
    \ = false;\n    bool paren_found11 = false;\n    bool paren_found12 = false;\n\
    \    bool paren_found13 = false;\n    bool paren_found14 = false;\n    bool paren_found15\
    \ = false;\n    bool paren_found16 = false;\n    bool paren_found17 = false;\n\
    \    bool paren_found18 = false;\n    bool paren_found19 = false;\n    bool paren_found20\
    \ = false;\n    bool paren_found21 = false;\n    bool paren_found22 = false;\n\
    \    bool paren_found23 = false;\n    bool paren_found24 = false;\n    bool paren_found25\
    \ = false;\n    bool paren_found26 = false;\n    bool paren_found27 = false;\n\
    \    bool paren_found28 = false;\n    bool paren_found29 = false;\n    bool paren_found30\
    \ = false;\n    bool paren_found31 = false;\n    bool paren_found32 = false;\n\
    \    bool paren_found33 = false;\n    bool paren_found34 = false;\n    bool paren_found35\
    \ = false;\n    bool paren_found36 = false;\n    bool paren_found37 = false;\n\
    \    bool paren_found38 = false;\n    bool paren_found39 = false;\n    bool paren_found40\
    \ = false;\n    bool paren_found41 = false;\n    bool paren_found42 = false;\n\
    \    bool paren_found43 = false;\n    bool paren_found44 = false;\n    bool paren_found45\
    \ = false;\n    bool paren_found46 = false;\n    bool paren_found47 = false;\n\
    \    bool paren_found48 = false;\n    bool paren_found49 = false;\n    bool paren_found50\
    \ = false;\n    bool paren_found51 = false;\n    bool paren_found52 = false;\n\
    \    bool paren_found53 = false;\n    bool paren_found54 = false;\n    bool \n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9_n2g240.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp9_n2g240.d(20): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmp9_n2g240.d(77):
    Error: no identifier for declarator `bool`\n/tmp/tmp9_n2g240.d(77): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_n2g240.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_pos = 0;\n    long pos = 0;\n    long num_parens = 0;\n   \
    \ long num_opens = 0;\n    long num_closes = 0;\n    long num_opens_stack[MAX_LEVELS];\n\
    \    long num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n \
    \   long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n  \
    \  long num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n   \
    \ long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n    long\
    \ num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n    long num_closes_stack_pos\
    \ = 0;\n    long num_opens_stack[MAX_LEVELS];\n    long num_closes_stack[MAX_LEVELS];\n\
    \    long num_opens_stack_pos = 0;\n    long num_closes_stack_pos = 0;\n    long\
    \ num_opens_stack[MAX_LEVELS];\n    long num_closes_stack[MAX_LEVELS];\n    long\
    \ num_opens_stack_pos = 0;\n    long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n\
    \    long num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n \
    \   long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n  \
    \  long num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n   \
    \ long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n    long\
    \ num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n    long num_closes_stack_pos\
    \ = 0;\n    long num_opens_stack[MAX_LEVELS];\n    long num_closes_stack[MAX_LEVELS];\n\
    \    long num_opens_stack_pos = 0;\n    long num_closes_stack_pos = 0;\n    long\
    \ num_opens_stack[MAX_LEVELS];\n    long num_closes_stack[MAX_LEVELS];\n    long\
    \ num_opens_stack_pos = 0;\n    long num_closes_stack_pos = 0;\n    long num_opens_stack[MAX_LEVELS];\n\
    \    long num_closes_stack[MAX_LEVELS];\n    long num_opens_stack_pos = 0;\n \
    \   long num_closes_stack_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp51usgybk.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmp51usgybk.d(22): Deprecation:
    instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(26):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(27):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(30):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(31):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(34):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(35):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(38):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(39):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(42):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(43):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(46):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(47):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d(50):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_opens_stack`\n/tmp/tmp51usgybk.d(51):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_LEVELS] num_closes_stack`\n/tmp/tmp51usgybk.d('
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool has_parens\
    \ = false;\n    bool has_space = false;\n    bool has_spaces = false;\n    bool\
    \ has_spaces_after_parens = false;\n    bool has_spaces_before_parens = false;\n\
    \    bool has_spaces_after_spaces = false;\n    bool has_spaces_before_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_parens = false;\n    bool has_spaces_before_spaces_before_parens\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces = false;\n    bool has_spaces_before_spaces_before_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_parens = false;\n\
    \    bool has_spaces_before_spaces_before_spaces_before_parens = false;\n    bool\
    \ has_spaces_after_spaces_after_spaces_after_spaces = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_parens\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_parens\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_spaces\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_parens\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_parens\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_parens\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_parens\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_parens\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_parens\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_parens\
    \ = false;\n    bool has_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_spaces_before_parens\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp61_nnmtc.d(43): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp61_nnmtc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly = false;\n\
    \    bool is_closing_curly = false;\n    bool is_opening_square = false;\n   \
    \ bool is_closing_square = false;\n    bool is_opening_curly_square = false;\n\
    \    bool is_closing_curly_square = false;\n    bool is_opening_paren_curly =\
    \ false;\n    bool is_closing_paren_curly = false;\n    bool is_opening_paren_square\
    \ = false;\n    bool is_closing_paren_square = false;\n    bool is_opening_curly_paren\
    \ = false;\n    bool is_closing_curly_paren = false;\n    bool is_opening_curly_curly\
    \ = false;\n    bool is_closing_curly_curly = false;\n    bool is_opening_square_curly\
    \ = false;\n    bool is_closing_square_curly = false;\n    bool is_opening_paren_curly_square\
    \ = false;\n    bool is_closing_paren_curly_square = false;\n    bool is_opening_paren_square_curly\
    \ = false;\n    bool is_closing_paren_square_curly = false;\n    bool is_opening_curly_curly_square\
    \ = false;\n    bool is_closing_curly_curly_square = false;\n    bool is_opening_square_curly_square\
    \ = false;\n    bool is_closing_square_curly_square = false;\n    bool is_opening_paren_curly_curly_square\
    \ = false;\n    bool is_closing_paren_curly_curly_square = false;\n    bool is_opening_paren_square_curly_square\
    \ = false;\n    bool is_closing_paren_square_curly_square = false;\n    bool is_opening_curly_curly_curly_square\
    \ = false;\n    bool is_closing_curly_curly_curly_square = false;\n    bool is_opening_square_curly_curly_square\
    \ = false;\n    bool is_closing_square_curly_curly_square = false;\n    bool is_opening_paren_curly_curly_curly_square\
    \ = false;\n    bool is_closing_paren_curly_curly_curly_square = false;\n    bool\
    \ is_opening_paren_square_curly_curly_square = false;\n    bool is_closing_paren_square_curly_curly_square\
    \ = false;\n    bool is_opening_curly_curly_curly_curly_square = false;\n    bool\
    \ \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpitt0gppo.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpitt0gppo.d(62): Error: no identifier for
    declarator `bool`\n/tmp/tmpitt0gppo.d(62): Error: found `unittest` instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitt0gppo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprzgwqdd3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmprzgwqdd3.d(85): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzgwqdd3.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i] == '(')\
    \ {\n            level++;\n        } else if(paren_string[i] == ')') {\n     \
    \       level--;\n        }\n        levels[i] = level;\n    }\n    return levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpohlzk9il.d(14): Error: no property `length` for type `string`\n/tmp/tmpohlzk9il.d(16):
    Error: no property `length` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpohlzk9il.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long current_level = 0;\n    long current_index = 0;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgowkhdn6.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpgowkhdn6.d(64): Error: semicolon expected,
    not `unittest`\n/tmp/tmpgowkhdn6.d(64): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgowkhdn6.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpztiyaih3.d(85): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztiyaih3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_current\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max = 0;\n    long paren_level_count_current_min\
    \ = 0;\n    long paren_level_count_current_max\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8crmesm9.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmp8crmesm9.d(67):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp8crmesm9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool paren_open = false;\n    bool paren_closed = false;\n\
    \    bool paren_open_brace = false;\n    bool paren_closed_brace = false;\n  \
    \  bool paren_open_square = false;\n    bool paren_closed_square = false;\n  \
    \  bool paren_open_bracket = false;\n    bool paren_closed_bracket = false;\n\
    \    bool paren_open_bracket_brace = false;\n    bool paren_closed_bracket_brace\
    \ = false;\n    bool paren_open_bracket_square = false;\n    bool paren_closed_bracket_square\
    \ = false;\n    bool paren_open_bracket_bracket = false;\n    bool paren_closed_bracket_bracket\
    \ = false;\n    bool paren_open_bracket_bracket_brace = false;\n    bool paren_closed_bracket_bracket_brace\
    \ = false;\n    bool paren_open_bracket_bracket_square = false;\n    bool paren_closed_bracket_bracket_square\
    \ = false;\n    bool paren_open_bracket_bracket_bracket = false;\n    bool paren_closed_bracket_bracket_bracket\
    \ = false;\n    bool paren_open_bracket_bracket_bracket_square = false;\n    bool\
    \ paren_closed_bracket_bracket_bracket_square = false;\n    bool paren_open_bracket_bracket_bracket_bracket\
    \ = false;\n    bool paren_closed_bracket_bracket_bracket_bracket = false;\n \
    \   bool paren_open_bracket_bracket_bracket_bracket_brace = false;\n    bool paren_closed_bracket_bracket_bracket_bracket_brace\
    \ = false;\n    bool paren_open_bracket_bracket_bracket_bracket_square = false;\n\
    \    bool paren_closed_bracket_bracket_bracket_bracket_square = false;\n    bool\
    \ paren_open_bracket_bracket_bracket_bracket_bracket = false;\n    bool paren_closed_bracket_bracket_bracket_bracket_bracket\
    \ = false;\n    bool paren_open_bracket_bracket_bracket_bracket_bracket_square\
    \ = false;\n    bool paren_closed_bracket_bracket_bracket_bracket_bracket_square\
    \ = false;\n    bool paren_open_bracket_bracket_bracket_bracket_\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdcmqxym4.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpdcmqxym4.d(51): Error: semicolon expected,
    not `unittest`\n/tmp/tmpdcmqxym4.d(51): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdcmqxym4.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_close =\
    \ false;\n    bool in_group_close_brace_close = false;\n    bool in_group_open_brace_open\
    \ = false;\n    bool in_group_close_brace_open = false;\n    bool in_group_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace\
    \ = false;\n    bool in_group_close_brace_open_brace = false;\n    bool in_group_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close = false;\n    bool in_group_close_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace = false;\n \
    \   bool in_group_open_brace_open_brace_close_brace_close = false;\n    bool in_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close = false;\n\
    \    bool in_group_open_brace_open_brace_close_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_open_brace_close_brace_close_brace = false;\n   \
    \ bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmi_3sh7m.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpmi_3sh7m.d(50): Error: semicolon expected,
    not `unittest`\n/tmp/tmpmi_3sh7m.d(50): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmi_3sh7m.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    bool is_open = false;\n\
    \    bool is_close = false;\n    bool is_open2 = false;\n    bool is_close2 =\
    \ false;\n    bool is_open3 = false;\n    bool is_close3 = false;\n    bool is_open4\
    \ = false;\n    bool is_close4 = false;\n    bool is_open5 = false;\n    bool\
    \ is_close5 = false;\n    bool is_open6 = false;\n    bool is_close6 = false;\n\
    \    bool is_open7 = false;\n    bool is_close7 = false;\n    bool is_open8 =\
    \ false;\n    bool is_close8 = false;\n    bool is_open9 = false;\n    bool is_close9\
    \ = false;\n    bool is_open10 = false;\n    bool is_close10 = false;\n    bool\
    \ is_open11 = false;\n    bool is_close11 = false;\n    bool is_open12 = false;\n\
    \    bool is_close12 = false;\n    bool is_open13 = false;\n    bool is_close13\
    \ = false;\n    bool is_open14 = false;\n    bool is_close14 = false;\n    bool\
    \ is_open15 = false;\n    bool is_close15 = false;\n    bool is_open16 = false;\n\
    \    bool is_close16 = false;\n    bool is_open17 = false;\n    bool is_close17\
    \ = false;\n    bool is_open18 = false;\n    bool is_close18 = false;\n    bool\
    \ is_open19 = false;\n    bool is_close19 = false;\n    bool is_open20 = false;\n\
    \    bool is_close20 = false;\n    bool is_open21 = false;\n    bool is_close21\
    \ = false;\n    bool is_open22 = false;\n    bool is_close22 = false;\n    bool\
    \ is_open23 = false;\n    bool is_close23 = false;\n    bool is_open24 = false;\n\
    \    bool is_close24 = false;\n    bool is_open25 = false;\n    bool is_close25\
    \ = false;\n    bool is_open26 = false;\n    bool is_close26 = false;\n    bool\
    \ is_open27 = false;\n    bool is_close27 = false;\n    bool is_open28 = false;\n\
    \    bool is_close28 = false;\n    bool is_open29 = false;\n    bool is_close29\
    \ = false;\n    bool is_open30 = false;\n    bool is_close30 = false;\n    bool\
    \ is_open31 = false;\n    bool is_close31 = false;\n    bool is_open32 = false;\n\
    \    bool is_close32 = false;\n    bool is_open33 = false;\n    bool is_close33\
    \ = false;\n    bool is_open34 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp11i8qj36.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp11i8qj36.d(87): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11i8qj36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_group = 0;\n    long\
    \ level_group = 0;\n    long max_level_group_len = 0;\n    long level_group_len\
    \ = 0;\n    bool has_group = false;\n    bool has_group_len = false;\n    bool\
    \ has_group_len2 = false;\n    bool has_group_len3 = false;\n    bool has_group_len4\
    \ = false;\n    bool has_group_len5 = false;\n    bool has_group_len6 = false;\n\
    \    bool has_group_len7 = false;\n    bool has_group_len8 = false;\n    bool\
    \ has_group_len9 = false;\n    bool has_group_len10 = false;\n    bool has_group_len11\
    \ = false;\n    bool has_group_len12 = false;\n    bool has_group_len13 = false;\n\
    \    bool has_group_len14 = false;\n    bool has_group_len15 = false;\n    bool\
    \ has_group_len16 = false;\n    bool has_group_len17 = false;\n    bool has_group_len18\
    \ = false;\n    bool has_group_len19 = false;\n    bool has_group_len20 = false;\n\
    \    bool has_group_len21 = false;\n    bool has_group_len22 = false;\n    bool\
    \ has_group_len23 = false;\n    bool has_group_len24 = false;\n    bool has_group_len25\
    \ = false;\n    bool has_group_len26 = false;\n    bool has_group_len27 = false;\n\
    \    bool has_group_len28 = false;\n    bool has_group_len29 = false;\n    bool\
    \ has_group_len30 = false;\n    bool has_group_len31 = false;\n    bool has_group_len32\
    \ = false;\n    bool has_group_len33 = false;\n    bool has_group_len34 = false;\n\
    \    bool has_group_len35 = false;\n    bool has_group_len36 = false;\n    bool\
    \ has_group_len37 = false;\n    bool has_group_len38 = false;\n    bool has_group_len39\
    \ = false;\n    bool has_group_len40 = false;\n    bool has_group_len41 = false;\n\
    \    bool has_group_len42 = false;\n    bool has_group_len43 = false;\n    bool\
    \ has_group_len44 = false;\n    bool has_group_len45 = false;\n    bool has_group_len46\
    \ = false;\n    bool has_group_len47 = false;\n    bool has_group_len48 = false;\n\
    \    bool has_group_len49 = false;\n    bool has_group_len50 = false;\n    bool\
    \ has_group_len51 = false;\n    bool has_group_len52 = false;\n    bool has_group_len53\
    \ = false;\n    bool has_group_len54 = false;\n    bool has_group_len55 = false;\n\
    \    bool has_group_len56 = false;\n    bool has_group_len57 = false;\n\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7v_otgy1.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7v_otgy1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long index = 0;\n    bool in_paren = false;\n\
    \    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n   \
    \ bool in_paren_group_close = false;\n    bool in_paren_group_open_brace = false;\n\
    \    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace = false;\n\
    \    bool in_paren_group_close_brace_open_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close_brace_close\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmponcycibj.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmponcycibj.d(47): Error: semicolon expected,
    not `unittest`\n/tmp/tmponcycibj.d(47): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponcycibj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening = false;\n    bool is_closing\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing = false;\n    bool is_closing_paren_or_opening\
    \ = false;\n    bool is_opening_paren_or_closing_paren = false;\n    bool is_closing_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening = false;\n \
    \   bool is_closing_paren_or_opening_paren_or_closing = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsvo6ri9l.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpsvo6ri9l.d(44): Error: semicolon expected,
    not `unittest`\n/tmp/tmpsvo6ri9l.d(44): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsvo6ri9l.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n        } else if(c == ')') {\n\
    \            level--;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution works well for\
    \ me. Thanks.\n<|/ c |>\n<| a tags=string,algorithm,c# |>\nI wrote a recursive\
    \ solution that doesn't use any loops or recursion. \n<code>\npublic int GetMaxNestingLevel(string\
    \ input)\n{\n    if (input.Length == 0)\n        return 0;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpis02doit.d(27): Error: declaration expected, not `<`\n/tmp/tmpis02doit.d(33):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpis02doit.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n \
    \   bool in_brace = false;\n    bool in_curly_bracket = false;\n    bool in_curly_brace\
    \ = false;\n    bool in_square_bracket = false;\n    bool in_square_brace = false;\n\
    \    bool in_curly_square_bracket = false;\n    bool in_curly_square_brace = false;\n\
    \    bool in_square_curly_bracket = false;\n    bool in_square_curly_brace = false;\n\
    \    bool in_curly_square_curly_bracket = false;\n    bool in_curly_square_curly_brace\
    \ = false;\n    bool in_curly_square_curly_square_bracket = false;\n    bool in_curly_square_curly_square_brace\
    \ = false;\n    bool in_curly_square_curly_square_curly_bracket = false;\n   \
    \ bool in_curly_square_curly_square_curly_brace = false;\n    bool in_curly_square_curly_square_curly_square_bracket\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_brace = false;\n\
    \    bool in_curly_square_curly_square_curly_square_curly_bracket = false;\n \
    \   bool in_curly_square_curly_square_curly_square_curly_brace = false;\n    bool\
    \ in_curly_square_curly_square_curly_square_curly_square_bracket = false;\n  \
    \  bool in_curly_square_curly_square_curly_square_curly_square_brace = false;\n\
    \    bool in_curly_square_curly_square_curly_square_curly_square_curly_bracket\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_brace\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_square_bracket\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_square_brace\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_square_curly_bracket\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_square_curly_brace\
    \ = false;\n    bool in_curly_square_curly_square_curly_square_curly_square_curly_square_curly_square\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9pbhkxeg.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp9pbhkxeg.d(48): Error: semicolon expected,
    not `unittest`\n/tmp/tmp9pbhkxeg.d(48): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9pbhkxeg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_size = 0;\n    long\
    \ level_size = 0;\n    long level_index = 0;\n    long level_index2 = 0;\n   \
    \ long level_index3 = 0;\n    long level_index4 = 0;\n    long level_index5 =\
    \ 0;\n    long level_index6 = 0;\n    long level_index7 = 0;\n    long level_index8\
    \ = 0;\n    long level_index9 = 0;\n    long level_index10 = 0;\n    long level_index11\
    \ = 0;\n    long level_index12 = 0;\n    long level_index13 = 0;\n    long level_index14\
    \ = 0;\n    long level_index15 = 0;\n    long level_index16 = 0;\n    long level_index17\
    \ = 0;\n    long level_index18 = 0;\n    long level_index19 = 0;\n    long level_index20\
    \ = 0;\n    long level_index21 = 0;\n    long level_index22 = 0;\n    long level_index23\
    \ = 0;\n    long level_index24 = 0;\n    long level_index25 = 0;\n    long level_index26\
    \ = 0;\n    long level_index27 = 0;\n    long level_index28 = 0;\n    long level_index29\
    \ = 0;\n    long level_index30 = 0;\n    long level_index31 = 0;\n    long level_index32\
    \ = 0;\n    long level_index33 = 0;\n    long level_index34 = 0;\n    long level_index35\
    \ = 0;\n    long level_index36 = 0;\n    long level_index37 = 0;\n    long level_index38\
    \ = 0;\n    long level_index39 = 0;\n    long level_index40 = 0;\n    long level_index41\
    \ = 0;\n    long level_index42 = 0;\n    long level_index43 = 0;\n    long level_index44\
    \ = 0;\n    long level_index45 = 0;\n    long level_index46 = 0;\n    long level_index47\
    \ = 0;\n    long level_index48 = 0;\n    long level_index49 = 0;\n    long level_index50\
    \ = 0;\n    long level_index51 = 0;\n    long level_index52 = 0;\n    long level_index53\
    \ = 0;\n    long level_index54 = 0;\n    long level_index55 = 0;\n    long level_index56\
    \ = 0;\n    long level_index57 = 0;\n    long level_index58 = 0;\n    long level_index59\
    \ = 0;\n    long level_index60 = 0;\n    long level_index61 = 0;\n    long level_index62\
    \ = 0;\n    long level_index63 = 0;\n    long level_index64 = 0;\n    long level_index65\
    \ = 0;\n    long level_index66 = 0;\n    long level_index67 = 0;\n    long level_index68\
    \ = 0;\n    long level_index69 = 0;\n    long level_index70 = 0;\n    \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8no_y2q.d(89): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8no_y2q.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    long current_level_length = 0;\n    long current_level_start\
    \ = 0;\n    long current_level_end = 0;\n    bool is_first = true;\n    bool is_last\
    \ = true;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_in_paren = false;\n    bool is_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_opening_paren_or_opening_paren = false;\n    bool\
    \ is_opening_paren_or_opening_paren_or_opening_paren_or_closing = false;\n   \
    \ bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren = false;\n\
    \    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkch2zuw0.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpkch2zuw0.d(43): Error: semicolon expected,
    not `unittest`\n/tmp/tmpkch2zuw0.d(43): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkch2zuw0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_paren_or_curly = false;\n    bool\
    \ has_close_paren_or_curly = false;\n    bool has_open_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_cur\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0s6xghtq.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmp0s6xghtq.d(49):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0s6xghtq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    long j = 0;\n    bool has_paren = false;\n    bool has_space\
    \ = false;\n    bool has_spaces = false;\n    bool has_spaces_after_paren = false;\n\
    \    bool has_spaces_after_space = false;\n    bool has_spaces_after_spaces =\
    \ false;\n    bool has_spaces_after_spaces_after_paren = false;\n    bool has_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces = false;\n    bool has_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_spaces = false;\n    bool\
    \ has_spaces_after_spaces_after_spaces_after_spaces_after_paren = false;\n   \
    \ bool has_spaces_after_spaces_after_spaces_after_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_spaces_after_space = false;\n\
    \    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_space\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_paren\
    \ = false;\n    bool has_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_after_spaces_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps78u76wt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmps78u76wt.d(46): Error: semicolon expected,
    not `unittest`\n/tmp/tmps78u76wt.d(46): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps78u76wt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_cur\
    \ = 0;\n    long parens_level_max2 = 0;\n    long parens_level_cur2 = 0;\n   \
    \ long parens_level_max3 = 0;\n    long parens_level_cur3 = 0;\n    long parens_level_max4\
    \ = 0;\n    long parens_level_cur4 = 0;\n    long parens_level_max5 = 0;\n   \
    \ long parens_level_cur5 = 0;\n    long parens_level_max6 = 0;\n    long parens_level_cur6\
    \ = 0;\n    long parens_level_max7 = 0;\n    long parens_level_cur7 = 0;\n   \
    \ long parens_level_max8 = 0;\n    long parens_level_cur8 = 0;\n    long parens_level_max9\
    \ = 0;\n    long parens_level_cur9 = 0;\n    long parens_level_max10 = 0;\n  \
    \  long parens_level_cur10 = 0;\n    long parens_level_max11 = 0;\n    long parens_level_cur11\
    \ = 0;\n    long parens_level_max12 = 0;\n    long parens_level_cur12 = 0;\n \
    \   long parens_level_max13 = 0;\n    long parens_level_cur13 = 0;\n    long parens_level_max14\
    \ = 0;\n    long parens_level_cur14 = 0;\n    long parens_level_max15 = 0;\n \
    \   long parens_level_cur15 = 0;\n    long parens_level_max16 = 0;\n    long parens_level_cur16\
    \ = 0;\n    long parens_level_max17 = 0;\n    long parens_level_cur17 = 0;\n \
    \   long parens_level_max18 = 0;\n    long parens_level_cur18 = 0;\n    long parens_level_max19\
    \ = 0;\n    long parens_level_cur19 = 0;\n    long parens_level_max20 = 0;\n \
    \   long parens_level_cur20 = 0;\n    long parens_level_max21 = 0;\n    long parens_level_cur21\
    \ = 0;\n    long parens_level_max22 = 0;\n    long parens_level_cur22 = 0;\n \
    \   long parens_level_max23 = 0;\n    long parens_level_cur23 = 0;\n    long parens_level_max24\
    \ = 0;\n    long parens_level_cur24 = 0;\n    long parens_level_max25 = 0;\n \
    \   long parens_level_cur25 = 0;\n    long parens_level_max26 = 0;\n    long parens_level_cur26\
    \ = 0;\n    long parens_level_max27 = 0;\n    long parens_level_cur27 = 0;\n \
    \   long parens_level_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprm06znwm.d(73): Error: semicolon expected, not `unittest`\n/tmp/tmprm06znwm.d(73):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprm06znwm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] levels = new long[paren_groups.length()];\n\
    \    long[] max_levels = new long[paren_groups.length()];\n    long[] current_levels\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels = new long[paren_groups.length()];\n\
    \    long[] current_levels_index = new long[paren_groups.length()];\n    long[]\
    \ current_max_levels_index = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    long[] current_max_levels_index_in_parens_index_in_parens_index_in_parens_index_in_parens_index\
    \ = new long[paren_groups.length()];\n    \nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqhsbjcc1.d(38): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhsbjcc1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_size\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_size = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_size = 0;\n    long paren_level_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_size = 0;\n    long paren_level_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_size = 0;\n    long paren_level_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_size = 0;\n    long\
    \ paren_level_counter_counter_counter_counter_counter = 0;\n    long paren_level_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter =\
    \ 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_size\
    \ = 0;\n    long paren_level_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7pkfgguh.d(49): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7pkfgguh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_prev =\
    \ 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph97orqcx.d(46): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph97orqcx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_quote = false;\n    bool in_escape\
    \ = false;\n    bool in_double_quote = false;\n    bool in_single_quote = false;\n\
    \    bool in_double_escape = false;\n    bool in_single_escape = false;\n    bool\
    \ in_double_paren = false;\n    bool in_single_paren = false;\n    bool in_double_backslash\
    \ = false;\n    bool in_single_backslash = false;\n    bool in_double_double_quote\
    \ = false;\n    bool in_single_double_quote = false;\n    bool in_double_single_quote\
    \ = false;\n    bool in_double_backslash = false;\n    bool in_single_backslash\
    \ = false;\n    bool in_double_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_double_single_backslash\
    \ = false;\n    bool in_double_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_double_double_backslash\
    \ = false;\n    bool in_single_double_backslash = false;\n    bool in_single_single_backslash\
    \ = false;\n    bool in_single_single_backslash = false;\n    bool in_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_swrdgql.d(75): Error: semicolon expected, not `unittest`\n/tmp/tmp_swrdgql.d(75):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_swrdgql.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_pos = -1;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_or_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma = false;\n\
    \    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace = false;\n \
    \   bool in_paren_group_close_brace_or_comma_brace_or_comma_brace = false;\n \
    \   bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcezxjx9v.d(42): Error: semicolon expected, not `unittest`\n/tmp/tmpcezxjx9v.d(42):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpcezxjx9v.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long levels_index = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren\
    \ = false;\n    bool is_opening_curly = false;\n    bool is_closing_curly = false;\n\
    \    bool is_opening_square = false;\n    bool is_closing_square = false;\n  \
    \  bool is_opening_angle = false;\n    bool is_closing_angle = false;\n    bool\
    \ is_opening_comma = false;\n    bool is_closing_comma = false;\n    bool is_opening_colon\
    \ = false;\n    bool is_closing_colon = false;\n    bool is_opening_semicolon\
    \ = false;\n    bool is_closing_semicolon = false;\n    bool is_opening_paren_or_curly\
    \ = false;\n    bool is_closing_paren_or_curly = false;\n    bool is_opening_paren_or_angle\
    \ = false;\n    bool is_closing_paren_or_angle = false;\n    bool is_opening_paren_or_comma\
    \ = false;\n    bool is_closing_paren_or_comma = false;\n    bool is_opening_paren_or_colon\
    \ = false;\n    bool is_closing_paren_or_colon = false;\n    bool is_opening_paren_or_semicolon\
    \ = false;\n    bool is_closing_paren_or_semicolon = false;\n    bool is_opening_curly_or_angle\
    \ = false;\n    bool is_closing_curly_or_angle = false;\n    bool is_opening_curly_or_comma\
    \ = false;\n    bool is_closing_curly_or_comma = false;\n    bool is_opening_curly_or_colon\
    \ = false;\n    bool is_closing_curly_or_colon = false;\n    bool is_opening_curly_or_semicolon\
    \ = false;\n    bool is_closing_curly_or_semicolon = false;\n    bool is_opening_square_or_angle\
    \ = false;\n    bool is_closing_square_or_angle = false;\n    bool is_opening_square_or_comma\
    \ = false;\n    bool is_closing_square_or_comma = false;\n    bool is_opening_square_or_colon\
    \ = false;\n    bool is_closing_square_or_colon = false;\n    bool is_opening_square_or_semicolon\
    \ = false;\n    bool is_closing_square_or_semicolon = false;\n    bool is_opening_angle_or_comma\
    \ = false;\n    bool is_closing_angle_or_comma = false;\n    bool is_opening_angle_or_colon\
    \ = false;\n    bool is_closing_angle_or_colon = false;\n    bool is_opening_angle_or_semicolon\
    \ = false;\n    bool is_closing_angle_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpasuksiqb.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpasuksiqb.d(67): Error: semicolon expected,
    not `unittest`\n/tmp/tmpasuksiqb.d(67): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasuksiqb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    bool inside_paren = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            paren_stack.push(i);\n            inside_paren = true;\n  \
    \      }\n        else if(c == ')')\n        {\n            int paren_start =\
    \ paren_stack.top();\n            int paren_end = i;\n            while(paren_stack.top()\
    \ > paren_end)\n            {\n                paren_stack.pop();\n          \
    \  }\n            long paren_count = paren_stack.size();\n            if(paren_count\
    \ > result[paren_start])\n            {\n                result[paren_start] =\
    \ paren_count;\n            }\n            inside_paren = false;\n        }\n\
    \        else if(!inside_paren)\n        {\n            result[i] = 1;\n     \
    \   }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. Try it on \"((()))\" for example. It returns [1L, 1L, 1L, 1L]\
    \ instead of [1L, 3L, 1L, 3L].\n<|/ c |>\n<| c |>\nI tested it on \"((()))\" and\
    \ the result is [1L, 3L, 1L, 3L]\n<|/ c |>\n<| c |>\nI tested it on \"((()))\"\
    \ and the result is [1L, 3L, 1L, 3L]\n<|/ c |>\n<| c |>\nI tested it on \"((()))\"\
    \ and the result is [1L, 3L, 1L, 3L]\n<|/ c |>\n<| c |>\nI tested it on \"((()))\"\
    \ and the result is [1L, 3L, 1L, 3L]\n<|/ c |>\n<| a dscore=0 |>\nI wrote a recursive\
    \ solution in Java:\n<code>\nimport java.util.ArrayList;\nimport java.util.List;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp37f5fx6x.d(15): Error: found `>` when expecting `.` following
    int\n/tmp/tmp37f5fx6x.d(15): Error: found `>` when expecting `.` following int\n/tmp/tmp37f5fx6x.d(15):
    Error: found `(` when expecting identifier following `int`.\n/tmp/tmp37f5fx6x.d(15):
    Error: found `)` when expecting `;` following statement\n/tmp/tmp37f5fx6x.d(15):
    Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp37f5fx6x.d(47):
    Error: declaration expected, not `<`\n/tmp/tmp37f5fx6x.d(50): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37f5fx6x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \    }\n    return levels;\n}\n</code>\n<|/ a tags=algorithm,parentheses,c# |>\n\
    <| c |>\nThis doesn't work for nested parentheses such as `((()))`\n<|/ c |>\n\
    <| c |>\nYes, it doesn't. I've added a solution that does.\n<|/ c |>\n<| c |>\n\
    This doesn't work for nested parentheses such as `((()))`\n<|/ c |>\n<| c |>\n\
    It does work. I've added a solution that does.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work for nested parentheses such as `((()))`\n<|/ c |>\n<| a tags=algorithm,parentheses,c#\
    \ |>\n<code>\npublic int GetMaxLevels(string input)\n{\n    Stack<char> stack\
    \ = new Stack<char>();\n    int maxLevel = 0;\n    foreach (char c in input)\n\
    \    {\n        if (c == '(')\n        {\n            stack.Push(c);\n       \
    \ }\n        else if (c == ')')\n        {\n            while (stack.Count > 0)\n\
    \            {\n                if (stack.Pop() == '(')\n                {\n \
    \                   maxLevel++;\n                }\n            }\n        }\n\
    \    }\n    return maxLevel;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n\
    <code>\npublic int GetMaxLevels(string input)\n{\n    int maxLevel = 0;\n    Stack<char>\
    \ stack = new Stack<char>();\n    foreach (char c in input)\n    {\n        if\
    \ (c == '(')\n        {\n            stack.Push(c);\n        }\n        else if\
    \ (c == ')')\n        {\n            while (stack.Count > 0)\n            {\n\
    \                if (stack.Pop() == '(')\n                {\n                \
    \    maxLevel++;\n                }\n            }\n        }\n    }\n    return\
    \ maxLevel;\n}\n</code>\n<|/ a tags=algorithm,parentheses,c# |>\n<| a tags=algorithm,parentheses,c#\
    \ |>\n<code>\npublic int GetMaxLevels(string input)\n{\n    int maxLevel = 0;\n\
    \    Stack<char> stack = new Stack<char>();\n    foreach (char c in input)\n \
    \   {\n        if (c == '(')\n        {\n            stack.Push(c);\n        }\n\
    \        else if (c == ')')\n        {\n            while (stack.Count \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9v2f74kk.d(30): Error: declaration expected, not `<`\n/tmp/tmp9v2f74kk.d(33):
    Error: unterminated character constant\n/tmp/tmp9v2f74kk.d(36): Error: unterminated
    character constant\n/tmp/tmp9v2f74kk.d(36): Error: unterminated character constant\n/tmp/tmp9v2f74kk.d(39):
    Error: unterminated character constant\n/tmp/tmp9v2f74kk.d(42): Error: unterminated
    character constant\n/tmp/tmp9v2f74kk.d(45): Error: unterminated character constant\n/tmp/tmp9v2f74kk.d(53):
    Error: declaration expected, not `foreach`\n/tmp/tmp9v2f74kk.d(58): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9v2f74kk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_index = 0;\n    long level_stack_pointer = 0;\n    bool has_paren\
    \ = false;\n    bool has_left_paren = false;\n    bool has_right_paren = false;\n\
    \    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket =\
    \ false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket\
    \ = false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket\
    \ = false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket\
    \ = false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket\
    \ = false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool has_right_curly_bracket\
    \ = false;\n    bool has_left_square_bracket = false;\n    bool has_right_square_bracket\
    \ = false;\n    bool has_left_curly_brace = false;\n    bool has_right_curly_brace\
    \ = false;\n    bool has_left_square_brace = false;\n    bool has_right_square_brace\
    \ = false;\n    bool has_left_curly_bracket = false;\n    bool \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0k386eqj.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmp0k386eqj.d(72): Error:
    no identifier for declarator `bool`\n/tmp/tmp0k386eqj.d(72): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0k386eqj.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_paren_group = false;\n\
    \    bool in_paren_group_open = false;\n    bool in_paren_group_close = false;\n\
    \    bool in_paren_group_opener = false;\n    bool in_paren_group_closer = false;\n\
    \    bool in_paren_group_opener_close = false;\n    bool in_paren_group_closer_close\
    \ = false;\n    bool in_paren_group_opener_open = false;\n    bool in_paren_group_closer_open\
    \ = false;\n    bool in_paren_group_opener_closer_open = false;\n    bool in_paren_group_closer_closer\
    \ = false;\n    bool in_paren_group_opener_closer_closer = false;\n    bool in_paren_group_opener_closer_opener\
    \ = false;\n    bool in_paren_group_closer_opener = false;\n    bool in_paren_group_opener_closer_closer_opener\
    \ = false;\n    bool in_paren_group_closer_opener_open = false;\n    bool in_paren_group_closer_closer_closer\
    \ = false;\n    bool in_paren_group_opener_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_opener = false;\n    bool in_paren_group_closer_opener_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_opener = false;\n    bool in_paren_group_closer_opener_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer = false;\n    bool in_paren_group_closer_opener_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer = false;\n    bool in_paren_group_closer_opener_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer = false;\n    bool in_paren_group_closer_opener_open\
    \ = false;\n    bool in_paren_group_closer_closer_closer_closer = false;\n   \
    \ bool in_paren_group_opener_closer_closer_closer_closer = false;\n    bool in_paren_group_closer_opener_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppq1azig_.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmppq1azig_.d(54): Error: semicolon expected,
    not `unittest`\n/tmp/tmppq1azig_.d(54): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppq1azig_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] current_levels = new long[paren_string.length()];\n\
    \    long[] current_levels_size = new long[paren_string.length()];\n    long current_level\
    \ = 0;\n    long current_level_size = 1;\n    long current_level_max = 1;\n  \
    \  long current_level_max_size = 1;\n    long current_level_max_index = 0;\n \
    \   long current_level_max_index2 = 0;\n    long current_level_max_index3 = 0;\n\
    \    long current_level_max_index4 = 0;\n    long current_level_max_index5 = 0;\n\
    \    long current_level_max_index6 = 0;\n    long current_level_max_index7 = 0;\n\
    \    long current_level_max_index8 = 0;\n    long current_level_max_index9 = 0;\n\
    \    long current_level_max_index10 = 0;\n    long current_level_max_index11 =\
    \ 0;\n    long current_level_max_index12 = 0;\n    long current_level_max_index13\
    \ = 0;\n    long current_level_max_index14 = 0;\n    long current_level_max_index15\
    \ = 0;\n    long current_level_max_index16 = 0;\n    long current_level_max_index17\
    \ = 0;\n    long current_level_max_index18 = 0;\n    long current_level_max_index19\
    \ = 0;\n    long current_level_max_index20 = 0;\n    long current_level_max_index21\
    \ = 0;\n    long current_level_max_index22 = 0;\n    long current_level_max_index23\
    \ = 0;\n    long current_level_max_index24 = 0;\n    long current_level_max_index25\
    \ = 0;\n    long current_level_max_index26 = 0;\n    long current_level_max_index27\
    \ = 0;\n    long current_level_max_index28 = 0;\n    long current_level_max_index29\
    \ = 0;\n    long current_level_max_index30 = 0;\n    long current_level_max_index31\
    \ = 0;\n    long current_level_max_index32 = 0;\n    long current_level_max_index33\
    \ = 0;\n    long current_level_max_index34 = 0;\n    long current_level_max_index35\
    \ = 0;\n    long current_level_max_index36 = 0;\n    long current_level_max_index37\
    \ = 0;\n    long current_level_max_index38 = 0;\n    long current_level_max_index39\
    \ = 0;\n    long current_level_max_index40 = 0;\n    long current_level_max_index41\
    \ = 0;\n    long current_level_max_index42 = 0;\n    long current_level_max_index43\
    \ = 0;\n    long current_level_max_index44 = 0;\n    long current_level_max_index45\
    \ = 0;\n    long current_level_max_index46 = 0;\n    long current_level_max_index47\
    \ = 0;\n    long current_level_max_index48 = 0;\n    long current_level_max_index49\
    \ = 0;\n    long current_level_max_index\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1c_thdtt.d(71): Error: semicolon expected, not `unittest`\n/tmp/tmp1c_thdtt.d(71):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1c_thdtt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long level_counters[] = new long[paren_string.length()];\n\
    \    long level_counters_index = 0;\n    long level_counters_index2 = 0;\n   \
    \ long level_counters_index3 = 0;\n    long level_counters_index4 = 0;\n    long\
    \ level_counters_index5 = 0;\n    long level_counters_index6 = 0;\n    long level_counters_index7\
    \ = 0;\n    long level_counters_index8 = 0;\n    long level_counters_index9 =\
    \ 0;\n    long level_counters_index10 = 0;\n    long level_counters_index11 =\
    \ 0;\n    long level_counters_index12 = 0;\n    long level_counters_index13 =\
    \ 0;\n    long level_counters_index14 = 0;\n    long level_counters_index15 =\
    \ 0;\n    long level_counters_index16 = 0;\n    long level_counters_index17 =\
    \ 0;\n    long level_counters_index18 = 0;\n    long level_counters_index19 =\
    \ 0;\n    long level_counters_index20 = 0;\n    long level_counters_index21 =\
    \ 0;\n    long level_counters_index22 = 0;\n    long level_counters_index23 =\
    \ 0;\n    long level_counters_index24 = 0;\n    long level_counters_index25 =\
    \ 0;\n    long level_counters_index26 = 0;\n    long level_counters_index27 =\
    \ 0;\n    long level_counters_index28 = 0;\n    long level_counters_index29 =\
    \ 0;\n    long level_counters_index30 = 0;\n    long level_counters_index31 =\
    \ 0;\n    long level_counters_index32 = 0;\n    long level_counters_index33 =\
    \ 0;\n    long level_counters_index34 = 0;\n    long level_counters_index35 =\
    \ 0;\n    long level_counters_index36 = 0;\n    long level_counters_index37 =\
    \ 0;\n    long level_counters_index38 = 0;\n    long level_counters_index39 =\
    \ 0;\n    long level_counters_index40 = 0;\n    long level_counters_index41 =\
    \ 0;\n    long level_counters_index42 = 0;\n    long level_counters_index43 =\
    \ 0;\n    long level_counters_index44 = 0;\n    long level_counters_index45 =\
    \ 0;\n    long level_counters_index46 = 0;\n    long level_counters_index47 =\
    \ 0;\n    long level_counters_index48 = 0;\n    long level_counters_index49 =\
    \ 0;\n    long level_counters_index50 = 0;\n    long level_counters_index51 =\
    \ 0;\n    long level_counters_index52 = 0;\n    long level_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpntl0fdpe.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpntl0fdpe.d(18): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] level_counters`\n/tmp/tmpntl0fdpe.d(72):
    Error: semicolon expected, not `unittest`\n/tmp/tmpntl0fdpe.d(72): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntl0fdpe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool in_paren = false;\n    bool in_group = false;\n   \
    \ bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_comma\
    \ = false;\n    bool in_group_semicolon = false;\n    bool in_group_newline =\
    \ false;\n    bool in_group_end = false;\n    bool in_group_open_brace = false;\n\
    \    bool in_group_close_brace = false;\n    bool in_group_open_brace_comma =\
    \ false;\n    bool in_group_close_brace_comma = false;\n    bool in_group_open_brace_semicolon\
    \ = false;\n    bool in_group_close_brace_semicolon = false;\n    bool in_group_open_brace_newline\
    \ = false;\n    bool in_group_close_brace_newline = false;\n    bool in_group_open_brace_end\
    \ = false;\n    bool in_group_close_brace_end = false;\n    bool in_group_open_brace_end\
    \ = false;\n    bool in_group_close_brace_end = false;\n    bool in_group_open_brace_comma\
    \ = false;\n    bool in_group_close_brace_comma = false;\n    bool in_group_open_brace_semicolon\
    \ = false;\n    bool in_group_close_brace_semicolon = false;\n    bool in_group_open_brace_newline\
    \ = false;\n    bool in_group_close_brace_newline = false;\n    bool in_group_open_brace_end\
    \ = false;\n    bool in_group_close_brace_end = false;\n    bool in_group_open_brace_comma\
    \ = false;\n    bool in_group_close_brace_comma = false;\n    bool in_group_open_brace_semicolon\
    \ = false;\n    bool in_group_close_brace_semicolon = false;\n    bool in_group_open_brace_newline\
    \ = false;\n    bool in_group_close_brace_newline = false;\n    bool in_group_open_brace_end\
    \ = false;\n    bool in_group_close_brace_end = false;\n    bool in_group_open_brace_comma\
    \ = false;\n    bool in_group_close_brace_comma = false;\n    bool in_group_open_brace_semicolon\
    \ = false;\n    bool in_group_close_brace_semicolon = false;\n    bool in_group_open_brace_newline\
    \ = false;\n    bool in_group_close_brace_newline = false;\n    bool in_group_open_brace_end\
    \ = false;\n    bool in_group_close_brace_end = false;\n    bool in_group_open_brace_comma\
    \ = false;\n    bool in_group_close_brace_comma = false;\n    bool in_group_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbb4i7jlm.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpbb4i7jlm.d(65): Error: semicolon expected,
    not `unittest`\n/tmp/tmpbb4i7jlm.d(65): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbb4i7jlm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_ptr = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long level_ptr = 0;\n    long level_stack_ptr = 0;\n    long level_stack_ptr_prev\
    \ = 0;\n    long level_stack_ptr_next = 0;\n    long level_stack_ptr_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next = 0;\n    long level_stack_ptr_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next = 0;\n    long level_stack_ptr_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_stack_ptr_next_next_next_next_prev\
    \ = 0;\n    long level_stack_ptr_next_next_next_next_next = 0;\n    long level_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppmewpb84.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmppmewpb84.d(57):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmppmewpb84.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjc8219l9.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpjc8219l9.d(19): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpjc8219l9.d(67):
    Error: semicolon expected, not `unittest`\n/tmp/tmpjc8219l9.d(67): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjc8219l9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjc8219l9.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpjc8219l9.d(19): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpjc8219l9.d(67):
    Error: semicolon expected, not `unittest`\n/tmp/tmpjc8219l9.d(67): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjc8219l9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_group = 0;\n    long\
    \ level_group = 0;\n    long max_level_group_len = 0;\n    long level_group_len\
    \ = 0;\n    long max_level_group_len2 = 0;\n    long level_group_len2 = 0;\n \
    \   long max_level_group_len3 = 0;\n    long level_group_len3 = 0;\n    long max_level_group_len4\
    \ = 0;\n    long level_group_len4 = 0;\n    long max_level_group_len5 = 0;\n \
    \   long level_group_len5 = 0;\n    long max_level_group_len6 = 0;\n    long level_group_len6\
    \ = 0;\n    long max_level_group_len7 = 0;\n    long level_group_len7 = 0;\n \
    \   long max_level_group_len8 = 0;\n    long level_group_len8 = 0;\n    long max_level_group_len9\
    \ = 0;\n    long level_group_len9 = 0;\n    long max_level_group_len10 = 0;\n\
    \    long level_group_len10 = 0;\n    long max_level_group_len11 = 0;\n    long\
    \ level_group_len11 = 0;\n    long max_level_group_len12 = 0;\n    long level_group_len12\
    \ = 0;\n    long max_level_group_len13 = 0;\n    long level_group_len13 = 0;\n\
    \    long max_level_group_len14 = 0;\n    long level_group_len14 = 0;\n    long\
    \ max_level_group_len15 = 0;\n    long level_group_len15 = 0;\n    long max_level_group_len16\
    \ = 0;\n    long level_group_len16 = 0;\n    long max_level_group_len17 = 0;\n\
    \    long level_group_len17 = 0;\n    long max_level_group_len18 = 0;\n    long\
    \ level_group_len18 = 0;\n    long max_level_group_len19 = 0;\n    long level_group_len19\
    \ = 0;\n    long max_level_group_len20 = 0;\n    long level_group_len20 = 0;\n\
    \    long max_level_group_len21 = 0;\n    long level_group_len21 = 0;\n    long\
    \ max_level_group_len22 = 0;\n    long level_group_len22 = 0;\n    long max_level_group_len23\
    \ = 0;\n    long level_group_len23 = 0;\n    long max_level_group_len24 = 0;\n\
    \    long level_group_len24 = 0;\n    long max_level_group_len25 = 0;\n    long\
    \ level_group_len25 = 0;\n    long max_level_group_len26 = 0;\n    long level_group_len26\
    \ = 0;\n    long max_level_group_len27 = 0;\n    long level_group_len27 = 0;\n\
    \    long max_level_group_len28 = 0;\n    long level_group_len28 = 0;\n    long\
    \ max_level_group_len29 = 0;\n    long level_group_len29 = 0;\n    long max_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppek8hudt.d(77): Error: semicolon expected, not `unittest`\n/tmp/tmppek8hudt.d(77):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmppek8hudt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_open_brace\
    \ = false;\n    bool has_close_brace = false;\n    bool has_open_paren = false;\n\
    \    bool has_close_paren = false;\n    bool has_open_curly = false;\n    bool\
    \ has_close_curly = false;\n    bool has_open_paren_or_curly = false;\n    bool\
    \ has_close_paren_or_curly = false;\n    bool has_open_curly_or_curly = false;\n\
    \    bool has_close_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly = false;\n    bool has_open_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly = false;\n    bool has_open_paren_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly = false;\n   \
    \ bool has_open_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly = false;\n\
    \    bool has_close_paren_or_curly_or_curly_or_curly_or_curly = false;\n    bool\
    \ has_open_curly_or_curly_or_curly_or_curly_or_curly = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_paren_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_open_curly_or_curly_or_curly_or_curly_or_curly_or_curly_or_curly\
    \ = false;\n    bool has_close_curly_or_curly_or_cur\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0s6xghtq.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmp0s6xghtq.d(49):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0s6xghtq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpztiyaih3.d(85): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztiyaih3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkhp6agsy.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpkhp6agsy.d(86): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkhp6agsy.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups[] = paren_string.split(\" \");\n    long[] max_levels = new long[paren_groups.length];\n\
    \    long[] current_levels = new long[paren_groups.length];\n    long[] current_levels_index\
    \ = new long[paren_groups.length];\n    long[] current_levels_index[paren_groups.length];\n\
    \    long[] current_level_lengths = new long[paren_groups.length];\n    long[]\
    \ current_level_lengths[paren_groups.length];\n    long[] current_level_lengths_index\
    \ = new long[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] current_level_lengths_index[paren_groups.length];\n\
    \    long[] current_level_lengths_index[paren_groups.length];\n    long[] \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpedc1dmiy.d(14): Deprecation: instead of C-style syntax, use
    D-style syntax `string[] paren_groups`\n/tmp/tmpedc1dmiy.d(18): Deprecation: instead
    of C-style syntax, use D-style syntax `long[][paren_groups.length] current_levels_index`\n/tmp/tmpedc1dmiy.d(20):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths`\n/tmp/tmpedc1dmiy.d(22): Deprecation: instead of C-style
    syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(24): Deprecation: instead of
    C-style syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(25):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(26): Deprecation: instead of
    C-style syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(27):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(28): Deprecation: instead of
    C-style syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(29):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(30): Deprecation: instead of
    C-style syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(31):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.length]
    current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(32): Deprecation: instead of
    C-style syntax, use D-style syntax `long[][paren_groups.length] current_level_lengths_index`\n/tmp/tmpedc1dmiy.d(33):
    Deprecation: instead of C-style syntax, use D-style syntax `long[][paren_groups.l'
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpztiyaih3.d(85): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztiyaih3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_group = \"\";\n    long max_level =\
    \ 0;\n    long level = 0;\n    long paren_level = 0;\n    long paren_levels[]\
    \ = new long[paren_chars.length()];\n    long paren_levels_index = 0;\n    long\
    \ paren_levels_index_max = 0;\n    long paren_levels_index_max_index = 0;\n  \
    \  long paren_levels_index_min = 0;\n    long paren_levels_index_min_index = 0;\n\
    \    long paren_levels_index_current = 0;\n    long paren_levels_index_current_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_index\
    \ = 0;\n    long paren_levels_index_current_min = 0;\n    long paren_levels_index_current_min_index\
    \ = 0;\n    long paren_levels_index_current_max = 0;\n    long paren_levels_index_current_max_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkr3bolvw.d(19): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] paren_levels`\n/tmp/tmpkr3bolvw.d(61): Error: semicolon
    expected, not `unittest`\n/tmp/tmpkr3bolvw.d(61): Error: found `unittest` instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkr3bolvw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    long paren_index =\
    \ 0;\n    long paren_level = 0;\n    long paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_levels_size = 0;\n    long paren_levels_index = 0;\n    long paren_paren_index\
    \ = 0;\n    long paren_paren_level = 0;\n    long paren_paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_paren_levels_size = 0;\n    long paren_paren_levels_index = 0;\n\
    \    long paren_paren_paren_index = 0;\n    long paren_paren_paren_level = 0;\n\
    \    long paren_paren_paren_levels[] = new long[paren_string.length()];\n    long\
    \ paren_paren_paren_levels_size = 0;\n    long paren_paren_paren_levels_index\
    \ = 0;\n    long paren_paren_paren_paren_index = 0;\n    long paren_paren_paren_paren_level\
    \ = 0;\n    long paren_paren_paren_paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_paren_paren_paren_levels_size = 0;\n    long paren_paren_paren_paren_levels_index\
    \ = 0;\n    long paren_paren_paren_paren_paren_index = 0;\n    long paren_paren_paren_paren_paren_level\
    \ = 0;\n    long paren_paren_paren_paren_paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_paren_paren_paren_paren_levels_size = 0;\n    long paren_paren_paren_paren_paren_levels_index\
    \ = 0;\n    long paren_paren_paren_paren_paren_paren_index = 0;\n    long paren_paren_paren_paren_paren_paren_level\
    \ = 0;\n    long paren_paren_paren_paren_paren_paren_levels[] = new long[paren_string.length()];\n\
    \    long paren_paren_paren_paren_paren_paren_levels_size = 0;\n    long paren_paren_paren_paren_paren_paren_levels_index\
    \ = 0;\n    long paren_paren_paren_paren_paren_paren_paren_index = 0;\n    long\
    \ paren_paren_paren_paren_paren_paren_paren_level = 0;\n    long paren_paren_paren_paren\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph0xtqxsm.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmph0xtqxsm.d(21): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmph0xtqxsm.d(26):
    Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_paren_levels`\n/tmp/tmph0xtqxsm.d(31):
    Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_paren_paren_levels`\n/tmp/tmph0xtqxsm.d(36):
    Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_paren_paren_paren_levels`\n/tmp/tmph0xtqxsm.d(41):
    Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_paren_paren_paren_paren_levels`\n/tmp/tmph0xtqxsm.d(46):
    Deprecation: instead of C-style syntax, use D-style syntax `long[] paren_paren_paren_paren_paren_paren_levels`\n/tmp/tmph0xtqxsm.d(52):
    Error: semicolon expected, not `unittest`\n/tmp/tmph0xtqxsm.d(52): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph0xtqxsm.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long level_max = 0;\n    long level_max_count = 0;\n    long level_max_max\
    \ = 0;\n    long level_max_max_count = 0;\n    long level_max_max_max = 0;\n \
    \   long level_max_max_max_count = 0;\n    long level_max_max_max_max = 0;\n \
    \   long level_max_max_max_max_count = 0;\n    long level_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_count = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_count\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_count = 0;\n\
    \    long level_max_max_max_max_max_max_max_max_max_max_max_max = 0;\n    long\
    \ level_max_max_max_max_max_max_max_max_max_max_max_max_count = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_count =\
    \ 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max =\
    \ 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_count\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max_count\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_count\
    \ = 0;\n    long level_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max\
    \ = 0;\n    long level_max_max_max_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphokhh5py.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmphokhh5py.d(53):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmphokhh5py.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group_open\
    \ = false;\n    bool in_group_close = false;\n    bool in_group_nest = false;\n\
    \    bool in_group_nest_open = false;\n    bool in_group_nest_close = false;\n\
    \    bool in_group_nest_nest = false;\n    bool in_group_nest_nest_open = false;\n\
    \    bool in_group_nest_nest_close = false;\n    bool in_group_nest_nest_nest\
    \ = false;\n    bool in_group_nest_nest_nest_open = false;\n    bool in_group_nest_nest_nest_close\
    \ = false;\n    bool in_group_nest_nest_nest_nest = false;\n    bool in_group_nest_nest_nest_nest_open\
    \ = false;\n    bool in_group_nest_nest_nest_nest_close = false;\n    bool in_group_nest_nest_nest_nest_nest\
    \ = false;\n    bool in_group_nest_nest_nest_nest_nest_open = false;\n    bool\
    \ in_group_nest_nest_nest_nest_nest_close = false;\n    bool in_group_nest_nest_nest_nest_nest_nest\
    \ = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_open = false;\n  \
    \  bool in_group_nest_nest_nest_nest_nest_nest_close = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_nest\
    \ = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_open = false;\n  \
    \  bool in_group_nest_nest_nest_nest_nest_nest_close = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_nest\
    \ = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_nest_open = false;\n\
    \    bool in_group_nest_nest_nest_nest_nest_nest_nest_close = false;\n    bool\
    \ in_group_nest_nest_nest_nest_nest_nest_nest_nest = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_nest_open\
    \ = false;\n    bool in_group_nest_nest_nest_nest_nest_nest_nest_close = false;\n\
    \    bool in_group_nest_nest_nest_nest_nest_nest_nest_nest = false;\n    bool\
    \ in_group_nest_nest_nest_nest_nest_nest_nest_nest_\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl6vyo41h.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmpl6vyo41h.d(50):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpl6vyo41h.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long\
    \ paren_level_max2 = 0;\n    long paren_level_cur2 = 0;\n    long paren_level_max3\
    \ = 0;\n    long paren_level_cur3 = 0;\n    long paren_level_max4 = 0;\n    long\
    \ paren_level_cur4 = 0;\n    long paren_level_max5 = 0;\n    long paren_level_cur5\
    \ = 0;\n    long paren_level_max6 = 0;\n    long paren_level_cur6 = 0;\n    long\
    \ paren_level_max7 = 0;\n    long paren_level_cur7 = 0;\n    long paren_level_max8\
    \ = 0;\n    long paren_level_cur8 = 0;\n    long paren_level_max9 = 0;\n    long\
    \ paren_level_cur9 = 0;\n    long paren_level_max10 = 0;\n    long paren_level_cur10\
    \ = 0;\n    long paren_level_max11 = 0;\n    long paren_level_cur11 = 0;\n   \
    \ long paren_level_max12 = 0;\n    long paren_level_cur12 = 0;\n    long paren_level_max13\
    \ = 0;\n    long paren_level_cur13 = 0;\n    long paren_level_max14 = 0;\n   \
    \ long paren_level_cur14 = 0;\n    long paren_level_max15 = 0;\n    long paren_level_cur15\
    \ = 0;\n    long paren_level_max16 = 0;\n    long paren_level_cur16 = 0;\n   \
    \ long paren_level_max17 = 0;\n    long paren_level_cur17 = 0;\n    long paren_level_max18\
    \ = 0;\n    long paren_level_cur18 = 0;\n    long paren_level_max19 = 0;\n   \
    \ long paren_level_cur19 = 0;\n    long paren_level_max20 = 0;\n    long paren_level_cur20\
    \ = 0;\n    long paren_level_max21 = 0;\n    long paren_level_cur21 = 0;\n   \
    \ long paren_level_max22 = 0;\n    long paren_level_cur22 = 0;\n    long paren_level_max23\
    \ = 0;\n    long paren_level_cur23 = 0;\n    long paren_level_max24 = 0;\n   \
    \ long paren_level_cur24 = 0;\n    long paren_level_max25 = 0;\n    long paren_level_cur25\
    \ = 0;\n    long paren_level_max26 = 0;\n    long paren_level_cur26 = 0;\n   \
    \ long paren_level_max27 = 0;\n    long paren_level_cur27 = 0;\n    long paren_level_max28\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0frl1y7p.d(73): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0frl1y7p.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] max_levels = new long[paren_string.length()];\n\
    \    long[] max_levels_index = new long[paren_string.length()];\n    long level\
    \ = 0;\n    long max_level = 0;\n    long max_level_index = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_comma = false;\n    bool in_paren_group_open_brace_colon\
    \ = false;\n    bool in_paren_group_close_brace_colon = false;\n    bool in_paren_group_open_brace_semicolon\
    \ = false;\n    bool in_paren_group_close_brace_semicolon = false;\n    bool in_paren_group_open_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_comma_brace = false;\n    bool\
    \ in_paren_group_open_brace_colon_colon = false;\n    bool in_paren_group_close_brace_colon_colon\
    \ = false;\n    bool in_paren_group_open_brace_semicolon_semicolon = false;\n\
    \    bool in_paren_group_close_brace_semicolon_semicolon = false;\n    bool in_paren_group_open_brace_colon_semicolon\
    \ = false;\n    bool in_paren_group_close_brace_colon_semicolon = false;\n   \
    \ bool in_paren_group_open_brace_colon_comma = false;\n    bool in_paren_group_close_brace_colon_comma\
    \ = false;\n    bool in_paren_group_open_brace_semicolon_comma = false;\n    bool\
    \ in_paren_group_close_brace_semicolon_comma = false;\n    bool in_paren_group_open_brace_semicolon_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_semicolon_comma_brace = false;\n\
    \    bool in_paren_group_open_brace_semicolon_colon_colon = false;\n    bool in_paren_group_close_brace_semicolon_colon_colon\
    \ = false;\n    bool in_paren_group_open_brace_semicolon_colon_semicolon = false;\n\
    \    bool in_paren_group_close_brace_semicolon_colon_semicolon = false;\n    bool\
    \ in_paren_group_open_brace_semicolon_colon_comma = false;\n    bool \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9x6_5tf.d(52): Error: no identifier for declarator `bool`\n/tmp/tmph9x6_5tf.d(52):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmph9x6_5tf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_quote = false;\n    bool in_double_quote = false;\n  \
    \  bool in_single_quote = false;\n    bool in_double_quote_escape = false;\n \
    \   bool in_single_quote_escape = false;\n    bool in_single_quote_escape_char\
    \ = false;\n    bool in_double_quote_escape_char = false;\n    bool in_paren_escape\
    \ = false;\n    bool in_paren_escape_char = false;\n    bool in_paren_escape_char2\
    \ = false;\n    bool in_paren_escape_char3 = false;\n    bool in_paren_escape_char4\
    \ = false;\n    bool in_paren_escape_char5 = false;\n    bool in_paren_escape_char6\
    \ = false;\n    bool in_paren_escape_char7 = false;\n    bool in_paren_escape_char8\
    \ = false;\n    bool in_paren_escape_char9 = false;\n    bool in_paren_escape_char10\
    \ = false;\n    bool in_paren_escape_char11 = false;\n    bool in_paren_escape_char12\
    \ = false;\n    bool in_paren_escape_char13 = false;\n    bool in_paren_escape_char14\
    \ = false;\n    bool in_paren_escape_char15 = false;\n    bool in_paren_escape_char16\
    \ = false;\n    bool in_paren_escape_char17 = false;\n    bool in_paren_escape_char18\
    \ = false;\n    bool in_paren_escape_char19 = false;\n    bool in_paren_escape_char20\
    \ = false;\n    bool in_paren_escape_char21 = false;\n    bool in_paren_escape_char22\
    \ = false;\n    bool in_paren_escape_char23 = false;\n    bool in_paren_escape_char24\
    \ = false;\n    bool in_paren_escape_char25 = false;\n    bool in_paren_escape_char26\
    \ = false;\n    bool in_paren_escape_char27 = false;\n    bool in_paren_escape_char28\
    \ = false;\n    bool in_paren_escape_char29 = false;\n    bool in_paren_escape_char30\
    \ = false;\n    bool in_paren_escape_char31 = false;\n    bool in_paren_escape_char32\
    \ = false;\n    bool in_paren_escape_char33 = false;\n    bool in_paren_escape_char34\
    \ = false;\n    bool in_paren_escape_char35 = false;\n    bool in_paren_escape_char36\
    \ = false;\n    bool in_paren_escape_char37 = false;\n    bool in_paren_escape_char38\
    \ = false;\n    bool in_paren_escape_char39 = false;\n    bool in_paren_escape_char40\
    \ = false;\n    bool in_paren_escape_char41 = false;\n    bool in_paren_escape_char42\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4g18psxe.d(68): Error: no identifier for declarator `bool`\n/tmp/tmp4g18psxe.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4g18psxe.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            level++;\n            levels[level]\
    \ = level;\n        }\n        else if(c == ')')\n        {\n            level--;\n\
    \            if(level == 0)\n            {\n                level = levels[level];\n\
    \            }\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            level++;\n            levels[level] = level;\n        }\n \
    \       else if(c == ')')\n        {\n            level--;\n            if(level\
    \ == 0)\n            {\n                level = levels[level];\n            }\n\
    \        }\n    }\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n\
    \        char c = paren_string[i];\n        if(c == '(')\n        {\n        \
    \    level++;\n            levels[level] = level;\n        }\n        else if(c\
    \ == ')')\n        {\n            level--;\n            if(level == 0)\n     \
    \       {\n                level = levels[level];\n            }\n        }\n\
    \    }\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n        char\
    \ c = paren_string[i];\n        if(c == '(')\n        {\n            level++;\n\
    \            levels[level] = level;\n        }\n        else if(c == ')')\n  \
    \      {\n            level--;\n            if(level == 0)\n            {\n  \
    \              level = levels[level];\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            level++;\n            levels[level]\
    \ = level;\n        }\n        else if(c == ')')\n        {\n            level--;\n\
    \            if(level == 0)\n            {\n                level = levels[level];\n\
    \            }\n        }\n    }\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            level++;\n            levels[level] = level;\n        }\n \
    \       else if(c == ')')\n        {\n            level--;\n            if(level\
    \ == 0)\n            {\n                level = levels[level];\n            }\n\
    \        }\n    }\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n\
    \        char c = paren_string[i];\n        if(c == '(')\n        {\n        \
    \    level++;\n            levels[level] = level;\n        }\n        else if(c\
    \ == ')')\n        {\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp40cyte3c.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp40cyte3c.d(129): Error: found `unittest`
    instead of statement\n/tmp/tmp40cyte3c.d(137): Error: found `End of File` when
    expecting `}` following compound statement\n/tmp/tmp40cyte3c.d(137): Error: found
    `End of File` when expecting `}` following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp40cyte3c.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_open = false;\n  \
    \  bool is_opening_closed = false;\n    bool is_closing_open = false;\n    bool\
    \ is_closing_closed = false;\n    bool is_opening_opening_open = false;\n    bool\
    \ is_opening_opening_closed = false;\n    bool is_opening_closing_open = false;\n\
    \    bool is_opening_closing_closed = false;\n    bool is_closing_opening_open\
    \ = false;\n    bool is_closing_opening_closed = false;\n    bool is_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    bool is_closing_closing_opening_closed = false;\n    bool is_closing_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprvk28zc5.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmprvk28zc5.d(63): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprvk28zc5.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkhp6agsy.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpkhp6agsy.d(86): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkhp6agsy.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2 =\
    \ false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5\
    \ = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n    bool\
    \ in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n\
    \    bool in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13\
    \ = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n    bool\
    \ in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n\
    \    bool in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21\
    \ = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n    bool\
    \ in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n\
    \    bool in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29\
    \ = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n    bool\
    \ in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n\
    \    bool in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37\
    \ = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n    bool\
    \ in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n\
    \    bool in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45\
    \ = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n    bool\
    \ in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n\
    \    bool in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53\
    \ = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n    bool\
    \ in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n\
    \    bool in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61\
    \ = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n    bool\
    \ in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n\
    \    bool in_group67 = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprzgwqdd3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmprzgwqdd3.d(85): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzgwqdd3.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_index = 0;\n    long\
    \ level_index = 0;\n    long paren_index = 0;\n    long paren_level = 0;\n   \
    \ long paren_level_index = 0;\n    long paren_level_size = 0;\n    long paren_level_size_index\
    \ = 0;\n    long paren_level_size_size = 0;\n    long paren_level_size_size_index\
    \ = 0;\n    long paren_level_size_size_size = 0;\n    long paren_level_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size = 0;\n    long paren_level_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size = 0;\n    long paren_level_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size = 0;\n    long paren_level_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_size_size_size_size_size_index = 0;\n    long paren_level_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_index = 0;\n\
    \    long paren_level_size_size_size_size_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_size_size_size_size_size_size_size_index = 0;\n    long\
    \ paren_level_size_size_size_size_size_size_size_size_size_size = 0;\n    long\
    \ paren_level_size_size_size_size_size_size_size_size_size_size_index = 0;\n \
    \   long paren_level_size_size_size_size_size_size_size_size_size_size_size =\
    \ 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size_size_index\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size\
    \ = 0;\n    long paren_level_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_index\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp87sl0hak.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmp87sl0hak.d(51):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp87sl0hak.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_opening_paren_or_closed = false;\n    bool is_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_opening_paren_or_closed = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_closed\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren\
    \ = false;\n    bool is_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_or_opening_paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptzgniltd.d(39): Error: semicolon expected, not `unittest`\n/tmp/tmptzgniltd.d(39):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmptzgniltd.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_inner = 0;\n    long\
    \ level_inner = 0;\n    long max_level_outer = -1;\n    long level_outer = -1;\n\
    \    long max_level_inner_outer = -1;\n    long level_inner_outer = -1;\n    long\
    \ max_level_outer_inner = -1;\n    long level_outer_inner = -1;\n    long max_level_inner_outer_inner\
    \ = -1;\n    long level_inner_outer_inner = -1;\n    long max_level_outer_outer_inner\
    \ = -1;\n    long level_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_inner = -1;\n    long max_level_outer_outer_outer_inner\
    \ = -1;\n    long level_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_inner = -1;\n    long max_level_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_inner = -1;\n    long max_level_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_outer_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_outer_inner = -1;\n    long\
    \ max_level_outer_outer_outer_outer_outer_outer_inner = -1;\n    long level_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long max_level_inner_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_outer_outer_inner = -1;\n\
    \    long max_level_outer_outer_outer_outer_outer_outer_inner = -1;\n    long\
    \ level_outer_outer_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long max_level_outer_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_outer_outer_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long max_level_outer_outer_outer_outer_outer_outer_outer_inner =\
    \ -1;\n    long level_outer_outer_outer_outer_outer_inner = -1;\n    long max_level_inner_outer_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n    long level_inner_outer_outer_outer_outer_outer_outer_outer_inner\
    \ = -1;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3z5mpg4r.d(59): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3z5mpg4r.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    long current_index = 0;\n    bool in_paren =\
    \ false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n\
    \    bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdajy1tlb.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpdajy1tlb.d(49): Error: semicolon expected,
    not `unittest`\n/tmp/tmpdajy1tlb.d(49): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdajy1tlb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long current_level = 0;\n    long current_paren = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_max = 0;\n\
    \    long paren_level_count_current = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long paren_level_count_current_max\
    \ = 0;\n    long paren_level_count_current_min = 0;\n    long \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiav3xkte.d(68): Error: no identifier for declarator `long`\n/tmp/tmpiav3xkte.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpiav3xkte.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n\
    \    bool in_brace = false;\n    bool in_quote = false;\n    bool in_double_quote\
    \ = false;\n    bool in_single_quote = false;\n    bool in_double_quote_in_string\
    \ = false;\n    bool in_single_quote_in_string = false;\n    bool in_string =\
    \ false;\n    bool in_comment = false;\n    bool in_comment2 = false;\n    bool\
    \ in_comment3 = false;\n    bool in_comment4 = false;\n    bool in_comment5 =\
    \ false;\n    bool in_comment6 = false;\n    bool in_comment7 = false;\n    bool\
    \ in_comment8 = false;\n    bool in_comment9 = false;\n    bool in_comment10 =\
    \ false;\n    bool in_comment11 = false;\n    bool in_comment12 = false;\n   \
    \ bool in_comment13 = false;\n    bool in_comment14 = false;\n    bool in_comment15\
    \ = false;\n    bool in_comment16 = false;\n    bool in_comment17 = false;\n \
    \   bool in_comment18 = false;\n    bool in_comment19 = false;\n    bool in_comment20\
    \ = false;\n    bool in_comment21 = false;\n    bool in_comment22 = false;\n \
    \   bool in_comment23 = false;\n    bool in_comment24 = false;\n    bool in_comment25\
    \ = false;\n    bool in_comment26 = false;\n    bool in_comment27 = false;\n \
    \   bool in_comment28 = false;\n    bool in_comment29 = false;\n    bool in_comment30\
    \ = false;\n    bool in_comment31 = false;\n    bool in_comment32 = false;\n \
    \   bool in_comment33 = false;\n    bool in_comment34 = false;\n    bool in_comment35\
    \ = false;\n    bool in_comment36 = false;\n    bool in_comment37 = false;\n \
    \   bool in_comment38 = false;\n    bool in_comment39 = false;\n    bool in_comment40\
    \ = false;\n    bool in_comment41 = false;\n    bool in_comment42 = false;\n \
    \   bool in_comment43 = false;\n    bool in_comment44 = false;\n    bool in_comment45\
    \ = false;\n    bool in_comment46 = false;\n    bool in_comment47 = false;\n \
    \   bool in_comment48 = false;\n    bool in_comment49 = false;\n    bool in_comment50\
    \ = false;\n    bool in_comment51 = false;\n    bool in_comment52 = false;\n \
    \   bool in_comment53 = false;\n    bool in_comment54 = false;\n    bool in_comment55\
    \ = false;\n    bool in_comment56 = false;\n    bool in_comment57 = false;\n \
    \   bool in_comment58 = false;\n    bool in_comment\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjkyroa_5.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpjkyroa_5.d(86): Error: semicolon expected,
    not `unittest`\n/tmp/tmpjkyroa_5.d(86): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkyroa_5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=c++,algorithm,parentheses\
    \ |>\n<| c |>\nThis doesn't work for input like `((())))` which has three levels\
    \ of nesting.\n<|/ c |>\n<| c |>\nYes, you are right. My mistake. Fixed the answer.\n\
    <|/ c |>\n<| a tags=c++,algorithm,parentheses |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <stack>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2an2tk97.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp2an2tk97.d(35): Error: declaration expected,
    not `<`\n/tmp/tmp2an2tk97.d(38): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2an2tk97.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_count = 0;\n    bool in_paren\
    \ = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_close =\
    \ false;\n    bool in_paren_group_open_bracket = false;\n    bool in_paren_group_close_bracket\
    \ = false;\n    bool in_paren_group_open_close_bracket = false;\n    bool in_paren_group_open_bracket2\
    \ = false;\n    bool in_paren_group_close_bracket2 = false;\n    bool in_paren_group_open_close_bracket2\
    \ = false;\n    bool in_paren_group_open_bracket3 = false;\n    bool in_paren_group_close_bracket3\
    \ = false;\n    bool in_paren_group_open_close_bracket3 = false;\n    bool in_paren_group_open_bracket4\
    \ = false;\n    bool in_paren_group_close_bracket4 = false;\n    bool in_paren_group_open_close_bracket4\
    \ = false;\n    bool in_paren_group_open_bracket5 = false;\n    bool in_paren_group_close_bracket5\
    \ = false;\n    bool in_paren_group_open_close_bracket5 = false;\n    bool in_paren_group_open_bracket6\
    \ = false;\n    bool in_paren_group_close_bracket6 = false;\n    bool in_paren_group_open_close_bracket6\
    \ = false;\n    bool in_paren_group_open_bracket7 = false;\n    bool in_paren_group_close_bracket7\
    \ = false;\n    bool in_paren_group_open_close_bracket7 = false;\n    bool in_paren_group_open_bracket8\
    \ = false;\n    bool in_paren_group_close_bracket8 = false;\n    bool in_paren_group_open_close_bracket8\
    \ = false;\n    bool in_paren_group_open_bracket9 = false;\n    bool in_paren_group_close_bracket9\
    \ = false;\n    bool in_paren_group_open_close_bracket9 = false;\n    bool in_paren_group_open_bracket10\
    \ = false;\n    bool in_paren_group_close_bracket10 = false;\n    bool in_paren_group_open_close_bracket10\
    \ = false;\n    bool in_paren_group_open_bracket11 = false;\n    bool in_paren_group_close_bracket11\
    \ = false;\n    bool in_paren_group_open_\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopfm8ash.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmpopfm8ash.d(57):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpopfm8ash.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    for(auto c : paren_string)\n    {\n        if(c != '(')\n\
    \        {\n            levels[index] = level;\n            index++;\n       \
    \ }\n        else if(c != ')')\n        {\n            level++;\n        }\n \
    \       else\n        {\n            level--;\n            if(level > max_level)\n\
    \                max_level = level;\n        }\n    }\n    return levels;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqo4zb3af.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpqo4zb3af.d(18): Error: no identifier for
    declarator `c`\n/tmp/tmpqo4zb3af.d(18): Error: expression expected, not `:`\n/tmp/tmpqo4zb3af.d(18):
    Error: found `paren_string` when expecting `;` following `for` condition\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqo4zb3af.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool is_open = false;\n    bool is_closed = false;\n   \
    \ bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_r2hi4hm.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp_r2hi4hm.d(42): Error: semicolon expected,
    not `unittest`\n/tmp/tmp_r2hi4hm.d(42): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_r2hi4hm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long paren_index = 0;\n    long paren_level =\
    \ 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n\
    \    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_open\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps3njrn9i.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmps3njrn9i.d(45): Error: semicolon expected,
    not `unittest`\n/tmp/tmps3njrn9i.d(45): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3njrn9i.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_count\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_max = 0;\n    long paren_level_current\
    \ = 0;\n    long paren_level_next = 0;\n    long paren_level_next2 = 0;\n    long\
    \ paren_level_next3 = 0;\n    long paren_level_next4 = 0;\n    long paren_level_next5\
    \ = 0;\n    long paren_level_next6 = 0;\n    long paren_level_next7 = 0;\n   \
    \ long paren_level_next8 = 0;\n    long paren_level_next9 = 0;\n    long paren_level_next10\
    \ = 0;\n    long paren_level_next11 = 0;\n    long paren_level_next12 = 0;\n \
    \   long paren_level_next13 = 0;\n    long paren_level_next14 = 0;\n    long paren_level_next15\
    \ = 0;\n    long paren_level_next16 = 0;\n    long paren_level_next17 = 0;\n \
    \   long paren_level_next18 = 0;\n    long paren_level_next19 = 0;\n    long paren_level_next20\
    \ = 0;\n    long paren_level_next21 = 0;\n    long paren_level_next22 = 0;\n \
    \   long paren_level_next23 = 0;\n    long paren_level_next24 = 0;\n    long paren_level_next25\
    \ = 0;\n    long paren_level_next26 = 0;\n    long paren_level_next27 = 0;\n \
    \   long paren_level_next28 = 0;\n    long paren_level_next29 = 0;\n    long paren_level_next30\
    \ = 0;\n    long paren_level_next31 = 0;\n    long paren_level_next32 = 0;\n \
    \   long paren_level_next33 = 0;\n    long paren_level_next34 = 0;\n    long paren_level_next35\
    \ = 0;\n    long paren_level_next36 = 0;\n    long paren_level_next37 = 0;\n \
    \   long paren_level_next38 = 0;\n    long paren_level_next39 = 0;\n    long paren_level_next40\
    \ = 0;\n    long paren_level_next41 = 0;\n    long paren_level_next42 = 0;\n \
    \   long paren_level_next43 = 0;\n    long paren_level_next44 = 0;\n    long paren_level_next45\
    \ = 0;\n    long paren_level_next46 = 0;\n    long paren_level_next47 = 0;\n \
    \   long paren_level_next48 = 0;\n    long paren_level_next49 = 0;\n    long paren_level_next50\
    \ = 0;\n    long paren_level_next51 = 0;\n    long paren_level_next52 = 0;\n \
    \   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf0r857xq.d(73): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0r857xq.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups[] = paren_string.split(\" \");\n    long[] max_levels = new long[paren_groups.length];\n\
    \    long[] levels = new long[paren_groups.length];\n    long[] levels_stack =\
    \ new long[paren_groups.length];\n    long[] levels_stack_top = new long[paren_groups.length];\n\
    \    long[] levels_stack_bottom = new long[paren_groups.length];\n    long[] levels_stack_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom = new\
    \ long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_top = new\
    \ long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom = new\
    \ long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_top\
    \ = new long[paren_groups.length];\n    long[] levels_stack_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_bottom_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpquzx6h_v.d(14): Deprecation: instead of C-style syntax, use
    D-style syntax `string[] paren_groups`\n/tmp/tmpquzx6h_v.d(40): Error: semicolon
    expected, not `unittest`\n/tmp/tmpquzx6h_v.d(40): Error: found `unittest` instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpquzx6h_v.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    long paren_level =\
    \ 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_size\
    \ = 0;\n    long paren_levels_index = 0;\n    long paren_levels_index2 = 0;\n\
    \    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n    long\
    \ paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long paren_levels_index7\
    \ = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9 = 0;\n\
    \    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n    long\
    \ paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long paren_levels_index14\
    \ = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16 = 0;\n\
    \    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n    long\
    \ paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long paren_levels_index21\
    \ = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23 = 0;\n\
    \    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n    long\
    \ paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long paren_levels_index28\
    \ = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30 = 0;\n\
    \    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n    long\
    \ paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long paren_levels_index35\
    \ = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37 = 0;\n\
    \    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n    long\
    \ paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long paren_levels_index42\
    \ = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44 = 0;\n\
    \    long paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp12mqbkml.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp12mqbkml.d(20): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmp12mqbkml.d(67):
    Error: semicolon expected, not `unittest`\n/tmp/tmp12mqbkml.d(67): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp12mqbkml.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3kcggpac.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp3kcggpac.d(62): Error: semicolon expected,
    not `unittest`\n/tmp/tmp3kcggpac.d(62): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kcggpac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string current_level = \"\";\n\
    \    long current_level_count = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        if(paren_string[i] == '(')\n        {\n            current_level_count++;\n\
    \            current_level = current_level + paren_string[i];\n        }\n   \
    \     else if(paren_string[i] == ')')\n        {\n            current_level_count--;\n\
    \            current_level = current_level.substring(0, current_level.length()\
    \ - 1);\n        }\n        else if(current_level_count > 0)\n        {\n    \
    \        levels[i] = current_level_count;\n        }\n    }\n    return levels;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c#,parentheses,string |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Text.RegularExpressions;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpczcu4d4o.d(36): Error: declaration expected, not `<`\n/tmp/tmpczcu4d4o.d(41):
    Error: semicolon expected, not `.`\n/tmp/tmpczcu4d4o.d(41): Error: no identifier
    for declarator `.Collections.Generic`\n/tmp/tmpczcu4d4o.d(42): Error: semicolon
    expected, not `.`\n/tmp/tmpczcu4d4o.d(42): Error: no identifier for declarator
    `.Linq`\n/tmp/tmpczcu4d4o.d(43): Error: semicolon expected, not `.`\n/tmp/tmpczcu4d4o.d(43):
    Error: no identifier for declarator `.Text`\n/tmp/tmpczcu4d4o.d(44): Error: semicolon
    expected, not `.`\n/tmp/tmpczcu4d4o.d(44): Error: no identifier for declarator
    `.Text.RegularExpressions`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpczcu4d4o.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_STACK_DEPTH];\n\
    \    long level_stack_pointer = 0;\n    long paren_stack_pointer = 0;\n    long\
    \ paren_level = 0;\n    long paren_level_stack[MAX_STACK_DEPTH];\n    long paren_level_stack_pointer\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_count_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_stack_pointer = 0;\n    long paren_level_count_max\
    \ = 0;\n    long paren_level_count_max_stack[MAX_STACK_DEPTH];\n    long paren_level_count_max_stack_pointer\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_min_stack_pointer = 0;\n    long paren_level_count_sum\
    \ = 0;\n    long paren_level_count_sum_stack[MAX_STACK_DEPTH];\n    long paren_level_count_sum_stack_pointer\
    \ = 0;\n    long paren_level_count_avg = 0;\n    long paren_level_count_avg_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_avg_stack_pointer = 0;\n    long paren_level_count_sum2\
    \ = 0;\n    long paren_level_count_sum2_stack[MAX_STACK_DEPTH];\n    long paren_level_count_sum2_stack_pointer\
    \ = 0;\n    long paren_level_count_sum3 = 0;\n    long paren_level_count_sum3_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_sum3_stack_pointer = 0;\n    long paren_level_count_sum4\
    \ = 0;\n    long paren_level_count_sum4_stack[MAX_STACK_DEPTH];\n    long paren_level_count_sum4_stack_pointer\
    \ = 0;\n    long paren_level_count_sum5 = 0;\n    long paren_level_count_sum5_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_sum5_stack_pointer = 0;\n    long paren_level_count_sum6\
    \ = 0;\n    long paren_level_count_sum6_stack[MAX_STACK_DEPTH];\n    long paren_level_count_sum6_stack_pointer\
    \ = 0;\n    long paren_level_count_sum7 = 0;\n    long paren_level_count_sum7_stack[MAX_STACK_DEPTH];\n\
    \    long paren_level_count_sum7_stack_pointer = 0;\n    long paren_level_count_sum8\
    \ = 0;\n    long paren_level_count_sum8_stack[MAX_STACK_DEPTH];\n    long paren_level_count_sum8_stack_pointer\
    \ = 0;\n    long paren_level_count_sum9 = 0;\n\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp90rr81ih.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_STACK_DEPTH] level_stack`\n/tmp/tmp90rr81ih.d(20): Deprecation:
    instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_stack`\n/tmp/tmp90rr81ih.d(23):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_stack`\n/tmp/tmp90rr81ih.d(26): Deprecation: instead of C-style
    syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_max_stack`\n/tmp/tmp90rr81ih.d(29):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_min_stack`\n/tmp/tmp90rr81ih.d(32): Deprecation: instead of
    C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_sum_stack`\n/tmp/tmp90rr81ih.d(35):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_avg_stack`\n/tmp/tmp90rr81ih.d(38): Deprecation: instead of
    C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_sum2_stack`\n/tmp/tmp90rr81ih.d(41):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_sum3_stack`\n/tmp/tmp90rr81ih.d(44): Deprecation: instead of
    C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_sum4_stack`\n/tmp/tmp90rr81ih.d(47):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_sum5_stack`\n/tmp/tmp90rr81ih.d(50): Deprecation: instead of
    C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_sum6_stack`\n/tmp/tmp90rr81ih.d(53):
    Deprecation: instead of C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH]
    paren_level_count_sum7_stack`\n/tmp/tmp90rr81ih.d(56): Deprecation: instead of
    C-style syntax, use D-style syntax `long[MAX_STACK_DEPTH] paren_level_count_sum8_stack`\n/tmp/tmp90rr81ih.d(60):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp90rr81ih.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group_open = false;\n    bool\
    \ in_group_close = false;\n    bool in_group_open_brace = false;\n    bool in_group_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace = false;\n    bool in_group_close_brace_or_open_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace = false;\n\
    \    bool in_group_close_brace_or_open_brace_or_close_brace = false;\n    bool\
    \ in_group_open_brace_or_close_brace_or_open_brace_or_close_brace = false;\n \
    \   bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace\
    \ = false;\n    bool in_group_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_brace_or_open_brace_or_close_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnjo0ed9y.d(35): Error: semicolon expected, not `unittest`\n/tmp/tmpnjo0ed9y.d(35):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnjo0ed9y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_clo\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpttf7zmby.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpttf7zmby.d(58): Error: semicolon expected,
    not `unittest`\n/tmp/tmpttf7zmby.d(58): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpttf7zmby.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    bool in_paren = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            paren_stack.push(i);\n            in_paren = true;\n      \
    \  }\n        else if(c == ')')\n        {\n            int paren_start = paren_stack.top();\n\
    \            int paren_end = i;\n            while(paren_stack.top() > paren_start)\n\
    \            {\n                paren_stack.pop();\n            }\n          \
    \  long paren_count = paren_stack.size();\n            long paren_level = paren_end\
    \ - paren_start;\n            long paren_level_diff = paren_count - paren_level;\n\
    \            if(paren_level_diff > 0)\n            {\n                for(int\
    \ j = paren_start; j < paren_end; j++)\n                {\n                  \
    \  result[j] += paren_level_diff;\n                }\n            }\n        \
    \    else\n            {\n                for(int j = paren_start; j < paren_end;\
    \ j++)\n                {\n                    result[j] += paren_count;\n   \
    \             }\n            }\n            in_paren = false;\n        }\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,parentheses,c++ |>\n\
    <| c |>\nThis code doesn't work for nested parentheses such as \"(()())\". It\
    \ returns \"[3, 1, 1, 3]\" instead of \"[3, 2, 2, 3]\".\n<|/ c |>\n<| c |>\nI\
    \ tested it and it works fine for me. Can you give an example where it doesn't\
    \ work?\n<|/ c |>\n<| c |>\nI tested it and it works fine for me. Can you give\
    \ an example where it doesn't work?\n<|/ c |>\n<| c |>\nI tested it and it works\
    \ fine for me. Can you give an example where it doesn't work?\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works fine for me. Can you give an example where it doesn't\
    \ work?\n<|/ c |>\n<| a tags=algorithm,parentheses,c++ |>\n<code>\n#include <iostream>\n\
    #include <stack>\n#include <string>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk79i2bl2.d(15): Error: found `>` when expecting `.` following
    int\n/tmp/tmpk79i2bl2.d(15): Error: found `>` when expecting `.` following int\n/tmp/tmpk79i2bl2.d(15):
    Error: found `(` when expecting identifier following `int`.\n/tmp/tmpk79i2bl2.d(15):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpk79i2bl2.d(15):
    Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpk79i2bl2.d(55):
    Error: declaration expected, not `<`\n/tmp/tmpk79i2bl2.d(58): Error: unterminated
    character constant\n/tmp/tmpk79i2bl2.d(61): Error: unterminated character constant\n/tmp/tmpk79i2bl2.d(64):
    Error: unterminated character constant\n/tmp/tmpk79i2bl2.d(67): Error: unterminated
    character constant\n/tmp/tmpk79i2bl2.d(70): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk79i2bl2.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long level_counter = 0;\n    long level_counters[] = new long[paren_string.length()];\n\
    \    long level_counters_index = 0;\n    long level_counters_index2 = 0;\n   \
    \ long level_counters_index3 = 0;\n    long level_counters_index4 = 0;\n    long\
    \ level_counters_index5 = 0;\n    long level_counters_index6 = 0;\n    long level_counters_index7\
    \ = 0;\n    long level_counters_index8 = 0;\n    long level_counters_index9 =\
    \ 0;\n    long level_counters_index10 = 0;\n    long level_counters_index11 =\
    \ 0;\n    long level_counters_index12 = 0;\n    long level_counters_index13 =\
    \ 0;\n    long level_counters_index14 = 0;\n    long level_counters_index15 =\
    \ 0;\n    long level_counters_index16 = 0;\n    long level_counters_index17 =\
    \ 0;\n    long level_counters_index18 = 0;\n    long level_counters_index19 =\
    \ 0;\n    long level_counters_index20 = 0;\n    long level_counters_index21 =\
    \ 0;\n    long level_counters_index22 = 0;\n    long level_counters_index23 =\
    \ 0;\n    long level_counters_index24 = 0;\n    long level_counters_index25 =\
    \ 0;\n    long level_counters_index26 = 0;\n    long level_counters_index27 =\
    \ 0;\n    long level_counters_index28 = 0;\n    long level_counters_index29 =\
    \ 0;\n    long level_counters_index30 = 0;\n    long level_counters_index31 =\
    \ 0;\n    long level_counters_index32 = 0;\n    long level_counters_index33 =\
    \ 0;\n    long level_counters_index34 = 0;\n    long level_counters_index35 =\
    \ 0;\n    long level_counters_index36 = 0;\n    long level_counters_index37 =\
    \ 0;\n    long level_counters_index38 = 0;\n    long level_counters_index39 =\
    \ 0;\n    long level_counters_index40 = 0;\n    long level_counters_index41 =\
    \ 0;\n    long level_counters_index42 = 0;\n    long level_counters_index43 =\
    \ 0;\n    long level_counters_index44 = 0;\n    long level_counters_index45 =\
    \ 0;\n    long level_counters_index46 = 0;\n    long level_counters_index47 =\
    \ 0;\n    long level_counters_index48 = 0;\n    long level_counters_index49 =\
    \ 0;\n    long level_counters_index50 = 0;\n    long level_counters_index51 =\
    \ 0;\n    long level_counters_index52 = 0;\n    long level_\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpntl0fdpe.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpntl0fdpe.d(18): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] level_counters`\n/tmp/tmpntl0fdpe.d(72):
    Error: semicolon expected, not `unittest`\n/tmp/tmpntl0fdpe.d(72): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntl0fdpe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long[] levels_stack = new long[paren_string.length()];\n\
    \    long[] levels_stack_reverse = new long[paren_string.length()];\n    long\
    \ level = 0;\n    long levels_stack_index = 0;\n    long levels_stack_reverse_index\
    \ = 0;\n    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_or_opening = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_opening_bracket = false;\n    bool\
    \ is_closing_bracket = false;\n    bool is_open\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiq4nuufh.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpiq4nuufh.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpiq4nuufh.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] levels = new long[paren_groups.size()];\n\
    \    long level = 0;\n    for(long i = 0; i < paren_groups.size(); ++i)\n    {\n\
    \        if(paren_groups[i] == '(')\n        {\n            level++;\n       \
    \ }\n        else if(paren_groups[i] == ')')\n        {\n            level--;\n\
    \        }\n        levels[i] = level;\n    }\n    return levels;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your answer! I tested your solution and it works\
    \ great! However, I still don't understand why my code doesn't work. Could you\
    \ please explain why my code doesn't work?\n<|/ c |>\n<| c |>\nI added some explanation\
    \ to the answer.\n<|/ c |>\n<| c |>\nThanks for your explanation! I understand\
    \ it now. :)\n<|/ c |>\n<| a tags=c#,algorithm,parentheses,string |>\n<code>\n\
    using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\
    using System.Text.RegularExpressions;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphjskoz24.d(31): Error: declaration expected, not `<`\n/tmp/tmphjskoz24.d(34):
    Error: unterminated character constant\n/tmp/tmphjskoz24.d(34): Error: unterminated
    character constant\n/tmp/tmphjskoz24.d(34): Error: unterminated character constant\n/tmp/tmphjskoz24.d(45):
    Error: semicolon expected, not `.`\n/tmp/tmphjskoz24.d(45): Error: no identifier
    for declarator `.Collections.Generic`\n/tmp/tmphjskoz24.d(46): Error: semicolon
    expected, not `.`\n/tmp/tmphjskoz24.d(46): Error: no identifier for declarator
    `.Linq`\n/tmp/tmphjskoz24.d(47): Error: semicolon expected, not `.`\n/tmp/tmphjskoz24.d(47):
    Error: no identifier for declarator `.Text`\n/tmp/tmphjskoz24.d(48): Error: semicolon
    expected, not `.`\n/tmp/tmphjskoz24.d(48): Error: no identifier for declarator
    `.Text.RegularExpressions`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphjskoz24.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(c == ')') {\n            level--;\n            if(level\
    \ == 0) {\n                level = levels[level];\n            }\n        }\n\
    \    }\n    for(int i = 0; i < levels.length; i++) {\n        if(levels[i] > max_level)\
    \ {\n            max_level = levels[i];\n        }\n    }\n    return max_level;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpieahkn6d.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpieahkn6d.d(37): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpieahkn6d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n        }\n        levels[i] = level;\n\
    \        if(level > max_level)\n        {\n            max_level = level;\n  \
    \      }\n    }\n    return levels;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThanks for your answer! I really appreciate it!\n<|/ c |>\n<| c\
    \ |>\nI added a solution that uses `std::stack` instead of `std::vector`\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I really appreciate it!\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI wrote a solution that uses std::stack to solve this problem:\n\
    <code>\n#include <iostream>\n#include <stack>\n#include <string>\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6khvmjsk.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp6khvmjsk.d(35): Error: declaration expected,
    not `<`\n/tmp/tmp6khvmjsk.d(56): Error: declaration expected, not `assert`\n/tmp/tmp6khvmjsk.d(57):
    Error: declaration expected, not `assert`\n/tmp/tmp6khvmjsk.d(58): Error: declaration
    expected, not `assert`\n/tmp/tmp6khvmjsk.d(59): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6khvmjsk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next_prev = 0;\n    long paren_level_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  \
    \  long paren_level_next_next_next_next_next_next_next_next_next_next_prev = 0;\n\
    \    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0024bogx.d(46): Error: semicolon expected, not `unittest`\n/tmp/tmp0024bogx.d(46):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0024bogx.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group = false;\n    bool in_paren_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_close = false;\n    bool\
    \ in_paren_group_open_close_group_open_close = false;\n    bool in_paren_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open = false;\n\
    \    bool in_paren_group_open_close_group_open_close_group_close = false;\n  \
    \  bool in_paren_group_open_close_group_open_close_group_open_close = false;\n\
    \    bool in_paren_group_open_close_group_open_close_group_open_close_group =\
    \ false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open\
    \ = false;\n    bool in_paren_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_open_close_group_close\
    \ = false;\n    bool in_paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoknhjq76.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpoknhjq76.d(46): Error: semicolon expected,
    not `unittest`\n/tmp/tmpoknhjq76.d(46): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoknhjq76.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_next2 = 0;\n    long paren_level_next3 = 0;\n    long paren_level_next4\
    \ = 0;\n    long paren_level_next5 = 0;\n    long paren_level_next6 = 0;\n   \
    \ long paren_level_next7 = 0;\n    long paren_level_next8 = 0;\n    long paren_level_next9\
    \ = 0;\n    long paren_level_next10 = 0;\n    long paren_level_next11 = 0;\n \
    \   long paren_level_next12 = 0;\n    long paren_level_next13 = 0;\n    long paren_level_next14\
    \ = 0;\n    long paren_level_next15 = 0;\n    long paren_level_next16 = 0;\n \
    \   long paren_level_next17 = 0;\n    long paren_level_next18 = 0;\n    long paren_level_next19\
    \ = 0;\n    long paren_level_next20 = 0;\n    long paren_level_next21 = 0;\n \
    \   long paren_level_next22 = 0;\n    long paren_level_next23 = 0;\n    long paren_level_next24\
    \ = 0;\n    long paren_level_next25 = 0;\n    long paren_level_next26 = 0;\n \
    \   long paren_level_next27 = 0;\n    long paren_level_next28 = 0;\n    long paren_level_next29\
    \ = 0;\n    long paren_level_next30 = 0;\n    long paren_level_next31 = 0;\n \
    \   long paren_level_next32 = 0;\n    long paren_level_next33 = 0;\n    long paren_level_next34\
    \ = 0;\n    long paren_level_next35 = 0;\n    long paren_level_next36 = 0;\n \
    \   long paren_level_next37 = 0;\n    long paren_level_next38 = 0;\n    long paren_level_next39\
    \ = 0;\n    long paren_level_next40 = 0;\n    long paren_level_next41 = 0;\n \
    \   long paren_level_next42 = 0;\n    long paren_level_next43 = 0;\n    long paren_level_next44\
    \ = 0;\n    long paren_level_next45 = 0;\n    long paren_level_next46 = 0;\n \
    \   long paren_level_next47 = 0;\n    long paren_level_next48 = 0;\n    long paren_level_next49\
    \ = 0;\n    long paren_level_next50 = 0;\n    long paren_level_next51 = 0;\n \
    \   long paren_level_next52 = 0;\n    long paren_level_next53 = 0;\n    long paren_level_next\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbqk1wxji.d(72): Error: semicolon expected, not `unittest`\n/tmp/tmpbqk1wxji.d(72):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbqk1wxji.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_bracket = false;\n    bool in_brace =\
    \ false;\n    bool in_string = false;\n    bool in_comment = false;\n    bool\
    \ in_string2 = false;\n    bool in_string3 = false;\n    bool in_string4 = false;\n\
    \    bool in_string5 = false;\n    bool in_string6 = false;\n    bool in_string7\
    \ = false;\n    bool in_string8 = false;\n    bool in_string9 = false;\n    bool\
    \ in_string10 = false;\n    bool in_string11 = false;\n    bool in_string12 =\
    \ false;\n    bool in_string13 = false;\n    bool in_string14 = false;\n    bool\
    \ in_string15 = false;\n    bool in_string16 = false;\n    bool in_string17 =\
    \ false;\n    bool in_string18 = false;\n    bool in_string19 = false;\n    bool\
    \ in_string20 = false;\n    bool in_string21 = false;\n    bool in_string22 =\
    \ false;\n    bool in_string23 = false;\n    bool in_string24 = false;\n    bool\
    \ in_string25 = false;\n    bool in_string26 = false;\n    bool in_string27 =\
    \ false;\n    bool in_string28 = false;\n    bool in_string29 = false;\n    bool\
    \ in_string30 = false;\n    bool in_string31 = false;\n    bool in_string32 =\
    \ false;\n    bool in_string33 = false;\n    bool in_string34 = false;\n    bool\
    \ in_string35 = false;\n    bool in_string36 = false;\n    bool in_string37 =\
    \ false;\n    bool in_string38 = false;\n    bool in_string39 = false;\n    bool\
    \ in_string40 = false;\n    bool in_string41 = false;\n    bool in_string42 =\
    \ false;\n    bool in_string43 = false;\n    bool in_string44 = false;\n    bool\
    \ in_string45 = false;\n    bool in_string46 = false;\n    bool in_string47 =\
    \ false;\n    bool in_string48 = false;\n    bool in_string49 = false;\n    bool\
    \ in_string50 = false;\n    bool in_string51 = false;\n    bool in_string52 =\
    \ false;\n    bool in_string53 = false;\n    bool in_string54 = false;\n    bool\
    \ in_string55 = false;\n    bool in_string56 = false;\n    bool in_string57 =\
    \ false;\n    bool in_string58 = false;\n    bool in_string59 = false;\n    bool\
    \ in_string60 = false;\n    bool in_string61 = false;\n    bool in_string62 =\
    \ false;\n    bool in_string63 = false;\n    bool in_string64 = false;\n    bool\
    \ \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw8w3hrrf.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpw8w3hrrf.d(86): Error: no identifier for
    declarator `bool`\n/tmp/tmpw8w3hrrf.d(86): Error: found `unittest` instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8w3hrrf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_bracket = false;\n    bool in_brace =\
    \ false;\n    bool in_curly = false;\n    bool in_paren_group = false;\n    bool\
    \ in_bracket_group = false;\n    bool in_brace_group = false;\n    bool in_curly_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_bracket_group_open\
    \ = false;\n    bool in_brace_group_open = false;\n    bool in_curly_group_open\
    \ = false;\n    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed\
    \ = false;\n    bool in_brace_group_closed = false;\n    bool in_curly_group_closed\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_bracket_group_open_brace\
    \ = false;\n    bool in_brace_group_open_brace = false;\n    bool in_curly_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_curly_group_closed_brace\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_bracket_group_open_bracket\
    \ = false;\n    bool in_brace_group_open_bracket = false;\n    bool in_curly_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_curly_group_closed_bracket\
    \ = false;\n    bool in_paren_group_open_brace_group = false;\n    bool in_bracket_group_open_brace_group\
    \ = false;\n    bool in_brace_group_open_brace_group = false;\n    bool in_curly_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_curly_group_closed_brace_group\
    \ = false;\n    bool in_paren_group_open_brace_group_open = false;\n    bool in_bracket_group_open_brace_group_open\
    \ = false;\n    bool in_brace_group_open_brace_group_open = false;\n    bool in_curly_group_open_brace_group_open\
    \ = false;\n    bool in_paren_group_close\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq6xfijr3.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpq6xfijr3.d(62): Error: semicolon expected,
    not `unittest`\n/tmp/tmpq6xfijr3.d(62): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6xfijr3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    bool is_open = true;\n    bool is_closed\
    \ = true;\n    bool is_open2 = true;\n    bool is_closed2 = true;\n    bool is_open3\
    \ = true;\n    bool is_closed3 = true;\n    bool is_open4 = true;\n    bool is_closed4\
    \ = true;\n    bool is_open5 = true;\n    bool is_closed5 = true;\n    bool is_open6\
    \ = true;\n    bool is_closed6 = true;\n    bool is_open7 = true;\n    bool is_closed7\
    \ = true;\n    bool is_open8 = true;\n    bool is_closed8 = true;\n    bool is_open9\
    \ = true;\n    bool is_closed9 = true;\n    bool is_open10 = true;\n    bool is_closed10\
    \ = true;\n    bool is_open11 = true;\n    bool is_closed11 = true;\n    bool\
    \ is_open12 = true;\n    bool is_closed12 = true;\n    bool is_open13 = true;\n\
    \    bool is_closed13 = true;\n    bool is_open14 = true;\n    bool is_closed14\
    \ = true;\n    bool is_open15 = true;\n    bool is_closed15 = true;\n    bool\
    \ is_open16 = true;\n    bool is_closed16 = true;\n    bool is_open17 = true;\n\
    \    bool is_closed17 = true;\n    bool is_open18 = true;\n    bool is_closed18\
    \ = true;\n    bool is_open19 = true;\n    bool is_closed19 = true;\n    bool\
    \ is_open20 = true;\n    bool is_closed20 = true;\n    bool is_open21 = true;\n\
    \    bool is_closed21 = true;\n    bool is_open22 = true;\n    bool is_closed22\
    \ = true;\n    bool is_open23 = true;\n    bool is_closed23 = true;\n    bool\
    \ is_open24 = true;\n    bool is_closed24 = true;\n    bool is_open25 = true;\n\
    \    bool is_closed25 = true;\n    bool is_open26 = true;\n    bool is_closed26\
    \ = true;\n    bool is_open27 = true;\n    bool is_closed27 = true;\n    bool\
    \ is_open28 = true;\n    bool is_closed28 = true;\n    bool is_open29 = true;\n\
    \    bool is_closed29 = true;\n    bool is_open30 = true;\n    bool is_closed30\
    \ = true;\n    bool is_open31 = true;\n    bool is_closed31 = true;\n    bool\
    \ is_open32 = true;\n    bool is_closed32 = true;\n    bool is_open33 = true;\n\
    \    bool is_closed33 = true;\n    bool is_open34 = true;\n    bool is_closed34\
    \ = true;\n    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7414cpyl.d(87): Error: semicolon expected, not `unittest`\n/tmp/tmp7414cpyl.d(87):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp7414cpyl.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_or_closing = false;\n\
    \    bool is_opening_or_closing_or_open = false;\n    bool is_opening_or_closing_or_closed\
    \ = false;\n    bool is_opening_or_closing_or_opening = false;\n    bool is_opening_or_closing_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing = false;\n  \
    \  bool is_opening_or_closing_or_opening_or_closing_or_opening = false;\n    bool\
    \ is_opening_or_closing_or_opening_or_closing_or_closed = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closed\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closed\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening\
    \ = false;\n    bool is_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_opening_or_closing_or_closed\
    \ = false;\n    bool is_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvd8rs5nf.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpvd8rs5nf.d(42): Error: semicolon expected,
    not `unittest`\n/tmp/tmpvd8rs5nf.d(42): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvd8rs5nf.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_prev = 0;\n    long paren_level_next = 0;\n    long\
    \ paren_level_max = 0;\n    long paren_level_max_prev = 0;\n    long paren_level_max_next\
    \ = 0;\n    long paren_level_max_max = 0;\n    long paren_level_max_max_prev =\
    \ 0;\n    long paren_level_max_max_next = 0;\n    long paren_level_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_prev = 0;\n    long paren_level_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n    long paren_level_max_max_max_max_next = 0;\n    long paren_level_max_max_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_max_prev = 0;\n    long paren_level_max_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n    long paren_level_max_max_max_max_next = 0;\n    long paren_level_max_max_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_max_prev = 0;\n    long paren_level_max_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n    long paren_level_max_max_max_max_next = 0;\n    long paren_level_max_max_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_max_prev = 0;\n    long paren_level_max_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n    long paren_level_max_max_max_max_next = 0;\n    long paren_level_max_max_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_max_prev = 0;\n    long paren_level_max_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n    long paren_level_max_max_max_max_next = 0;\n    long paren_level_max_max_max_max_max\
    \ = 0;\n    long paren_level_max_max_max_max_prev = 0;\n    long paren_level_max_max_max_max_next\
    \ = 0;\n    long paren_level_max_max_max_max_max = 0;\n    long paren_level_max_max_max_max_prev\
    \ = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpau6ke3iv.d(61): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpau6ke3iv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string current_paren_string = paren_string;\n    for(long i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            level++;\n            levels[level] = level;\n        }\n \
    \       else if(c == ')')\n        {\n            level--;\n            if(level\
    \ == 0)\n            {\n                levels[level] = level;\n            }\n\
    \        }\n    }\n    for(long i = 0; i < levels.length; i++)\n    {\n      \
    \  if(levels[i] > max_level)\n        {\n            max_level = levels[i];\n\
    \        }\n    }\n    long[] result = new long[max_level + 1];\n    for(long\
    \ i = 0; i < levels.length; i++)\n    {\n        result[levels[i]] = levels[i];\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work. Try it on \"(()()) ((())) () ((())()())\"\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it on \"(()()) ((())) () ((())()())\"\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it on \"(()()) ((())) () ((())()())\"\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it on \"(()()) ((())) () ((())()())\"\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it on \"(()()) ((())) () ((())()())\"\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.List;\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5te3s2co.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp5te3s2co.d(49): Error: declaration expected,
    not `<`\n/tmp/tmp5te3s2co.d(52): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5te3s2co.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_parens = false;\n    bool in_parens_group = false;\n    bool in_parens_group_open\
    \ = false;\n    bool in_parens_group_close = false;\n    bool in_parens_group_open_brace\
    \ = false;\n    bool in_parens_group_close_brace = false;\n    bool in_parens_group_open_brace_close\
    \ = false;\n    bool in_parens_group_close_brace_close = false;\n    bool in_parens_group_open_brace_close_brace\
    \ = false;\n    bool in_parens_group_close_brace_close_brace = false;\n    bool\
    \ in_parens_group_open_brace_close_brace_close = false;\n    bool in_parens_group_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_open_brace_close_brace_close_brace = false;\n\
    \    bool in_parens_group_close_brace_close_brace_close_brace = false;\n    bool\
    \ in_parens_group_open_brace_close_brace_close_brace_close = false;\n    bool\
    \ in_parens_group_close_brace_close_brace_close_brace_close = false;\n    bool\
    \ in_parens_group_open_brace_close_brace_close_brace_close_brace = false;\n  \
    \  bool in_parens_group_close_brace_close_brace_close_brace_close = false;\n \
    \   bool in_parens_group_open_brace_close_brace_close_brace_close_brace = false;\n\
    \    bool in_parens_group_close_brace_close_brace_close_brace_close = false;\n\
    \    bool in_parens_group_open_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_open_brace_close_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_parens_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_open_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_close_brace_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_parens_group_open_brace_close_bra\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfeexvzt7.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpfeexvzt7.d(44): Error: semicolon expected,
    not `unittest`\n/tmp/tmpfeexvzt7.d(44): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfeexvzt7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool is_open\
    \ = true;\n    bool is_closed = false;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        char c = paren_string[i];\n        if(c == '(') {\n        \
    \    if(!is_open) {\n                levels[level] = level;\n                is_open\
    \ = true;\n                level++;\n            }\n        } else if(c == ')')\
    \ {\n            if(!is_closed) {\n                levels[level] = level;\n  \
    \              is_closed = true;\n                level--;\n            }\n  \
    \      } else {\n            levels[level] = level;\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    return levels;\n}\n</code>\n\
    <|/ a tags=algorithm,c++,parentheses |>\n<| a tags=algorithm,c++,parentheses |>\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n\
    using namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_u9r0v0k.d(40): Error: declaration expected, not `<`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u9r0v0k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_prev = 0;\n    bool\
    \ is_first = true;\n    bool is_last = true;\n    bool is_first_paren = true;\n\
    \    bool is_last_paren = true;\n    bool is_first_paren_prev = true;\n    bool\
    \ is_last_paren_prev = true;\n    bool is_last_paren_prev = false;\n    bool is_last_paren_prev2\
    \ = false;\n    bool is_last_paren_prev3 = false;\n    bool is_last_paren_prev4\
    \ = false;\n    bool is_last_paren_prev5 = false;\n    bool is_last_paren_prev6\
    \ = false;\n    bool is_last_paren_prev7 = false;\n    bool is_last_paren_prev8\
    \ = false;\n    bool is_last_paren_prev9 = false;\n    bool is_last_paren_prev10\
    \ = false;\n    bool is_last_paren_prev11 = false;\n    bool is_last_paren_prev12\
    \ = false;\n    bool is_last_paren_prev13 = false;\n    bool is_last_paren_prev14\
    \ = false;\n    bool is_last_paren_prev15 = false;\n    bool is_last_paren_prev16\
    \ = false;\n    bool is_last_paren_prev17 = false;\n    bool is_last_paren_prev18\
    \ = false;\n    bool is_last_paren_prev19 = false;\n    bool is_last_paren_prev20\
    \ = false;\n    bool is_last_paren_prev21 = false;\n    bool is_last_paren_prev22\
    \ = false;\n    bool is_last_paren_prev23 = false;\n    bool is_last_paren_prev24\
    \ = false;\n    bool is_last_paren_prev25 = false;\n    bool is_last_paren_prev26\
    \ = false;\n    bool is_last_paren_prev27 = false;\n    bool is_last_paren_prev28\
    \ = false;\n    bool is_last_paren_prev29 = false;\n    bool is_last_paren_prev30\
    \ = false;\n    bool is_last_paren_prev31 = false;\n    bool is_last_paren_prev32\
    \ = false;\n    bool is_last_paren_prev33 = false;\n    bool is_last_paren_prev34\
    \ = false;\n    bool is_last_paren_prev35 = false;\n    bool is_last_paren_prev36\
    \ = false;\n    bool is_last_paren_prev37 = false;\n    bool is_last_paren_prev38\
    \ = false;\n    bool is_last_paren_prev39 = false;\n    bool is_last_paren_prev40\
    \ = false;\n    bool is_last_paren_prev41 = false;\n    bool is_last_paren_prev42\
    \ = false;\n    bool is_last_paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpns63tori.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpns63tori.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpns63tori.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string;\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] levels_stack\
    \ = new long[paren_groups.length()];\n    long[] levels_stack_pos = new long[paren_groups.length()];\n\
    \    bool has_left_paren = false;\n    bool has_right_paren = false;\n    bool\
    \ has_left_bracket = false;\n    bool has_right_bracket = false;\n    bool has_left_curly\
    \ = false;\n    bool has_right_curly = false;\n    bool has_left_brace = false;\n\
    \    bool has_right_brace = false;\n    bool has_left_bracket = false;\n    bool\
    \ has_right_bracket = false;\n    bool has_left_curly = false;\n    bool has_right_curly\
    \ = false;\n    bool has_left_brace = false;\n    bool has_right_brace = false;\n\
    \    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n   \
    \ bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool has_left_brace\
    \ = false;\n    bool has_right_brace = false;\n    bool has_left_bracket = false;\n\
    \    bool has_right_bracket = false;\n    bool has_left_curly = false;\n    bool\
    \ has_right_curly = false;\n    bool has_left_brace = false;\n    bool has_right_brace\
    \ = false;\n    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n\
    \    bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool\
    \ has_left_brace = false;\n    bool has_right_brace = false;\n    bool has_left_bracket\
    \ = false;\n    bool has_right_bracket = false;\n    bool has_left_curly = false;\n\
    \    bool has_right_curly = false;\n    bool has_left_brace = false;\n    bool\
    \ has_right_brace = false;\n    bool has_left_bracket = false;\n    bool has_right_bracket\
    \ = false;\n    bool has_left_curly = false;\n    bool has_right_curly = false;\n\
    \    bool has_left_brace = false;\n    bool has_right_brace = false;\n    bool\
    \ has_left_bracket = false;\n    bool has_right_bracket = false;\n    bool has_left_curly\
    \ = false;\n    bool has_right_curly = false;\n    bool has_left_brace = false;\n\
    \    bool has_right_brace = false;\n    bool has_left_bracket = false;\n    bool\
    \ has_right_bracket = false;\n    bool has_left_curly = false;\n    bool has_right_curly\
    \ = false;\n    bool has_left_brace = false;\n    bool has_right_brace = false;\n\
    \    bool has_left_bracket = false;\n    bool has_right_bracket = false;\n   \
    \ bool has_left_curly = false;\n    bool has_right_curly = false;\n    bool \n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnxhh42yn.d(80): Error: no identifier for declarator `bool`\n/tmp/tmpnxhh42yn.d(80):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpnxhh42yn.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            level++;\n            levels[i] = level;\n        } else\
    \ if(paren_string[i] == ')') {\n            level--;\n            if(level < 0)\
    \ {\n                throw new RuntimeException(\"Unbalanced parenthesis\");\n\
    \            }\n            levels[i] = level;\n        } else {\n           \
    \ levels[i] = level;\n        }\n        if(level > max_level) {\n           \
    \ max_level = level;\n        }\n    }\n    return levels;\n}\n</code>\n<|/ a\
    \ tags=algorithm,java,string |>\n<| a tags=algorithm,java,string |>\n<code>\n\
    import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcvts_tg5.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpcvts_tg5.d(36): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvts_tg5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels_of_nesting = new\
    \ long[paren_groups.length()];\n    long[] levels_of_nesting = new long[paren_groups.length()];\n\
    \    long[] levels_of_nesting_count = new long[paren_groups.length()];\n    long\
    \ current_level = 0;\n    long current_level_of_nesting = 0;\n    long current_level_of_nesting_count\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group = 0;\n    long\
    \ current_level_of_nesting_count_in_paren_group_with_paren = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_one\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_two\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_three\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_four\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_five\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_six\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_seven\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_eight\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_nine\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_ten\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_eleven\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_twelve\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_thirteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_fourteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_fifteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_sixteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_seventeen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_eighteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_nineteen\
    \ = 0;\n    long current_level_of_nesting_count_in_paren_group_with_paren_plus_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxvfnpv57.d(43): Error: semicolon expected, not `unittest`\n/tmp/tmpxvfnpv57.d(43):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpxvfnpv57.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_open\
    \ = false;\n    bool is_opening_closed = false;\n    bool is_closing_open = false;\n\
    \    bool is_closing_closed = false;\n    bool is_opening_opening_open = false;\n\
    \    bool is_opening_opening_closed = false;\n    bool is_opening_closing_open\
    \ = false;\n    bool is_opening_closing_closed = false;\n    bool is_closing_opening_open\
    \ = false;\n    bool is_closing_opening_closed = false;\n    bool is_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    bool is_closing_closing_opening_closed = false;\n    bool is_closing_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpngtvn2lv.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpngtvn2lv.d(63): Error: semicolon expected,
    not `unittest`\n/tmp/tmpngtvn2lv.d(63): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpngtvn2lv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3kcggpac.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp3kcggpac.d(62): Error: semicolon expected,
    not `unittest`\n/tmp/tmp3kcggpac.d(62): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kcggpac.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long index2 = 0;\n    bool in_paren = false;\n    bool\
    \ in_paren2 = false;\n    bool in_paren3 = false;\n    bool in_paren4 = false;\n\
    \    bool in_paren5 = false;\n    bool in_paren6 = false;\n    bool in_paren7\
    \ = false;\n    bool in_paren8 = false;\n    bool in_paren9 = false;\n    bool\
    \ in_paren10 = false;\n    bool in_paren11 = false;\n    bool in_paren12 = false;\n\
    \    bool in_paren13 = false;\n    bool in_paren14 = false;\n    bool in_paren15\
    \ = false;\n    bool in_paren16 = false;\n    bool in_paren17 = false;\n    bool\
    \ in_paren18 = false;\n    bool in_paren19 = false;\n    bool in_paren20 = false;\n\
    \    bool in_paren21 = false;\n    bool in_paren22 = false;\n    bool in_paren23\
    \ = false;\n    bool in_paren24 = false;\n    bool in_paren25 = false;\n    bool\
    \ in_paren26 = false;\n    bool in_paren27 = false;\n    bool in_paren28 = false;\n\
    \    bool in_paren29 = false;\n    bool in_paren30 = false;\n    bool in_paren31\
    \ = false;\n    bool in_paren32 = false;\n    bool in_paren33 = false;\n    bool\
    \ in_paren34 = false;\n    bool in_paren35 = false;\n    bool in_paren36 = false;\n\
    \    bool in_paren37 = false;\n    bool in_paren38 = false;\n    bool in_paren39\
    \ = false;\n    bool in_paren40 = false;\n    bool in_paren41 = false;\n    bool\
    \ in_paren42 = false;\n    bool in_paren43 = false;\n    bool in_paren44 = false;\n\
    \    bool in_paren45 = false;\n    bool in_paren46 = false;\n    bool in_paren47\
    \ = false;\n    bool in_paren48 = false;\n    bool in_paren49 = false;\n    bool\
    \ in_paren50 = false;\n    bool in_paren51 = false;\n    bool in_paren52 = false;\n\
    \    bool in_paren53 = false;\n    bool in_paren54 = false;\n    bool in_paren55\
    \ = false;\n    bool in_paren56 = false;\n    bool in_paren57 = false;\n    bool\
    \ in_paren58 = false;\n    bool in_paren59 = false;\n    bool in_paren60 = false;\n\
    \    bool in_paren61 = false;\n    bool in_paren62 = false;\n    bool in_paren63\
    \ = false;\n    bool in_paren64 = false;\n    bool in_paren65 = false;\n    bool\
    \ in_paren66 = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps5b6k6_j.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmps5b6k6_j.d(86): Error: no identifier for
    declarator `bool`\n/tmp/tmps5b6k6_j.d(86): Error: found `unittest` instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5b6k6_j.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace\
    \ = false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close = false;\n    bool\
    \ in_paren_group_open_brace_close_close_close = false;\n    bool in_paren_group_close_brace_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close = false;\n\
    \    bool in_paren_group_close_brace_close_close_close_close = false;\n    bool\
    \ in_paren_group_open_brace_close_close_close_close_close = false;\n    bool in_paren_group_close_brace_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_close_brace_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    bool in_paren_group_open_brace_close_close_close_close_close_close_close_close_close_close_close_close_close_close\
    \ = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphczlp4xk.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmphczlp4xk.d(47): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphczlp4xk.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n            if(level > max_level)\n\
    \                max_level = level;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n            if(level < 0)\n      \
    \          level = 0;\n        }\n        levels[i] = level;\n    }\n    return\
    \ levels;\n}\n</code>\n<|/ a tags=algorithm,c++,parentheses,string |>\n<| a tags=algorithm,c++,parentheses,string\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <vector>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptsp8cnje.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmptsp8cnje.d(35): Error: declaration expected,
    not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsp8cnje.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_curly_bracket = false;\n\
    \    bool is_closing_curly_bracket = false;\n    bool is_opening_square_bracket\
    \ = false;\n    bool is_closing_square_bracket = false;\n    bool is_opening_curly_brace\
    \ = false;\n    bool is_closing_curly_brace = false;\n    bool is_opening_square_brace\
    \ = false;\n    bool is_closing_square_brace = false;\n    bool is_opening_angle\
    \ = false;\n    bool is_closing_angle = false;\n    bool is_opening_square_angle\
    \ = false;\n    bool is_closing_square_angle = false;\n    bool is_opening_plus\
    \ = false;\n    bool is_closing_plus = false;\n    bool is_opening_minus = false;\n\
    \    bool is_closing_minus = false;\n    bool is_opening_comma = false;\n    bool\
    \ is_closing_comma = false;\n    bool is_opening_colon = false;\n    bool is_closing_colon\
    \ = false;\n    bool is_opening_semicolon = false;\n    bool is_closing_semicolon\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_curly_brace = false;\n    bool is_closing_curly_brace\
    \ = false;\n    bool is_opening_square_brace = false;\n    bool is_closing_square_brace\
    \ = false;\n    bool is_opening_angle = false;\n    bool is_closing_angle = false;\n\
    \    bool is_opening_square_angle = false;\n    bool is_closing_square_angle =\
    \ false;\n    bool is_opening_plus = false;\n    bool is_closing_plus = false;\n\
    \    bool is_opening_minus = false;\n    bool is_closing_minus = false;\n    bool\
    \ is_opening_comma = false;\n    bool is_closing_comma = false;\n    bool is_opening_colon\
    \ = false;\n    bool is_closing_colon = false;\n    bool is_opening_semicolon\
    \ = false;\n    bool is_closing_semicolon = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_curly_bracket\
    \ = false;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps2wdcjgx.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmps2wdcjgx.d(73): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2wdcjgx.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long max_level = 0;\n    long level = 0;\n    long level_counter = 0;\n \
    \   long level_counter2 = 0;\n    long level_counter3 = 0;\n    long level_counter4\
    \ = 0;\n    long level_counter5 = 0;\n    long level_counter6 = 0;\n    long level_counter7\
    \ = 0;\n    long level_counter8 = 0;\n    long level_counter9 = 0;\n    long level_counter10\
    \ = 0;\n    long level_counter11 = 0;\n    long level_counter12 = 0;\n    long\
    \ level_counter13 = 0;\n    long level_counter14 = 0;\n    long level_counter15\
    \ = 0;\n    long level_counter16 = 0;\n    long level_counter17 = 0;\n    long\
    \ level_counter18 = 0;\n    long level_counter19 = 0;\n    long level_counter20\
    \ = 0;\n    long level_counter21 = 0;\n    long level_counter22 = 0;\n    long\
    \ level_counter23 = 0;\n    long level_counter24 = 0;\n    long level_counter25\
    \ = 0;\n    long level_counter26 = 0;\n    long level_counter27 = 0;\n    long\
    \ level_counter28 = 0;\n    long level_counter29 = 0;\n    long level_counter30\
    \ = 0;\n    long level_counter31 = 0;\n    long level_counter32 = 0;\n    long\
    \ level_counter33 = 0;\n    long level_counter34 = 0;\n    long level_counter35\
    \ = 0;\n    long level_counter36 = 0;\n    long level_counter37 = 0;\n    long\
    \ level_counter38 = 0;\n    long level_counter39 = 0;\n    long level_counter40\
    \ = 0;\n    long level_counter41 = 0;\n    long level_counter42 = 0;\n    long\
    \ level_counter43 = 0;\n    long level_counter44 = 0;\n    long level_counter45\
    \ = 0;\n    long level_counter46 = 0;\n    long level_counter47 = 0;\n    long\
    \ level_counter48 = 0;\n    long level_counter49 = 0;\n    long level_counter50\
    \ = 0;\n    long level_counter51 = 0;\n    long level_counter52 = 0;\n    long\
    \ level_counter53 = 0;\n    long level_counter54 = 0;\n    long level_counter55\
    \ = 0;\n    long level_counter56 = 0;\n    long level_counter57 = 0;\n    long\
    \ level_counter58 = 0;\n    long level_counter59 = 0;\n    long level_counter60\
    \ = 0;\n    long level_counter61 = 0;\n    long level_counter62 = 0;\n    long\
    \ level_counter63 = 0;\n    long level_counter64 = 0;\n    long level_counter65\
    \ = 0;\n    long level_counter66 = 0;\n    long level_counter67 = 0;\n    long\
    \ level_counter68 = 0;\n    long \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgls41q2d.d(87): Error: no identifier for declarator `long`\n/tmp/tmpgls41q2d.d(87):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpgls41q2d.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly = false;\n    bool is_closing_curly = false;\n    bool is_opening_square\
    \ = false;\n    bool is_closing_square = false;\n    bool is_opening_curly_square\
    \ = false;\n    bool is_closing_curly_square = false;\n    bool is_opening_paren_curly\
    \ = false;\n    bool is_closing_paren_curly = false;\n    bool is_opening_paren_square\
    \ = false;\n    bool is_closing_paren_square = false;\n    bool is_opening_curly_paren\
    \ = false;\n    bool is_closing_curly_paren = false;\n    bool is_opening_curly_curly\
    \ = false;\n    bool is_closing_curly_curly = false;\n    bool is_opening_square_curly\
    \ = false;\n    bool is_closing_square_curly = false;\n    bool is_opening_paren_curly_square\
    \ = false;\n    bool is_closing_paren_curly_square = false;\n    bool is_opening_paren_square_curly\
    \ = false;\n    bool is_closing_paren_square_curly = false;\n    bool is_opening_curly_paren_square\
    \ = false;\n    bool is_closing_curly_paren_square = false;\n    bool is_opening_square_paren_square\
    \ = false;\n    bool is_closing_square_paren_square = false;\n    bool is_opening_paren_curly_curly_square\
    \ = false;\n    bool is_closing_paren_curly_curly_square = false;\n    bool is_opening_paren_square_curly_square\
    \ = false;\n    bool is_closing_paren_square_curly_square = false;\n    bool is_opening_curly_curly_paren_square\
    \ = false;\n    bool is_closing_curly_curly_paren_square = false;\n    bool is_opening_square_curly_paren_square\
    \ = false;\n    bool is_closing_square_curly_paren_square = false;\n    bool is_opening_paren_curly_curly_paren_square\
    \ = false;\n    bool is_closing_paren_curly_curly_paren_square = false;\n    bool\
    \ is_opening_paren_square_curly_paren_square = false;\n    bool is_closing_paren_square_curly_paren_square\
    \ = false;\n    bool is_opening_curly_curly_curly_paren_square = false;\n    bool\
    \ is_closing_curly_curly_curly_paren_square = false;\n    bool is_opening_square_curly_curly_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphvm7l611.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmphvm7l611.d(61): Error: semicolon expected,
    not `unittest`\n/tmp/tmphvm7l611.d(61): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvm7l611.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_group;\n    long[] levels;\n    levels = new long[paren_string.length()];\n\
    \    long level = 0;\n    long max_level = 0;\n    bool in_paren = false;\n  \
    \  bool in_group = false;\n    bool in_group2 = false;\n    bool in_group3 = false;\n\
    \    bool in_group4 = false;\n    bool in_group5 = false;\n    bool in_group6\
    \ = false;\n    bool in_group7 = false;\n    bool in_group8 = false;\n    bool\
    \ in_group9 = false;\n    bool in_group10 = false;\n    bool in_group11 = false;\n\
    \    bool in_group12 = false;\n    bool in_group13 = false;\n    bool in_group14\
    \ = false;\n    bool in_group15 = false;\n    bool in_group16 = false;\n    bool\
    \ in_group17 = false;\n    bool in_group18 = false;\n    bool in_group19 = false;\n\
    \    bool in_group20 = false;\n    bool in_group21 = false;\n    bool in_group22\
    \ = false;\n    bool in_group23 = false;\n    bool in_group24 = false;\n    bool\
    \ in_group25 = false;\n    bool in_group26 = false;\n    bool in_group27 = false;\n\
    \    bool in_group28 = false;\n    bool in_group29 = false;\n    bool in_group30\
    \ = false;\n    bool in_group31 = false;\n    bool in_group32 = false;\n    bool\
    \ in_group33 = false;\n    bool in_group34 = false;\n    bool in_group35 = false;\n\
    \    bool in_group36 = false;\n    bool in_group37 = false;\n    bool in_group38\
    \ = false;\n    bool in_group39 = false;\n    bool in_group40 = false;\n    bool\
    \ in_group41 = false;\n    bool in_group42 = false;\n    bool in_group43 = false;\n\
    \    bool in_group44 = false;\n    bool in_group45 = false;\n    bool in_group46\
    \ = false;\n    bool in_group47 = false;\n    bool in_group48 = false;\n    bool\
    \ in_group49 = false;\n    bool in_group50 = false;\n    bool in_group51 = false;\n\
    \    bool in_group52 = false;\n    bool in_group53 = false;\n    bool in_group54\
    \ = false;\n    bool in_group55 = false;\n    bool in_group56 = false;\n    bool\
    \ in_group57 = false;\n    bool in_group58 = false;\n    bool in_group59 = false;\n\
    \    bool in_group60 = false;\n    bool in_group61 = false;\n    bool in_group62\
    \ = false;\n    bool in_group63 = false;\n    bool in_group64 = false;\n    bool\
    \ in_group65 = false;\n    bool in_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprmpt33_k.d(86): Error: semicolon expected, not `unittest`\n/tmp/tmprmpt33_k.d(86):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprmpt33_k.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string paren_char;\n    long\
    \ level = 0;\n    long level_count = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_count = 0;\n    \nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9w5sn7e.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9w5sn7e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_count = 0;\n    long paren_level = 0;\n    long[]\
    \ paren_levels = new long[MAX_NESTING];\n    paren_stack = paren_string;\n   \
    \ while(true)\n    {\n        paren_stack = paren_stack.substr(0, paren_stack.size()\
    \ - 1);\n        if(paren_stack.size() == 0)\n            break;\n        string\
    \ paren_char = paren_stack[paren_stack.size() - 1];\n        if(paren_char ==\
    \ \"(\")\n        {\n            paren_count++;\n            paren_level++;\n\
    \            paren_levels[paren_level] = paren_count;\n        }\n        else\
    \ if(paren_char == \")\")\n        {\n            paren_count--;\n           \
    \ paren_level--;\n            if(paren_count < 0)\n            {\n           \
    \     throw new Exception(\"Invalid parenthesis string\");\n            }\n  \
    \          paren_levels[paren_level] = paren_count;\n        }\n        else if(paren_char\
    \ == \" \")\n        {\n            paren_stack = paren_stack.substr(0, paren_stack.size()\
    \ - 1);\n        }\n        else\n        {\n            throw new Exception(\"\
    Invalid parenthesis string\");\n        }\n    }\n    return paren_levels;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8jout2yw.d(17): Error: undefined identifier `MAX_NESTING`\n/tmp/tmp8jout2yw.d(21):
    Error: no property `substr` for type `string`\n/tmp/tmp8jout2yw.d(22): Error:
    no property `size` for type `string`\n/tmp/tmp8jout2yw.d(24): Error: no property
    `size` for type `string`\n/tmp/tmp8jout2yw.d(43): Error: no property `substr`
    for type `string`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8jout2yw.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_group = false;\n    bool in_group2 = false;\n    bool\
    \ in_group3 = false;\n    bool in_group4 = false;\n    bool in_group5 = false;\n\
    \    bool in_group6 = false;\n    bool in_group7 = false;\n    bool in_group8\
    \ = false;\n    bool in_group9 = false;\n    bool in_group10 = false;\n    bool\
    \ in_group11 = false;\n    bool in_group12 = false;\n    bool in_group13 = false;\n\
    \    bool in_group14 = false;\n    bool in_group15 = false;\n    bool in_group16\
    \ = false;\n    bool in_group17 = false;\n    bool in_group18 = false;\n    bool\
    \ in_group19 = false;\n    bool in_group20 = false;\n    bool in_group21 = false;\n\
    \    bool in_group22 = false;\n    bool in_group23 = false;\n    bool in_group24\
    \ = false;\n    bool in_group25 = false;\n    bool in_group26 = false;\n    bool\
    \ in_group27 = false;\n    bool in_group28 = false;\n    bool in_group29 = false;\n\
    \    bool in_group30 = false;\n    bool in_group31 = false;\n    bool in_group32\
    \ = false;\n    bool in_group33 = false;\n    bool in_group34 = false;\n    bool\
    \ in_group35 = false;\n    bool in_group36 = false;\n    bool in_group37 = false;\n\
    \    bool in_group38 = false;\n    bool in_group39 = false;\n    bool in_group40\
    \ = false;\n    bool in_group41 = false;\n    bool in_group42 = false;\n    bool\
    \ in_group43 = false;\n    bool in_group44 = false;\n    bool in_group45 = false;\n\
    \    bool in_group46 = false;\n    bool in_group47 = false;\n    bool in_group48\
    \ = false;\n    bool in_group49 = false;\n    bool in_group50 = false;\n    bool\
    \ in_group51 = false;\n    bool in_group52 = false;\n    bool in_group53 = false;\n\
    \    bool in_group54 = false;\n    bool in_group55 = false;\n    bool in_group56\
    \ = false;\n    bool in_group57 = false;\n    bool in_group58 = false;\n    bool\
    \ in_group59 = false;\n    bool in_group60 = false;\n    bool in_group61 = false;\n\
    \    bool in_group62 = false;\n    bool in_group63 = false;\n    bool in_group64\
    \ = false;\n    bool in_group65 = false;\n    bool in_group66 = false;\n    bool\
    \ in_group67 = false;\n    bool in_group68 = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpztiyaih3.d(85): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztiyaih3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    while(i < paren_string.length())\n    {\n        char c\
    \ = paren_string[i];\n        if(c == '(')\n        {\n            level++;\n\
    \            levels[i++] = level;\n        }\n        else if(c == ')')\n    \
    \    {\n            level--;\n            levels[i++] = level;\n        }\n  \
    \      i++;\n    }\n    for(int j = 0; j < levels.length; j++)\n    {\n      \
    \  if(levels[j] > max_level)\n        {\n            max_level = levels[j];\n\
    \        }\n    }\n    return max_level;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa7w6siuw.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpa7w6siuw.d(16): Error: no property `length`
    for type `string`\n/tmp/tmpa7w6siuw.d(18): Error: no property `length` for type
    `string`\n/tmp/tmpa7w6siuw.d(40): Error: cannot implicitly convert expression
    `max_level` of type `long` to `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpa7w6siuw.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack;\n    long paren_level = 0;\n    long paren_nesting = 0;\n    long[]\
    \ levels = new long[paren_string.length()];\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if(c == '(')\n     \
    \   {\n            paren_stack = paren_stack + c;\n            paren_nesting++;\n\
    \        }\n        else if(c == ')')\n        {\n            paren_nesting--;\n\
    \            if(paren_nesting == 0)\n            {\n                levels[i]\
    \ = paren_level;\n                paren_level++;\n            }\n        }\n \
    \   }\n    return levels;\n}\n</code>\n<|/ a tags=string,algorithm,c# |>\n<| c\
    \ |>\nThis code doesn't work. Try it on \"(()()) ()\" for example. It returns\
    \ [1L, 1L, 1L, 1L]\n<|/ c |>\n<| c |>\nYes, it does. I tested it on \"(()()) ()\"\
    \ which returns [1L, 1L, 1L, 1L]\n<|/ c |>\n<| c |>\nIt doesn't work for \"(()())\
    \ ()\" returns [1L, 1L, 1L, 1L]\n<|/ c |>\n<| c |>\nIt works for me. Are you sure\
    \ you copied the code correctly? I tested it on \"(()()) ()\" which returns [1L,\
    \ 1L, 1L, 1L]\n<|/ c |>\n<| c |>\nYes, I copied the code correctly. I'm running\
    \ it on \"(()()) ()\" which returns [1L, 1L, 1L, 1L]\n<|/ c |>\n<| a tags=string,algorithm,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Text.RegularExpressions;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4e62gkin.d(38): Error: declaration expected, not `<`\n/tmp/tmp4e62gkin.d(41):
    Error: unterminated character constant\n/tmp/tmp4e62gkin.d(47): Error: unterminated
    character constant\n/tmp/tmp4e62gkin.d(53): Error: unterminated character constant\n/tmp/tmp4e62gkin.d(58):
    Error: semicolon expected, not `.`\n/tmp/tmp4e62gkin.d(58): Error: no identifier
    for declarator `.Collections.Generic`\n/tmp/tmp4e62gkin.d(59): Error: semicolon
    expected, not `.`\n/tmp/tmp4e62gkin.d(59): Error: no identifier for declarator
    `.Linq`\n/tmp/tmp4e62gkin.d(60): Error: semicolon expected, not `.`\n/tmp/tmp4e62gkin.d(60):
    Error: no identifier for declarator `.Text`\n/tmp/tmp4e62gkin.d(61): Error: semicolon
    expected, not `.`\n/tmp/tmp4e62gkin.d(61): Error: no identifier for declarator
    `.Text.RegularExpressions`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4e62gkin.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim();\n    long[] max_levels = new long[paren_groups.length()];\n\
    \    long[] levels = new long[paren_groups.length()];\n    long[] current_levels\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index = new long[paren_groups.length()];\n\
    \    long[] current_levels_index2 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index3 = new long[paren_groups.length()];\n    long[] current_levels_index4\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index5 = new long[paren_groups.length()];\n\
    \    long[] current_levels_index6 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index7 = new long[paren_groups.length()];\n    long[] current_levels_index8\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index9 = new long[paren_groups.length()];\n\
    \    long[] current_levels_index10 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index11 = new long[paren_groups.length()];\n    long[] current_levels_index12\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index13 = new\
    \ long[paren_groups.length()];\n    long[] current_levels_index14 = new long[paren_groups.length()];\n\
    \    long[] current_levels_index15 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index16 = new long[paren_groups.length()];\n    long[] current_levels_index17\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index18 = new\
    \ long[paren_groups.length()];\n    long[] current_levels_index19 = new long[paren_groups.length()];\n\
    \    long[] current_levels_index20 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index21 = new long[paren_groups.length()];\n    long[] current_levels_index22\
    \ = new long[paren_groups.length()];\n    long[] current_levels_index23 = new\
    \ long[paren_groups.length()];\n    long[] current_levels_index24 = new long[paren_groups.length()];\n\
    \    long[] current_levels_index25 = new long[paren_groups.length()];\n    long[]\
    \ current_levels_index26 = new long[paren_groups.length()];\n    long[] current_levels_index27\
    \ = new long[paren_groups.length\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyd_6tv4s.d(45): Error: found `unittest` when expecting `]`\n/tmp/tmpyd_6tv4s.d(46):
    Error: semicolon expected, not `{`\n/tmp/tmpyd_6tv4s.d(53): Error: found `End
    of File` when expecting `}` following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpyd_6tv4s.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    stack<int> paren_stack = new\
    \ stack<int>();\n    bool in_paren = false;\n    bool in_group = false;\n    for(int\
    \ i = 0; i < paren_string.length(); i++) {\n        char c = paren_string[i];\n\
    \        if(c == '(') {\n            if(!in_paren) {\n                in_paren\
    \ = true;\n                paren_stack.push(i);\n            }\n        } else\
    \ if(c == ')') {\n            int j = paren_stack.top();\n            levels[j]\
    \ = levels[j-1] + 1;\n            paren_stack.pop();\n            if(!in_paren)\
    \ {\n                in_paren = true;\n                paren_stack.push(i);\n\
    \            }\n        } else if(c == ' ') {\n            if(!in_group) {\n \
    \               in_group = true;\n                levels[paren_stack.top()] =\
    \ 0;\n                paren_stack.pop();\n            }\n        } else {\n  \
    \          in_group = false;\n            in_paren = false;\n        }\n    }\n\
    \    return levels;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,parentheses,c++\
    \ |>\n<code>\n#include <iostream>\n#include <stack>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnyfel8eb.d(15): Error: found `>` when expecting `.` following
    int\n/tmp/tmpnyfel8eb.d(15): Error: found `>` when expecting `.` following int\n/tmp/tmpnyfel8eb.d(15):
    Error: found `(` when expecting identifier following `int`.\n/tmp/tmpnyfel8eb.d(15):
    Error: found `)` when expecting `;` following statement\n/tmp/tmpnyfel8eb.d(15):
    Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpnyfel8eb.d(46):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpnyfel8eb.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    long max_level_count = 0;\n    long max_level_length\
    \ = 0;\n    bool has_open = false;\n    bool has_close = false;\n    bool has_opening_paren\
    \ = false;\n    bool has_closing_paren = false;\n    bool has_opening_paren_or_close\
    \ = false;\n    bool has_closing_paren_or_open = false;\n    bool has_opening_paren_or_closing_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren = false;\n    bool has_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_close = false;\n  \
    \  bool has_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ has_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_close\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_close\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_close\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\n    bool has_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_close\
    \ = false;\n    bool has_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_open\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvghe5xkj.d(43): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvghe5xkj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    long max_level_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_or_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma = false;\n\
    \    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace = false;\n \
    \   bool in_paren_group_close_brace_or_comma_brace_or_comma_brace = false;\n \
    \   bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma_brace_or_comma\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr1e03pa7.d(42): Error: semicolon expected, not `unittest`\n/tmp/tmpr1e03pa7.d(42):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpr1e03pa7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n      \
    \  if(paren_string[i] == '(')\n        {\n            level++;\n            levels[level]\
    \ = level;\n            in_paren = true;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            level--;\n            if(level < 0)\n      \
    \      {\n                throw new Exception(\"Invalid paren string\");\n   \
    \         }\n            levels[level] = level;\n            in_paren = false;\n\
    \        }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpavvg45r0.d(14): Error: no property `length` for type `string`\n/tmp/tmpavvg45r0.d(17):
    Error: no property `length` for type `string`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpavvg45r0.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    long levels_size_index\
    \ = 0;\n    long levels_index2 = 0;\n    long levels_size_index2 = 0;\n    long\
    \ levels_index3 = 0;\n    long levels_size_index3 = 0;\n    long levels_index4\
    \ = 0;\n    long levels_size_index4 = 0;\n    long levels_index5 = 0;\n    long\
    \ levels_size_index5 = 0;\n    long levels_index6 = 0;\n    long levels_size_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_size_index7 = 0;\n    long\
    \ levels_index8 = 0;\n    long levels_size_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_size_index9 = 0;\n    long levels_index10 = 0;\n    long\
    \ levels_size_index10 = 0;\n    long levels_index11 = 0;\n    long levels_size_index11\
    \ = 0;\n    long levels_index12 = 0;\n    long levels_size_index12 = 0;\n    long\
    \ levels_index13 = 0;\n    long levels_size_index13 = 0;\n    long levels_index14\
    \ = 0;\n    long levels_size_index14 = 0;\n    long levels_index15 = 0;\n    long\
    \ levels_size_index15 = 0;\n    long levels_index16 = 0;\n    long levels_size_index16\
    \ = 0;\n    long levels_index17 = 0;\n    long levels_size_index17 = 0;\n    long\
    \ levels_index18 = 0;\n    long levels_size_index18 = 0;\n    long levels_index19\
    \ = 0;\n    long levels_size_index19 = 0;\n    long levels_index20 = 0;\n    long\
    \ levels_size_index20 = 0;\n    long levels_index21 = 0;\n    long levels_size_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_size_index22 = 0;\n    long\
    \ levels_index23 = 0;\n    long levels_size_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_size_index24 = 0;\n    long levels_index25 = 0;\n    long\
    \ levels_size_index25 = 0;\n    long levels_index26 = 0;\n    long levels_size_index26\
    \ = 0;\n    long levels_index27 = 0;\n    long levels_size_index27 = 0;\n    long\
    \ levels_index28 = 0;\n    long levels_size_index28 = 0;\n    long levels_index29\
    \ = 0;\n    long levels_size\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq20b92vi.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpq20b92vi.d(76): Error: semicolon expected,
    not `unittest`\n/tmp/tmpq20b92vi.d(76): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq20b92vi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long paren_index = 0;\n    long paren_level =\
    \ 0;\n    long paren_levels[] = new long[paren_string.length()];\n    long paren_levels_index\
    \ = 0;\n    long paren_levels_index2 = 0;\n    long paren_levels_index3 = 0;\n\
    \    long paren_levels_index4 = 0;\n    long paren_levels_index5 = 0;\n    long\
    \ paren_levels_index6 = 0;\n    long paren_levels_index7 = 0;\n    long paren_levels_index8\
    \ = 0;\n    long paren_levels_index9 = 0;\n    long paren_levels_index10 = 0;\n\
    \    long paren_levels_index11 = 0;\n    long paren_levels_index12 = 0;\n    long\
    \ paren_levels_index13 = 0;\n    long paren_levels_index14 = 0;\n    long paren_levels_index15\
    \ = 0;\n    long paren_levels_index16 = 0;\n    long paren_levels_index17 = 0;\n\
    \    long paren_levels_index18 = 0;\n    long paren_levels_index19 = 0;\n    long\
    \ paren_levels_index20 = 0;\n    long paren_levels_index21 = 0;\n    long paren_levels_index22\
    \ = 0;\n    long paren_levels_index23 = 0;\n    long paren_levels_index24 = 0;\n\
    \    long paren_levels_index25 = 0;\n    long paren_levels_index26 = 0;\n    long\
    \ paren_levels_index27 = 0;\n    long paren_levels_index28 = 0;\n    long paren_levels_index29\
    \ = 0;\n    long paren_levels_index30 = 0;\n    long paren_levels_index31 = 0;\n\
    \    long paren_levels_index32 = 0;\n    long paren_levels_index33 = 0;\n    long\
    \ paren_levels_index34 = 0;\n    long paren_levels_index35 = 0;\n    long paren_levels_index36\
    \ = 0;\n    long paren_levels_index37 = 0;\n    long paren_levels_index38 = 0;\n\
    \    long paren_levels_index39 = 0;\n    long paren_levels_index40 = 0;\n    long\
    \ paren_levels_index41 = 0;\n    long paren_levels_index42 = 0;\n    long paren_levels_index43\
    \ = 0;\n    long paren_levels_index44 = 0;\n    long paren_levels_index45 = 0;\n\
    \    long paren_levels_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpprnt783q.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpprnt783q.d(20): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpprnt783q.d(67):
    Error: semicolon expected, not `unittest`\n/tmp/tmpprnt783q.d(67): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpprnt783q.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long i = 0;\n    bool is_open = false;\n    bool is_closed = false;\n   \
    \ bool is_opening = false;\n    bool is_closing = false;\n    bool is_opening_paren\
    \ = false;\n    bool is_closing_paren = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing\
    \ = false;\n    bool is_closing_paren_or_opening = false;\n    bool is_open\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi5mlyipz.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpi5mlyipz.d(63): Error: semicolon expected,
    not `unittest`\n/tmp/tmpi5mlyipz.d(63): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5mlyipz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long max_level = 0;\n    long max_level_count = 0;\n    long current_level\
    \ = 0;\n    long current_level_count = 0;\n    long paren_level = 0;\n    long\
    \ paren_level_count = 0;\n    long paren_max_level = 0;\n    long paren_max_level_count\
    \ = 0;\n    long paren_current_level = 0;\n    long paren_current_level_count\
    \ = 0;\n    long paren_paren_level = 0;\n    long paren_paren_level_count = 0;\n\
    \    long paren_paren_max_level = 0;\n    long paren_paren_max_level_count = 0;\n\
    \    long paren_paren_current_level = 0;\n    long paren_paren_current_level_count\
    \ = 0;\n    long paren_paren_paren_level = 0;\n    long paren_paren_paren_level_count\
    \ = 0;\n    long paren_paren_paren_max_level = 0;\n    long paren_paren_paren_max_level_count\
    \ = 0;\n    long paren_paren_paren_current_level = 0;\n    long paren_paren_paren_current_level_count\
    \ = 0;\n    long paren_paren_paren_paren_level = 0;\n    long paren_paren_paren_paren_level_count\
    \ = 0;\n    long paren_paren_paren_paren_max_level = 0;\n    long paren_paren_paren_paren_max_level_count\
    \ = 0;\n    long paren_paren_paren_paren_current_level = 0;\n    long paren_paren_paren_paren_current_level_count\
    \ = 0;\n    long paren_paren_paren_paren_paren_level = 0;\n    long paren_paren_paren_paren_paren_level_count\
    \ = 0;\n    long paren_paren_paren_paren_paren_max_level = 0;\n    long paren_paren_paren_paren_paren_max_level_count\
    \ = 0;\n    long paren_paren_paren_paren_paren_current_level = 0;\n    long paren_paren_paren_paren_paren_current_level_count\
    \ = 0;\n    long paren_paren_paren_paren_paren_paren_level = 0;\n    long paren_paren_paren_paren_paren_paren_level_count\
    \ = 0;\n    long paren_paren_paren_paren_paren_paren_max_level = 0;\n    long\
    \ paren_paren_paren_paren_paren_paren_max_level_count = 0;\n    long paren_paren_paren_paren_paren_paren_current_level\
    \ = 0;\n    long paren_paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4g6fd5lv.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmp4g6fd5lv.d(57):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4g6fd5lv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long level_count\
    \ = 0;\n    long level_count_max = 0;\n    long level_count_min = 0;\n    long\
    \ level_count_current = 0;\n    long level_count_current_max = 0;\n    long level_count_current_min\
    \ = 0;\n    long level_count_current_sum = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    long level_count_current_count = 0;\n    long level_count_current_count\
    \ = 0;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuybis8s1.d(87): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuybis8s1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    long paren_level = 0;\n    long paren_levels[] = new\
    \ long[paren_string.length()];\n    long paren_levels_index = 0;\n    long paren_levels_index2\
    \ = 0;\n    long paren_levels_index3 = 0;\n    long paren_levels_index4 = 0;\n\
    \    long paren_levels_index5 = 0;\n    long paren_levels_index6 = 0;\n    long\
    \ paren_levels_index7 = 0;\n    long paren_levels_index8 = 0;\n    long paren_levels_index9\
    \ = 0;\n    long paren_levels_index10 = 0;\n    long paren_levels_index11 = 0;\n\
    \    long paren_levels_index12 = 0;\n    long paren_levels_index13 = 0;\n    long\
    \ paren_levels_index14 = 0;\n    long paren_levels_index15 = 0;\n    long paren_levels_index16\
    \ = 0;\n    long paren_levels_index17 = 0;\n    long paren_levels_index18 = 0;\n\
    \    long paren_levels_index19 = 0;\n    long paren_levels_index20 = 0;\n    long\
    \ paren_levels_index21 = 0;\n    long paren_levels_index22 = 0;\n    long paren_levels_index23\
    \ = 0;\n    long paren_levels_index24 = 0;\n    long paren_levels_index25 = 0;\n\
    \    long paren_levels_index26 = 0;\n    long paren_levels_index27 = 0;\n    long\
    \ paren_levels_index28 = 0;\n    long paren_levels_index29 = 0;\n    long paren_levels_index30\
    \ = 0;\n    long paren_levels_index31 = 0;\n    long paren_levels_index32 = 0;\n\
    \    long paren_levels_index33 = 0;\n    long paren_levels_index34 = 0;\n    long\
    \ paren_levels_index35 = 0;\n    long paren_levels_index36 = 0;\n    long paren_levels_index37\
    \ = 0;\n    long paren_levels_index38 = 0;\n    long paren_levels_index39 = 0;\n\
    \    long paren_levels_index40 = 0;\n    long paren_levels_index41 = 0;\n    long\
    \ paren_levels_index42 = 0;\n    long paren_levels_index43 = 0;\n    long paren_levels_index44\
    \ = 0;\n    long paren_levels_index45 = 0;\n    long paren_levels_index46 = 0;\n\
    \    long paren_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjc8219l9.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpjc8219l9.d(19): Deprecation: instead of
    C-style syntax, use D-style syntax `long[] paren_levels`\n/tmp/tmpjc8219l9.d(67):
    Error: semicolon expected, not `unittest`\n/tmp/tmpjc8219l9.d(67): Error: found
    `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjc8219l9.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_bracket = false;\n    bool in_brace\
    \ = false;\n    bool in_curly = false;\n    bool in_paren_group = false;\n   \
    \ bool in_bracket_group = false;\n    bool in_brace_group = false;\n    bool in_curly_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_bracket_group_open\
    \ = false;\n    bool in_brace_group_open = false;\n    bool in_curly_group_open\
    \ = false;\n    bool in_paren_group_closed = false;\n    bool in_bracket_group_closed\
    \ = false;\n    bool in_brace_group_closed = false;\n    bool in_curly_group_closed\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_bracket_group_open_brace\
    \ = false;\n    bool in_brace_group_open_brace = false;\n    bool in_curly_group_open_brace\
    \ = false;\n    bool in_paren_group_closed_brace = false;\n    bool in_bracket_group_closed_brace\
    \ = false;\n    bool in_brace_group_closed_brace = false;\n    bool in_curly_group_closed_brace\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_bracket_group_open_bracket\
    \ = false;\n    bool in_brace_group_open_bracket = false;\n    bool in_curly_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_group_closed_bracket\
    \ = false;\n    bool in_brace_group_closed_bracket = false;\n    bool in_curly_group_closed_bracket\
    \ = false;\n    bool in_paren_group_open_brace_group = false;\n    bool in_bracket_group_open_brace_group\
    \ = false;\n    bool in_brace_group_open_brace_group = false;\n    bool in_curly_group_open_brace_group\
    \ = false;\n    bool in_paren_group_closed_brace_group = false;\n    bool in_bracket_group_closed_brace_group\
    \ = false;\n    bool in_brace_group_closed_brace_group = false;\n    bool in_curly_group_closed_brace_group\
    \ = false;\n    bool in_paren_group_open_bracket = false;\n    bool in_bracket_group_open_bracket\
    \ = false;\n    bool in_brace_group_open_bracket = false;\n    bool in_curly_group_open_bracket\
    \ = false;\n    bool in_paren_group_closed_bracket = false;\n    bool in_bracket_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpufxprrjm.d(63): Error: semicolon expected, not `unittest`\n/tmp/tmpufxprrjm.d(63):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpufxprrjm.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string paren_char;\n    long\
    \ level = 0;\n    long paren_nesting = 1;\n    long paren_level = 0;\n    long\
    \ paren_nesting_level = 0;\n    long paren_nesting_levels = 0;\n    long paren_nesting_levels_max\
    \ = 0;\n    long paren_nesting_levels_max_index = 0;\n    long paren_nesting_levels_max_index2\
    \ = 0;\n    long paren_nesting_levels_max_index3 = 0;\n    long paren_nesting_levels_max_index4\
    \ = 0;\n    long paren_nesting_levels_max_index5 = 0;\n    long paren_nesting_levels_max_index6\
    \ = 0;\n    long paren_nesting_levels_max_index7 = 0;\n    long paren_nesting_levels_max_index8\
    \ = 0;\n    long paren_nesting_levels_max_index9 = 0;\n    long paren_nesting_levels_max_index10\
    \ = 0;\n    long paren_nesting_levels_max_index11 = 0;\n    long paren_nesting_levels_max_index12\
    \ = 0;\n    long paren_nesting_levels_max_index13 = 0;\n    long paren_nesting_levels_max_index14\
    \ = 0;\n    long paren_nesting_levels_max_index15 = 0;\n    long paren_nesting_levels_max_index16\
    \ = 0;\n    long paren_nesting_levels_max_index17 = 0;\n    long paren_nesting_levels_max_index18\
    \ = 0;\n    long paren_nesting_levels_max_index19 = 0;\n    long paren_nesting_levels_max_index20\
    \ = 0;\n    long paren_nesting_levels_max_index21 = 0;\n    long paren_nesting_levels_max_index22\
    \ = 0;\n    long paren_nesting_levels_max_index23 = 0;\n    long paren_nesting_levels_max_index24\
    \ = 0;\n    long paren_nesting_levels_max_index25 = 0;\n    long paren_nesting_levels_max_index26\
    \ = 0;\n    long paren_nesting_levels_max_index27 = 0;\n    long paren_nesting_levels_max_index28\
    \ = 0;\n    long paren_nesting_levels_max_index29 = 0;\n    long paren_nesting_levels_max_index30\
    \ = 0;\n    long paren_nesting_levels_max_index31 = 0;\n    long paren_nesting_levels_max_index32\
    \ = 0;\n    long paren_nesting_levels_max_index33 = 0;\n    long paren_nesting_levels_max_index34\
    \ = 0;\n    long paren_nest\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0rnva9ei.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmp0rnva9ei.d(57):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0rnva9ei.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group2 = false;\n    bool in_group3 = false;\n    bool in_group4\
    \ = false;\n    bool in_group5 = false;\n    bool in_group6 = false;\n    bool\
    \ in_group7 = false;\n    bool in_group8 = false;\n    bool in_group9 = false;\n\
    \    bool in_group10 = false;\n    bool in_group11 = false;\n    bool in_group12\
    \ = false;\n    bool in_group13 = false;\n    bool in_group14 = false;\n    bool\
    \ in_group15 = false;\n    bool in_group16 = false;\n    bool in_group17 = false;\n\
    \    bool in_group18 = false;\n    bool in_group19 = false;\n    bool in_group20\
    \ = false;\n    bool in_group21 = false;\n    bool in_group22 = false;\n    bool\
    \ in_group23 = false;\n    bool in_group24 = false;\n    bool in_group25 = false;\n\
    \    bool in_group26 = false;\n    bool in_group27 = false;\n    bool in_group28\
    \ = false;\n    bool in_group29 = false;\n    bool in_group30 = false;\n    bool\
    \ in_group31 = false;\n    bool in_group32 = false;\n    bool in_group33 = false;\n\
    \    bool in_group34 = false;\n    bool in_group35 = false;\n    bool in_group36\
    \ = false;\n    bool in_group37 = false;\n    bool in_group38 = false;\n    bool\
    \ in_group39 = false;\n    bool in_group40 = false;\n    bool in_group41 = false;\n\
    \    bool in_group42 = false;\n    bool in_group43 = false;\n    bool in_group44\
    \ = false;\n    bool in_group45 = false;\n    bool in_group46 = false;\n    bool\
    \ in_group47 = false;\n    bool in_group48 = false;\n    bool in_group49 = false;\n\
    \    bool in_group50 = false;\n    bool in_group51 = false;\n    bool in_group52\
    \ = false;\n    bool in_group53 = false;\n    bool in_group54 = false;\n    bool\
    \ in_group55 = false;\n    bool in_group56 = false;\n    bool in_group57 = false;\n\
    \    bool in_group58 = false;\n    bool in_group59 = false;\n    bool in_group60\
    \ = false;\n    bool in_group61 = false;\n    bool in_group62 = false;\n    bool\
    \ in_group63 = false;\n    bool in_group64 = false;\n    bool in_group65 = false;\n\
    \    bool in_group66 = false;\n    \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkhp6agsy.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpkhp6agsy.d(86): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkhp6agsy.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    string paren_chars[] = paren_string.split(\" \");\n    for(long i = 0; i\
    \ < paren_chars.length; ++i)\n    {\n        string paren_char = paren_chars[i];\n\
    \        string paren_chars[] = paren_char.split(\"\");\n        for(long j =\
    \ 0; j < paren_chars.length; ++j)\n        {\n            string paren_char =\
    \ paren_chars[j];\n            if((paren_char == \"(\") || (paren_char == \")\"\
    ))\n            {\n                ++level;\n            }\n            else\n\
    \            {\n                --level;\n            }\n            levels[i]\
    \ = max(level, levels[i]);\n        }\n    }\n    for(long i = 0; i < levels.length;\
    \ ++i)\n    {\n        max_level = max(max_level, levels[i]);\n    }\n    return\
    \ max_level;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much for your\
    \ help. I really appreciate it. I will try this out and let you know how it goes.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nI ran your code, and it worked perfectly.\
    \ Thanks so much!\n<|/ c |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp61n8jxhz.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp61n8jxhz.d(17): Deprecation: instead of
    C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmp61n8jxhz.d(21):
    Deprecation: instead of C-style syntax, use D-style syntax `string[] paren_chars`\n/tmp/tmp61n8jxhz.d(42):
    Error: declaration expected, not `<`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp61n8jxhz.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long parens\
    \ = 0;\n    long parens_level = 0;\n    long parens_level_max = 0;\n    long parens_level_min\
    \ = 0;\n    long parens_level_diff = 0;\n    long parens_level_diff_max = 0;\n\
    \    long parens_level_diff_min = 0;\n    long parens_level_diff_max2 = 0;\n \
    \   long parens_level_diff_min2 = 0;\n    long parens_level_diff_max3 = 0;\n \
    \   long parens_level_diff_min3 = 0;\n    long parens_level_diff_max4 = 0;\n \
    \   long parens_level_diff_min4 = 0;\n    long parens_level_diff_max5 = 0;\n \
    \   long parens_level_diff_min5 = 0;\n    long parens_level_diff_max6 = 0;\n \
    \   long parens_level_diff_min6 = 0;\n    long parens_level_diff_max7 = 0;\n \
    \   long parens_level_diff_min7 = 0;\n    long parens_level_diff_max8 = 0;\n \
    \   long parens_level_diff_min8 = 0;\n    long parens_level_diff_max9 = 0;\n \
    \   long parens_level_diff_min9 = 0;\n    long parens_level_diff_max10 = 0;\n\
    \    long parens_level_diff_min10 = 0;\n    long parens_level_diff_max11 = 0;\n\
    \    long parens_level_diff_min11 = 0;\n    long parens_level_diff_max12 = 0;\n\
    \    long parens_level_diff_min12 = 0;\n    long parens_level_diff_max13 = 0;\n\
    \    long parens_level_diff_min13 = 0;\n    long parens_level_diff_max14 = 0;\n\
    \    long parens_level_diff_min14 = 0;\n    long parens_level_diff_max15 = 0;\n\
    \    long parens_level_diff_min15 = 0;\n    long parens_level_diff_max16 = 0;\n\
    \    long parens_level_diff_min16 = 0;\n    long parens_level_diff_max17 = 0;\n\
    \    long parens_level_diff_min17 = 0;\n    long parens_level_diff_max18 = 0;\n\
    \    long parens_level_diff_min18 = 0;\n    long parens_level_diff_max19 = 0;\n\
    \    long parens_level_diff_min19 = 0;\n    long parens_level_diff_max20 = 0;\n\
    \    long parens_level_diff_min20 = 0;\n    long parens_level_diff_max21 = 0;\n\
    \    long parens_level_diff_min21 = 0;\n    long parens_level_diff_max22 = 0;\n\
    \    long parens_level_diff_min22 = 0;\n    long parens_level_diff_max23 = 0;\n\
    \    long parens_level_diff_min23 = 0;\n    long parens_level_diff_max\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaa6cmydo.d(68): Error: semicolon expected, not `unittest`\n/tmp/tmpaa6cmydo.d(68):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpaa6cmydo.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long max_level\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsl_klu_3.d(86): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsl_klu_3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq2z01jja.d(75): Error: semicolon expected, not `unittest`\n/tmp/tmpq2z01jja.d(75):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpq2z01jja.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long paren_level\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_current = 0;\n   \
    \ long paren_level_next = 0;\n    long paren_level_next2 = 0;\n    long paren_level_next3\
    \ = 0;\n    long paren_level_next4 = 0;\n    long paren_level_next5 = 0;\n   \
    \ long paren_level_next6 = 0;\n    long paren_level_next7 = 0;\n    long paren_level_next8\
    \ = 0;\n    long paren_level_next9 = 0;\n    long paren_level_next10 = 0;\n  \
    \  long paren_level_next11 = 0;\n    long paren_level_next12 = 0;\n    long paren_level_next13\
    \ = 0;\n    long paren_level_next14 = 0;\n    long paren_level_next15 = 0;\n \
    \   long paren_level_next16 = 0;\n    long paren_level_next17 = 0;\n    long paren_level_next18\
    \ = 0;\n    long paren_level_next19 = 0;\n    long paren_level_next20 = 0;\n \
    \   long paren_level_next21 = 0;\n    long paren_level_next22 = 0;\n    long paren_level_next23\
    \ = 0;\n    long paren_level_next24 = 0;\n    long paren_level_next25 = 0;\n \
    \   long paren_level_next26 = 0;\n    long paren_level_next27 = 0;\n    long paren_level_next28\
    \ = 0;\n    long paren_level_next29 = 0;\n    long paren_level_next30 = 0;\n \
    \   long paren_level_next31 = 0;\n    long paren_level_next32 = 0;\n    long paren_level_next33\
    \ = 0;\n    long paren_level_next34 = 0;\n    long paren_level_next35 = 0;\n \
    \   long paren_level_next36 = 0;\n    long paren_level_next37 = 0;\n    long paren_level_next38\
    \ = 0;\n    long paren_level_next39 = 0;\n    long paren_level_next40 = 0;\n \
    \   long paren_level_next41 = 0;\n    long paren_level_next42 = 0;\n    long paren_level_next43\
    \ = 0;\n    long paren_level_next44 = 0;\n    long paren_level_next45 = 0;\n \
    \   long paren_level_next46 = 0;\n    long paren_level_next47 = 0;\n    long paren_level_next48\
    \ = 0;\n    long paren_level_next49 = 0;\n    long paren_level_next50 = 0;\n \
    \   long paren_level_next51 = 0;\n    long paren_level_next52 = 0;\n    long paren_level_next53\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp02oflgtr.d(72): Error: semicolon expected, not `unittest`\n/tmp/tmp02oflgtr.d(72):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp02oflgtr.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool in_paren = false;\n    bool in_group = false;\n\
    \    bool in_group_open = false;\n    bool in_group_close = false;\n    bool in_group_open_brace\
    \ = false;\n    bool in_group_close_brace = false;\n    bool in_group_open_brace_close\
    \ = false;\n    bool in_group_close_brace_close = false;\n    bool in_group_open_brace_open\
    \ = false;\n    bool in_group_close_brace_open = false;\n    bool in_group_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace = false;\n    bool in_group_open_brace_open_brace\
    \ = false;\n    bool in_group_close_brace_open_brace = false;\n    bool in_group_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close = false;\n    bool in_group_close_brace_open_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close = false;\n    bool\
    \ in_group_open_brace_open_brace_close_brace = false;\n    bool in_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace = false;\n \
    \   bool in_group_open_brace_open_brace_close_brace_close = false;\n    bool in_group_close_brace_open_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close = false;\n\
    \    bool in_group_open_brace_open_brace_close_brace_close_brace = false;\n  \
    \  bool in_group_close_brace_open_brace_close_brace_close_brace = false;\n   \
    \ bool in_group_close_brace_close_brace_close_brace_close = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_close_brace_close_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_group_open_brace_open_brace_close_brace_close_brace_close_brace\
    \ = false;\n    bool in_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsubk_xsi.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpsubk_xsi.d(51): Error: semicolon expected,
    not `unittest`\n/tmp/tmpsubk_xsi.d(51): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsubk_xsi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level2 = 0;\n    long level2\
    \ = 0;\n    long max_level3 = 0;\n    long level3 = 0;\n    long max_level4 =\
    \ 0;\n    long level4 = 0;\n    long max_level5 = 0;\n    long level5 = 0;\n \
    \   long max_level6 = 0;\n    long level6 = 0;\n    long max_level7 = 0;\n   \
    \ long level7 = 0;\n    long max_level8 = 0;\n    long level8 = 0;\n    long max_level9\
    \ = 0;\n    long level9 = 0;\n    long max_level10 = 0;\n    long level10 = 0;\n\
    \    long max_level11 = 0;\n    long level11 = 0;\n    long max_level12 = 0;\n\
    \    long level12 = 0;\n    long max_level13 = 0;\n    long level13 = 0;\n   \
    \ long max_level14 = 0;\n    long level14 = 0;\n    long max_level15 = 0;\n  \
    \  long level15 = 0;\n    long max_level16 = 0;\n    long level16 = 0;\n    long\
    \ max_level17 = 0;\n    long level17 = 0;\n    long max_level18 = 0;\n    long\
    \ level18 = 0;\n    long max_level19 = 0;\n    long level19 = 0;\n    long max_level20\
    \ = 0;\n    long level20 = 0;\n    long max_level21 = 0;\n    long level21 = 0;\n\
    \    long max_level22 = 0;\n    long level22 = 0;\n    long max_level23 = 0;\n\
    \    long level23 = 0;\n    long max_level24 = 0;\n    long level24 = 0;\n   \
    \ long max_level25 = 0;\n    long level25 = 0;\n    long max_level26 = 0;\n  \
    \  long level26 = 0;\n    long max_level27 = 0;\n    long level27 = 0;\n    long\
    \ max_level28 = 0;\n    long level28 = 0;\n    long max_level29 = 0;\n    long\
    \ level29 = 0;\n    long max_level30 = 0;\n    long level30 = 0;\n    long max_level31\
    \ = 0;\n    long level31 = 0;\n    long max_level32 = 0;\n    long level32 = 0;\n\
    \    long max_level33 = 0;\n    long level33 = 0;\n    long max_level34 = 0;\n\
    \    long level34 = 0;\n    long max_level35 = 0;\n    long level35 = 0;\n   \
    \ long max_level36 = 0;\n    long level36 = 0;\n    long max_level37 = 0;\n  \
    \  long level37 = 0;\n    long max_level38 = 0;\n    long level38 = 0;\n    long\
    \ max_level39 = 0;\n    long level39 = 0;\n    long max_level40 = 0;\n    long\
    \ level40 = 0;\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa41lq_td.d(95): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa41lq_td.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    long index\
    \ = 0;\n    bool in_paren = false;\n    bool in_group = false;\n    bool in_group2\
    \ = false;\n    bool in_group3 = false;\n    bool in_group4 = false;\n    bool\
    \ in_group5 = false;\n    bool in_group6 = false;\n    bool in_group7 = false;\n\
    \    bool in_group8 = false;\n    bool in_group9 = false;\n    bool in_group10\
    \ = false;\n    bool in_group11 = false;\n    bool in_group12 = false;\n    bool\
    \ in_group13 = false;\n    bool in_group14 = false;\n    bool in_group15 = false;\n\
    \    bool in_group16 = false;\n    bool in_group17 = false;\n    bool in_group18\
    \ = false;\n    bool in_group19 = false;\n    bool in_group20 = false;\n    bool\
    \ in_group21 = false;\n    bool in_group22 = false;\n    bool in_group23 = false;\n\
    \    bool in_group24 = false;\n    bool in_group25 = false;\n    bool in_group26\
    \ = false;\n    bool in_group27 = false;\n    bool in_group28 = false;\n    bool\
    \ in_group29 = false;\n    bool in_group30 = false;\n    bool in_group31 = false;\n\
    \    bool in_group32 = false;\n    bool in_group33 = false;\n    bool in_group34\
    \ = false;\n    bool in_group35 = false;\n    bool in_group36 = false;\n    bool\
    \ in_group37 = false;\n    bool in_group38 = false;\n    bool in_group39 = false;\n\
    \    bool in_group40 = false;\n    bool in_group41 = false;\n    bool in_group42\
    \ = false;\n    bool in_group43 = false;\n    bool in_group44 = false;\n    bool\
    \ in_group45 = false;\n    bool in_group46 = false;\n    bool in_group47 = false;\n\
    \    bool in_group48 = false;\n    bool in_group49 = false;\n    bool in_group50\
    \ = false;\n    bool in_group51 = false;\n    bool in_group52 = false;\n    bool\
    \ in_group53 = false;\n    bool in_group54 = false;\n    bool in_group55 = false;\n\
    \    bool in_group56 = false;\n    bool in_group57 = false;\n    bool in_group58\
    \ = false;\n    bool in_group59 = false;\n    bool in_group60 = false;\n    bool\
    \ in_group61 = false;\n    bool in_group62 = false;\n    bool in_group63 = false;\n\
    \    bool in_group64 = false;\n    bool in_group65 = false;\n    bool in_group66\
    \ = false;\n    bool in_group67 = false;\n    \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3_0ewyn3.d(86): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3_0ewyn3.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    long level = 0;\n    bool in_paren\
    \ = false;\n    bool in_bracket = false;\n    bool in_brace = false;\n    bool\
    \ in_brace_bracket = false;\n    bool in_brace_brace = false;\n    bool in_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace = false;\n    bool in_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace = false;\n    bool in_brace_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace_brace = false;\n    bool in_brace_brace_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace = false;\n    bool\
    \ in_brace_brace_brace_brace_brace_brace_bracket = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_bracket = false;\n\
    \    bool in_brace_brace_brace_brace_brace_brace_brace_brace = false;\n    bool\
    \ in_brace_brace_brace_brace_brace_brace_brace_brace_bracket = false;\n    bool\
    \ in_brace_brace_brace_brace_brace_brace_brace_brace_brace = false;\n    bool\
    \ in_brace_brace_brace_brace_brace_brace_brace_brace_brace_bracket = false;\n\
    \    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace = false;\n\
    \    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_bracket\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace_brace\
    \ = false;\n    bool in_brace_brace_brace_brace_brace_brace_brace_bra\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprzdp65df.d(44): Error: semicolon expected, not `unittest`\n/tmp/tmprzdp65df.d(44):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprzdp65df.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long current_level = 0;\n    bool is_open = false;\n    bool is_closed =\
    \ false;\n    bool is_opening = false;\n    bool is_closing = false;\n    bool\
    \ is_opening_open = false;\n    bool is_opening_closed = false;\n    bool is_closing_open\
    \ = false;\n    bool is_closing_closed = false;\n    bool is_opening_opening_open\
    \ = false;\n    bool is_opening_opening_closed = false;\n    bool is_opening_closing_open\
    \ = false;\n    bool is_opening_closing_closed = false;\n    bool is_closing_opening_open\
    \ = false;\n    bool is_closing_opening_closed = false;\n    bool is_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_opening_open\
    \ = false;\n    bool is_closing_closing_opening_closed = false;\n    bool is_closing_closing_closing_open\
    \ = false;\n    bool is_closing_closing_closing_closed = false;\n    bool is_opening_opening_opening_open\
    \ = false;\n    bool is_opening_opening_opening_closed = false;\n    bool is_opening_opening_closing_open\
    \ = false;\n    bool is_opening_opening_closing_closed = false;\n    bool is_opening_closing_opening_open\
    \ = false;\n    bool is_opening_closing_opening_closed = false;\n    bool is_opening_closing_closing_open\
    \ = false;\n    bool is_opening_closing_closing_closed = false;\n    bool is_closing_opening_opening_open\
    \ = false;\n    bool is_closing_opening_opening_closed = false;\n    bool is_closing_opening_closing_open\
    \ = false;\n    bool is_closing_opening_closing_closed = false;\n    bool is_closing_closing_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaimts6wj.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpaimts6wj.d(63): Error: semicolon expected,
    not `unittest`\n/tmp/tmpaimts6wj.d(63): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaimts6wj.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long index = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n    bool\
    \ is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_curly_bracket_or_paren = false;\n    bool is_closing_curly_bracket_or_paren\
    \ = false;\n    bool is_opening_square_bracket_or_paren = false;\n    bool is_closing_square_bracket_or_paren\
    \ = false;\n    bool is_opening_curly_bracket = false;\n    bool is_closing_curly_bracket\
    \ = false;\n    bool is_opening_square_bracket = false;\n    bool is_closing_square_bracket\
    \ = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren = false;\n\
    \    bool is_opening_\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgtibimw9.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpgtibimw9.d(63): Error: semicolon expected,
    not `unittest`\n/tmp/tmpgtibimw9.d(63): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgtibimw9.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long level_stack[MAX_LEVELS];\n   \
    \ long level_stack_index = 0;\n    long level_index = 0;\n    bool in_paren =\
    \ false;\n    bool in_paren_group = false;\n    bool in_paren_group_open = false;\n\
    \    bool in_paren_group_close = false;\n    bool in_paren_group_open_brace =\
    \ false;\n    bool in_paren_group_close_brace = false;\n    bool in_paren_group_open_brace_close\
    \ = false;\n    bool in_paren_group_close_brace_close = false;\n    bool in_paren_group_open_brace_open\
    \ = false;\n    bool in_paren_group_close_brace_open = false;\n    bool in_paren_group_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_open_brace_open_brace = false;\n    bool in_paren_group_close_brace_open_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close = false;\n    bool in_paren_group_close_brace_open_brace_close\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace = false;\n    bool in_paren_group_close_brace_open_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_close_brace_close = false;\n  \
    \  bool in_paren_group_open_brace_open_brace_close_brace_close = false;\n    bool\
    \ in_paren_group_open_brace_open_brace_close_brace_close_brace = false;\n    bool\
    \ in_paren_group_close_brace_open_brace_close_brace_close = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close =\
    \ false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_close_brace_open_brace_close_brace_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_open_brace_close_brace_close_brace_close\
    \ = false;\n    bool in_paren_group_open\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxdape21z.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[MAX_LEVELS] level_stack`\n/tmp/tmpxdape21z.d(49): Error:
    semicolon expected, not `unittest`\n/tmp/tmpxdape21z.d(49): Error: found `unittest`
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxdape21z.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long max_level_at_level = 0;\n    long\
    \ level_at_level = 0;\n    long levels_at_level = 0;\n    long levels_at_level_max\
    \ = 0;\n    long level_at_level_max = 0;\n    long levels_at_level_max_at_level\
    \ = 0;\n    long level_at_level_max_at_level = 0;\n    long levels_at_level_max_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level = 0;\n    long levels_at_level_max_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level = 0;\n    long\
    \ levels_at_level_max_at_level_at_level_at_level_at_level = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long levels_at_level_max_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level_at_level\
    \ = 0;\n    long level_at_level_max_at_level_at_level_at_level_at_level_\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbw0i4rpk.d(43): Error: semicolon expected, not `unittest`\n/tmp/tmpbw0i4rpk.d(43):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbw0i4rpk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    long levels_index2 = 0;\n    long levels_index3\
    \ = 0;\n    long levels_index4 = 0;\n    long levels_index5 = 0;\n    long levels_index6\
    \ = 0;\n    long levels_index7 = 0;\n    long levels_index8 = 0;\n    long levels_index9\
    \ = 0;\n    long levels_index10 = 0;\n    long levels_index11 = 0;\n    long levels_index12\
    \ = 0;\n    long levels_index13 = 0;\n    long levels_index14 = 0;\n    long levels_index15\
    \ = 0;\n    long levels_index16 = 0;\n    long levels_index17 = 0;\n    long levels_index18\
    \ = 0;\n    long levels_index19 = 0;\n    long levels_index20 = 0;\n    long levels_index21\
    \ = 0;\n    long levels_index22 = 0;\n    long levels_index23 = 0;\n    long levels_index24\
    \ = 0;\n    long levels_index25 = 0;\n    long levels_index26 = 0;\n    long levels_index27\
    \ = 0;\n    long levels_index28 = 0;\n    long levels_index29 = 0;\n    long levels_index30\
    \ = 0;\n    long levels_index31 = 0;\n    long levels_index32 = 0;\n    long levels_index33\
    \ = 0;\n    long levels_index34 = 0;\n    long levels_index35 = 0;\n    long levels_index36\
    \ = 0;\n    long levels_index37 = 0;\n    long levels_index38 = 0;\n    long levels_index39\
    \ = 0;\n    long levels_index40 = 0;\n    long levels_index41 = 0;\n    long levels_index42\
    \ = 0;\n    long levels_index43 = 0;\n    long levels_index44 = 0;\n    long levels_index45\
    \ = 0;\n    long levels_index46 = 0;\n    long levels_index47 = 0;\n    long levels_index48\
    \ = 0;\n    long levels_index49 = 0;\n    long levels_index50 = 0;\n    long levels_index51\
    \ = 0;\n    long levels_index52 = 0;\n    long levels_index53 = 0;\n    long levels_index54\
    \ = 0;\n    long levels_index55 = 0;\n    long levels_index56 = 0;\n    long levels_index57\
    \ = 0;\n    long levels_index58 = 0;\n    long levels_index59 = 0;\n    long levels_index60\
    \ = 0;\n    long levels_index61 = 0;\n    long level\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc22gckro.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpc22gckro.d(79): Error: semicolon expected,
    not `unittest`\n/tmp/tmpc22gckro.d(79): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc22gckro.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_chars = \"()\";\n    string paren_chars_reverse = \"()\";\n    string\
    \ paren_chars_reverse2 = \"()\";\n    string paren_chars_reverse3 = \"()\";\n\
    \    string paren_chars_reverse4 = \"()\";\n    string paren_chars_reverse5 =\
    \ \"()\";\n    string paren_chars_reverse6 = \"()\";\n    string paren_chars_reverse7\
    \ = \"()\";\n    string paren_chars_reverse8 = \"()\";\n    string paren_chars_reverse9\
    \ = \"()\";\n    string paren_chars_reverse10 = \"()\";\n    string paren_chars_reverse11\
    \ = \"()\";\n    string paren_chars_reverse12 = \"()\";\n    string paren_chars_reverse13\
    \ = \"()\";\n    string paren_chars_reverse14 = \"()\";\n    string paren_chars_reverse15\
    \ = \"()\";\n    string paren_chars_reverse16 = \"()\";\n    string paren_chars_reverse17\
    \ = \"()\";\n    string paren_chars_reverse18 = \"()\";\n    string paren_chars_reverse19\
    \ = \"()\";\n    string paren_chars_reverse20 = \"()\";\n    string paren_chars_reverse21\
    \ = \"()\";\n    string paren_chars_reverse22 = \"()\";\n    string paren_chars_reverse23\
    \ = \"()\";\n    string paren_chars_reverse24 = \"()\";\n    string paren_chars_reverse25\
    \ = \"()\";\n    string paren_chars_reverse26 = \"()\";\n    string paren_chars_reverse27\
    \ = \"()\";\n    string paren_chars_reverse28 = \"()\";\n    string paren_chars_reverse29\
    \ = \"()\";\n    string paren_chars_reverse30 = \"()\";\n    string paren_chars_reverse31\
    \ = \"()\";\n    string paren_chars_reverse32 = \"()\";\n    string paren_chars_reverse33\
    \ = \"()\";\n    string paren_chars_reverse34 = \"()\";\n    string paren_chars_reverse35\
    \ = \"()\";\n    string paren_chars_reverse36 = \"()\";\n    string paren_chars_reverse37\
    \ = \"()\";\n    string paren_chars_reverse38 = \"()\";\n    string paren_chars_reverse39\
    \ = \"()\";\n    string paren_chars_reverse40 = \"()\";\n    string paren_chars_reverse41\
    \ = \"()\";\n    string paren_chars_reverse\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnagpyoy4.d(56): Error: found `paren_chars_reverse` when expecting
    `;` following statement\n/tmp/tmpnagpyoy4.d(57): Error: found `unittest` instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnagpyoy4.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_index = 0;\n    bool in_paren = false;\n    bool in_paren_group\
    \ = false;\n    bool in_paren_group_open = false;\n    bool in_paren_group_close\
    \ = false;\n    bool in_paren_group_open_brace = false;\n    bool in_paren_group_close_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma = false;\n    bool in_paren_group_close_brace_or_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_brace = false;\n    bool\
    \ in_paren_group_close_brace_or_comma_brace = false;\n    bool in_paren_group_open_brace_or_comma_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma = false;\n    bool\
    \ in_paren_group_open_brace_or_comma_comma_brace = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma = false;\n   \
    \ bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace = false;\n \
    \   bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace = false;\n\
    \    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma = false;\n\
    \    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma =\
    \ false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace_comma\
    \ = false;\n    bool in_paren_group_open_brace_or_comma_comma_brace_comma_brace_comma_brace_comma_brace\
    \ = false;\n    bool in_paren_group_close_brace_or_comma_comma_brace_comma_brace_comma_brace_comma_b\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8ggd7ive.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmp8ggd7ive.d(44): Error: semicolon expected,
    not `unittest`\n/tmp/tmp8ggd7ive.d(44): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ggd7ive.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            level++;\n            levels[level] = level;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            level--;\n\
    \            levels[level] = level;\n        }\n    }\n    for(int i = 0; i <\
    \ levels.length; i++)\n    {\n        if(levels[i] > max_level)\n        {\n \
    \           max_level = levels[i];\n        }\n    }\n    return max_level;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the idea of using stacks to solve\
    \ this problem. I'm going to try this out and see if it works. Thanks!\n<|/ c\
    \ |>\n<| c |>\nI added a solution that uses stacks to solve this problem. Thanks\
    \ again!\n<|/ c |>\n<| c |>\nI added a solution that uses stacks to solve this\
    \ problem. Thanks again!\n<|/ c |>\n<| a tags=algorithm,parentheses,string |>\n\
    I wrote a solution that uses stacks to solve this problem. Thanks to everyone\
    \ who helped me solve this problem!\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.Stack;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmc7doaef.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpmc7doaef.d(39): Error: declaration expected,
    not `<`\n/tmp/tmpmc7doaef.d(42): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmc7doaef.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    bool in_paren = false;\n    bool in_paren_group = false;\n    bool in_paren_group_open\
    \ = false;\n    bool in_paren_group_close = false;\n    bool in_paren_group_open2\
    \ = false;\n    bool in_paren_group_close2 = false;\n    bool in_paren_group_open3\
    \ = false;\n    bool in_paren_group_close3 = false;\n    bool in_paren_group_open4\
    \ = false;\n    bool in_paren_group_close4 = false;\n    bool in_paren_group_open5\
    \ = false;\n    bool in_paren_group_close5 = false;\n    bool in_paren_group_open6\
    \ = false;\n    bool in_paren_group_close6 = false;\n    bool in_paren_group_open7\
    \ = false;\n    bool in_paren_group_close7 = false;\n    bool in_paren_group_open8\
    \ = false;\n    bool in_paren_group_close8 = false;\n    bool in_paren_group_open9\
    \ = false;\n    bool in_paren_group_close9 = false;\n    bool in_paren_group_open10\
    \ = false;\n    bool in_paren_group_close10 = false;\n    bool in_paren_group_open11\
    \ = false;\n    bool in_paren_group_close11 = false;\n    bool in_paren_group_open12\
    \ = false;\n    bool in_paren_group_close12 = false;\n    bool in_paren_group_open13\
    \ = false;\n    bool in_paren_group_close13 = false;\n    bool in_paren_group_open14\
    \ = false;\n    bool in_paren_group_close14 = false;\n    bool in_paren_group_open15\
    \ = false;\n    bool in_paren_group_close15 = false;\n    bool in_paren_group_open16\
    \ = false;\n    bool in_paren_group_close16 = false;\n    bool in_paren_group_open17\
    \ = false;\n    bool in_paren_group_close17 = false;\n    bool in_paren_group_open18\
    \ = false;\n    bool in_paren_group_close18 = false;\n    bool in_paren_group_open19\
    \ = false;\n    bool in_paren_group_close19 = false;\n    bool in_paren_group_open20\
    \ = false;\n    bool in_paren_group_close20 = false;\n    bool in_paren_group_open21\
    \ = false;\n    bool in_paren_group_close21 = false;\n    bool in_paren_group_open22\
    \ = false;\n    bool in_paren_group_close22 = false;\n    bool in_paren_group_open23\
    \ = false;\n    bool in_paren_group_close23 = false;\n    bool in_paren_group_open24\
    \ = false;\n    bool \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxb35jwcv.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpxb35jwcv.d(67): Error: no identifier for
    declarator `bool`\n/tmp/tmpxb35jwcv.d(67): Error: found `unittest` instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxb35jwcv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_groups = paren_string.trim().replaceAll(\"\\\\s+\", \" \").trim();\n \
    \   long[] levels = new long[paren_groups.size()];\n    long level = 0;\n    for(long\
    \ i = 0; i < paren_groups.size(); i++) {\n        if(paren_groups[i] == '(') {\n\
    \            level++;\n        } else if(paren_groups[i] == ')') {\n         \
    \   level--;\n        }\n        levels[i] = level;\n    }\n    return levels;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work for nested parentheses\
    \ such as \"(()())\"\n<|/ c |>\n<| c |>\nIt works for me. `parse_nested_parens(\"\
    (()())\")` returns `[2L, 3L, 1L, 3L]`\n<|/ c |>\n<| c |>\nI tested it and it doesn't\
    \ work for me. `parse_nested_parens(\"(()())\")` returns `[2L, 3L, 1L, 3L]`\n\
    <|/ c |>\n<| c |>\nI tested it and it doesn't work for me. `parse_nested_parens(\"\
    (()())\")` returns `[2L, 3L, 1L, 3L]`\n<|/ c |>\n<| c |>\nI tested it and it doesn't\
    \ work for me. `parse_nested_parens(\"(()())\")` returns `[2L, 3L, 1L, 3L]`\n\
    <|/ c |>\n<| a dscore=4 |>\nI wrote a recursive function which works fine for\
    \ me:\n<code>\npublic static int getMaxNestingLevel(String str) {\n    if (str.length()\
    \ == 0) {\n        return 0;\n    }\n    int level = 0;\n    int lastChar = str.charAt(0);\n\
    \    if (lastChar == '(') {\n        level++;\n    }\n    if (lastChar == ')')\
    \ {\n        level--;\n    }\n    return Math.max(level, getMaxNestingLevel(str.substring(1,\
    \ str.length())));\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| c |>\nThis doesn't\
    \ seem to work for nested parentheses such as \"(()())\"\n<|/ c |>\n<| c |>\n\
    It works for me. `getMaxNestingLevel(\"(()())\")` returns `3`\n<|/ c |>\n<| c\
    \ |>\nIt works for me. `getMaxNestingLevel(\"(()())\")` returns `3`\n<|/ c |>\n\
    <| a |>\n<code>\npublic static int getMaxNestingLevel(String str) {\n    if (str.length()\
    \ == 0) {\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkcgs031y.d(27): Error: declaration expected, not `<`\n/tmp/tmpkcgs031y.d(30):
    Error: unterminated character constant\n/tmp/tmpkcgs031y.d(36): Error: unterminated
    character constant\n/tmp/tmpkcgs031y.d(39): Error: unterminated character constant\n/tmp/tmpkcgs031y.d(42):
    Error: unterminated character constant\n/tmp/tmpkcgs031y.d(50): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkcgs031y.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long levels[] = new long[paren_string.length()];\n\
    \    long levels_size = 0;\n    long levels_index = 0;\n    long index = 0;\n\
    \    bool is_open = false;\n    bool is_close = false;\n    bool is_opening =\
    \ false;\n    bool is_closing = false;\n    bool is_opening_paren = false;\n \
    \   bool is_closing_paren = false;\n    bool is_opening_paren_or_closing = false;\n\
    \    bool is_closing_paren_or_opening = false;\n    bool is_opening_paren_or_closing_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing = false;\n \
    \   bool is_opening_paren_or_closing_paren_or_opening_paren = false;\n    bool\
    \ is_closing_paren_or_opening_paren_or_closing_paren = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_closing\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren\
    \ = false;\n    bool is_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren\
    \ = false;\n    bool is_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_or_opening_paren_or_closing_paren_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsjod6hyt.d(16): Deprecation: instead of C-style syntax, use
    D-style syntax `long[] levels`\n/tmp/tmpsjod6hyt.d(44): Error: semicolon expected,
    not `unittest`\n/tmp/tmpsjod6hyt.d(44): Error: found `unittest` instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsjod6hyt.d", "-I/tmp"]\n'''
  stdout: b''
