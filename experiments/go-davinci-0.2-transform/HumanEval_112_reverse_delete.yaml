name: HumanEval_112_reverse_delete
language: go_test.go
prompt: "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Task\n// We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n// then check if the result string\
  \ is palindrome.\n// A string is called palindrome if it reads the same backward\
  \ as forward.\n// You should return a tuple containing the result string and True/False\
  \ for the check.\n// Example\n// >>> reverse_delete(\"abcde\", \"ae\")\n// []interface{}{\"\
  bcd\", false}\n// >>> reverse_delete(\"abcdef\", \"b\")\n// []interface{}{\"acdef\"\
  , false}\n// >>> reverse_delete(\"abcdedcba\", \"ab\")\n// []interface{}{\"cdedc\"\
  , true}\nfunc reverse_delete(s string, c string) []interface{} {\n"
tests: "func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"\
  bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"\
  acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"\
  cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"\
  dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\
  \", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"\
  abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected:\
  \ []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"\
  v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\"\
  , \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    return []interface{}{s, false}\n}\n", "    var result string\n\
    \    for _, v := range s {\n        if !strings.Contains(c, string(v)) {\n   \
    \         result += string(v)\n        }\n    }\n    return []interface{}{result,\
    \ result == reverse(result)}\n}\n", "    var result string\n    for _, char :=\
    \ range s {\n        if !contains(c, char) {\n            result += string(char)\n\
    \        }\n    }\n    return []interface{}{result, isPalindrome(result)}\n}\n",
  "    var result string\n    for _, v := range s {\n        if !strings.ContainsRune(c,\
    \ v) {\n            result += string(v)\n        }\n    }\n    return []interface{}{result,\
    \ result == reverse(result)}\n}\n", "    var result string\n    for _, char :=\
    \ range s {\n        if !contains(c, char) {\n            result += string(char)\n\
    \        }\n    }\n    return []interface{}{result, isPalindrome(result)}\n}\n",
  "    var result string\n    for _, char := range s {\n        if !strings.Contains(c,\
    \ string(char)) {\n            result += string(char)\n        }\n    }\n    return\
    \ []interface{}{result, result == reverse(result)}\n}\n", "    var result string\n\
    \    for _, char := range s {\n        if !strings.Contains(c, string(char)) {\n\
    \            result += string(char)\n        }\n    }\n    return []interface{}{result,\
    \ result == reverse(result)}\n}\n", "    // your code here\n    return nil\n}\n",
  "    var res string\n    for _, v := range s {\n        if !strings.ContainsRune(c,\
    \ v) {\n            res += string(v)\n        }\n    }\n    return []interface{}{res,\
    \ res == Reverse(res)}\n}\n", "    // your code here\n    return nil\n}\n", " \
    \   var result string\n    for _, char := range s {\n        if !contains(c, string(char))\
    \ {\n            result += string(char)\n        }\n    }\n    return []interface{}{result,\
    \ isPalindrome(result)}\n}\n", "    var result string\n    for _, char := range\
    \ s {\n        if !strings.Contains(c, string(char)) {\n            result +=\
    \ string(char)\n        }\n    }\n    return []interface{}{result, result == reverse(result)}\n\
    }\n", "    // your code here\n    return nil\n}\n", "    // your code here\n \
    \   return nil\n}\n", "    // your code here\n    return nil\n}\n", "    var result\
    \ string\n    for _, char := range s {\n        if !strings.ContainsRune(c, char)\
    \ {\n            result += string(char)\n        }\n    }\n    return []interface{}{result,\
    \ result == Reverse(result)}\n}\n", "    var result string\n    for _, v := range\
    \ s {\n        if !strings.Contains(c, string(v)) {\n            result += string(v)\n\
    \        }\n    }\n    return []interface{}{result, result == reverse(result)}\n\
    }\n", "    var result string\n    for _, r := range s {\n        if !strings.ContainsRune(c,\
    \ r) {\n            result += string(r)\n        }\n    }\n    return []interface{}{result,\
    \ result == reverse(result)}\n}\n", "    var result string\n    for _, char :=\
    \ range s {\n        if !contains(c, string(char)) {\n            result += string(char)\n\
    \        }\n    }\n    return []interface{}{result, isPalindrome(result)}\n}\n",
  "    var res string\n    for _, ch := range s {\n        if !strings.ContainsRune(c,\
    \ ch) {\n            res += string(ch)\n        }\n    }\n    return []interface{}{res,\
    \ res == reverse(res)}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
