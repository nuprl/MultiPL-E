name: HumanEval_20_find_closest_elements
language: go_test.go
prompt: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
  \ []float64) []interface{} {\n"
tests: "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
  \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
  \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
  \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var closest_elements []interface{}\n    var closest_difference\
    \ float64 = numbers[1] - numbers[0]\n    for i := 0; i < len(numbers) - 1; i++\
    \ {\n        difference := numbers[i + 1] - numbers[i]\n        if difference\
    \ < closest_difference {\n            closest_difference = difference\n      \
    \      closest_elements = []interface{}{numbers[i], numbers[i + 1]}\n        }\n\
    \    }\n    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_diff float64\n    var diff float64\n    var smaller_number float64\n\
    \    var larger_number float64\n\n    for i := 0; i < len(numbers) - 1; i++ {\n\
    \        for j := i + 1; j < len(numbers); j++ {\n            diff = numbers[j]\
    \ - numbers[i]\n            if diff < 0 {\n                diff = -diff\n    \
    \        }\n            if closest_diff == 0 || diff < closest_diff {\n      \
    \          closest_diff = diff\n                smaller_number = numbers[i]\n\
    \                larger_number = numbers[j]\n            }\n        }\n    }\n\
    \n    closest_elements = append(closest_elements, smaller_number)\n    closest_elements\
    \ = append(closest_elements, larger_number)\n\n    return closest_elements\n}\n",
  "    var closest_elements []interface{}\n    var closest_diff float64\n    var diff\
    \ float64\n    var smaller_number float64\n    var larger_number float64\n\n \
    \   for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            if numbers[i] < numbers[j] {\n                smaller_number\
    \ = numbers[i]\n                larger_number = numbers[j]\n            } else\
    \ {\n                smaller_number = numbers[j]\n                larger_number\
    \ = numbers[i]\n            }\n            diff = larger_number - smaller_number\n\
    \            if closest_diff == 0 || diff < closest_diff {\n                closest_diff\
    \ = diff\n                closest_elements = []interface{}{smaller_number, larger_number}\n\
    \            }\n        }\n    }\n    return closest_elements\n}\n", "    var\
    \ closest_elements []interface{}\n    var closest_difference float64 = numbers[1]\
    \ - numbers[0]\n    var closest_elements_index int = 0\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        if numbers[i + 1] - numbers[i] < closest_difference {\n\
    \            closest_difference = numbers[i + 1] - numbers[i]\n            closest_elements_index\
    \ = i\n        }\n    }\n    closest_elements = append(closest_elements, numbers[closest_elements_index])\n\
    \    closest_elements = append(closest_elements, numbers[closest_elements_index\
    \ + 1])\n    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_difference float64 = numbers[1] - numbers[0]\n    for i := 0;\
    \ i < len(numbers) - 1; i++ {\n        difference := numbers[i + 1] - numbers[i]\n\
    \        if difference < closest_difference {\n            closest_difference\
    \ = difference\n            closest_elements = []interface{}{numbers[i], numbers[i\
    \ + 1]}\n        }\n    }\n    return closest_elements\n}\n", "    var closest\
    \ []interface{}\n    closest = append(closest, numbers[0])\n    closest = append(closest,\
    \ numbers[1])\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1;\
    \ j < len(numbers); j++ {\n            if abs(numbers[i] - numbers[j]) < abs(closest[0].(float64)\
    \ - closest[1].(float64)) {\n                closest[0] = numbers[i]\n       \
    \         closest[1] = numbers[j]\n            }\n        }\n    }\n    return\
    \ closest\n}\n", "    var closest_elements []interface{}\n    var min_diff float64\
    \ = numbers[1] - numbers[0]\n    for i := 0; i < len(numbers) - 1; i++ {\n   \
    \     diff := numbers[i + 1] - numbers[i]\n        if diff < min_diff {\n    \
    \        min_diff = diff\n            closest_elements = []interface{}{numbers[i],\
    \ numbers[i + 1]}\n        }\n    }\n    return closest_elements\n}\n", "    var\
    \ closest_elements []interface{}\n    var closest_difference float64\n    for\
    \ i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            difference := numbers[j] - numbers[i]\n            if closest_difference\
    \ == 0 || difference < closest_difference {\n                closest_difference\
    \ = difference\n                closest_elements = []interface{}{numbers[i], numbers[j]}\n\
    \            }\n        }\n    }\n    return closest_elements\n}\n", "    var\
    \ closest_elements []interface{}\n    var closest_difference float64\n    for\
    \ i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            difference := numbers[j] - numbers[i]\n            if closest_difference\
    \ == 0 || difference < closest_difference {\n                closest_difference\
    \ = difference\n                closest_elements = []interface{}{numbers[i], numbers[j]}\n\
    \            }\n        }\n    }\n    return closest_elements\n}\n", "    var\
    \ closest_elements []interface{}\n    var closest_difference float64\n    var\
    \ current_difference float64\n    var current_element float64\n    var previous_element\
    \ float64\n\n    for i, element := range numbers {\n        if i == 0 {\n    \
    \        previous_element = element\n            continue\n        }\n\n     \
    \   current_element = element\n        current_difference = current_element -\
    \ previous_element\n\n        if closest_difference == 0 || current_difference\
    \ < closest_difference {\n            closest_difference = current_difference\n\
    \            closest_elements = []interface{}{previous_element, current_element}\n\
    \        }\n\n        previous_element = current_element\n    }\n\n    return\
    \ closest_elements\n}\n", "    var closest []interface{}\n    var diff float64\n\
    \    var diff_min float64\n    var i int\n    var j int\n    var k int\n    var\
    \ l int\n    var n int\n    var n_min int\n    var n_max int\n    var n_min_prev\
    \ int\n    var n_max_prev int\n    var n_min_prev_prev int\n    var n_max_prev_prev\
    \ int\n    var n_min_prev_prev_prev int\n    var n_max_prev_prev_prev int\n  \
    \  var n_min_prev_prev_prev_prev int\n    var n_max_prev_prev_prev_prev int\n\
    \    var n_min_prev_prev_prev_prev_prev int\n    var n_max_prev_prev_prev_prev_prev\
    \ int\n    var n_min_prev_prev_prev_prev_prev_prev int\n    var n_max_prev_prev_prev_prev_prev_prev\
    \ int\n    var n_min_prev_prev_prev_prev_prev_prev_prev int\n    var n_max_prev_prev_prev_prev_prev_prev_prev\
    \ int\n    var n_min_prev_prev_prev_prev_prev_prev_prev_prev int\n    var n_max_prev_prev_prev_prev_prev_prev_prev_prev\
    \ int\n    var n_min_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var\
    \ n_max_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var n_min_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ int\n    var n_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n \
    \   var n_min_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n   \
    \ var n_max_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var\
    \ n_min_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n   ",
  "    var closest_elements []interface{}\n    var closest_difference float64\n  \
    \  var current_difference float64\n    var current_elements []interface{}\n\n\
    \    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            current_difference = numbers[j] - numbers[i]\n          \
    \  if closest_difference == 0 || current_difference < closest_difference {\n \
    \               closest_difference = current_difference\n                closest_elements\
    \ = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n    }\n\n\
    \    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_distance float64 = -1\n    var distance float64\n    var number_1\
    \ float64\n    var number_2 float64\n\n    for i := 0; i < len(numbers) - 1; i++\
    \ {\n        for j := i + 1; j < len(numbers); j++ {\n            distance = numbers[j]\
    \ - numbers[i]\n            if closest_distance == -1 || distance < closest_distance\
    \ {\n                closest_distance = distance\n                number_1 = numbers[i]\n\
    \                number_2 = numbers[j]\n            }\n        }\n    }\n\n  \
    \  closest_elements = append(closest_elements, number_1)\n    closest_elements\
    \ = append(closest_elements, number_2)\n\n    return closest_elements\n}\n", " \
    \   var closest []interface{}\n    var closest_diff float64\n    for i := 0; i\
    \ < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n   \
    \         diff := numbers[j] - numbers[i]\n            if closest_diff == 0 ||\
    \ diff < closest_diff {\n                closest_diff = diff\n               \
    \ closest = []interface{}{numbers[i], numbers[j]}\n            }\n        }\n\
    \    }\n    return closest\n}\n", "    var closest_elements []interface{}\n  \
    \  var closest_distance float64\n    for i := 0; i < len(numbers); i++ {\n   \
    \     for j := i + 1; j < len(numbers); j++ {\n            distance := numbers[j]\
    \ - numbers[i]\n            if closest_distance == 0 || distance < closest_distance\
    \ {\n                closest_elements = []interface{}{numbers[i], numbers[j]}\n\
    \                closest_distance = distance\n            }\n        }\n    }\n\
    \    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_difference float64 = numbers[1] - numbers[0]\n    for i := 0;\
    \ i < len(numbers) - 1; i++ {\n        if numbers[i+1] - numbers[i] < closest_difference\
    \ {\n            closest_difference = numbers[i+1] - numbers[i]\n            closest_elements\
    \ = []interface{}{numbers[i], numbers[i+1]}\n        }\n    }\n    return closest_elements\n\
    }\n", "    var closest_elements []interface{}\n    var closest_difference float64\
    \ = numbers[1] - numbers[0]\n    var closest_index int = 0\n    for i := 1; i\
    \ < len(numbers) - 1; i++ {\n        diff := numbers[i + 1] - numbers[i]\n   \
    \     if diff < closest_difference {\n            closest_difference = diff\n\
    \            closest_index = i\n        }\n    }\n    closest_elements = append(closest_elements,\
    \ numbers[closest_index])\n    closest_elements = append(closest_elements, numbers[closest_index\
    \ + 1])\n    return closest_elements\n}\n", "    var closest_elements []interface{}\n\
    \    var closest_difference float64 = numbers[1] - numbers[0]\n    for i := 0;\
    \ i < len(numbers) - 1; i++ {\n        difference := numbers[i + 1] - numbers[i]\n\
    \        if difference < closest_difference {\n            closest_difference\
    \ = difference\n            closest_elements = []interface{}{numbers[i], numbers[i\
    \ + 1]}\n        }\n    }\n    return closest_elements\n}\n", "    var closest\
    \ []interface{}\n    var closest_diff float64\n    for i := 0; i < len(numbers)\
    \ - 1; i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            diff\
    \ := numbers[j] - numbers[i]\n            if closest_diff == 0 || diff < closest_diff\
    \ {\n                closest_diff = diff\n                closest = []interface{}{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n    return closest\n}\n", "  \
    \  // TODO: Implement this function\n    return []interface{}{}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
