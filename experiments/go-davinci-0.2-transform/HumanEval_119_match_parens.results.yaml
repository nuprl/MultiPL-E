language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    str1, str2 := lst[0], lst[1]\n    if len(str1) ==\
    \ 0 || len(str2) == 0 {\n        return \"No\"\n    }\n    if len(str1) % 2 !=\
    \ 0 || len(str2) % 2 != 0 {\n        return \"No\"\n    }\n    if str1[0] == ')'\
    \ || str2[0] == ')' {\n        return \"No\"\n    }\n    if str1[len(str1)-1]\
    \ == '(' || str2[len(str2)-1] == '(' {\n        return \"No\"\n    }\n    if len(str1)\
    \ == 2 && len(str2) == 2 {\n        return \"Yes\"\n    }\n    if len(str1) ==\
    \ 2 {\n        return match_parens([]string{str2, str1})\n    }\n    if len(str2)\
    \ == 2 {\n        return match_parens([]string{str1, str2})\n    }\n    if str1[0]\
    \ == '(' && str1[len(str1)-1] == ')' {\n        return match_parens([]string{str1[1:len(str1)-1],\
    \ str2})\n    }\n    if str2[0] == '(' && str2[len(str2)-1] == ')' {\n       \
    \ return match_parens([]string{str1, str2[1:len(str2)-1]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpmuinpnhd_test.go:80: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpmuinpnhd_test.go:80: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpmuinpnhd_test.go:80: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpmuinpnhd_test.go:80: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpmuinpnhd_test.go:80: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpmuinpnhd_test.go:80: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == '(' {\n\
    \            for j := i + 1; j < len(s); j++ {\n                if s[j] == ')'\
    \ {\n                    s = s[:i] + s[i+1:j] + s[j+1:]\n                    i\
    \ = -1\n                    break\n                }\n            }\n        }\n\
    \    }\n    if len(s) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf4ip5vrl_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf4ip5vrl_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf4ip5vrl_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmsuq0e2z_test.go:30:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:33:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:35:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:38:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:41:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:44:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: implement\n    return\
    \ \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn9ahv5nj_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn_540ory_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn_540ory_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn_540ory_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    if match_parens_helper(s1) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s1 + s2) == \"Yes\"\
    \ {\n        return \"Yes\"\n    }\n    if match_parens_helper(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmfea8nie_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:33:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:35:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:38:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:41:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:44:8: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []rune\n    for _, r := range s {\n        if r\
    \ == '(' {\n            stack = append(stack, r)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp0cog_nkn_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp0cog_nkn_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp0cog_nkn_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close || s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp8q7r8zuv_test.go:73: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8q7r8zuv_test.go:73: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        l1, l2 int\n        res string\n    )\n    s1 = lst[0]\n\
    \    s2 = lst[1]\n    l1 = len(s1)\n    l2 = len(s2)\n    for i = 0; i < l1; i++\
    \ {\n        if s1[i] == '(' {\n            for j = 0; j < l2; j++ {\n       \
    \         if s2[j] == ')' {\n                    s1 = s1[:i] + s1[i+1:]\n    \
    \                s2 = s2[:j] + s2[j+1:]\n                    l1--\n          \
    \          l2--\n                    i--\n                    break\n        \
    \        }\n            }\n        }\n    }\n    if l1 == 0 && l2 == 0 {\n   \
    \     res = \"Yes\"\n    } else {\n        res = \"No\"\n    }\n    return res\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppwc75h1r_test.go:78: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmppwc75h1r_test.go:78: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmppwc75h1r_test.go:78: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmppwc75h1r_test.go:78: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmppwc75h1r_test.go:78: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1 + s2) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfts5y72f_test.go:27:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:30:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:32:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:35:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []byte\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, byte(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpaieu3mrb_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn9ahv5nj_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073606
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 byte\n        ok bool\n    )\n    s1, s2 = lst[0],\
    \ lst[1]\n    for i, j = 0, 0; i < len(s1) && j < len(s2); {\n        c1, c2 =\
    \ s1[i], s2[j]\n        if c1 == '(' {\n            i++\n        } else {\n  \
    \          i--\n        }\n        if c2 == '(' {\n            j++\n        }\
    \ else {\n            j--\n        }\n        if i < 0 || j < 0 {\n          \
    \  break\n        }\n    }\n    if i == 0 && j == 0 {\n        ok = true\n   \
    \ } else {\n        ok = false\n    }\n    if ok {\n        return \"Yes\"\n \
    \   } else {\n        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073715
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open += 1\n        } else {\n            s1_close += 1\n     \
    \   }\n    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open\
    \ += 1\n        } else {\n            s2_close += 1\n        }\n    }\n    if\
    \ s1_open == s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps9iuzxlq_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps9iuzxlq_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps9iuzxlq_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps9iuzxlq_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmps9iuzxlq_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_string(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpheib4qs6_test.go:26:12: undefined: match_parens_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: implement\n    return\
    \ \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []byte\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, byte(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpaieu3mrb_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []byte\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, byte(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpaieu3mrb_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        i int\n    )\n    for i = 0; i < len(lst[0]); i++ {\n        if\
    \ lst[0][i] == '(' {\n            open++\n        } else {\n            close++\n\
    \        }\n    }\n    for i = 0; i < len(lst[1]); i++ {\n        if lst[1][i]\
    \ == '(' {\n            open++\n        } else {\n            close++\n      \
    \  }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpv7erikb2_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_0cudrv_test.go:30:16: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:33:16: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:35:8: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        i, j, k int\n\
    \        res string\n    )\n    for i = 0; i < len(lst); i++ {\n        for j\
    \ = 0; j < len(lst[i]); j++ {\n            if lst[i][j] == '(' {\n           \
    \     k++\n            } else {\n                k--\n            }\n        \
    \    if k < 0 {\n                return \"No\"\n            }\n        }\n   \
    \ }\n    if k == 0 {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\
    \n    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpk_094eac_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpk_094eac_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpk_094eac_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []byte\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, byte(c))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpn9ahv5nj_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpn9ahv5nj_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, c)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp4gdaiv64_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp4gdaiv64_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp4gdaiv64_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2})\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens([]string{s1})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n \
    \       return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] ==\
    \ '(' {\n        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0]\
    \ == ')' {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqa4yv9qi_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ count := 0\n    for _, c := range s {\n        if c == '(' {\n            count++\n\
    \        } else {\n            count--\n        }\n        if count < 0 {\n  \
    \          return \"No\"\n        }\n    }\n    if count == 0 {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpukb_pdot_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpukb_pdot_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpukb_pdot_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    s = lst[0]\
    \ + lst[1]\n    var count int\n    for _, c := range s {\n        if c == '('\
    \ {\n            count++\n        } else {\n            count--\n        }\n \
    \       if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpi89vzbyw_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpi89vzbyw_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpi89vzbyw_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    if match_parens_helper(s1) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if match_parens_helper(s1 + s2) == \"Yes\"\
    \ {\n        return \"Yes\"\n    }\n    if match_parens_helper(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmfea8nie_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:33:16: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:35:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:38:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:41:8: undefined: match_parens_helper

    /tmp/tmpmfea8nie_test.go:44:8: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2})\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens([]string{s1})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n \
    \       return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] ==\
    \ '(' {\n        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0]\
    \ == ')' {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bnjemr8_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if is_good(s) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfhywnfip_test.go:26:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []rune\n    for _, r := range s {\n        if r\
    \ == '(' {\n            stack = append(stack, r)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmprfb4101j_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmprfb4101j_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmprfb4101j_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2})\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens([]string{s1})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n \
    \       return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] ==\
    \ '(' {\n        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0]\
    \ == ')' {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            res += \"()\"\n            i++\n            j++\n        } else if\
    \ s1[i] == '(' {\n            res += \"(\"\n            i++\n        } else if\
    \ s2[j] == ')' {\n            res += \")\"\n            j++\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if i < len(s1) {\n        res\
    \ += s1[i:]\n    }\n    if j < len(s2) {\n        res += s2[j:]\n    }\n    if\
    \ len(res) == 0 {\n        return \"Yes\"\n    }\n    if len(res) % 2 == 1 {\n\
    \        return \"No\"\n    }\n    var (\n        stack []byte\n        c byte\n\
    \    )\n    for i := 0; i < len(res); i++ {\n        c = res[i]\n        if c\
    \ == '(' {\n            stack = append(stack, c)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpnyj4pvdt_test.go:100: expected 'Yes', got 'No'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpnyj4pvdt_test.go:100:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpnyj4pvdt_test.go:100: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpnyj4pvdt_test.go:100: expected 'Yes', got 'No'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__11 (0.00s)\n        tmpnyj4pvdt_test.go:100:\
    \ expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == '(' {\n            stack = append(stack, s[i])\n        } else\
    \ {\n            if len(stack) == 0 {\n                return \"No\"\n       \
    \     }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpbd6ll9py_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpbd6ll9py_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpbd6ll9py_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        r1, r2 int\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  i, j = 0, 0\n    for i < len(s1) {\n        if s1[i] == '(' {\n           \
    \ r1++\n        } else {\n            r1--\n        }\n        i++\n    }\n  \
    \  for j < len(s2) {\n        if s2[j] == '(' {\n            r2++\n        } else\
    \ {\n            r2--\n        }\n        j++\n    }\n    if r1 == 0 && r2 ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvxvfagp1_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpvxvfagp1_test.go:75: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpvxvfagp1_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpvxvfagp1_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvxvfagp1_test.go:75: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpvxvfagp1_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpvxvfagp1_test.go:75: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_rec(s)\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_r58w7u_test.go:26:12: undefined: match_parens_rec

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, c)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcw3suv28_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var result string\n    var\
    \ open, close int\n    for _, s := range lst {\n        for _, c := range s {\n\
    \            if c == '(' {\n                open++\n            } else {\n   \
    \             close++\n            }\n        }\n    }\n    if open == close {\n\
    \        result = \"Yes\"\n    } else {\n        result = \"No\"\n    }\n    return\
    \ result\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp1p1grdcb_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var stack []string\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                stack = append(stack, \"(\")\n            } else {\n    \
    \            if len(stack) == 0 {\n                    return \"No\"\n       \
    \         }\n                stack = stack[:len(stack)-1]\n            }\n   \
    \     }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf7nlnqy5_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf7nlnqy5_test.go:65: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if is_good(s1 + s2)\
    \ {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvfev5nou_test.go:26:8: undefined: is_good

    /tmp/tmpvfev5nou_test.go:29:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement this function\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpbov3mp3__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpbov3mp3__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpbov3mp3__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpbov3mp3__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpbov3mp3__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpbov3mp3__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpbov3mp3__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpbov3mp3__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpbov3mp3__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpbov3mp3__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpbov3mp3__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpbov3mp3__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        count int\n    )\n    s1, s2 = lst[0], lst[1]\n   \
    \ for i, j = 0, len(s2) - 1; i < len(s1) && j >= 0; i, j = i + 1, j - 1 {\n  \
    \      if s1[i] == '(' {\n            count++\n        } else {\n            count--\n\
    \        }\n        if s2[j] == ')' {\n            count++\n        } else {\n\
    \            count--\n        }\n        if count < 0 {\n            return \"\
    No\"\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp9g3rj3rf_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp9g3rj3rf_test.go:73: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmp9g3rj3rf_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp9g3rj3rf_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp9g3rj3rf_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp9g3rj3rf_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp9g3rj3rf_test.go:73: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) == 0 {\n     \
    \   return \"Yes\"\n    }\n    if len(lst) == 1 {\n        return \"No\"\n   \
    \ }\n    if len(lst[0]) == 0 {\n        return match_parens(lst[1:])\n    }\n\
    \    if len(lst[1]) == 0 {\n        return match_parens(lst[:1])\n    }\n    if\
    \ lst[0][0] == '(' {\n        if lst[1][0] == ')' {\n            return match_parens([]string{lst[0][1:],\
    \ lst[1][1:]})\n        } else {\n            return match_parens([]string{lst[0][1:],\
    \ lst[1]})\n        }\n    } else {\n        if lst[1][0] == ')' {\n         \
    \   return match_parens([]string{lst[0], lst[1][1:]})\n        } else {\n    \
    \        return \"No\"\n        }\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpmrlqq419_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpmrlqq419_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpmrlqq419_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpmrlqq419_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpmrlqq419_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpmrlqq419_test.go:73: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        left, right\
    \ int\n        str string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                left++\n        \
    \    } else {\n                right++\n            }\n        }\n        str\
    \ += s\n    }\n    if left == right {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp4gufjecr_test.go:66: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(lst) == 1 {\n        return \"Yes\"\n   \
    \ }\n    if len(lst) == 2 {\n        return match_parens_helper(lst[0], lst[1])\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pute882_test.go:29:16: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpipkgq425_test.go:49: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpipkgq425_test.go:49: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpipkgq425_test.go:49:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpipkgq425_test.go:49: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073610
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for i := 0; i < len(s); i++ {\n   \
    \     if s[i] == '(' {\n            stack = append(stack, s[i])\n        } else\
    \ {\n            if len(stack) == 0 {\n                return \"No\"\n       \
    \     }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp21hezssj_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp21hezssj_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp21hezssj_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        lst_len = len(lst)\n\
    \        lst_str = \"\"\n        lst_str_len = 0\n        lst_str_open_parens\
    \ = 0\n        lst_str_close_parens = 0\n        lst_str_open_parens_diff = 0\n\
    \        lst_str_close_parens_diff = 0\n        lst_str_open_parens_diff_sum =\
    \ 0\n        lst_str_close_parens_diff_sum = 0\n        lst_str_open_parens_diff_sum_max\
    \ = 0\n        lst_str_close_parens_diff_sum_max = 0\n        lst_str_open_parens_diff_sum_min\
    \ = 0\n        lst_str_close_parens_diff_sum_min = 0\n        lst_str_open_parens_diff_sum_max_index\
    \ = 0\n        lst_str_close_parens_diff_sum_max_index = 0\n        lst_str_open_parens_diff_sum_min_index\
    \ = 0\n        lst_str_close_parens_diff_sum_min_index = 0\n        lst_str_open_parens_diff_sum_max_index_prev\
    \ = 0\n        lst_str_close_parens_diff_sum_max_index_prev = 0\n        lst_str_open_parens_diff_sum_min_index_prev\
    \ = 0\n        lst_str_close_parens_diff_sum_min_index_prev = 0\n        lst_str_open_parens_diff_sum_max_index_next\
    \ = 0\n        lst_str_close_parens_diff_sum_max_index_next = 0\n        lst_str_open_parens_diff_sum_min_index_next\
    \ = 0\n        lst_str_close_parens_diff_sum_min_index_next = 0\n        lst_str_open_parens_diff_sum_max_index_prev_next\
    \ = 0\n        lst_str_close_parens_diff_sum_max_index\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3frtd_jz_test.go:49:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073705
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if is_balanced(s) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb9qwlsqw_test.go:26:8: undefined: is_balanced

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open_parens, close_parens\
    \ int\n    for _, s := range lst {\n        for _, c := range s {\n          \
    \  if c == '(' {\n                open_parens++\n            } else {\n      \
    \          close_parens++\n            }\n        }\n    }\n    if open_parens\
    \ == close_parens {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmplf5fz1fs_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, c)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcw3suv28_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1 = lst[0]\n\
    \        s2 = lst[1]\n        s3 = s1 + s2\n        s4 = s2 + s1\n    )\n    if\
    \ is_good(s3) {\n        return \"Yes\"\n    }\n    if is_good(s4) {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0_7tv6y1_test.go:28:8: undefined: is_good

    /tmp/tmp0_7tv6y1_test.go:31:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var res string\n    for _,\
    \ s := range lst {\n        res += s\n    }\n    return match_parens_helper(res)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy739idga_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open_parens\
    \ int\n        close_parens int\n    )\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                open_parens++\n\
    \            } else {\n                close_parens++\n            }\n       \
    \ }\n    }\n    if open_parens == close_parens {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpvq9o_k12_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    if len(s) % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    var stack []byte\n    for _, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, '(')\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp844w2uqc_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp844w2uqc_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp844w2uqc_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []rune\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, v)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp6itgj8m1_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6itgj8m1_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i = 0; i < len(s1); i++ {\n        if s1[i] == '(' {\n            for j\
    \ = 0; j < len(s2); j++ {\n                if s2[j] == ')' {\n               \
    \     res = s1[:i] + s2[:j] + s1[i:] + s2[j:]\n                    if is_good(res)\
    \ {\n                        return \"Yes\"\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprcztgl1r_test.go:33:24: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n       \
    \ return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hwqbcfv_test.go:27:16: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:30:16: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:32:8: undefined: check_parens

    /tmp/tmp2hwqbcfv_test.go:35:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open_count,\
    \ close_count int\n        result string\n    )\n    for _, s := range lst {\n\
    \        for _, c := range s {\n            if c == '(' {\n                open_count++\n\
    \            } else {\n                close_count++\n            }\n        }\n\
    \    }\n    if open_count == close_count {\n        result = \"Yes\"\n    } else\
    \ {\n        result = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsdbscdio_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s3 string\n        i, j int\n        l1, l2 int\n        l3 int\n   \
    \     c1, c2, c3 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    l1 = len(s1)\n\
    \    l2 = len(s2)\n    l3 = l1 + l2\n    c1 = 0\n    c2 = 0\n    c3 = 0\n    for\
    \ i = 0; i < l1; i++ {\n        if s1[i] == '(' {\n            c1++\n        }\
    \ else {\n            c1--\n        }\n    }\n    for j = 0; j < l2; j++ {\n \
    \       if s2[j] == '(' {\n            c2++\n        } else {\n            c2--\n\
    \        }\n    }\n    if c1 != c2 {\n        return \"No\"\n    }\n    for i\
    \ = 0; i < l1; i++ {\n        if s1[i] == '(' {\n            c3++\n        } else\
    \ {\n            c3--\n        }\n        if c3 < 0 {\n            break\n   \
    \     }\n    }\n    if c3 == 0 {\n        return \"Yes\"\n    }\n    for j = 0;\
    \ j < l2; j++ {\n        if s2[j] == '(' {\n            c3++\n        } else {\n\
    \            c3--\n        }\n        if c3 == 0 {\n            return \"Yes\"\
    \n        }\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcssfq6cx_test.go:24:9: s3 declared but not used

    /tmp/tmpcssfq6cx_test.go:27:9: l3 declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ var stack []rune\n    for _, r := range s {\n        if r == '(' {\n       \
    \     stack = append(stack, r)\n        } else {\n            if len(stack) ==\
    \ 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpu5ztb67y_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpu5ztb67y_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpu5ztb67y_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        s string\n    )\n    for _, s = range lst {\n        for _, c :=\
    \ range s {\n            if c == '(' {\n                open++\n            }\
    \ else {\n                close++\n            }\n        }\n    }\n    if open\
    \ == close {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp57q80i5l_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_balanced(s2)\n    }\n    if len(s2) == 0 {\n        return is_balanced(s1)\n\
    \    }\n    if is_balanced(s1) == \"Yes\" {\n        return is_balanced(s2)\n\
    \    }\n    if is_balanced(s2) == \"Yes\" {\n        return is_balanced(s1)\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgdn1ih_g_test.go:30:16: undefined: is_balanced

    /tmp/tmpgdn1ih_g_test.go:33:16: undefined: is_balanced

    /tmp/tmpgdn1ih_g_test.go:35:8: undefined: is_balanced

    /tmp/tmpgdn1ih_g_test.go:36:16: undefined: is_balanced

    /tmp/tmpgdn1ih_g_test.go:38:8: undefined: is_balanced

    /tmp/tmpgdn1ih_g_test.go:39:16: undefined: is_balanced

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        res string\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    if len(s1) ==\
    \ 0 {\n        if len(s2) == 0 {\n            return \"Yes\"\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if len(s2) == 0 {\n        if\
    \ len(s1) == 0 {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }\n    }\n    if s1[0] == '(' {\n        res = match_parens([]string{s1[1:],\
    \ s2})\n        if res == \"Yes\" {\n            return res\n        }\n    }\n\
    \    if s2[0] == '(' {\n        res = match_parens([]string{s1, s2[1:]})\n   \
    \     if res == \"Yes\" {\n            return res\n        }\n    }\n    if s1[0]\
    \ == ')' {\n        res = match_parens([]string{s1[1:], s2})\n        if res ==\
    \ \"Yes\" {\n            return res\n        }\n    }\n    if s2[0] == ')' {\n\
    \        res = match_parens([]string{s1, s2[1:]})\n        if res == \"Yes\" {\n\
    \            return res\n        }\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpsjgwrwud_test.go:93: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpsjgwrwud_test.go:93: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpsjgwrwud_test.go:93: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpsjgwrwud_test.go:93: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpsjgwrwud_test.go:93: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpsjgwrwud_test.go:93: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 byte\n        ok bool\n    )\n    s1, s2 = lst[0],\
    \ lst[1]\n    for i, j = 0, 0; i < len(s1) && j < len(s2); {\n        c1, c2 =\
    \ s1[i], s2[j]\n        if c1 == '(' && c2 == ')' {\n            i++\n       \
    \     j++\n        } else if c1 == '(' && c2 == '(' {\n            i++\n     \
    \   } else if c1 == ')' && c2 == ')' {\n            j++\n        } else {\n  \
    \          break\n        }\n    }\n    if i == len(s1) && j == len(s2) {\n  \
    \      return \"Yes\"\n    }\n    for i, j = 0, 0; i < len(s1) && j < len(s2);\
    \ {\n        c1, c2 = s1[i], s2[j]\n        if c1 == '(' && c2 == ')' {\n    \
    \        i++\n            j++\n        } else if c1 == '(' && c2 == '(' {\n  \
    \          j++\n        } else if c1 == ')' && c2 == ')' {\n            i++\n\
    \        } else {\n            break\n        }\n    }\n    if i == len(s1) &&\
    \ j == len(s2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfzdckdkd_test.go:26:9: ok declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        i, j int\n\
    \        s1, s2 string\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    for i = 0;\
    \ i < len(s1); i++ {\n        if s1[i] == '(' {\n            for j = 0; j < len(s2);\
    \ j++ {\n                if s2[j] == ')' {\n                    s1 = s1[:i] +\
    \ s1[i+1:]\n                    s2 = s2[:j] + s2[j+1:]\n                    break\n\
    \                }\n            }\n        }\n    }\n    if len(s1) == 0 && len(s2)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8nmytpb7_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8nmytpb7_test.go:69: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8nmytpb7_test.go:69: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8nmytpb7_test.go:69: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmp8nmytpb7_test.go:69: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 byte\n        open, close int\n    )\n    s1,\
    \ s2 = lst[0], lst[1]\n    for i = 0; i < len(s1); i++ {\n        c1 = s1[i]\n\
    \        if c1 == '(' {\n            open++\n        } else {\n            close++\n\
    \        }\n    }\n    for j = 0; j < len(s2); j++ {\n        c2 = s2[j]\n   \
    \     if c2 == '(' {\n            open++\n        } else {\n            close++\n\
    \        }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n   \
    \ return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmphpcx_7ix_test.go:75: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    return match_parens_helper(s)\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqa4yv9qi_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open, s1_close, s2_close int\n    )\n    if len(lst) != 2\
    \ {\n        return \"No\"\n    }\n    s1, s2 = lst[0], lst[1]\n    for _, c :=\
    \ range s1 {\n        if c == '(' {\n            s1_open++\n        } else {\n\
    \            s1_close++\n        }\n    }\n    for _, c := range s2 {\n      \
    \  if c == '(' {\n            s2_open++\n        } else {\n            s2_close++\n\
    \        }\n    }\n    if s1_open == s2_close && s1_close == s2_open {\n     \
    \   return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp57v2j9qj_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp57v2j9qj_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp57v2j9qj_test.go:74: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    var stack []byte\n    for i :=\
    \ 0; i < len(s); i++ {\n        if s[i] == '(' {\n            stack = append(stack,\
    \ s[i])\n        } else {\n            if len(stack) == 0 {\n                return\
    \ \"No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp1pcdyel5_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp1pcdyel5_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp1pcdyel5_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ check_parens(s1)\n    }\n    if check_parens(s1) == \"Yes\" && check_parens(s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1 + s2) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"\
    Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfts5y72f_test.go:27:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:30:16: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:32:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:35:8: undefined: check_parens

    /tmp/tmpfts5y72f_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    return match_parens_str(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp41w1e_ox_test.go:26:12: undefined: match_parens_str

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: implement\n    return\
    \ \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpamrjxyqu_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpamrjxyqu_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpamrjxyqu_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpamrjxyqu_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpwmme76wk_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_0cudrv_test.go:30:16: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:33:16: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:35:8: undefined: check_parens

    /tmp/tmph_0cudrv_test.go:38:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        res string\n    )\n    for _, s := range lst {\n        for _,\
    \ c := range s {\n            if c == '(' {\n                open++\n        \
    \    } else {\n                close++\n            }\n        }\n    }\n    if\
    \ open == close {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n\
    \    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpyqrongtc_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s1 +\
    \ s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if is_good(s2 + s1) ==\
    \ \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmsuq0e2z_test.go:30:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:33:16: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:35:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:38:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:41:8: undefined: is_good

    /tmp/tmpmsuq0e2z_test.go:44:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_len, s2_len int\n        s1_open, s2_open int\n        s1_close, s2_close\
    \ int\n        s1_open_close, s2_open_close int\n        s1_close_open, s2_close_open\
    \ int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    s1_len = len(s1)\n    s2_len\
    \ = len(s2)\n    for i := 0; i < s1_len; i++ {\n        if s1[i] == '(' {\n  \
    \          s1_open++\n        } else {\n            s1_close++\n        }\n  \
    \  }\n    for i := 0; i < s2_len; i++ {\n        if s2[i] == '(' {\n         \
    \   s2_open++\n        } else {\n            s2_close++\n        }\n    }\n  \
    \  if s1_open > s2_close {\n        s1_open_close = s1_open - s2_close\n    }\
    \ else {\n        s1_open_close = s2_close - s1_open\n    }\n    if s1_close >\
    \ s2_open {\n        s1_close_open = s1_close - s2_open\n    } else {\n      \
    \  s1_close_open = s2_open - s1_close\n    }\n    if s1_open_close % 2 == 0 &&\
    \ s1_close_open % 2 == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy6_dm07__test.go:27:24: s2_open_close declared but not used

    /tmp/tmpy6_dm07__test.go:28:24: s2_close_open declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n\
    \        return \"Yes\"\n    }\n    if len(s2) == 0 {\n        return \"Yes\"\n\
    \    }\n    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmped2y_lzm_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmped2y_lzm_test.go:71: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmped2y_lzm_test.go:71: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        i int\n    )\n    for i = 0; i < len(lst[0]); i++ {\n        if\
    \ lst[0][i] == '(' {\n            open++\n        } else {\n            close++\n\
    \        }\n    }\n    for i = 0; i < len(lst[1]); i++ {\n        if lst[1][i]\
    \ == '(' {\n            open++\n        } else {\n            close++\n      \
    \  }\n    }\n    if open == close {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpv7erikb2_test.go:70: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    if is_good(s) {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppotoxlh0_test.go:26:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2, \"\"})\n    }\n    if len(s2) == 0 {\n  \
    \      return match_parens([]string{s1, \"\"})\n    }\n    if s1[0] == '(' {\n\
    \        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0] == ')'\
    \ {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0338\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52038f?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.match_parens({0xc0201e03a0?,\
    \ 0x2?, 0x2?})\n\t/tmp/tmp0lf_8ahv_test.go:21 +0x1f5 fp=0xc0201e0348 sp=0xc0201e0340\
    \ pc=0x4ef855\ncommand-line-arguments_test.match_parens({0xc0201e0448?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e03f0 sp=0xc0201e0348\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e04f0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0498 sp=0xc0201e03f0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0598?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0540 sp=0xc0201e0498\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0640?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e05e8 sp=0xc0201e0540\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e06e8?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0690 sp=0xc0201e05e8\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0790?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0738 sp=0xc0201e0690\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0838?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e07e0 sp=0xc0201e0738\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e08e0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0888 sp=0xc0201e07e0\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0988?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp0lf_8ahv_test.go:33 +0x1b4 fp=0xc0201e0930 sp=0xc0201e0888\
    \ pc=0x4ef814\ncommand-line-arguments_test.match_parens({0xc0201e0a30?, 0x0?,\
    \ 0x0?})\n\t/tmp/"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens_helper(s2)\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens_helper(s1)\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8pr0umy_test.go:30:16: undefined: match_parens_helper

    /tmp/tmpt8pr0umy_test.go:33:16: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpm89jmi9e_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpm89jmi9e_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 int\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  i, j = 0, 0\n    c1, c2 = 0, 0\n    for i < len(s1) && j < len(s2) {\n    \
    \    if s1[i] == '(' {\n            c1++\n        } else {\n            c1--\n\
    \        }\n        if s2[j] == '(' {\n            c2++\n        } else {\n  \
    \          c2--\n        }\n        if c1 < 0 || c2 < 0 {\n            return\
    \ \"No\"\n        }\n        i++\n        j++\n    }\n    if i < len(s1) {\n \
    \       for i < len(s1) {\n            if s1[i] == '(' {\n                c1++\n\
    \            } else {\n                c1--\n            }\n            if c1\
    \ < 0 {\n                return \"No\"\n            }\n            i++\n     \
    \   }\n    } else if j < len(s2) {\n        for j < len(s2) {\n            if\
    \ s2[j] == '(' {\n                c2++\n            } else {\n               \
    \ c2--\n            }\n            if c2 < 0 {\n                return \"No\"\n\
    \            }\n            j++\n        }\n    }\n    if c1 == 0 && c2 == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpyva0moen_test.go:102: expected 'Yes', got 'No'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpyva0moen_test.go:102:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpyva0moen_test.go:102: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpyva0moen_test.go:102: expected 'Yes', got 'No'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpyva0moen_test.go:102:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpyva0moen_test.go:102: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ return match_parens_helper(s)\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuiq3i2hc_test.go:23:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  i, j = 0, 0\n    for i < len(s1) && j < len(s2) {\n        if s1[i] == '('\
    \ && s2[j] == ')' {\n            res += \"()\"\n            i++\n            j++\n\
    \        } else if s1[i] == '(' && s2[j] == '(' {\n            res += \"(\"\n\
    \            i++\n        } else if s1[i] == ')' && s2[j] == ')' {\n         \
    \   res += \")\"\n            j++\n        } else if s1[i] == ')' && s2[j] ==\
    \ '(' {\n            res += \"(\"\n            j++\n        }\n    }\n    for\
    \ i < len(s1) {\n        res += string(s1[i])\n        i++\n    }\n    for j <\
    \ len(s2) {\n        res += string(s2[j])\n        j++\n    }\n    if is_good(res)\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkyhdp1ac_test.go:53:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    var stack []byte\n    for _, v :=\
    \ range s {\n        if v == '(' {\n            stack = append(stack, byte(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpaieu3mrb_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpaieu3mrb_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        c1, c2 rune\n        balance int\n    )\n    s1, s2\
    \ = lst[0], lst[1]\n    for i, j = 0, 0; i < len(s1) && j < len(s2); {\n     \
    \   c1, c2 = rune(s1[i]), rune(s2[j])\n        if c1 == '(' {\n            balance++\n\
    \        } else {\n            balance--\n        }\n        if c2 == '(' {\n\
    \            balance++\n        } else {\n            balance--\n        }\n \
    \       if balance < 0 {\n            return \"No\"\n        }\n        i++\n\
    \        j++\n    }\n    if balance != 0 {\n        return \"No\"\n    }\n   \
    \ return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpthjsjd6a_test.go:77: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpthjsjd6a_test.go:77: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpthjsjd6a_test.go:77: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073708
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s := lst[0] + lst[1]\n   \
    \ stack := make([]rune, 0)\n    for _, r := range s {\n        if r == '(' {\n\
    \            stack = append(stack, r)\n        } else {\n            if len(stack)\
    \ == 0 {\n                return \"No\"\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpyx15oh_2_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpyx15oh_2_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpyx15oh_2_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073708
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return match_parens([]string{s2})\n    }\n    if len(s2) == 0 {\n        return\
    \ match_parens([]string{s1})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n \
    \       return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] ==\
    \ '(' {\n        return match_parens([]string{s1[1:], s2})\n    }\n    if s2[0]\
    \ == ')' {\n        return match_parens([]string{s1, s2[1:]})\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmphp0hyn5k_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmphp0hyn5k_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073611
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO: Implement me\n  \
    \  return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp2opunfe__test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp2opunfe__test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp2opunfe__test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp2opunfe__test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073607
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        s string\n    )\n    for _, s = range lst {\n        for _, c :=\
    \ range s {\n            if c == '(' {\n                open++\n            }\
    \ else {\n                close++\n            }\n        }\n    }\n    if open\
    \ == close {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp57q80i5l_test.go:65: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, r :=\
    \ range s {\n        if r == '(' {\n            stack = append(stack, r)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpwmme76wk_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpwmme76wk_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        i, j int\n        res string\n    )\n    s1, s2 = lst[0], lst[1]\n  \
    \  for i < len(s1) && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n\
    \            i++\n            j++\n        } else if s1[i] == '(' && s2[j] ==\
    \ '(' {\n            i++\n        } else if s1[i] == ')' && s2[j] == ')' {\n \
    \           j++\n        } else {\n            return \"No\"\n        }\n    }\n\
    \    if i < len(s1) {\n        res = s1[i:]\n    } else if j < len(s2) {\n   \
    \     res = s2[j:]\n    }\n    if len(res) % 2 == 0 {\n        return \"No\"\n\
    \    }\n    for i := 0; i < len(res); i++ {\n        if res[i] == '(' {\n    \
    \        return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpxfhvwxzv_test.go:80: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpxfhvwxzv_test.go:80: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpxfhvwxzv_test.go:80: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpxfhvwxzv_test.go:80: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpxfhvwxzv_test.go:80: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpxfhvwxzv_test.go:80: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpxfhvwxzv_test.go:80: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073708
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return check_parens(s2)\n    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n\
    \    }\n    if check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n\
    \    if check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s1\
    \ + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2 +\
    \ s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdngj3oy7_test.go:30:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:33:16: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:35:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:38:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:41:8: undefined: check_parens

    /tmp/tmpdngj3oy7_test.go:44:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073604
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, v\
    \ := range lst {\n        s += v\n    }\n    return match_parens_helper(s)\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptydlkbcw_test.go:26:12: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var open, close int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                open++\n            } else {\n                close++\n \
    \           }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpnw8hkoyf_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    str1, str2 := lst[0], lst[1]\n    if len(str1) ==\
    \ 0 || len(str2) == 0 {\n        return \"No\"\n    }\n    if len(str1) == 1 &&\
    \ len(str2) == 1 {\n        if str1 == \"(\" && str2 == \")\" {\n            return\
    \ \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n   \
    \ if len(str1) == 1 {\n        if str1 == \"(\" {\n            return match_parens([]string{str2[1:],\
    \ str2[:len(str2)-1]})\n        } else {\n            return \"No\"\n        }\n\
    \    }\n    if len(str2) == 1 {\n        if str2 == \")\" {\n            return\
    \ match_parens([]string{str1[1:], str1[:len(str1)-1]})\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpk5sslk18_test.go:77: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpk5sslk18_test.go:77: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpk5sslk18_test.go:77: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpk5sslk18_test.go:77: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpk5sslk18_test.go:77: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073708
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        result string\n    )\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                open++\n     \
    \       } else {\n                close++\n            }\n        }\n    }\n \
    \   if open == close {\n        result = \"Yes\"\n    } else {\n        result\
    \ = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp5emz724n_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073708
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    // TODO - Add your code here\n\
    \    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp8vee9v72_test.go:50: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp8vee9v72_test.go:50: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp8vee9v72_test.go:50:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp8vee9v72_test.go:50: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1 = lst[0]\n\
    \        s2 = lst[1]\n        s3 = s1 + s2\n        s4 = s2 + s1\n    )\n    if\
    \ is_good(s3) {\n        return \"Yes\"\n    }\n    if is_good(s4) {\n       \
    \ return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0_7tv6y1_test.go:28:8: undefined: is_good

    /tmp/tmp0_7tv6y1_test.go:31:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073706
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi6vc1vj6_test.go:49: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi6vc1vj6_test.go:49: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, str\
    \ := range lst {\n        s += str\n    }\n    if is_good(s) {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt6lc9dy5_test.go:26:8: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    s1, s2 := lst[0], lst[1]\n\
    \    if len(s1) == 0 {\n        return check_parens(s2)\n    }\n    if len(s2)\
    \ == 0 {\n        return check_parens(s1)\n    }\n    if check_parens(s1) == \"\
    Yes\" && check_parens(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ check_parens(s1 + s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2\
    \ + s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg1pedx0y_test.go:24:16: undefined: check_parens

    /tmp/tmpg1pedx0y_test.go:27:16: undefined: check_parens

    /tmp/tmpg1pedx0y_test.go:29:8: undefined: check_parens

    /tmp/tmpg1pedx0y_test.go:32:8: undefined: check_parens

    /tmp/tmpg1pedx0y_test.go:35:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        lst_len = len(lst)\n\
    \        i, j int\n        str1, str2 string\n        str1_len, str2_len int\n\
    \        str1_open, str2_open int\n        str1_close, str2_close int\n      \
    \  str1_open_close, str2_open_close int\n        str1_close_open, str2_close_open\
    \ int\n        str1_open_close_open, str2_open_close_open int\n        str1_close_open_close,\
    \ str2_close_open_close int\n        str1_open_close_open_close, str2_open_close_open_close\
    \ int\n        str1_close_open_close_open, str2_close_open_close_open int\n  \
    \      str1_open_close_open_close_open, str2_open_close_open_close_open int\n\
    \        str1_close_open_close_open_close, str2_close_open_close_open_close int\n\
    \        str1_open_close_open_close_open_close, str2_open_close_open_close_open_close\
    \ int\n        str1_close_open_close_open_close_open, str2_close_open_close_open_close_open\
    \ int\n        str1_open_close_open_close_open_close_open, str2_open_close_open_close_open_close_open\
    \ int\n        str1_close_open_close_open_close_open_close, str2_close_open_close_open_close_open_close\
    \ int\n        str1_open_close_open_close_open_close_open_close, str2_open_close_open_close_open_close_open_close\
    \ int\n        str1_close_open_close_open_close_open_close_open, str2_close_open_close_open_close_open_close_open\
    \ int\n        str1_open_close_open_close_open_close_open_close_open, str2_open_close_open_close_open_close_open_close_open\
    \ int\n        str1_close_open_close\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdabpc2fc_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var left, right int\n    for\
    \ _, s := range lst {\n        for _, c := range s {\n            if c == '('\
    \ {\n                left++\n            } else {\n                right++\n \
    \           }\n        }\n    }\n    if left == right {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpty0dxs3m_test.go:62: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        return match_parens([]string{s1[1:], s2})\n  \
    \  }\n    if s2[0] == '(' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    if s1[0] == ')' {\n        return match_parens([]string{s1[1:], s2})\n\
    \    }\n    if s2[0] == ')' {\n        return match_parens([]string{s1, s2[1:]})\n\
    \    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp8wi35xmi_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8wi35xmi_test.go:74: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close || s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmp8q7r8zuv_test.go:73: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp8q7r8zuv_test.go:73: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmp8q7r8zuv_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp8q7r8zuv_test.go:73: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073704
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        s1, s2 string\n\
    \        s1_open, s2_open int\n        s1_close, s2_close int\n    )\n    s1 =\
    \ lst[0]\n    s2 = lst[1]\n    for _, c := range s1 {\n        if c == '(' {\n\
    \            s1_open++\n        } else {\n            s1_close++\n        }\n\
    \    }\n    for _, c := range s2 {\n        if c == '(' {\n            s2_open++\n\
    \        } else {\n            s2_close++\n        }\n    }\n    if s1_open ==\
    \ s2_close && s1_close == s2_open {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp5li5y_4d_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp5li5y_4d_test.go:73: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073605
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var s string\n    for _, s1\
    \ := range lst {\n        s += s1\n    }\n    var stack []rune\n    for _, c :=\
    \ range s {\n        if c == '(' {\n            stack = append(stack, c)\n   \
    \     } else {\n            if len(stack) == 0 {\n                return \"No\"\
    \n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcw3suv28_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcw3suv28_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073609
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return \"No\"\n    }\n    if len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmps2qo8rra_test.go:74: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmps2qo8rra_test.go:74: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073606
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    if len(lst) != 2 {\n     \
    \   return \"No\"\n    }\n    s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 &&\
    \ len(s2) == 0 {\n        return \"Yes\"\n    }\n    if len(s1) == 0 {\n     \
    \   return is_good(s2)\n    }\n    if len(s2) == 0 {\n        return is_good(s1)\n\
    \    }\n    if is_good(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if\
    \ is_good(s2) == \"Yes\" {\n        return \"Yes\"\n    }\n    return is_good(s1\
    \ + s2)\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzvzy7y4g_test.go:30:16: undefined: is_good

    /tmp/tmpzvzy7y4g_test.go:33:16: undefined: is_good

    /tmp/tmpzvzy7y4g_test.go:35:8: undefined: is_good

    /tmp/tmpzvzy7y4g_test.go:38:8: undefined: is_good

    /tmp/tmpzvzy7y4g_test.go:41:12: undefined: is_good

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073707
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens([]string{\"\
    ()(\", \")\"})\n// \"Yes\"\n// >>> match_parens([]string{\")\", \")\"})\n// \"\
    No\"\nfunc match_parens(lst []string) string {\n    var (\n        open, close\
    \ int\n        result string\n    )\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                open++\n     \
    \       } else {\n                close++\n            }\n        }\n    }\n \
    \   if open == close {\n        result = \"Yes\"\n    } else {\n        result\
    \ = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp5emz724n_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073708
