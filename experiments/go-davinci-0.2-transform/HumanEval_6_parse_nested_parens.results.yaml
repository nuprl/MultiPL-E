language: go_test.go
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var count int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            count++\n      \
    \  } else if char == ')' {\n            count--\n        } else if char == ' '\
    \ {\n            result = append(result, count)\n            count = 0\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmppejrz0f3_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmppejrz0f3_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmppejrz0f3_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_count int\n    var max_paren_count\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         paren_count += 1\n            if paren_count > max_paren_count {\n \
    \               max_paren_count = paren_count\n            }\n        } else if\
    \ char == ')' {\n            paren_count -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_paren_count)\n            max_paren_count\
    \ = 0\n            paren_count = 0\n        }\n    }\n    result = append(result,\
    \ max_paren_count)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   level++\n            if level > max_level {\n                max_level = level\n\
    \            }\n        } else if c == ')' {\n            level--\n        } else\
    \ if c == ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n            level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    for _, c :=\
    \ range paren_string {\n        if c == '(' {\n            depth++\n        }\
    \ else if c == ')' {\n            depth--\n        } else if c == ' ' {\n    \
    \        max_depth = append(max_depth, depth)\n            depth = 0\n       \
    \ }\n    }\n    max_depth = append(max_depth, depth)\n    return max_depth\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpjic4oswa_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpjic4oswa_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpjic4oswa_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            level++\n      \
    \  } else if char == ')' {\n            level--\n        } else if char == ' '\
    \ {\n            result = append(result, level)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            current_depth -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660074133
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []int\n    var current_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   paren_stack = append(paren_stack, current_level)\n            current_level++\n\
    \        } else if c == ')' {\n            current_level = paren_stack[len(paren_stack)-1]\n\
    \            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if\
    \ c == ' ' {\n            result = append(result, current_level)\n           \
    \ current_level = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpipfpka7z_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpipfpka7z_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpipfpka7z_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this function.\n    return []int{}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpq_dyu4a9_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpq_dyu4a9_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpq_dyu4a9_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074133
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    depth := 0\n    depths := []int{}\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depths\
    \ = append(depths, max_depth)\n            depth -= 1\n        }\n    }\n    return\
    \ depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp5bzdlv8x_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp5bzdlv8x_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp5bzdlv8x_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_nesting int\n    var current_nesting\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == ')' {\n            current_nesting -= 1\n        } else if char ==\
    \ ' ' {\n            result = append(result, max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result = append(result,\
    \ max_nesting)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         stack = append(stack, 1)\n            if len(stack) > max_depth {\n\
    \                max_depth = len(stack)\n            }\n        } else if char\
    \ == ')' {\n            stack = stack[:len(stack)-1]\n        } else if char ==\
    \ ' ' {\n            result = append(result, max_depth)\n            max_depth\
    \ = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8aeiudqn_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp8aeiudqn_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp8aeiudqn_test.go:48: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            if current_depth == 0 {\n                panic(\"Invalid\
    \ input string\")\n            }\n            current_depth -= 1\n           \
    \ if current_depth == 0 {\n                result = append(result, max_depth)\n\
    \                max_depth = 0\n            }\n        } else if char == ' ' {\n\
    \            continue\n        } else {\n            panic(\"Invalid input string\"\
    )\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         stack = append(stack, 1)\n            max_depth++\n        } else if\
    \ char == ')' {\n            stack = stack[:len(stack)-1]\n            max_depth--\n\
    \        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp2jw5q4ra_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp2jw5q4ra_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp2jw5q4ra_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            current_level = 0\n            max_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            current_level\
    \ += 1\n        } else if c == ')' {\n            result = append(result, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp90ef6098_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp90ef6098_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp90ef6098_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            current_level = 0\n            max_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth += 1\n        } else\
    \ if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n      \
    \      result = append(result, depth)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []int\n    var max_depth\
    \ int\n    var depth int\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            depth += 1\n            paren_stack = append(paren_stack,\
    \ depth)\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == ')' {\n            depth -= 1\n       \
    \     paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if c == '\
    \ ' {\n            result = append(result, max_depth)\n            max_depth =\
    \ 0\n            depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    max_depth := 0\n    depth\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if c == ')' {\n            depth -= 1\n\
    \        } else if c == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            depth++\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if c == ')' {\n            depth--\n        } else if\
    \ c == ' ' {\n            result = append(result, max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting []int\n    var current_nesting int\n  \
    \  for _, char := range paren_string {\n        if char == '(' {\n           \
    \ current_nesting += 1\n        } else if char == ')' {\n            current_nesting\
    \ -= 1\n        } else if char == ' ' {\n            max_nesting = append(max_nesting,\
    \ current_nesting)\n            current_nesting = 0\n        }\n    }\n    max_nesting\
    \ = append(max_nesting, current_nesting)\n    return max_nesting\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpd1wq7eoc_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd1wq7eoc_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpd1wq7eoc_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth++\n        } else if\
    \ c == ')' {\n            depth--\n        } else if c == ' ' {\n            result\
    \ = append(result, depth)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level\
    \ += 1\n        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_3zpae3c_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_3zpae3c_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp_3zpae3c_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []rune\n    var max_depth\
    \ int\n    var current_depth int\n    for _, c := range paren_string {\n     \
    \   if c == '(' {\n            stack = append(stack, c)\n            current_depth++\n\
    \            if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        } else if c == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            current_depth--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result = append(result, max_depth)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_depth\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, 1)\n            if len(stack) > max_depth {\n      \
    \          max_depth = len(stack)\n            }\n        } else if c == ')' {\n\
    \            stack = stack[:len(stack)-1]\n        } else if c == ' ' {\n    \
    \        result = append(result, max_depth)\n            max_depth = 0\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpu7d6una5_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpu7d6una5_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpu7d6una5_test.go:48: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level\
    \ -= 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpat7aaxj2_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpat7aaxj2_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var level int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   level++\n            stack = append(stack, level)\n        } else if char\
    \ == ')' {\n            result = append(result, stack[len(stack)-1])\n       \
    \     stack = stack[:len(stack)-1]\n        }\n    }\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpd6kwfslm_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=6) %!s(int=5) %!s(int=4)\
    \ %!s(int=7) %!s(int=10) %!s(int=9) %!s(int=11) %!s(int=12) %!s(int=8)]'\n   \
    \ --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd6kwfslm_test.go:44:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=3)\
    \ %!s(int=2) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=10) %!s(int=9) %!s(int=8)\
    \ %!s(int=7)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpd6kwfslm_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=4)\
    \ %!s(int=3) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depths []int\n    var depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         depth++\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depths\
    \ = append(depths, depth)\n            depth--\n        }\n    }\n    return depths\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpn9qn__t8_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpn9qn__t8_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpn9qn__t8_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []string\n    var max_depth\
    \ int\n    var depth int\n    var paren_group string\n    var paren_char string\n\
    \n    for _, paren_group = range paren_string {\n        stack = []string{}\n\
    \        max_depth = 0\n        depth = 0\n        for _, paren_char = range paren_group\
    \ {\n            if paren_char == '(' {\n                stack = append(stack,\
    \ \"(\")\n                depth += 1\n                if depth > max_depth {\n\
    \                    max_depth = depth\n                }\n            } else\
    \ if paren_char == ')' {\n                stack = stack[:len(stack)-1]\n     \
    \           depth -= 1\n            }\n        }\n        result = append(result,\
    \ max_depth)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1w70rxt8_test.go:21:12: cannot use paren_group (value of type rune) as
    type string in assignment

    /tmp/tmp1w70rxt8_test.go:25:16: cannot use paren_char (value of type rune) as
    type string in assignment

    /tmp/tmp1w70rxt8_test.go:26:30: invalid operation: paren_char == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmp1w70rxt8_test.go:32:37: invalid operation: paren_char == '')'' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if char == ')' {\n            level--\n\
    \        } else if char == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            current_depth -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660074133
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpycapnzhz_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpycapnzhz_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int = 0\n    var depth int = 0\n    var result\
    \ []int = make([]int, 0)\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            depth += 1\n            if depth > max_depth {\n        \
    \        max_depth = depth\n            }\n        } else if c == ')' {\n    \
    \        depth -= 1\n        } else if c == ' ' {\n            result = append(result,\
    \ max_depth)\n            max_depth = 0\n            depth = 0\n        }\n  \
    \  }\n    result = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting []int\n    var current_nesting int\n  \
    \  var current_char byte\n    var i int\n    for i = 0; i < len(paren_string);\
    \ i++ {\n        current_char = paren_string[i]\n        if current_char == '('\
    \ {\n            current_nesting++\n        } else if current_char == ')' {\n\
    \            current_nesting--\n        } else if current_char == ' ' {\n    \
    \        max_nesting = append(max_nesting, current_nesting)\n            current_nesting\
    \ = 0\n        }\n    }\n    max_nesting = append(max_nesting, current_nesting)\n\
    \    return max_nesting\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpiph5fil1_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpiph5fil1_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpiph5fil1_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            current_depth -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660074133
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    for _, paren_group := range paren_string\
    \ {\n        var depth int\n        for _, paren := range paren_group {\n    \
    \        if paren == '(' {\n                depth += 1\n            } else if\
    \ paren == ')' {\n                depth -= 1\n            }\n        }\n     \
    \   result = append(result, depth)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfe86dvyp_test.go:17:31: cannot range over paren_group (variable of type
    rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level\
    \ += 1\n        } else if char == ')' {\n            current_level -= 1\n    \
    \    } else if char == ' ' {\n            result = append(result, current_level)\n\
    \            current_level = 0\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprfpbe2p7_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprfpbe2p7_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprfpbe2p7_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpycapnzhz_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpycapnzhz_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    for _, paren_group := range paren_string\
    \ {\n        var level int\n        for _, paren := range paren_group {\n    \
    \        if paren == '(' {\n                level++\n            } else if paren\
    \ == ')' {\n                level--\n            }\n        }\n        result\
    \ = append(result, level)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpljqlylus_test.go:17:31: cannot range over paren_group (variable of type
    rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    depth := 0\n    max_depths := []int{}\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n            if depth == 0 {\n                max_depths = append(max_depths,\
    \ max_depth)\n                max_depth = 0\n            }\n        }\n    }\n\
    \    return max_depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    var i int\n\
    \    for i = 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            depth++\n        } else if paren_string[i] == ')' {\n       \
    \     depth--\n        } else if paren_string[i] == ' ' {\n            max_depth\
    \ = append(max_depth, depth)\n            depth = 0\n        }\n    }\n    max_depth\
    \ = append(max_depth, depth)\n    return max_depth\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1mqgkt7b_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1mqgkt7b_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp1mqgkt7b_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []int\n    var paren_count\
    \ int\n    var paren_max int\n    for _, c := range paren_string {\n        if\
    \ c == '(' {\n            paren_stack = append(paren_stack, 1)\n            paren_count++\n\
    \            if paren_count > paren_max {\n                paren_max = paren_count\n\
    \            }\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \            paren_count--\n        } else if c == ' ' {\n            result =\
    \ append(result, paren_max)\n            paren_max = 0\n            paren_count\
    \ = 0\n        }\n    }\n    result = append(result, paren_max)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            current_level = 0\n            max_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_depth\
    \ int\n    var depth int\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            stack = append(stack, 1)\n            depth++\n \
    \           if depth > max_depth {\n                max_depth = depth\n      \
    \      }\n        } else if char == ')' {\n            stack = stack[:len(stack)-1]\n\
    \            depth--\n        } else if char == ' ' {\n            result = append(result,\
    \ max_depth)\n            max_depth = 0\n            depth = 0\n        }\n  \
    \  }\n    result = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth++\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == ')' {\n            depth--\n       \
    \ } else if char == ' ' {\n            result = append(result, max_depth)\n  \
    \          max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level\
    \ += 1\n        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_3zpae3c_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_3zpae3c_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp_3zpae3c_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting []int\n    var nesting int\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            nesting += 1\n\
    \        } else if c == ')' {\n            nesting -= 1\n        } else if c ==\
    \ ' ' {\n            max_nesting = append(max_nesting, nesting)\n            nesting\
    \ = 0\n        }\n    }\n    max_nesting = append(max_nesting, nesting)\n    return\
    \ max_nesting\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmppm_qix4z_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmppm_qix4z_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmppm_qix4z_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            depth += 1\n   \
    \     } else if char == ')' {\n            depth -= 1\n        } else if char\
    \ == ' ' {\n            result = append(result, depth)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []rune\n    var depth int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            stack\
    \ = append(stack, c)\n            depth += 1\n        } else if c == ')' {\n \
    \           stack = stack[:len(stack)-1]\n            depth -= 1\n        } else\
    \ if c == ' ' {\n            result = append(result, depth)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmppxdzhv9l_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmppxdzhv9l_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmppxdzhv9l_test.go:46: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpycapnzhz_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpycapnzhz_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []rune\n    var current_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, c)\n            current_level++\n        } else if c\
    \ == ')' {\n            stack = stack[:len(stack)-1]\n            if len(stack)\
    \ == 0 {\n                result = append(result, current_level)\n           \
    \     current_level = 0\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7u9wj0j9_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=3) %!s(int=1) %!s(int=5)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp7u9wj0j9_test.go:47:\
    \ expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_nesting int\n    var current_nesting\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_nesting++\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == ')' {\n            current_nesting--\n        } else if char == '\
    \ ' {\n            result = append(result, max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result = append(result,\
    \ max_nesting)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            depth += 1\n   \
    \     } else if char == ')' {\n            depth -= 1\n        } else if char\
    \ == ' ' {\n            result = append(result, depth)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_stack []int\n    var result []int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            paren_stack\
    \ = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack)\
    \ > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n    \
    \        }\n        } else if char == ' ' {\n            result = append(result,\
    \ len(paren_stack))\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpchdw1rq9_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpchdw1rq9_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpchdw1rq9_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        } else if c == ' ' {\n            if current_level == max_level {\n \
    \               result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpxlx50oec_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var depth\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if c == ')' {\n            depth -= 1\n\
    \        } else if c == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    for _, char\
    \ := range paren_string {\n        if char == '(' {\n            depth += 1\n\
    \        } else if char == ')' {\n            depth -= 1\n        } else if char\
    \ == ' ' {\n            max_depth = append(max_depth, depth)\n            depth\
    \ = 0\n        }\n    }\n    return max_depth\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprtvjpmsa_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprtvjpmsa_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprtvjpmsa_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074135
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            level++\n      \
    \  } else if char == ')' {\n            result = append(result, level)\n     \
    \       level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmptcprvxy3_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptcprvxy3_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmptcprvxy3_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var cur_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   cur_level++\n            if cur_level > max_level {\n                max_level\
    \ = cur_level\n            }\n        } else if c == ')' {\n            cur_level--\n\
    \        } else if c == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            cur_level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []rune\n    var current_level\
    \ int\n    var max_level int\n    for _, c := range paren_string {\n        if\
    \ c == '(' {\n            paren_stack = append(paren_stack, c)\n            current_level\
    \ += 1\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        } else if c == ')' {\n            if\
    \ len(paren_stack) == 0 {\n                panic(\"Unmatched parentheses\")\n\
    \            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n \
    \           current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        } else if c == ' ' {\n            if current_level == max_level {\n \
    \               result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpxlx50oec_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level\
    \ += 1\n        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_3zpae3c_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_3zpae3c_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp_3zpae3c_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    for _, c :=\
    \ range paren_string {\n        if c == '(' {\n            depth++\n        }\
    \ else if c == ')' {\n            depth--\n        } else if c == ' ' {\n    \
    \        max_depth = append(max_depth, depth)\n            depth = 0\n       \
    \ }\n    }\n    return max_depth\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpvxqtzshz_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpvxqtzshz_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpvxqtzshz_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if char == ')' {\n            level--\n\
    \        } else if char == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth += 1\n        } else\
    \ if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n      \
    \      result = append(result, depth)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int = 0\n    var\
    \ max_level int = 0\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            current_level++\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == ')' {\n            current_level--\n        } else if char == ' '\
    \ {\n            result = append(result, max_level)\n            max_level = 0\n\
    \            current_level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var depth_stack []int\n    var depth_list []int\n    var\
    \ depth int\n\n    for _, char := range paren_string {\n        if char == '('\
    \ {\n            depth += 1\n            depth_stack = append(depth_stack, depth)\n\
    \        } else if char == ')' {\n            depth_list = append(depth_list,\
    \ depth_stack[len(depth_stack)-1])\n            depth_stack = depth_stack[:len(depth_stack)-1]\n\
    \            depth -= 1\n        }\n    }\n\n    return depth_list\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp4oeylh1t_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4oeylh1t_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp4oeylh1t_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   level += 1\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if c == ')' {\n            level -= 1\n\
    \        } else if c == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var current_depth int\n    var result\
    \ []int\n    for _, char := range paren_string {\n        if char == '(' {\n \
    \           current_depth++\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            current_depth--\n        } else if char == ' ' {\n   \
    \         result = append(result, max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   level++\n            if level > max_level {\n                max_level = level\n\
    \            }\n        } else if c == ')' {\n            level--\n        } else\
    \ if c == ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n            level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074134
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         stack = append(stack, 1)\n            if len(stack) > max_level {\n\
    \                max_level = len(stack)\n            }\n        } else if char\
    \ == ')' {\n            stack = stack[:len(stack)-1]\n        } else if char ==\
    \ ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfxrnwyvw_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpfxrnwyvw_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpfxrnwyvw_test.go:48: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth += 1\n        } else\
    \ if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n      \
    \      result = append(result, depth)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            current_level++\n\
    \        } else if c == ')' {\n            current_level--\n        } else if\
    \ c == ' ' {\n            result = append(result, current_level)\n           \
    \ current_level = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        } else if c == ' ' {\n            if current_level == max_level {\n \
    \               result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpxlx50oec_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_nesting int\n    var nesting\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   nesting++\n            if nesting > max_nesting {\n                max_nesting\
    \ = nesting\n            }\n        } else if c == ')' {\n            nesting--\n\
    \        } else if c == ' ' {\n            result = append(result, max_nesting)\n\
    \            max_nesting = 0\n            nesting = 0\n        }\n    }\n    result\
    \ = append(result, max_nesting)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    var i int\n  \
    \  for i = 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            depth++\n        } else if paren_string[i] == ')' {\n       \
    \     depth--\n        } else if paren_string[i] == ' ' {\n            result\
    \ = append(result, depth)\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpsxqm746t_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpsxqm746t_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpsxqm746t_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == ')' {\n            depth -= 1\n       \
    \ } else if c == ' ' {\n            result = append(result, max_depth)\n     \
    \       max_depth = 0\n            depth = 0\n        }\n    }\n    result = append(result,\
    \ max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_depth\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, 1)\n            if len(stack) > max_depth {\n      \
    \          max_depth = len(stack)\n            }\n        } else if c == ')' {\n\
    \            stack = stack[:len(stack)-1]\n        } else if c == ' ' {\n    \
    \        result = append(result, max_depth)\n            max_depth = 0\n     \
    \   }\n    }\n    result = append(result, max_depth)\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == ')' {\n            depth -= 1\n       \
    \ } else if c == ' ' {\n            result = append(result, max_depth)\n     \
    \       max_depth = 0\n            depth = 0\n        }\n    }\n    result = append(result,\
    \ max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var current_max\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > current_max {\n       \
    \         current_max = current_level\n            }\n        } else if c == ')'\
    \ {\n            current_level -= 1\n        } else if c == ' ' {\n          \
    \  result = append(result, current_max)\n            current_max = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, current_max)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []string\n    var\
    \ paren_count int\n    for _, paren := range paren_string {\n        if paren\
    \ == '(' {\n            paren_stack = append(paren_stack, \"(\")\n           \
    \ paren_count += 1\n        } else if paren == ')' {\n            paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n            paren_count -= 1\n        }\
    \ else if paren == ' ' {\n            result = append(result, paren_count)\n \
    \           paren_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7evkrt57_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp7evkrt57_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp7evkrt57_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_level\
    \ int\n    var level int\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            stack = append(stack, 1)\n            level++\n         \
    \   if level > max_level {\n                max_level = level\n            }\n\
    \        } else if c == ')' {\n            stack = stack[:len(stack)-1]\n    \
    \        level--\n        } else if c == ' ' {\n            result = append(result,\
    \ max_level)\n            max_level = 0\n            level = 0\n        }\n  \
    \  }\n    result = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []string\n    var\
    \ current_level int\n    var current_max_level int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\
    (\")\n            current_level += 1\n            if current_level > current_max_level\
    \ {\n                current_max_level = current_level\n            }\n      \
    \  } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \            current_level -= 1\n        } else if char == ' ' {\n           \
    \ result = append(result, current_max_level)\n            current_level = 0\n\
    \            current_max_level = 0\n        }\n    }\n    result = append(result,\
    \ current_max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int = 0\n    var\
    \ max_level int = 0\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            current_level++\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == ')' {\n            current_level--\n        } else if char == ' '\
    \ {\n            result = append(result, max_level)\n            max_level = 0\n\
    \            current_level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting_levels []int\n    var current_nesting_level\
    \ int\n    var current_group string\n    var current_group_index int\n    var\
    \ current_char string\n    var current_char_index int\n\n    for current_group_index,\
    \ current_group = range strings.Split(paren_string, \" \") {\n        current_nesting_level\
    \ = 0\n        for current_char_index, current_char = range current_group {\n\
    \            if current_char == '(' {\n                current_nesting_level++\n\
    \            } else if current_char == ')' {\n                current_nesting_level--\n\
    \            } else {\n                fmt.Printf(\"Invalid character %s at position\
    \ %d of group %d\\n\", current_char, current_char_index, current_group_index)\n\
    \            }\n        }\n        max_nesting_levels = append(max_nesting_levels,\
    \ current_nesting_level)\n    }\n    return max_nesting_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvjxpbhk_test.go:21:52: undefined: strings

    /tmp/tmpwvjxpbhk_test.go:23:33: cannot use current_char (value of type rune) as
    type string in assignment

    /tmp/tmpwvjxpbhk_test.go:24:32: invalid operation: current_char == ''('' (mismatched
    types string and untyped rune)

    /tmp/tmpwvjxpbhk_test.go:26:39: invalid operation: current_char == '')'' (mismatched
    types string and untyped rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        } else if c == ' ' {\n            if current_level == max_level {\n \
    \               result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpxlx50oec_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level--\n\
    \        } else if c == ' ' {\n            if current_level == max_level {\n \
    \               result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxlx50oec_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpxlx50oec_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            current_level++\n\
    \        } else if c == ')' {\n            current_level--\n        } else if\
    \ c == ' ' {\n            result = append(result, current_level)\n           \
    \ current_level = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth++\n        } else if\
    \ c == ')' {\n            depth--\n        } else if c == ' ' {\n            result\
    \ = append(result, depth)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp4hp8wm_p_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth += 1\n        } else\
    \ if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n      \
    \      result = append(result, depth)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            current_level++\n\
    \        } else if c == ')' {\n            current_level--\n        } else if\
    \ c == ' ' {\n            result = append(result, current_level)\n           \
    \ current_level = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp8lfguc_m_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int\n    var depth int\n    var result []int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, paren := range paren_string {\n        if paren == '(' {\n \
    \           current_level += 1\n            if current_level > max_level {\n \
    \               max_level = current_level\n            }\n        } else if paren\
    \ == ')' {\n            current_level -= 1\n        } else if paren == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            level += 1\n   \
    \     } else if char == ')' {\n            result = append(result, level)\n  \
    \          level -= 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfcmaw6wm_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfcmaw6wm_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpfcmaw6wm_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            level++\n        } else if\
    \ c == ')' {\n            level--\n        } else if c == ' ' {\n            result\
    \ = append(result, level)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprzxu5fq9_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, 1)\n            if len(stack) > max_level {\n      \
    \          max_level = len(stack)\n            }\n        } else if c == ')' {\n\
    \            stack = stack[:len(stack)-1]\n        } else if c == ' ' {\n    \
    \        result = append(result, max_level)\n            max_level = 0\n     \
    \   }\n    }\n    result = append(result, max_level)\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_count int\n    var max_paren_count\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   paren_count++\n            if paren_count > max_paren_count {\n          \
    \      max_paren_count = paren_count\n            }\n        } else if c == ')'\
    \ {\n            paren_count--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_paren_count)\n            max_paren_count = 0\n       \
    \     paren_count = 0\n        }\n    }\n    result = append(result, max_paren_count)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074134
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   level++\n            if level > max_level {\n                max_level = level\n\
    \            }\n        } else if c == ')' {\n            level--\n        } else\
    \ if c == ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n            level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, c := range\
    \ paren_string {\n        if c == '(' {\n            depth += 1\n        } else\
    \ if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n      \
    \      result = append(result, depth)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpp7axx4b8_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := []int{}\n    paren_count := 0\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            paren_count\
    \ += 1\n        } else if char == ')' {\n            paren_count -= 1\n      \
    \  } else if char == ' ' {\n            paren_list = append(paren_list, paren_count)\n\
    \            paren_count = 0\n        }\n    }\n    return paren_list\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpaluy1mho_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpaluy1mho_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpaluy1mho_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_nesting int\n    var nesting\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   nesting += 1\n            if nesting > max_nesting {\n                max_nesting\
    \ = nesting\n            }\n        } else if c == ')' {\n            nesting\
    \ -= 1\n        } else if c == ' ' {\n            result = append(result, max_nesting)\n\
    \            max_nesting = 0\n            nesting = 0\n        }\n    }\n    result\
    \ = append(result, max_nesting)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var count int\n    var max int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            count++\n\
    \            if count > max {\n                max = count\n            }\n  \
    \      } else if c == ')' {\n            count--\n        } else if c == ' ' {\n\
    \            result = append(result, max)\n            max = 0\n            count\
    \ = 0\n        }\n    }\n    result = append(result, max)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var depth int\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   stack = append(stack, 1)\n            depth += 1\n        } else if char ==\
    \ ')' {\n            stack = stack[:len(stack)-1]\n            depth -= 1\n  \
    \      } else if char == ' ' {\n            result = append(result, depth)\n \
    \       }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpvgrk_szs_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpvgrk_szs_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpvgrk_szs_test.go:46: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074134
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []rune\n    var current_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   paren_stack = append(paren_stack, c)\n            current_level += 1\n   \
    \     } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, current_level)\n        }\n    }\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp6q_v35bj_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp6q_v35bj_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp6q_v35bj_test.go:46: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            current_level = 0\n            max_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    var paren_count\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         depth += 1\n            paren_count += 1\n        } else if char ==\
    \ ')' {\n            depth -= 1\n            paren_count += 1\n        } else\
    \ if char == ' ' {\n            max_depth = append(max_depth, depth)\n       \
    \     depth = 0\n            paren_count = 0\n        }\n    }\n    if paren_count\
    \ > 0 {\n        max_depth = append(max_depth, depth)\n    }\n    return max_depth\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9rj4gaq6_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9rj4gaq6_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp9rj4gaq6_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_level++\n\
    \        } else if char == ')' {\n            result = append(result, current_level)\n\
    \            current_level--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpavazasud_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpavazasud_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpavazasud_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var depth\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   depth++\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == ')' {\n            depth--\n        } else\
    \ if c == ' ' {\n            result = append(result, max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074131
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            if current_depth == 0 {\n                panic(\"Unmatched\
    \ closing parentheses\")\n            }\n            current_depth -= 1\n    \
    \    } else if char == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        } else {\n\
    \            panic(\"Unexpected character\")\n        }\n    }\n    result = append(result,\
    \ max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            depth += 1\n   \
    \     } else if char == ')' {\n            depth -= 1\n        } else if char\
    \ == ' ' {\n            result = append(result, depth)\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprpm2j8lm_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074137
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_nesting int\n    var nesting\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         nesting += 1\n            if nesting > max_nesting {\n             \
    \   max_nesting = nesting\n            }\n        } else if char == ')' {\n  \
    \          nesting -= 1\n        } else if char == ' ' {\n            result =\
    \ append(result, max_nesting)\n            max_nesting = 0\n            nesting\
    \ = 0\n        }\n    }\n    result = append(result, max_nesting)\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth++\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if char ==\
    \ ')' {\n            current_depth--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_depth)\n            max_depth = 0\n       \
    \     current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.017s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []int\n    var current_level\
    \ int\n    var current_char byte\n    for i := 0; i < len(paren_string); i++ {\n\
    \        current_char = paren_string[i]\n        if current_char == '(' {\n  \
    \          paren_stack = append(paren_stack, current_level)\n            current_level++\n\
    \        } else if current_char == ')' {\n            current_level = paren_stack[len(paren_stack)\
    \ - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n       \
    \ } else if current_char == ' ' {\n            result = append(result, current_level)\n\
    \            current_level = 0\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpf8kx_h5v_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpf8kx_h5v_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpf8kx_h5v_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var depth int\n    for _, c :=\
    \ range paren_string {\n        if c == '(' {\n            depth += 1\n      \
    \  } else if c == ')' {\n            depth -= 1\n        } else if c == ' ' {\n\
    \            max_depth = append(max_depth, depth)\n            depth = 0\n   \
    \     }\n    }\n    return max_depth\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpod00yjmw_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpod00yjmw_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpod00yjmw_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int = 0\n    var\
    \ max_level int = 0\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            current_level++\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == ')' {\n            current_level--\n        } else if char == ' '\
    \ {\n            result = append(result, max_level)\n            max_level = 0\n\
    \            current_level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this function.\n    return []int{}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpq_dyu4a9_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpq_dyu4a9_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpq_dyu4a9_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level -= 1\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            current_level = 0\n            max_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var depth int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            stack\
    \ = append(stack, depth)\n            depth += 1\n        } else if c == ')' {\n\
    \            result = append(result, depth)\n            depth = stack[len(stack)-1]\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9eq3810b_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9eq3810b_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp9eq3810b_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_depth int\n    var current_depth\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_depth += 1\n            if current_depth > max_depth {\n   \
    \             max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            current_depth -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level int\n    var level int\n    var result []int\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            level++\n\
    \            if level > max_level {\n                max_level = level\n     \
    \       }\n        } else if c == ')' {\n            level--\n        } else if\
    \ c == ' ' {\n            result = append(result, max_level)\n            max_level\
    \ = 0\n            level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this function.\n    return nil\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfyxngbra_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpfyxngbra_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpfyxngbra_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            current_level\
    \ -= 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpat7aaxj2_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpat7aaxj2_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var max_level int\n    var level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if char == ')' {\n            level--\n\
    \        } else if char == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074223
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := []int{}\n    for _, paren_group := range\
    \ paren_string {\n        paren_count := 0\n        max_paren_count := 0\n   \
    \     for _, paren := range paren_group {\n            if paren == '(' {\n   \
    \             paren_count++\n            } else if paren == ')' {\n          \
    \      paren_count--\n            }\n            if paren_count > max_paren_count\
    \ {\n                max_paren_count = paren_count\n            }\n        }\n\
    \        paren_list = append(paren_list, max_paren_count)\n    }\n    return paren_list\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8b4111og_test.go:18:31: cannot range over paren_group (variable of type
    rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, c := range\
    \ paren_string {\n        switch c {\n        case '(':\n            level++\n\
    \        case ')':\n            result = append(result, level)\n            level--\n\
    \        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpj4wm7nud_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpj4wm7nud_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpj4wm7nud_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack []int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, 1)\n            if len(stack) > max_level {\n      \
    \          max_level = len(stack)\n            }\n        } else if c == ')' {\n\
    \            stack = stack[:len(stack)-1]\n        } else if c == ' ' {\n    \
    \        result = append(result, max_level)\n            max_level = 0\n     \
    \   }\n    }\n    result = append(result, max_level)\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   current_level++\n            if current_level > max_level {\n            \
    \    max_level = current_level\n            }\n        } else if c == ')' {\n\
    \            current_level--\n        } else if c == ' ' {\n            result\
    \ = append(result, max_level)\n            max_level = 0\n            current_level\
    \ = 0\n        }\n    }\n    result = append(result, max_level)\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this function.\n    return []int{}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpq_dyu4a9_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpq_dyu4a9_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpq_dyu4a9_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074133
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            current_level -= 1\n        } else if char == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074128
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level++\n            if current_level > max_level {\n      \
    \          max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int\n    var max_level\
    \ int\n    for _, char := range paren_string {\n        if char == '(' {\n   \
    \         current_level += 1\n            if current_level > max_level {\n   \
    \             max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            current_level -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpycapnzhz_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpycapnzhz_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var level int\n    for _, char :=\
    \ range paren_string {\n        if char == '(' {\n            level++\n      \
    \  } else if char == ')' {\n            level--\n        } else if char == ' '\
    \ {\n            result = append(result, level)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpznpwgn40_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var cur_depth int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            cur_depth\
    \ += 1\n        } else if char == ')' {\n            cur_depth -= 1\n        }\
    \ else if char == ' ' {\n            max_depth = append(max_depth, cur_depth)\n\
    \            cur_depth = 0\n        }\n    }\n    return max_depth\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpi4jgy9d6_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpi4jgy9d6_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpi4jgy9d6_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []string\n    var\
    \ max_level int\n    var level int\n    for _, paren := range paren_string {\n\
    \        if paren == '(' {\n            paren_stack = append(paren_stack, \"(\"\
    )\n            level++\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if paren == ')' {\n            paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n            level--\n        }\n       \
    \ if paren == ' ' {\n            result = append(result, max_level)\n        \
    \    max_level = 0\n            level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074228
